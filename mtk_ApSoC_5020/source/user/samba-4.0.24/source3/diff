diff -ur smbd/aio.c ../../samba-3.6.24/source3/smbd/aio.c
--- smbd/aio.c	2014-05-28 01:20:37.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/aio.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,35 +22,89 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "../lib/util/tevent_ntstatus.h"
-#include "../lib/util/tevent_unix.h"
-#include "lib/tevent_wait.h"
+
+#if defined(WITH_AIO)
+
+/* The signal we'll use to signify aio done. */
+#ifndef RT_SIGNAL_AIO
+#define RT_SIGNAL_AIO	(SIGRTMIN+3)
+#endif
+
+#ifndef HAVE_STRUCT_SIGEVENT_SIGEV_VALUE_SIVAL_PTR
+#ifdef HAVE_STRUCT_SIGEVENT_SIGEV_VALUE_SIGVAL_PTR
+#define sival_int	sigval_int
+#define sival_ptr	sigval_ptr
+#endif
+#endif
 
 /****************************************************************************
  The buffer we keep around whilst an aio request is in process.
 *****************************************************************************/
 
 struct aio_extra {
+	struct aio_extra *next, *prev;
+	SMB_STRUCT_AIOCB acb;
 	files_struct *fsp;
 	struct smb_request *smbreq;
 	DATA_BLOB outbuf;
 	struct lock_struct lock;
-	size_t nbyte;
-	off_t offset;
 	bool write_through;
+	int (*handle_completion)(struct aio_extra *ex, int errcode);
 };
 
 /****************************************************************************
- Accessor function to return write_through state.
+ Initialize the signal handler for aio read/write.
 *****************************************************************************/
 
-bool aio_write_through_requested(struct aio_extra *aio_ex)
+static void smbd_aio_signal_handler(struct tevent_context *ev_ctx,
+				    struct tevent_signal *se,
+				    int signum, int count,
+				    void *_info, void *private_data)
+{
+	siginfo_t *info = (siginfo_t *)_info;
+	struct aio_extra *aio_ex = (struct aio_extra *)
+				info->si_value.sival_ptr;
+
+	smbd_aio_complete_aio_ex(aio_ex);
+	TALLOC_FREE(aio_ex);
+}
+
+
+static bool initialize_async_io_handler(void)
 {
-	return aio_ex->write_through;
+	static bool tried_signal_setup = false;
+
+	if (aio_signal_event) {
+		return true;
+	}
+	if (tried_signal_setup) {
+		return false;
+	}
+	tried_signal_setup = true;
+
+	aio_signal_event = tevent_add_signal(smbd_event_context(),
+					     smbd_event_context(),
+					     RT_SIGNAL_AIO, SA_SIGINFO,
+					     smbd_aio_signal_handler,
+					     NULL);
+	if (!aio_signal_event) {
+		DEBUG(10, ("Failed to setup RT_SIGNAL_AIO handler\n"));
+		return false;
+	}
+
+	/* tevent supports 100 signal with SA_SIGINFO */
+	aio_pending_size = 100;
+	return true;
 }
 
+static int handle_aio_read_complete(struct aio_extra *aio_ex, int errcode);
+static int handle_aio_write_complete(struct aio_extra *aio_ex, int errcode);
+static int handle_aio_smb2_read_complete(struct aio_extra *aio_ex, int errcode);
+static int handle_aio_smb2_write_complete(struct aio_extra *aio_ex, int errcode);
+
 static int aio_extra_destructor(struct aio_extra *aio_ex)
 {
-	outstanding_aio_calls--;
+	DLIST_REMOVE(aio_list_head, aio_ex);
 	return 0;
 }
 
@@ -63,7 +117,7 @@
 					files_struct *fsp,
 					size_t buflen)
 {
-	struct aio_extra *aio_ex = talloc_zero(mem_ctx, struct aio_extra);
+	struct aio_extra *aio_ex = TALLOC_ZERO_P(mem_ctx, struct aio_extra);
 
 	if (!aio_ex) {
 		return NULL;
@@ -80,89 +134,31 @@
 			return NULL;
 		}
 	}
+	DLIST_ADD(aio_list_head, aio_ex);
 	talloc_set_destructor(aio_ex, aio_extra_destructor);
 	aio_ex->fsp = fsp;
-	outstanding_aio_calls++;
 	return aio_ex;
 }
 
-struct aio_req_fsp_link {
-	files_struct *fsp;
-	struct tevent_req *req;
-};
-
-static int aio_del_req_from_fsp(struct aio_req_fsp_link *lnk)
-{
-	unsigned i;
-	files_struct *fsp = lnk->fsp;
-	struct tevent_req *req = lnk->req;
-
-	for (i=0; i<fsp->num_aio_requests; i++) {
-		if (fsp->aio_requests[i] == req) {
-			break;
-		}
-	}
-	if (i == fsp->num_aio_requests) {
-		DEBUG(1, ("req %p not found in fsp %p\n", req, fsp));
-		return 0;
-	}
-	fsp->num_aio_requests -= 1;
-	fsp->aio_requests[i] = fsp->aio_requests[fsp->num_aio_requests];
-
-	if (fsp->num_aio_requests == 0) {
-		tevent_wait_done(fsp->deferred_close);
-	}
-	return 0;
-}
-
-static bool aio_add_req_to_fsp(files_struct *fsp, struct tevent_req *req)
-{
-	size_t array_len;
-	struct aio_req_fsp_link *lnk;
-
-	lnk = talloc(req, struct aio_req_fsp_link);
-	if (lnk == NULL) {
-		return false;
-	}
-
-	array_len = talloc_array_length(fsp->aio_requests);
-	if (array_len <= fsp->num_aio_requests) {
-		struct tevent_req **tmp;
-
-		tmp = talloc_realloc(
-			fsp, fsp->aio_requests, struct tevent_req *,
-			fsp->num_aio_requests+1);
-		if (tmp == NULL) {
-			TALLOC_FREE(lnk);
-			return false;
-		}
-		fsp->aio_requests = tmp;
-	}
-	fsp->aio_requests[fsp->num_aio_requests] = req;
-	fsp->num_aio_requests += 1;
-
-	lnk->fsp = fsp;
-	lnk->req = req;
-	talloc_set_destructor(lnk, aio_del_req_from_fsp);
-
-	return true;
-}
-
-static void aio_pread_smb1_done(struct tevent_req *req);
-
 /****************************************************************************
  Set up an aio request from a SMBreadX call.
 *****************************************************************************/
 
 NTSTATUS schedule_aio_read_and_X(connection_struct *conn,
 			     struct smb_request *smbreq,
-			     files_struct *fsp, off_t startpos,
+			     files_struct *fsp, SMB_OFF_T startpos,
 			     size_t smb_maxcnt)
 {
 	struct aio_extra *aio_ex;
+	SMB_STRUCT_AIOCB *a;
 	size_t bufsize;
 	size_t min_aio_read_size = lp_aio_read_size(SNUM(conn));
-	struct tevent_req *req;
+	int ret;
+
+	/* Ensure aio is initialized. */
+	if (!initialize_async_io_handler()) {
+		return NT_STATUS_RETRY;
+	}
 
 	if (fsp->base_fsp != NULL) {
 		/* No AIO on streams yet */
@@ -202,6 +198,7 @@
 		DEBUG(10,("schedule_aio_read_and_X: malloc fail.\n"));
 		return NT_STATUS_NO_MEMORY;
 	}
+	aio_ex->handle_completion = handle_aio_read_complete;
 
 	construct_reply_common_req(smbreq, (char *)aio_ex->outbuf.data);
 	srv_set_message((char *)aio_ex->outbuf.data, 12, 0, True);
@@ -217,28 +214,28 @@
 		return NT_STATUS_FILE_LOCK_CONFLICT;
 	}
 
-	aio_ex->nbyte = smb_maxcnt;
-	aio_ex->offset = startpos;
+	a = &aio_ex->acb;
+
+	/* Now set up the aio record for the read call. */
 
-	req = SMB_VFS_PREAD_SEND(aio_ex, fsp->conn->sconn->ev_ctx,
-				 fsp, smb_buf(aio_ex->outbuf.data),
-				 smb_maxcnt, startpos);
-	if (req == NULL) {
+	a->aio_fildes = fsp->fh->fd;
+	a->aio_buf = smb_buf(aio_ex->outbuf.data);
+	a->aio_nbytes = smb_maxcnt;
+	a->aio_offset = startpos;
+	a->aio_sigevent.sigev_notify = SIGEV_SIGNAL;
+	a->aio_sigevent.sigev_signo  = RT_SIGNAL_AIO;
+	a->aio_sigevent.sigev_value.sival_ptr = aio_ex;
+
+	ret = SMB_VFS_AIO_READ(fsp, a);
+	if (ret == -1) {
 		DEBUG(0,("schedule_aio_read_and_X: aio_read failed. "
 			 "Error %s\n", strerror(errno) ));
 		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
 		TALLOC_FREE(aio_ex);
 		return NT_STATUS_RETRY;
 	}
-	tevent_req_set_callback(req, aio_pread_smb1_done, aio_ex);
-
-	if (!aio_add_req_to_fsp(fsp, req)) {
-		DEBUG(1, ("Could not add req to fsp\n"));
-		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
-		TALLOC_FREE(aio_ex);
-		return NT_STATUS_RETRY;
-	}
 
+	outstanding_aio_calls++;
 	aio_ex->smbreq = talloc_move(aio_ex, &smbreq);
 
 	DEBUG(10,("schedule_aio_read_and_X: scheduled aio_read for file %s, "
@@ -249,183 +246,26 @@
 	return NT_STATUS_OK;
 }
 
-static void aio_pread_smb1_done(struct tevent_req *req)
-{
-	struct aio_extra *aio_ex = tevent_req_callback_data(
-		req, struct aio_extra);
-	files_struct *fsp = aio_ex->fsp;
-	int outsize;
-	char *outbuf = (char *)aio_ex->outbuf.data;
-	char *data = smb_buf(outbuf);
-	ssize_t nread;
-	int err;
-
-	nread = SMB_VFS_PREAD_RECV(req, &err);
-	TALLOC_FREE(req);
-
-	DEBUG(10, ("pread_recv returned %d, err = %s\n", (int)nread,
-		   (nread == -1) ? strerror(err) : "no error"));
-
-	if (fsp == NULL) {
-		DEBUG( 3, ("aio_pread_smb1_done: file closed whilst "
-			   "aio outstanding (mid[%llu]).\n",
-			   (unsigned long long)aio_ex->smbreq->mid));
-		TALLOC_FREE(aio_ex);
-		return;
-	}
-
-	/* Unlock now we're done. */
-	SMB_VFS_STRICT_UNLOCK(fsp->conn, fsp, &aio_ex->lock);
-
-	if (nread < 0) {
-		DEBUG( 3, ("handle_aio_read_complete: file %s nread == %d. "
-			   "Error = %s\n", fsp_str_dbg(fsp), (int)nread,
-			   strerror(err)));
-
-		ERROR_NT(map_nt_error_from_unix(err));
-		outsize = srv_set_message(outbuf,0,0,true);
-	} else {
-		outsize = srv_set_message(outbuf, 12, nread, False);
-		SSVAL(outbuf,smb_vwv2, 0xFFFF); /* Remaining - must be * -1. */
-		SSVAL(outbuf,smb_vwv5, nread);
-		SSVAL(outbuf,smb_vwv6, smb_offset(data,outbuf));
-		SSVAL(outbuf,smb_vwv7, ((nread >> 16) & 1));
-		SSVAL(smb_buf(outbuf), -2, nread);
-
-		aio_ex->fsp->fh->pos = aio_ex->offset + nread;
-		aio_ex->fsp->fh->position_information = aio_ex->fsp->fh->pos;
-
-		DEBUG( 3, ("handle_aio_read_complete file %s max=%d "
-			   "nread=%d\n", fsp_str_dbg(fsp),
-			   (int)aio_ex->nbyte, (int)nread ) );
-
-	}
-	smb_setlen(outbuf, outsize - 4);
-	show_msg(outbuf);
-	if (!srv_send_smb(aio_ex->smbreq->sconn, outbuf,
-			  true, aio_ex->smbreq->seqnum+1,
-			  IS_CONN_ENCRYPTED(fsp->conn), NULL)) {
-		exit_server_cleanly("handle_aio_read_complete: srv_send_smb "
-				    "failed.");
-	}
-
-	DEBUG(10, ("handle_aio_read_complete: scheduled aio_read completed "
-		   "for file %s, offset %.0f, len = %u\n",
-		   fsp_str_dbg(fsp), (double)aio_ex->offset,
-		   (unsigned int)nread));
-
-	TALLOC_FREE(aio_ex);
-}
-
-struct pwrite_fsync_state {
-	struct tevent_context *ev;
-	files_struct *fsp;
-	bool write_through;
-	ssize_t nwritten;
-};
-
-static void pwrite_fsync_write_done(struct tevent_req *subreq);
-static void pwrite_fsync_sync_done(struct tevent_req *subreq);
-
-static struct tevent_req *pwrite_fsync_send(TALLOC_CTX *mem_ctx,
-					    struct tevent_context *ev,
-					    struct files_struct *fsp,
-					    const void *data,
-					    size_t n, off_t offset,
-					    bool write_through)
-{
-	struct tevent_req *req, *subreq;
-	struct pwrite_fsync_state *state;
-
-	req = tevent_req_create(mem_ctx, &state, struct pwrite_fsync_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->ev = ev;
-	state->fsp = fsp;
-	state->write_through = write_through;
-
-	subreq = SMB_VFS_PWRITE_SEND(state, ev, fsp, data, n, offset);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
-	}
-	tevent_req_set_callback(subreq, pwrite_fsync_write_done, req);
-	return req;
-}
-
-static void pwrite_fsync_write_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct pwrite_fsync_state *state = tevent_req_data(
-		req, struct pwrite_fsync_state);
-	connection_struct *conn = state->fsp->conn;
-	int err;
-	bool do_sync;
-
-	state->nwritten = SMB_VFS_PWRITE_RECV(subreq, &err);
-	TALLOC_FREE(subreq);
-	if (state->nwritten == -1) {
-		tevent_req_error(req, err);
-		return;
-	}
-
-	do_sync = (lp_strict_sync(SNUM(conn)) &&
-		   (lp_syncalways(SNUM(conn)) || state->write_through));
-	if (!do_sync) {
-		tevent_req_done(req);
-		return;
-	}
-
-	subreq = SMB_VFS_FSYNC_SEND(state, state->ev, state->fsp);
-	if (tevent_req_nomem(subreq, req)) {
-		return;
-	}
-	tevent_req_set_callback(subreq, pwrite_fsync_sync_done, req);
-}
-
-static void pwrite_fsync_sync_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	int ret, err;
-
-	ret = SMB_VFS_FSYNC_RECV(subreq, &err);
-	TALLOC_FREE(subreq);
-	if (ret == -1) {
-		tevent_req_error(req, err);
-		return;
-	}
-	tevent_req_done(req);
-}
-
-static ssize_t pwrite_fsync_recv(struct tevent_req *req, int *perr)
-{
-	struct pwrite_fsync_state *state = tevent_req_data(
-		req, struct pwrite_fsync_state);
-
-	if (tevent_req_is_unix_error(req, perr)) {
-		return -1;
-	}
-	return state->nwritten;
-}
-
-static void aio_pwrite_smb1_done(struct tevent_req *req);
-
 /****************************************************************************
  Set up an aio request from a SMBwriteX call.
 *****************************************************************************/
 
 NTSTATUS schedule_aio_write_and_X(connection_struct *conn,
 			      struct smb_request *smbreq,
-			      files_struct *fsp, const char *data,
-			      off_t startpos,
+			      files_struct *fsp, char *data,
+			      SMB_OFF_T startpos,
 			      size_t numtowrite)
 {
 	struct aio_extra *aio_ex;
+	SMB_STRUCT_AIOCB *a;
 	size_t bufsize;
 	size_t min_aio_write_size = lp_aio_write_size(SNUM(conn));
-	struct tevent_req *req;
+	int ret;
+
+	/* Ensure aio is initialized. */
+	if (!initialize_async_io_handler()) {
+		return NT_STATUS_RETRY;
+	}
 
 	if (fsp->base_fsp != NULL) {
 		/* No AIO on streams yet */
@@ -468,6 +308,7 @@
 		DEBUG(0,("schedule_aio_write_and_X: malloc fail.\n"));
 		return NT_STATUS_NO_MEMORY;
 	}
+	aio_ex->handle_completion = handle_aio_write_complete;
 	aio_ex->write_through = BITSETW(smbreq->vwv+7,0);
 
 	construct_reply_common_req(smbreq, (char *)aio_ex->outbuf.data);
@@ -484,28 +325,28 @@
 		return NT_STATUS_FILE_LOCK_CONFLICT;
 	}
 
-	aio_ex->nbyte = numtowrite;
-	aio_ex->offset = startpos;
+	a = &aio_ex->acb;
+
+	/* Now set up the aio record for the write call. */
 
-	req = pwrite_fsync_send(aio_ex, fsp->conn->sconn->ev_ctx, fsp,
-				data, numtowrite, startpos,
-				aio_ex->write_through);
-	if (req == NULL) {
+	a->aio_fildes = fsp->fh->fd;
+	a->aio_buf = data;
+	a->aio_nbytes = numtowrite;
+	a->aio_offset = startpos;
+	a->aio_sigevent.sigev_notify = SIGEV_SIGNAL;
+	a->aio_sigevent.sigev_signo  = RT_SIGNAL_AIO;
+	a->aio_sigevent.sigev_value.sival_ptr = aio_ex;
+
+	ret = SMB_VFS_AIO_WRITE(fsp, a);
+	if (ret == -1) {
 		DEBUG(3,("schedule_aio_wrote_and_X: aio_write failed. "
 			 "Error %s\n", strerror(errno) ));
 		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
 		TALLOC_FREE(aio_ex);
 		return NT_STATUS_RETRY;
 	}
-	tevent_req_set_callback(req, aio_pwrite_smb1_done, aio_ex);
-
-	if (!aio_add_req_to_fsp(fsp, req)) {
-		DEBUG(1, ("Could not add req to fsp\n"));
-		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
-		TALLOC_FREE(aio_ex);
-		return NT_STATUS_RETRY;
-	}
 
+	outstanding_aio_calls++;
 	aio_ex->smbreq = talloc_move(aio_ex, &smbreq);
 
 	/* This should actually be improved to span the write. */
@@ -540,132 +381,6 @@
 	return NT_STATUS_OK;
 }
 
-static void aio_pwrite_smb1_done(struct tevent_req *req)
-{
-	struct aio_extra *aio_ex = tevent_req_callback_data(
-		req, struct aio_extra);
-	files_struct *fsp = aio_ex->fsp;
-	char *outbuf = (char *)aio_ex->outbuf.data;
-	ssize_t numtowrite = aio_ex->nbyte;
-	ssize_t nwritten;
-	int err;
-
-	nwritten = pwrite_fsync_recv(req, &err);
-	TALLOC_FREE(req);
-
-	DEBUG(10, ("pwrite_recv returned %d, err = %s\n", (int)nwritten,
-		   (nwritten == -1) ? strerror(err) : "no error"));
-
-	if (fsp == NULL) {
-		DEBUG( 3, ("aio_pwrite_smb1_done: file closed whilst "
-			   "aio outstanding (mid[%llu]).\n",
-			   (unsigned long long)aio_ex->smbreq->mid));
-		TALLOC_FREE(aio_ex);
-		return;
-	}
-
-	/* Unlock now we're done. */
-	SMB_VFS_STRICT_UNLOCK(fsp->conn, fsp, &aio_ex->lock);
-
-	mark_file_modified(fsp);
-
-	if (fsp->aio_write_behind) {
-
-		if (nwritten != numtowrite) {
-			if (nwritten == -1) {
-				DEBUG(5,("handle_aio_write_complete: "
-					 "aio_write_behind failed ! File %s "
-					 "is corrupt ! Error %s\n",
-					 fsp_str_dbg(fsp), strerror(err)));
-			} else {
-				DEBUG(0,("handle_aio_write_complete: "
-					 "aio_write_behind failed ! File %s "
-					 "is corrupt ! Wanted %u bytes but "
-					 "only wrote %d\n", fsp_str_dbg(fsp),
-					 (unsigned int)numtowrite,
-					 (int)nwritten ));
-			}
-		} else {
-			DEBUG(10,("handle_aio_write_complete: "
-				  "aio_write_behind completed for file %s\n",
-				  fsp_str_dbg(fsp)));
-		}
-		/* TODO: should no return success in case of an error !!! */
-		TALLOC_FREE(aio_ex);
-		return;
-	}
-
-	/* We don't need outsize or set_message here as we've already set the
-	   fixed size length when we set up the aio call. */
-
-	if (nwritten == -1) {
-		DEBUG(3, ("handle_aio_write: file %s wanted %u bytes. "
-			  "nwritten == %d. Error = %s\n",
-			  fsp_str_dbg(fsp), (unsigned int)numtowrite,
-			  (int)nwritten, strerror(err)));
-
-		ERROR_NT(map_nt_error_from_unix(err));
-		srv_set_message(outbuf,0,0,true);
-        } else {
-		SSVAL(outbuf,smb_vwv2,nwritten);
-		SSVAL(outbuf,smb_vwv4,(nwritten>>16)&1);
-		if (nwritten < (ssize_t)numtowrite) {
-			SCVAL(outbuf,smb_rcls,ERRHRD);
-			SSVAL(outbuf,smb_err,ERRdiskfull);
-		}
-
-		DEBUG(3,("handle_aio_write: %s, num=%d wrote=%d\n",
-			 fsp_fnum_dbg(fsp), (int)numtowrite, (int)nwritten));
-
-		aio_ex->fsp->fh->pos = aio_ex->offset + nwritten;
-	}
-
-	show_msg(outbuf);
-	if (!srv_send_smb(aio_ex->smbreq->sconn, outbuf,
-			  true, aio_ex->smbreq->seqnum+1,
-			  IS_CONN_ENCRYPTED(fsp->conn),
-			  NULL)) {
-		exit_server_cleanly("handle_aio_write_complete: "
-				    "srv_send_smb failed.");
-	}
-
-	DEBUG(10, ("handle_aio_write_complete: scheduled aio_write completed "
-		   "for file %s, offset %.0f, requested %u, written = %u\n",
-		   fsp_str_dbg(fsp), (double)aio_ex->offset,
-		   (unsigned int)numtowrite, (unsigned int)nwritten));
-
-	TALLOC_FREE(aio_ex);
-}
-
-bool cancel_smb2_aio(struct smb_request *smbreq)
-{
-	struct smbd_smb2_request *smb2req = smbreq->smb2req;
-	struct aio_extra *aio_ex = NULL;
-
-	if (smb2req) {
-		aio_ex = talloc_get_type(smbreq->async_priv,
-					 struct aio_extra);
-	}
-
-	if (aio_ex == NULL) {
-		return false;
-	}
-
-	if (aio_ex->fsp == NULL) {
-		return false;
-	}
-
-	/*
-	 * We let the aio request run. Setting fsp to NULL has the
-	 * effect that the _done routines don't send anything out.
-	 */
-
-	aio_ex->fsp = NULL;
-	return true;
-}
-
-static void aio_pread_smb2_done(struct tevent_req *req);
-
 /****************************************************************************
  Set up an aio request from a SMB2 read call.
 *****************************************************************************/
@@ -675,21 +390,22 @@
 				files_struct *fsp,
 				TALLOC_CTX *ctx,
 				DATA_BLOB *preadbuf,
-				off_t startpos,
+				SMB_OFF_T startpos,
 				size_t smb_maxcnt)
 {
 	struct aio_extra *aio_ex;
+	SMB_STRUCT_AIOCB *a;
 	size_t min_aio_read_size = lp_aio_read_size(SNUM(conn));
-	struct tevent_req *req;
+	int ret;
 
-	if (fsp->base_fsp != NULL) {
-		/* No AIO on streams yet */
-		DEBUG(10, ("AIO on streams not yet supported\n"));
+	/* Ensure aio is initialized. */
+	if (!initialize_async_io_handler()) {
 		return NT_STATUS_RETRY;
 	}
 
-	if (fsp->op == NULL) {
-		/* No AIO on internal opens. */
+	if (fsp->base_fsp != NULL) {
+		/* No AIO on streams yet */
+		DEBUG(10, ("AIO on streams not yet supported\n"));
 		return NT_STATUS_RETRY;
 	}
 
@@ -724,8 +440,9 @@
 	if (!(aio_ex = create_aio_extra(smbreq->smb2req, fsp, 0))) {
 		return NT_STATUS_NO_MEMORY;
 	}
+	aio_ex->handle_completion = handle_aio_smb2_read_complete;
 
-	init_strict_lock_struct(fsp, fsp->op->global->open_persistent_id,
+	init_strict_lock_struct(fsp, (uint64_t)smbreq->smbpid,
 		(uint64_t)startpos, (uint64_t)smb_maxcnt, READ_LOCK,
 		&aio_ex->lock);
 
@@ -735,31 +452,31 @@
 		return NT_STATUS_FILE_LOCK_CONFLICT;
 	}
 
-	aio_ex->nbyte = smb_maxcnt;
-	aio_ex->offset = startpos;
+	a = &aio_ex->acb;
 
-	req = SMB_VFS_PREAD_SEND(aio_ex, fsp->conn->sconn->ev_ctx, fsp,
-				 preadbuf->data, smb_maxcnt, startpos);
-	if (req == NULL) {
-		DEBUG(0, ("smb2: SMB_VFS_PREAD_SEND failed. "
-			  "Error %s\n", strerror(errno)));
-		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
-		TALLOC_FREE(aio_ex);
-		return NT_STATUS_RETRY;
-	}
-	tevent_req_set_callback(req, aio_pread_smb2_done, aio_ex);
+	/* Now set up the aio record for the read call. */
+
+	a->aio_fildes = fsp->fh->fd;
+	a->aio_buf = preadbuf->data;
+	a->aio_nbytes = smb_maxcnt;
+	a->aio_offset = startpos;
+	a->aio_sigevent.sigev_notify = SIGEV_SIGNAL;
+	a->aio_sigevent.sigev_signo  = RT_SIGNAL_AIO;
+	a->aio_sigevent.sigev_value.sival_ptr = aio_ex;
 
-	if (!aio_add_req_to_fsp(fsp, req)) {
-		DEBUG(1, ("Could not add req to fsp\n"));
+	ret = SMB_VFS_AIO_READ(fsp, a);
+	if (ret == -1) {
+		DEBUG(0,("smb2: aio_read failed. "
+			"Error %s\n", strerror(errno) ));
 		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
 		TALLOC_FREE(aio_ex);
 		return NT_STATUS_RETRY;
 	}
 
+	outstanding_aio_calls++;
 	/* We don't need talloc_move here as both aio_ex and
 	 * smbreq are children of smbreq->smb2req. */
 	aio_ex->smbreq = smbreq;
-	smbreq->async_priv = aio_ex;
 
 	DEBUG(10,("smb2: scheduled aio_read for file %s, "
 		"offset %.0f, len = %u (mid = %u)\n",
@@ -769,63 +486,9 @@
 	return NT_STATUS_OK;
 }
 
-static void aio_pread_smb2_done(struct tevent_req *req)
-{
-	struct aio_extra *aio_ex = tevent_req_callback_data(
-		req, struct aio_extra);
-	struct tevent_req *subreq = aio_ex->smbreq->smb2req->subreq;
-	files_struct *fsp = aio_ex->fsp;
-	NTSTATUS status;
-	ssize_t nread;
-	int err = 0;
-
-	nread = SMB_VFS_PREAD_RECV(req, &err);
-	TALLOC_FREE(req);
-
-	DEBUG(10, ("pread_recv returned %d, err = %s\n", (int)nread,
-		   (nread == -1) ? strerror(err) : "no error"));
-
-	if (fsp == NULL) {
-		DEBUG( 3, ("aio_pread_smb2_done: file closed whilst "
-			   "aio outstanding (mid[%llu]).\n",
-			   (unsigned long long)aio_ex->smbreq->mid));
-		TALLOC_FREE(aio_ex);
-		return;
-	}
-
-	/* Unlock now we're done. */
-	SMB_VFS_STRICT_UNLOCK(fsp->conn, fsp, &aio_ex->lock);
-
-	/* Common error or success code processing for async or sync
-	   read returns. */
-
-	status = smb2_read_complete(subreq, nread, err);
-
-	if (nread > 0) {
-		fsp->fh->pos = aio_ex->offset + nread;
-		fsp->fh->position_information = fsp->fh->pos;
-	}
-
-	DEBUG(10, ("smb2: scheduled aio_read completed "
-		   "for file %s, offset %.0f, len = %u "
-		   "(errcode = %d, NTSTATUS = %s)\n",
-		   fsp_str_dbg(aio_ex->fsp),
-		   (double)aio_ex->offset,
-		   (unsigned int)nread,
-		   err, nt_errstr(status)));
-
-	if (!NT_STATUS_IS_OK(status)) {
-		tevent_req_nterror(subreq, status);
-		return;
-	}
-	tevent_req_done(subreq);
-}
-
-static void aio_pwrite_smb2_done(struct tevent_req *req);
-
-/****************************************************************************
- Set up an aio request from a SMB2write call.
-*****************************************************************************/
+/****************************************************************************
+ Set up an aio request from a SMB2write call.
+*****************************************************************************/
 
 NTSTATUS schedule_aio_smb2_write(connection_struct *conn,
 				struct smb_request *smbreq,
@@ -835,17 +498,18 @@
 				bool write_through)
 {
 	struct aio_extra *aio_ex = NULL;
+	SMB_STRUCT_AIOCB *a = NULL;
 	size_t min_aio_write_size = lp_aio_write_size(SNUM(conn));
-	struct tevent_req *req;
+	int ret;
 
-	if (fsp->base_fsp != NULL) {
-		/* No AIO on streams yet */
-		DEBUG(10, ("AIO on streams not yet supported\n"));
+	/* Ensure aio is initialized. */
+	if (!initialize_async_io_handler()) {
 		return NT_STATUS_RETRY;
 	}
 
-	if (fsp->op == NULL) {
-		/* No AIO on internal opens. */
+	if (fsp->base_fsp != NULL) {
+		/* No AIO on streams yet */
+		DEBUG(10, ("AIO on streams not yet supported\n"));
 		return NT_STATUS_RETRY;
 	}
 
@@ -871,18 +535,14 @@
 		return NT_STATUS_RETRY;
 	}
 
-	if (smbreq->unread_bytes) {
-		/* Can't do async with recvfile. */
-		return NT_STATUS_RETRY;
-	}
-
 	if (!(aio_ex = create_aio_extra(smbreq->smb2req, fsp, 0))) {
 		return NT_STATUS_NO_MEMORY;
 	}
 
+	aio_ex->handle_completion = handle_aio_smb2_write_complete;
 	aio_ex->write_through = write_through;
 
-	init_strict_lock_struct(fsp, fsp->op->global->open_persistent_id,
+	init_strict_lock_struct(fsp, (uint64_t)smbreq->smbpid,
 		in_offset, (uint64_t)in_data.length, WRITE_LOCK,
 		&aio_ex->lock);
 
@@ -892,32 +552,31 @@
 		return NT_STATUS_FILE_LOCK_CONFLICT;
 	}
 
-	aio_ex->nbyte = in_data.length;
-	aio_ex->offset = in_offset;
+	a = &aio_ex->acb;
 
-	req = pwrite_fsync_send(aio_ex, fsp->conn->sconn->ev_ctx, fsp,
-				in_data.data, in_data.length, in_offset,
-				write_through);
-	if (req == NULL) {
-		DEBUG(3, ("smb2: SMB_VFS_PWRITE_SEND failed. "
-			  "Error %s\n", strerror(errno)));
-		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
-		TALLOC_FREE(aio_ex);
-		return NT_STATUS_RETRY;
-	}
-	tevent_req_set_callback(req, aio_pwrite_smb2_done, aio_ex);
+	/* Now set up the aio record for the write call. */
 
-	if (!aio_add_req_to_fsp(fsp, req)) {
-		DEBUG(1, ("Could not add req to fsp\n"));
+	a->aio_fildes = fsp->fh->fd;
+	a->aio_buf = in_data.data;
+	a->aio_nbytes = in_data.length;
+	a->aio_offset = in_offset;
+	a->aio_sigevent.sigev_notify = SIGEV_SIGNAL;
+	a->aio_sigevent.sigev_signo  = RT_SIGNAL_AIO;
+	a->aio_sigevent.sigev_value.sival_ptr = aio_ex;
+
+	ret = SMB_VFS_AIO_WRITE(fsp, a);
+	if (ret == -1) {
+		DEBUG(3,("smb2: aio_write failed. "
+			"Error %s\n", strerror(errno) ));
 		SMB_VFS_STRICT_UNLOCK(conn, fsp, &aio_ex->lock);
 		TALLOC_FREE(aio_ex);
 		return NT_STATUS_RETRY;
 	}
 
+	outstanding_aio_calls++;
 	/* We don't need talloc_move here as both aio_ex and
 	* smbreq are children of smbreq->smb2req. */
 	aio_ex->smbreq = smbreq;
-	smbreq->async_priv = aio_ex;
 
 	/* This should actually be improved to span the write. */
 	contend_level2_oplocks_begin(fsp, LEVEL2_CONTEND_WRITE);
@@ -941,48 +600,474 @@
 	return NT_STATUS_OK;
 }
 
-static void aio_pwrite_smb2_done(struct tevent_req *req)
+/****************************************************************************
+ Complete the read and return the data or error back to the client.
+ Returns errno or zero if all ok.
+*****************************************************************************/
+
+static int handle_aio_read_complete(struct aio_extra *aio_ex, int errcode)
 {
-	struct aio_extra *aio_ex = tevent_req_callback_data(
-		req, struct aio_extra);
-	ssize_t numtowrite = aio_ex->nbyte;
+	int outsize;
+	char *outbuf = (char *)aio_ex->outbuf.data;
+	char *data = smb_buf(outbuf);
+	ssize_t nread = SMB_VFS_AIO_RETURN(aio_ex->fsp,&aio_ex->acb);
+
+	if (nread < 0) {
+		/* We're relying here on the fact that if the fd is
+		   closed then the aio will complete and aio_return
+		   will return an error. Hopefully this is
+		   true.... JRA. */
+
+		DEBUG( 3,( "handle_aio_read_complete: file %s nread == %d. "
+			   "Error = %s\n",
+			   fsp_str_dbg(aio_ex->fsp), (int)nread, strerror(errcode)));
+
+		ERROR_NT(map_nt_error_from_unix(errcode));
+		outsize = srv_set_message(outbuf,0,0,true);
+	} else {
+		outsize = srv_set_message(outbuf,12,nread,False);
+		SSVAL(outbuf,smb_vwv2,0xFFFF); /* Remaining - must be * -1. */
+		SSVAL(outbuf,smb_vwv5,nread);
+		SSVAL(outbuf,smb_vwv6,smb_offset(data,outbuf));
+		SSVAL(outbuf,smb_vwv7,((nread >> 16) & 1));
+		SSVAL(smb_buf(outbuf),-2,nread);
+
+		aio_ex->fsp->fh->pos = aio_ex->acb.aio_offset + nread;
+		aio_ex->fsp->fh->position_information = aio_ex->fsp->fh->pos;
+
+		DEBUG( 3, ( "handle_aio_read_complete file %s max=%d "
+			    "nread=%d\n",
+			    fsp_str_dbg(aio_ex->fsp),
+			    (int)aio_ex->acb.aio_nbytes, (int)nread ) );
+
+	}
+	smb_setlen(outbuf,outsize - 4);
+	show_msg(outbuf);
+	if (!srv_send_smb(aio_ex->smbreq->sconn, outbuf,
+			true, aio_ex->smbreq->seqnum+1,
+			IS_CONN_ENCRYPTED(aio_ex->fsp->conn), NULL)) {
+		exit_server_cleanly("handle_aio_read_complete: srv_send_smb "
+				    "failed.");
+	}
+
+	DEBUG(10,("handle_aio_read_complete: scheduled aio_read completed "
+		  "for file %s, offset %.0f, len = %u\n",
+		  fsp_str_dbg(aio_ex->fsp), (double)aio_ex->acb.aio_offset,
+		  (unsigned int)nread ));
+
+	return errcode;
+}
+
+/****************************************************************************
+ Complete the write and return the data or error back to the client.
+ Returns error code or zero if all ok.
+*****************************************************************************/
+
+static int handle_aio_write_complete(struct aio_extra *aio_ex, int errcode)
+{
+	files_struct *fsp = aio_ex->fsp;
+	char *outbuf = (char *)aio_ex->outbuf.data;
+	ssize_t numtowrite = aio_ex->acb.aio_nbytes;
+	ssize_t nwritten = SMB_VFS_AIO_RETURN(fsp,&aio_ex->acb);
+
+	if (fsp->aio_write_behind) {
+		if (nwritten != numtowrite) {
+			if (nwritten == -1) {
+				DEBUG(5,("handle_aio_write_complete: "
+					 "aio_write_behind failed ! File %s "
+					 "is corrupt ! Error %s\n",
+					 fsp_str_dbg(fsp), strerror(errcode)));
+			} else {
+				DEBUG(0,("handle_aio_write_complete: "
+					 "aio_write_behind failed ! File %s "
+					 "is corrupt ! Wanted %u bytes but "
+					 "only wrote %d\n", fsp_str_dbg(fsp),
+					 (unsigned int)numtowrite,
+					 (int)nwritten ));
+				errcode = EIO;
+			}
+		} else {
+			DEBUG(10,("handle_aio_write_complete: "
+				  "aio_write_behind completed for file %s\n",
+				  fsp_str_dbg(fsp)));
+		}
+		/* TODO: should no return 0 in case of an error !!! */
+		return 0;
+	}
+
+	/* We don't need outsize or set_message here as we've already set the
+	   fixed size length when we set up the aio call. */
+
+	if(nwritten == -1) {
+		DEBUG( 3,( "handle_aio_write: file %s wanted %u bytes. "
+			   "nwritten == %d. Error = %s\n",
+			   fsp_str_dbg(fsp), (unsigned int)numtowrite,
+			   (int)nwritten, strerror(errcode) ));
+
+		ERROR_NT(map_nt_error_from_unix(errcode));
+		srv_set_message(outbuf,0,0,true);
+        } else {
+		NTSTATUS status;
+
+        	SSVAL(outbuf,smb_vwv2,nwritten);
+		SSVAL(outbuf,smb_vwv4,(nwritten>>16)&1);
+		if (nwritten < (ssize_t)numtowrite) {
+			SCVAL(outbuf,smb_rcls,ERRHRD);
+			SSVAL(outbuf,smb_err,ERRdiskfull);
+		}
+
+		DEBUG(3,("handle_aio_write: fnum=%d num=%d wrote=%d\n",
+			 fsp->fnum, (int)numtowrite, (int)nwritten));
+		status = sync_file(fsp->conn,fsp, aio_ex->write_through);
+		if (!NT_STATUS_IS_OK(status)) {
+			errcode = errno;
+			ERROR_BOTH(map_nt_error_from_unix(errcode),
+				   ERRHRD, ERRdiskfull);
+			srv_set_message(outbuf,0,0,true);
+                	DEBUG(5,("handle_aio_write: sync_file for %s returned %s\n",
+				 fsp_str_dbg(fsp), nt_errstr(status)));
+		}
+
+		aio_ex->fsp->fh->pos = aio_ex->acb.aio_offset + nwritten;
+	}
+
+	show_msg(outbuf);
+	if (!srv_send_smb(aio_ex->smbreq->sconn, outbuf,
+			  true, aio_ex->smbreq->seqnum+1,
+			  IS_CONN_ENCRYPTED(fsp->conn),
+			  NULL)) {
+		exit_server_cleanly("handle_aio_write_complete: "
+				    "srv_send_smb failed.");
+	}
+
+	DEBUG(10,("handle_aio_write_complete: scheduled aio_write completed "
+		  "for file %s, offset %.0f, requested %u, written = %u\n",
+		  fsp_str_dbg(fsp), (double)aio_ex->acb.aio_offset,
+		  (unsigned int)numtowrite, (unsigned int)nwritten ));
+
+	return errcode;
+}
+
+/****************************************************************************
+ Complete the read and return the data or error back to the client.
+ Returns errno or zero if all ok.
+*****************************************************************************/
+
+static int handle_aio_smb2_read_complete(struct aio_extra *aio_ex, int errcode)
+{
+	NTSTATUS status;
 	struct tevent_req *subreq = aio_ex->smbreq->smb2req->subreq;
+	ssize_t nread = SMB_VFS_AIO_RETURN(aio_ex->fsp,&aio_ex->acb);
+
+	/* Common error or success code processing for async or sync
+	   read returns. */
+
+	status = smb2_read_complete(subreq, nread, errcode);
+
+	if (nread > 0) {
+		aio_ex->fsp->fh->pos = aio_ex->acb.aio_offset + nread;
+		aio_ex->fsp->fh->position_information = aio_ex->fsp->fh->pos;
+	}
+
+	DEBUG(10,("smb2: scheduled aio_read completed "
+		"for file %s, offset %.0f, len = %u "
+		"(errcode = %d, NTSTATUS = %s)\n",
+		fsp_str_dbg(aio_ex->fsp),
+		(double)aio_ex->acb.aio_offset,
+		(unsigned int)nread,
+		errcode,
+		nt_errstr(status) ));
+
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(subreq, status);
+		return errcode;
+	}
+
+	tevent_req_done(subreq);
+	return errcode;
+}
+
+/****************************************************************************
+ Complete the SMB2 write and return the data or error back to the client.
+ Returns error code or zero if all ok.
+*****************************************************************************/
+
+static int handle_aio_smb2_write_complete(struct aio_extra *aio_ex, int errcode)
+{
 	files_struct *fsp = aio_ex->fsp;
+	ssize_t numtowrite = aio_ex->acb.aio_nbytes;
+	ssize_t nwritten = SMB_VFS_AIO_RETURN(fsp,&aio_ex->acb);
+	struct tevent_req *subreq = aio_ex->smbreq->smb2req->subreq;
 	NTSTATUS status;
-	ssize_t nwritten;
-	int err = 0;
 
-	nwritten = pwrite_fsync_recv(req, &err);
-	TALLOC_FREE(req);
+	status = smb2_write_complete(subreq, nwritten, errcode);
 
-	DEBUG(10, ("pwrite_recv returned %d, err = %s\n", (int)nwritten,
-		   (nwritten == -1) ? strerror(err) : "no error"));
+	DEBUG(10,("smb2: scheduled aio_write completed "
+		"for file %s, offset %.0f, requested %u, "
+		"written = %u (errcode = %d, NTSTATUS = %s)\n",
+		fsp_str_dbg(fsp),
+		(double)aio_ex->acb.aio_offset,
+		(unsigned int)numtowrite,
+		(unsigned int)nwritten,
+		errcode,
+		nt_errstr(status) ));
 
-	if (fsp == NULL) {
-		DEBUG( 3, ("aio_pwrite_smb2_done: file closed whilst "
-			   "aio outstanding (mid[%llu]).\n",
-			   (unsigned long long)aio_ex->smbreq->mid));
-		TALLOC_FREE(aio_ex);
-		return;
+	if (!NT_STATUS_IS_OK(status)) {
+		tevent_req_nterror(subreq, status);
+		return errcode;
+	}
+
+	tevent_req_done(subreq);
+	return errcode;
+}
+
+/****************************************************************************
+ Handle any aio completion. Returns True if finished (and sets *perr if err
+ was non-zero), False if not.
+*****************************************************************************/
+
+static bool handle_aio_completed(struct aio_extra *aio_ex, int *perr)
+{
+	files_struct *fsp = NULL;
+	int err;
+
+	if(!aio_ex) {
+	        DEBUG(3, ("handle_aio_completed: Non-existing aio_ex passed\n"));
+		return false;
+	}
+
+	fsp = aio_ex->fsp;
+
+	/* Ensure the operation has really completed. */
+	err = SMB_VFS_AIO_ERROR(fsp, &aio_ex->acb);
+	if (err == EINPROGRESS) {
+		DEBUG(10,( "handle_aio_completed: operation mid %llu still in "
+			"process for file %s\n",
+			(unsigned long long)aio_ex->smbreq->mid,
+			fsp_str_dbg(aio_ex->fsp)));
+		return False;
 	}
 
 	/* Unlock now we're done. */
 	SMB_VFS_STRICT_UNLOCK(fsp->conn, fsp, &aio_ex->lock);
 
-        status = smb2_write_complete_nosync(subreq, nwritten, err);
+	if (err == ECANCELED) {
+		/* If error is ECANCELED then don't return anything to the
+		 * client. */
+	        DEBUG(10,( "handle_aio_completed: operation mid %llu"
+			" canceled\n",
+			(unsigned long long)aio_ex->smbreq->mid));
+		return True;
+        }
+
+	err = aio_ex->handle_completion(aio_ex, err);
+	if (err) {
+		*perr = err; /* Only save non-zero errors. */
+	}
 
-	DEBUG(10, ("smb2: scheduled aio_write completed "
-		   "for file %s, offset %.0f, requested %u, "
-		   "written = %u (errcode = %d, NTSTATUS = %s)\n",
-		   fsp_str_dbg(fsp),
-		   (double)aio_ex->offset,
-		   (unsigned int)numtowrite,
-		   (unsigned int)nwritten,
-		   err, nt_errstr(status)));
+	return True;
+}
 
-	if (!NT_STATUS_IS_OK(status)) {
-		tevent_req_nterror(subreq, status);
+/****************************************************************************
+ Handle any aio completion inline.
+*****************************************************************************/
+
+void smbd_aio_complete_aio_ex(struct aio_extra *aio_ex)
+{
+	files_struct *fsp = NULL;
+	int ret = 0;
+
+	outstanding_aio_calls--;
+
+	DEBUG(10,("smbd_aio_complete_mid: mid[%llu]\n",
+		(unsigned long long)aio_ex->smbreq->mid));
+
+	fsp = aio_ex->fsp;
+	if (fsp == NULL) {
+		/* file was closed whilst I/O was outstanding. Just
+		 * ignore. */
+		DEBUG( 3,( "smbd_aio_complete_mid: file closed whilst "
+			"aio outstanding (mid[%llu]).\n",
+			(unsigned long long)aio_ex->smbreq->mid));
 		return;
 	}
-	tevent_req_done(subreq);
+
+	if (!handle_aio_completed(aio_ex, &ret)) {
+		return;
+	}
+}
+
+/****************************************************************************
+ We're doing write behind and the client closed the file. Wait up to 30
+ seconds (my arbitrary choice) for the aio to complete. Return 0 if all writes
+ completed, errno to return if not.
+*****************************************************************************/
+
+#define SMB_TIME_FOR_AIO_COMPLETE_WAIT 29
+
+int wait_for_aio_completion(files_struct *fsp)
+{
+	struct aio_extra *aio_ex;
+	const SMB_STRUCT_AIOCB **aiocb_list;
+	int aio_completion_count = 0;
+	time_t start_time = time_mono(NULL);
+	int seconds_left;
+
+	for (seconds_left = SMB_TIME_FOR_AIO_COMPLETE_WAIT;
+	     seconds_left >= 0;) {
+		int err = 0;
+		int i;
+		struct timespec ts;
+
+		aio_completion_count = 0;
+		for( aio_ex = aio_list_head; aio_ex; aio_ex = aio_ex->next) {
+			if (aio_ex->fsp == fsp) {
+				aio_completion_count++;
+			}
+		}
+
+		if (!aio_completion_count) {
+			return 0;
+		}
+
+		DEBUG(3,("wait_for_aio_completion: waiting for %d aio events "
+			 "to complete.\n", aio_completion_count ));
+
+		aiocb_list = SMB_MALLOC_ARRAY(const SMB_STRUCT_AIOCB *,
+					      aio_completion_count);
+		if (!aiocb_list) {
+			return ENOMEM;
+		}
+
+		for( i = 0, aio_ex = aio_list_head;
+		     aio_ex;
+		     aio_ex = aio_ex->next) {
+			if (aio_ex->fsp == fsp) {
+				aiocb_list[i++] = &aio_ex->acb;
+			}
+		}
+
+		/* Now wait up to seconds_left for completion. */
+		ts.tv_sec = seconds_left;
+		ts.tv_nsec = 0;
+
+		DEBUG(10,("wait_for_aio_completion: %d events, doing a wait "
+			  "of %d seconds.\n",
+			  aio_completion_count, seconds_left ));
+
+		err = SMB_VFS_AIO_SUSPEND(fsp, aiocb_list,
+					  aio_completion_count, &ts);
+
+		DEBUG(10,("wait_for_aio_completion: returned err = %d, "
+			  "errno = %s\n", err, strerror(errno) ));
+
+		if (err == -1 && errno == EAGAIN) {
+			DEBUG(0,("wait_for_aio_completion: aio_suspend timed "
+				 "out waiting for %d events after a wait of "
+				 "%d seconds\n", aio_completion_count,
+				 seconds_left));
+			/* Timeout. */
+			cancel_aio_by_fsp(fsp);
+			SAFE_FREE(aiocb_list);
+			return EIO;
+		}
+
+		/* One or more events might have completed - process them if
+		 * so. */
+		for( i = 0; i < aio_completion_count; i++) {
+			aio_ex = (struct aio_extra *)aiocb_list[i]->aio_sigevent.sigev_value.sival_ptr;
+
+			if (!handle_aio_completed(aio_ex, &err)) {
+				continue;
+			}
+			TALLOC_FREE(aio_ex);
+		}
+
+		SAFE_FREE(aiocb_list);
+		seconds_left = SMB_TIME_FOR_AIO_COMPLETE_WAIT
+			- (time_mono(NULL) - start_time);
+	}
+
+	/* We timed out - we don't know why. Return ret if already an error,
+	 * else EIO. */
+	DEBUG(10,("wait_for_aio_completion: aio_suspend timed out waiting "
+		  "for %d events\n",
+		  aio_completion_count));
+
+	return EIO;
+}
+
+/****************************************************************************
+ Cancel any outstanding aio requests. The client doesn't care about the reply.
+*****************************************************************************/
+
+void cancel_aio_by_fsp(files_struct *fsp)
+{
+	struct aio_extra *aio_ex;
+
+	for( aio_ex = aio_list_head; aio_ex; aio_ex = aio_ex->next) {
+		if (aio_ex->fsp == fsp) {
+			/* Unlock now we're done. */
+			SMB_VFS_STRICT_UNLOCK(fsp->conn, fsp, &aio_ex->lock);
+
+			/* Don't delete the aio_extra record as we may have
+			   completed and don't yet know it. Just do the
+			   aio_cancel call and return. */
+			SMB_VFS_AIO_CANCEL(fsp, &aio_ex->acb);
+			aio_ex->fsp = NULL; /* fsp will be closed when we
+					     * return. */
+		}
+	}
+}
+
+#else
+NTSTATUS schedule_aio_read_and_X(connection_struct *conn,
+			     struct smb_request *smbreq,
+			     files_struct *fsp, SMB_OFF_T startpos,
+			     size_t smb_maxcnt)
+{
+	return NT_STATUS_RETRY;
+}
+
+NTSTATUS schedule_aio_write_and_X(connection_struct *conn,
+			      struct smb_request *smbreq,
+			      files_struct *fsp, char *data,
+			      SMB_OFF_T startpos,
+			      size_t numtowrite)
+{
+	return NT_STATUS_RETRY;
 }
+
+NTSTATUS schedule_smb2_aio_read(connection_struct *conn,
+                                struct smb_request *smbreq,
+                                files_struct *fsp,
+				TALLOC_CTX *ctx,
+				DATA_BLOB *preadbuf,
+                                SMB_OFF_T startpos,
+                                size_t smb_maxcnt)
+{
+	return NT_STATUS_RETRY;
+}
+
+NTSTATUS schedule_aio_smb2_write(connection_struct *conn,
+				struct smb_request *smbreq,
+				files_struct *fsp,
+				uint64_t in_offset,
+				DATA_BLOB in_data,
+				bool write_through)
+{
+	return NT_STATUS_RETRY;
+}
+
+void cancel_aio_by_fsp(files_struct *fsp)
+{
+}
+
+int wait_for_aio_completion(files_struct *fsp)
+{
+	return 0;
+}
+
+void smbd_aio_complete_mid(uint64_t mid);
+
+#endif
Only in ../../samba-3.6.24/source3/smbd: aio.o
diff -ur smbd/avahi_register.c ../../samba-3.6.24/source3/smbd/avahi_register.c
--- smbd/avahi_register.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/avahi_register.c	2015-01-28 10:52:25.149068676 +0800
@@ -88,7 +88,7 @@
 		}
 		if (avahi_entry_group_add_service(
 			    state->entry_group, AVAHI_IF_UNSPEC,
-			    AVAHI_PROTO_UNSPEC, 0, lp_netbios_name(),
+			    AVAHI_PROTO_UNSPEC, 0, global_myname(),
 			    "_smb._tcp", NULL, NULL, state->port, NULL) < 0) {
 			error = avahi_client_errno(c);
 			DEBUG(10, ("avahi_entry_group_add_service failed: "
diff -ur smbd/blocking.c ../../samba-3.6.24/source3/smbd/blocking.c
--- smbd/blocking.c	2014-07-30 16:52:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/blocking.c	2015-01-28 10:52:25.149068676 +0800
@@ -139,9 +139,9 @@
 		    (int)from_now.tv_sec, (int)from_now.tv_usec));
 	}
 
-	sconn->smb1.locks.brl_timeout = tevent_add_timer(sconn->ev_ctx,
-							 NULL, next_timeout,
-							 brl_timeout_fn, sconn);
+	sconn->smb1.locks.brl_timeout = event_add_timed(smbd_event_context(),
+							NULL, next_timeout,
+							brl_timeout_fn, sconn);
 	if (sconn->smb1.locks.brl_timeout == NULL) {
 		return False;
 	}
@@ -208,7 +208,8 @@
 		blr->expire_time.tv_sec = 0;
 		blr->expire_time.tv_usec = 0; /* Never expire. */
 	} else {
-		blr->expire_time = timeval_current_ofs_msec(lock_timeout);
+		blr->expire_time = timeval_current_ofs(lock_timeout/1000,
+					(lock_timeout % 1000) * 1000);
 	}
 	blr->lock_num = lock_num;
 	blr->smblctx = smblctx;
@@ -225,7 +226,7 @@
 	status = brl_lock(req->sconn->msg_ctx,
 			br_lck,
 			smblctx,
-			messaging_server_id(req->sconn->msg_ctx),
+			sconn_server_id(req->sconn),
 			offset,
 			count,
 			lock_type == READ_LOCK ? PENDING_READ_LOCK : PENDING_WRITE_LOCK,
@@ -248,16 +249,16 @@
 
 	/* Ensure we'll receive messages when this is unlocked. */
 	if (!sconn->smb1.locks.blocking_lock_unlock_state) {
-		messaging_register(sconn->msg_ctx, sconn,
+		messaging_register(sconn->msg_ctx, NULL,
 				   MSG_SMB_UNLOCK, received_unlock_msg);
 		sconn->smb1.locks.blocking_lock_unlock_state = true;
 	}
 
 	DEBUG(3,("push_blocking_lock_request: lock request blocked with "
-		"expiry time (%u sec. %u usec) (+%d msec) for %s, name = %s\n",
+		"expiry time (%u sec. %u usec) (+%d msec) for fnum = %d, name = %s\n",
 		(unsigned int)blr->expire_time.tv_sec,
 		(unsigned int)blr->expire_time.tv_usec, lock_timeout,
-		fsp_fnum_dbg(blr->fsp), fsp_str_dbg(blr->fsp)));
+		blr->fsp->fnum, fsp_str_dbg(blr->fsp)));
 
 	return True;
 }
@@ -268,11 +269,7 @@
 
 static void reply_lockingX_success(struct blocking_lock_record *blr)
 {
-	struct smb_request *req = blr->req;
-
-	reply_outbuf(req, 2, 0);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
+	reply_outbuf(blr->req, 2, 0);
 
 	/*
 	 * As this message is a lockingX call we must handle
@@ -282,15 +279,8 @@
 	 * that here and must set up the chain info manually.
 	 */
 
-	if (!srv_send_smb(req->sconn,
-			(char *)req->outbuf,
-			true, req->seqnum+1,
-			IS_CONN_ENCRYPTED(req->conn)||req->encrypted,
-			&req->pcd)) {
-		exit_server_cleanly("construct_reply: srv_send_smb failed.");
-	}
-
-	TALLOC_FREE(req->outbuf);
+	chain_reply(blr->req);
+	TALLOC_FREE(blr->req->outbuf);
 }
 
 /****************************************************************************
@@ -313,7 +303,7 @@
 			fsp->last_lock_failure.context.smblctx = blr->smblctx;
 			fsp->last_lock_failure.context.tid = fsp->conn->cnum;
 			fsp->last_lock_failure.context.pid =
-				messaging_server_id(fsp->conn->sconn->msg_ctx);
+				sconn_server_id(fsp->conn->sconn);
 			fsp->last_lock_failure.start = blr->offset;
 			fsp->last_lock_failure.size = blr->count;
 			fsp->last_lock_failure.fnum = fsp->fnum;
@@ -347,7 +337,7 @@
 	uint8_t *data;
 	int i;
 
-	data = discard_const_p(uint8_t, blr->req->buf)
+	data = (uint8_t *)blr->req->buf
 		+ ((large_file_format ? 20 : 10)*num_ulocks);
 
 	/* 
@@ -402,7 +392,7 @@
 			undo_locks_obtained(blr);
 		}
 		generic_blocking_lock_error(blr, status);
-		break;
+                break;
 	case SMBtrans2:
 	case SMBtranss2:
 		reply_nterror(blr->req, status);
@@ -430,25 +420,6 @@
 }
 
 /****************************************************************************
- Utility function that returns true if a lock timed out.
-*****************************************************************************/
-
-static bool lock_timed_out(const struct blocking_lock_record *blr)
-{
-	struct timeval tv_curr;
-
-	if (timeval_is_zero(&blr->expire_time)) {
-		return false; /* Never times out. */
-	}
-
-	tv_curr = timeval_current();
-	if (timeval_compare(&blr->expire_time, &tv_curr) <= 0) {
-		return true;
-	}
-	return false;
-}
-
-/****************************************************************************
  Attempt to finish off getting all pending blocking locks for a lockingX call.
  Returns True if we want to be removed from the list.
 *****************************************************************************/
@@ -459,12 +430,13 @@
 	files_struct *fsp = blr->fsp;
 	uint16 num_ulocks = SVAL(blr->req->vwv+6, 0);
 	uint16 num_locks = SVAL(blr->req->vwv+7, 0);
+	uint64_t count = (uint64_t)0, offset = (uint64_t)0;
+	uint64_t smblctx;
 	bool large_file_format = (locktype & LOCKING_ANDX_LARGE_FILES);
 	uint8_t *data;
 	NTSTATUS status = NT_STATUS_OK;
-	bool lock_timeout = lock_timed_out(blr);
 
-	data = discard_const_p(uint8_t, blr->req->buf)
+	data = (uint8_t *)blr->req->buf
 		+ ((large_file_format ? 20 : 10)*num_ulocks);
 
 	/* 
@@ -476,14 +448,9 @@
 		struct byte_range_lock *br_lck = NULL;
 		bool err;
 
-		/*
-		 * Ensure the blr record gets updated with
-		 * any lock we might end up blocked on.
-		 */
-
-		blr->smblctx = get_lock_pid( data, blr->lock_num, large_file_format);
-		blr->count = get_lock_count( data, blr->lock_num, large_file_format);
-		blr->offset = get_lock_offset( data, blr->lock_num, large_file_format, &err);
+		smblctx = get_lock_pid( data, blr->lock_num, large_file_format);
+		count = get_lock_count( data, blr->lock_num, large_file_format);
+		offset = get_lock_offset( data, blr->lock_num, large_file_format, &err);
 
 		/*
 		 * We know err cannot be set as if it was the lock
@@ -492,9 +459,9 @@
 		errno = 0;
 		br_lck = do_lock(fsp->conn->sconn->msg_ctx,
 				fsp,
-				blr->smblctx,
-				blr->count,
-				blr->offset,
+				smblctx,
+				count,
+				offset,
 				((locktype & LOCKING_ANDX_SHARED_LOCK) ?
 					READ_LOCK : WRITE_LOCK),
 				WINDOWS_LOCK,
@@ -503,34 +470,6 @@
 				&blr->blocking_smblctx,
 				blr);
 
-		if (ERROR_WAS_LOCK_DENIED(status) && !lock_timeout) {
-			/*
-			 * If we didn't timeout, but still need to wait,
-			 * re-add the pending lock entry whilst holding
-			 * the brlock db lock.
-			 */
-			NTSTATUS status1 =
-				brl_lock(blr->fsp->conn->sconn->msg_ctx,
-					br_lck,
-					blr->smblctx,
-					messaging_server_id(
-						blr->fsp->conn->sconn->msg_ctx),
-					blr->offset,
-					blr->count,
-					blr->lock_type == READ_LOCK ?
-						PENDING_READ_LOCK :
-						PENDING_WRITE_LOCK,
-						blr->lock_flav,
-					true, /* Blocking lock. */
-					NULL,
-					blr);
-
-			if (!NT_STATUS_IS_OK(status1)) {
-				DEBUG(0,("failed to add PENDING_LOCK "
-					"record.\n"));
-			}
-		}
-
 		TALLOC_FREE(br_lck);
 
 		if (NT_STATUS_IS_ERR(status)) {
@@ -543,15 +482,16 @@
 		 * Success - we got all the locks.
 		 */
 
-		DEBUG(3,("process_lockingX file = %s, %s, type=%d "
-			 "num_locks=%d\n", fsp_str_dbg(fsp), fsp_fnum_dbg(fsp),
+		DEBUG(3,("process_lockingX file = %s, fnum=%d type=%d "
+			 "num_locks=%d\n", fsp_str_dbg(fsp), fsp->fnum,
 			 (unsigned int)locktype, num_locks));
 
 		reply_lockingX_success(blr);
 		return True;
 	}
 
-	if (!ERROR_WAS_LOCK_DENIED(status)) {
+	if (!NT_STATUS_EQUAL(status,NT_STATUS_LOCK_NOT_GRANTED) &&
+	    !NT_STATUS_EQUAL(status,NT_STATUS_FILE_LOCK_CONFLICT)) {
 		/*
 		 * We have other than a "can't get lock"
 		 * error. Free any locks we had and return an error.
@@ -562,21 +502,12 @@
 	}
 
 	/*
-	 * Return an error to the client if we timed out.
-	 */
-	if (lock_timeout) {
-		blocking_lock_reply_error(blr,NT_STATUS_FILE_LOCK_CONFLICT);
-		return true;
-	}
-
-	/*
 	 * Still can't get all the locks - keep waiting.
 	 */
 
-	DEBUG(10, ("process_lockingX: only got %d locks of %d needed for "
-		   "file %s, %s. Waiting....\n",
-		   blr->lock_num, num_locks, fsp_str_dbg(fsp),
-		   fsp_fnum_dbg(fsp)));
+	DEBUG(10,("process_lockingX: only got %d locks of %d needed for file %s, fnum = %d. \
+Waiting....\n", 
+		 blr->lock_num, num_locks, fsp_str_dbg(fsp), fsp->fnum));
 
 	return False;
 }
@@ -590,8 +521,6 @@
 {
 	char params[2];
 	NTSTATUS status;
-	bool lock_timeout = lock_timed_out(blr);
-
 	struct byte_range_lock *br_lck = do_lock(
 						blr->fsp->conn->sconn->msg_ctx,
 						blr->fsp,
@@ -604,46 +533,10 @@
 						&status,
 						&blr->blocking_smblctx,
 						blr);
-	if (ERROR_WAS_LOCK_DENIED(status) && !lock_timeout) {
-		/*
-		 * If we didn't timeout, but still need to wait,
-		 * re-add the pending lock entry whilst holding
-		 * the brlock db lock.
-		 */
-		NTSTATUS status1 =
-			brl_lock(blr->fsp->conn->sconn->msg_ctx,
-				br_lck,
-				blr->smblctx,
-				messaging_server_id(
-					blr->fsp->conn->sconn->msg_ctx),
-				blr->offset,
-				blr->count,
-				blr->lock_type == READ_LOCK ?
-					PENDING_READ_LOCK :
-					PENDING_WRITE_LOCK,
-				blr->lock_flav,
-				true, /* Blocking lock. */
-				NULL,
-				blr);
-
-		if (!NT_STATUS_IS_OK(status1)) {
-			DEBUG(0,("failed to add PENDING_LOCK record.\n"));
-		}
-	}
-
 	TALLOC_FREE(br_lck);
 
 	if (!NT_STATUS_IS_OK(status)) {
 		if (ERROR_WAS_LOCK_DENIED(status)) {
-			if (lock_timeout) {
-				/*
-				 * Return an error if we timed out
-				 * and return true to get dequeued.
-				 */
-				blocking_lock_reply_error(blr,
-					NT_STATUS_FILE_LOCK_CONFLICT);
-				return true;
-			}
 			/* Still can't get the lock, just keep waiting. */
 			return False;
 		}	
@@ -659,7 +552,7 @@
 
 	SSVAL(params,0,0);
 	/* Fake up max_data_bytes here - we know it fits. */
-	send_trans2_replies(blr->fsp->conn, blr->req, NT_STATUS_OK, params, 2, NULL, 0, 0xffff);
+	send_trans2_replies(blr->fsp->conn, blr->req, params, 2, NULL, 0, 0xffff);
 	return True;
 }
 
@@ -689,9 +582,9 @@
  Called when a file is closed.
 *****************************************************************************/
 
-void smbd_cancel_pending_lock_requests_by_fid(files_struct *fsp,
-					      struct byte_range_lock *br_lck,
-					      enum file_close_type close_type)
+void cancel_pending_lock_requests_by_fid(files_struct *fsp,
+			struct byte_range_lock *br_lck,
+			enum file_close_type close_type)
 {
 	struct smbd_server_connection *sconn = fsp->conn->sconn;
 	struct blocking_lock_record *blr, *blr_cancelled, *next = NULL;
@@ -716,8 +609,8 @@
 		}
 
 		DEBUG(10, ("remove_pending_lock_requests_by_fid - removing "
-			   "request type %d for file %s, %s\n",
-			   blr->req->cmd, fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+			   "request type %d for file %s fnum = %d\n",
+			   blr->req->cmd, fsp_str_dbg(fsp), fsp->fnum));
 
 		blr_cancelled = blocking_lock_cancel_smb1(fsp,
 				     blr->smblctx,
@@ -731,7 +624,7 @@
 
 		brl_lock_cancel(br_lck,
 				blr->smblctx,
-				messaging_server_id(sconn->msg_ctx),
+				sconn_server_id(sconn),
 				blr->offset,
 				blr->count,
 				blr->lock_flav,
@@ -768,13 +661,13 @@
 
 		if (br_lck) {
 			DEBUG(10, ("remove_pending_lock_requests_by_mid_smb1 - "
-				   "removing request type %d for file %s, %s\n",
-				   blr->req->cmd, fsp_str_dbg(fsp),
-				   fsp_fnum_dbg(fsp)));
+				   "removing request type %d for file %s fnum "
+				   "= %d\n", blr->req->cmd, fsp_str_dbg(fsp),
+				   fsp->fnum ));
 
 			brl_lock_cancel(br_lck,
 					blr->smblctx,
-					messaging_server_id(sconn->msg_ctx),
+					sconn_server_id(sconn),
 					blr->offset,
 					blr->count,
 					blr->lock_flav,
@@ -817,9 +710,13 @@
 				struct server_id server_id,
 				DATA_BLOB *data)
 {
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
+	struct smbd_server_connection *sconn;
+
+	sconn = msg_ctx_to_sconn(msg);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
 
 	DEBUG(10,("received_unlock_msg\n"));
 	process_blocking_lock_queue(sconn);
@@ -831,10 +728,11 @@
 
 void process_blocking_lock_queue(struct smbd_server_connection *sconn)
 {
+	struct timeval tv_curr = timeval_current();
 	struct blocking_lock_record *blr, *next = NULL;
 
 	if (sconn->using_smb2) {
-		process_blocking_lock_queue_smb2(sconn, timeval_current());
+		process_blocking_lock_queue_smb2(sconn, tv_curr);
 		return;
 	}
 
@@ -843,7 +741,6 @@
 	 */
 
 	for (blr = sconn->smb1.locks.blocking_lock_queue; blr; blr = next) {
-		struct byte_range_lock *br_lck = NULL;
 
 		next = blr->next;
 
@@ -863,34 +760,65 @@
 				SVAL(blr->req->inbuf,smb_flg),
 				false);
 
-		/*
-		 * Remove the pending lock we're waiting on.
-		 * If we need to keep waiting blocking_lock_record_process()
-		 * will re-add it.
-		 */
+		if(blocking_lock_record_process(blr)) {
+			struct byte_range_lock *br_lck = brl_get_locks(
+				talloc_tos(), blr->fsp);
 
-		br_lck = brl_get_locks(talloc_tos(), blr->fsp);
-		if (br_lck) {
-			brl_lock_cancel(br_lck,
-				blr->smblctx,
-				messaging_server_id(sconn->msg_ctx),
-				blr->offset,
-				blr->count,
-				blr->lock_flav,
-				blr);
-		}
-		TALLOC_FREE(br_lck);
+			DEBUG(10, ("BLR_process returned true: cancelling and "
+			    "removing lock. BLR = %p\n", blr));
 
-		if(!blocking_lock_record_process(blr)) {
-			DEBUG(10, ("still waiting for lock. BLR = %p\n", blr));
+			if (br_lck) {
+				brl_lock_cancel(br_lck,
+					blr->smblctx,
+					sconn_server_id(sconn),
+					blr->offset,
+					blr->count,
+					blr->lock_flav,
+					blr);
+				TALLOC_FREE(br_lck);
+			}
+
+			DLIST_REMOVE(sconn->smb1.locks.blocking_lock_queue, blr);
+			TALLOC_FREE(blr);
 			continue;
 		}
 
-		DEBUG(10, ("BLR_process returned true: removing BLR = %p\n",
-			blr));
+		/*
+		 * We couldn't get the locks for this record on the list.
+		 * If the time has expired, return a lock error.
+		 */
 
-		DLIST_REMOVE(sconn->smb1.locks.blocking_lock_queue, blr);
-		TALLOC_FREE(blr);
+		if (!timeval_is_zero(&blr->expire_time) && timeval_compare(&blr->expire_time, &tv_curr) <= 0) {
+			struct byte_range_lock *br_lck = brl_get_locks(
+				talloc_tos(), blr->fsp);
+
+			DEBUG(10, ("Lock timed out! BLR = %p\n", blr));
+
+			/*
+			 * Lock expired - throw away all previously
+			 * obtained locks and return lock error.
+			 */
+
+			if (br_lck) {
+				DEBUG(5,("process_blocking_lock_queue: "
+					 "pending lock fnum = %d for file %s "
+					 "timed out.\n", blr->fsp->fnum,
+					 fsp_str_dbg(blr->fsp)));
+
+				brl_lock_cancel(br_lck,
+					blr->smblctx,
+					sconn_server_id(sconn),
+					blr->offset,
+					blr->count,
+					blr->lock_flav,
+					blr);
+				TALLOC_FREE(br_lck);
+			}
+
+			blocking_lock_reply_error(blr,NT_STATUS_FILE_LOCK_CONFLICT);
+			DLIST_REMOVE(sconn->smb1.locks.blocking_lock_queue, blr);
+			TALLOC_FREE(blr);
+		}
 	}
 
 	recalc_brl_timeout(sconn);
@@ -908,12 +836,10 @@
 						 struct server_id server_id,
 						 DATA_BLOB *data)
 {
+	struct smbd_server_connection *sconn;
 	NTSTATUS err;
 	const char *msg = (const char *)data->data;
 	struct blocking_lock_record *blr;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
 
 	if (data->data == NULL) {
 		smb_panic("process_blocking_lock_cancel_message: null msg");
@@ -925,6 +851,12 @@
 		smb_panic("process_blocking_lock_cancel_message: bad msg");
         }
 
+	sconn = msg_ctx_to_sconn(ctx);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
+
 	memcpy(&blr, msg, sizeof(blr));
 	memcpy(&err, &msg[sizeof(blr)], sizeof(NTSTATUS));
 
@@ -956,7 +888,7 @@
 
 	if (!sconn->smb1.locks.blocking_lock_cancel_state) {
 		/* Register our message. */
-		messaging_register(sconn->msg_ctx, sconn,
+		messaging_register(sconn->msg_ctx, NULL,
 				   MSG_SMB_BLOCKING_LOCK_CANCEL,
 				   process_blocking_lock_cancel_message);
 
@@ -992,7 +924,7 @@
 	memcpy(msg, &blr, sizeof(blr));
 	memcpy(&msg[sizeof(blr)], &err, sizeof(NTSTATUS));
 
-	messaging_send_buf(sconn->msg_ctx, messaging_server_id(sconn->msg_ctx),
+	messaging_send_buf(sconn->msg_ctx, sconn_server_id(sconn),
 			   MSG_SMB_BLOCKING_LOCK_CANCEL,
 			   (uint8 *)&msg, sizeof(msg));
 
Only in ../../samba-3.6.24/source3/smbd: blocking.o
Only in ../../samba-3.6.24/source3/smbd: build_options.c
Only in ../../samba-3.6.24/source3/smbd: build_options.o
diff -ur smbd/close.c ../../samba-3.6.24/source3/smbd/close.c
--- smbd/close.c	2013-10-07 16:49:10.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/close.c	2015-01-28 10:52:25.149068676 +0800
@@ -24,12 +24,10 @@
 #include "printing.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
-#include "smbd/scavenger.h"
 #include "fake_file.h"
 #include "transfer_file.h"
 #include "auth.h"
 #include "messages.h"
-#include "../librpc/gen_ndr/open_files.h"
 
 /****************************************************************************
  Run a file if it is a magic script.
@@ -47,7 +45,7 @@
 	char *fname = NULL;
 	NTSTATUS status;
 
-	if (!*lp_magicscript(talloc_tos(), SNUM(conn))) {
+	if (!*lp_magicscript(SNUM(conn))) {
 		return NT_STATUS_OK;
 	}
 
@@ -63,13 +61,13 @@
 		p++;
 	}
 
-	if (!strequal(lp_magicscript(talloc_tos(), SNUM(conn)),p)) {
+	if (!strequal(lp_magicscript(SNUM(conn)),p)) {
 		status = NT_STATUS_OK;
 		goto out;
 	}
 
-	if (*lp_magicoutput(talloc_tos(), SNUM(conn))) {
-		magic_output = lp_magicoutput(talloc_tos(), SNUM(conn));
+	if (*lp_magicoutput(SNUM(conn))) {
+		magic_output = lp_magicoutput(SNUM(conn));
 	} else {
 		magic_output = talloc_asprintf(ctx,
 				"%s.out",
@@ -119,7 +117,7 @@
 		goto out;
 	}
 
-	if (transfer_file(tmp_fd,outfd,(off_t)st.st_ex_size) == (off_t)-1) {
+	if (transfer_file(tmp_fd,outfd,(SMB_OFF_T)st.st_ex_size) == (SMB_OFF_T)-1) {
 		int err = errno;
 		close(tmp_fd);
 		close(outfd);
@@ -157,106 +155,44 @@
 	return status;
 }
 
-static int compare_share_mode_times(const void *p1, const void *p2)
-{
-	const struct share_mode_entry *s1 = (const struct share_mode_entry *)p1;
-	const struct share_mode_entry *s2 = (const struct share_mode_entry *)p2;
-	return timeval_compare(&s1->time, &s2->time);
-}
-
 /****************************************************************************
  If any deferred opens are waiting on this close, notify them.
 ****************************************************************************/
 
-static void notify_deferred_opens(struct smbd_server_connection *sconn,
+static void notify_deferred_opens(struct messaging_context *msg_ctx,
 				  struct share_mode_lock *lck)
 {
-	struct server_id self = messaging_server_id(sconn->msg_ctx);
-	uint32_t i, num_deferred;
-	struct share_mode_entry *deferred;
-
-	if (!should_notify_deferred_opens(sconn)) {
-		return;
-	}
-
-	num_deferred = 0;
-	for (i=0; i<lck->data->num_share_modes; i++) {
-		struct share_mode_entry *e = &lck->data->share_modes[i];
-
-		if (!is_deferred_open_entry(e)) {
-			continue;
-		}
-		if (share_mode_stale_pid(lck->data, i)) {
-			continue;
-		}
-		num_deferred += 1;
-	}
-	if (num_deferred == 0) {
-		return;
-	}
+ 	int i;
 
-	deferred = talloc_array(talloc_tos(), struct share_mode_entry,
-				num_deferred);
-	if (deferred == NULL) {
+	if (!should_notify_deferred_opens()) {
 		return;
 	}
-
-	num_deferred = 0;
-	for (i=0; i<lck->data->num_share_modes; i++) {
-		struct share_mode_entry *e = &lck->data->share_modes[i];
-		if (!is_deferred_open_entry(e)) {
-			continue;
-		}
-		if (share_mode_stale_pid(lck->data, i)) {
-			continue;
-		}
-		deferred[num_deferred] = *e;
-		num_deferred += 1;
-	}
-
-	/*
-	 * We need to sort the notifications by initial request time. Imagine
-	 * two opens come in asyncronously, both conflicting with the open we
-	 * just close here. If we don't sort the notifications, the one that
-	 * came in last might get the response before the one that came in
-	 * first. This is demonstrated with the smbtorture4 raw.mux test.
-	 *
-	 * As long as we had the UNUSED_SHARE_MODE_ENTRY, we happened to
-	 * survive this particular test. Without UNUSED_SHARE_MODE_ENTRY, we
-	 * shuffle the share mode entries around a bit, so that we do not
-	 * survive raw.mux anymore.
-	 *
-	 * We could have kept the ordering in del_share_mode, but as the
-	 * ordering was never formalized I think it is better to do it here
-	 * where it is necessary.
-	 */
-
-	qsort(deferred, num_deferred, sizeof(struct share_mode_entry),
-	      compare_share_mode_times);
-
-	for (i=0; i<num_deferred; i++) {
-		struct share_mode_entry *e = &deferred[i];
-
-		if (serverid_equal(&self, &e->pid)) {
+ 
+ 	for (i=0; i<lck->num_share_modes; i++) {
+ 		struct share_mode_entry *e = &lck->share_modes[i];
+ 
+ 		if (!is_deferred_open_entry(e)) {
+ 			continue;
+ 		}
+ 
+ 		if (procid_is_me(&e->pid)) {
  			/*
  			 * We need to notify ourself to retry the open.  Do
  			 * this by finding the queued SMB record, moving it to
  			 * the head of the queue and changing the wait time to
  			 * zero.
  			 */
-			schedule_deferred_open_message_smb(sconn, e->op_mid);
+ 			schedule_deferred_open_message_smb(e->op_mid);
  		} else {
 			char msg[MSG_SMB_SHARE_MODE_ENTRY_SIZE];
 
 			share_mode_entry_to_message(msg, e);
 
-			messaging_send_buf(sconn->msg_ctx, e->pid,
-					   MSG_SMB_OPEN_RETRY,
+			messaging_send_buf(msg_ctx, e->pid, MSG_SMB_OPEN_RETRY,
 					   (uint8 *)msg,
 					   MSG_SMB_SHARE_MODE_ENTRY_SIZE);
  		}
  	}
-	TALLOC_FREE(deferred);
 }
 
 /****************************************************************************
@@ -337,7 +273,6 @@
 					enum file_close_type close_type)
 {
 	connection_struct *conn = fsp->conn;
-	struct server_id self = messaging_server_id(conn->sconn->msg_ctx);
 	bool delete_file = false;
 	bool changed_user = false;
 	struct share_mode_lock *lck = NULL;
@@ -347,11 +282,10 @@
 	const struct security_unix_token *del_token = NULL;
 	const struct security_token *del_nt_token = NULL;
 	bool got_tokens = false;
-	bool normal_close;
 
 	/* Ensure any pending write time updates are done. */
 	if (fsp->update_write_time_event) {
-		update_write_time_handler(fsp->conn->sconn->ev_ctx,
+		update_write_time_handler(smbd_event_context(),
 					fsp->update_write_time_event,
 					timeval_current(),
 					(void *)fsp);
@@ -363,18 +297,21 @@
 	 * This prevents race conditions with the file being created. JRA.
 	 */
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
+
 	if (lck == NULL) {
 		DEBUG(0, ("close_remove_share_mode: Could not get share mode "
 			  "lock for file %s\n", fsp_str_dbg(fsp)));
-		return NT_STATUS_INVALID_PARAMETER;
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto done;
 	}
 
 	if (fsp->write_time_forced) {
 		DEBUG(10,("close_remove_share_mode: write time forced "
 			"for file %s\n",
 			fsp_str_dbg(fsp)));
-		set_close_write_time(fsp, lck->data->changed_write_time);
+		set_close_write_time(fsp, lck->changed_write_time);
 	} else if (fsp->update_write_time_on_close) {
 		/* Someone had a pending write. */
 		if (null_timespec(fsp->close_write_time)) {
@@ -392,6 +329,12 @@
 		}
 	}
 
+	if (!del_share_mode(lck, fsp)) {
+		DEBUG(0, ("close_remove_share_mode: Could not delete share "
+			  "entry for file %s\n",
+			  fsp_str_dbg(fsp)));
+	}
+
 	if (fsp->initial_delete_on_close &&
 			!is_delete_on_close_set(lck, fsp->name_hash)) {
 		bool became_user = False;
@@ -419,33 +362,21 @@
 		/* See if others still have the file open via this pathname.
 		   If this is the case, then don't delete. If all opens are
 		   POSIX delete now. */
-		for (i=0; i<lck->data->num_share_modes; i++) {
-			struct share_mode_entry *e = &lck->data->share_modes[i];
-
-			if (!is_valid_share_mode_entry(e)) {
-				continue;
-			}
-			if (e->name_hash != fsp->name_hash) {
-				continue;
-			}
-			if (fsp->posix_open
-			    && (e->flags & SHARE_MODE_FLAG_POSIX_OPEN)) {
-				continue;
-			}
-			if (serverid_equal(&self, &e->pid) &&
-			    (e->share_file_id == fsp->fh->gen_id)) {
-				continue;
-			}
-			if (share_mode_stale_pid(lck->data, i)) {
-				continue;
+		for (i=0; i<lck->num_share_modes; i++) {
+			struct share_mode_entry *e = &lck->share_modes[i];
+			if (is_valid_share_mode_entry(e) &&
+					e->name_hash == fsp->name_hash) {
+				if (fsp->posix_open && (e->flags & SHARE_MODE_FLAG_POSIX_OPEN)) {
+					continue;
+				}
+				delete_file = False;
+				break;
 			}
-			delete_file = False;
-			break;
 		}
 	}
 
 	/* Notify any deferred opens waiting on this close. */
-	notify_deferred_opens(conn->sconn, lck);
+	notify_deferred_opens(conn->sconn->msg_ctx, lck);
 	reply_to_oplock_break_requests(fsp);
 
 	/*
@@ -453,16 +384,8 @@
 	 * reference to a file.
 	 */
 
-	normal_close = (close_type == NORMAL_CLOSE || close_type == SHUTDOWN_CLOSE);
-
-	if (!normal_close || !delete_file) {
-
-		if (!del_share_mode(lck, fsp)) {
-			DEBUG(0, ("close_remove_share_mode: Could not delete "
-				  "share entry for file %s\n",
-				  fsp_str_dbg(fsp)));
-		}
-
+	if (!(close_type == NORMAL_CLOSE || close_type == SHUTDOWN_CLOSE) ||
+			!delete_file) {
 		TALLOC_FREE(lck);
 		return NT_STATUS_OK;
 	}
@@ -582,11 +505,6 @@
 		pop_sec_ctx();
 	}
 
-	if (!del_share_mode(lck, fsp)) {
-		DEBUG(0, ("close_remove_share_mode: Could not delete share "
-			  "entry for file %s\n", fsp_str_dbg(fsp)));
-	}
-
 	TALLOC_FREE(lck);
 
 	if (delete_file) {
@@ -648,36 +566,26 @@
 		return NT_STATUS_OK;
 	}
 
-	/*
-	 * get_existing_share_mode_lock() isn't really the right
-	 * call here, as we're being called after
-	 * close_remove_share_mode() inside close_normal_file()
-	 * so it's quite normal to not have an existing share
-	 * mode here. However, get_share_mode_lock() doesn't
-	 * work because that will create a new share mode if
-	 * one doesn't exist - so stick with this call (just
-	 * ignore any error we get if the share mode doesn't
-	 * exist.
-	 */
+	/* On close if we're changing the real file time we
+	 * must update it in the open file db too. */
+	(void)set_write_time(fsp->file_id, fsp->close_write_time);
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL, NULL);
 	if (lck) {
-		/* On close if we're changing the real file time we
-		 * must update it in the open file db too. */
-		(void)set_write_time(fsp->file_id, fsp->close_write_time);
-
 		/* Close write times overwrite sticky write times
 		   so we must replace any sticky write time here. */
-		if (!null_timespec(lck->data->changed_write_time)) {
+		if (!null_timespec(lck->changed_write_time)) {
 			(void)set_sticky_write_time(fsp->file_id, fsp->close_write_time);
 		}
 		TALLOC_FREE(lck);
 	}
 
 	ft.mtime = fsp->close_write_time;
-	/* As this is a close based update, we are not directly changing the
+	/* We must use NULL for the fsp handle here, as smb_set_file_time()
+	   checks the fsp access_mask, which may not include FILE_WRITE_ATTRIBUTES.
+	   As this is a close based update, we are not directly changing the
 	   file attributes from a client call, but indirectly from a write. */
-	status = smb_set_file_time(fsp->conn, fsp, fsp->fsp_name, &ft, false);
+	status = smb_set_file_time(fsp->conn, NULL, fsp->fsp_name, &ft, false);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(10,("update_write_time_on_close: smb_set_file_time "
 			"on file %s returned %s\n",
@@ -711,45 +619,18 @@
 	NTSTATUS status = NT_STATUS_OK;
 	NTSTATUS tmp;
 	connection_struct *conn = fsp->conn;
-	bool is_durable = false;
-
-	if (fsp->num_aio_requests != 0) {
-
-		if (close_type != SHUTDOWN_CLOSE) {
-			/*
-			 * reply_close and the smb2 close must have
-			 * taken care of this. No other callers of
-			 * close_file should ever have created async
-			 * I/O.
-			 *
-			 * We need to panic here because if we close()
-			 * the fd while we have outstanding async I/O
-			 * requests, in the worst case we could end up
-			 * writing to the wrong file.
-			 */
-			DEBUG(0, ("fsp->num_aio_requests=%u\n",
-				  fsp->num_aio_requests));
-			smb_panic("can not close with outstanding aio "
-				  "requests");
-		}
 
+	if (close_type == ERROR_CLOSE) {
+		cancel_aio_by_fsp(fsp);
+	} else {
 		/*
-		 * For shutdown close, just drop the async requests
-		 * including a potential close request pending for
-		 * this fsp. Drop the close request first, the
-		 * destructor for the aio_requests would execute it.
+	 	 * If we're finishing async io on a close we can get a write
+		 * error here, we must remember this.
 		 */
-		TALLOC_FREE(fsp->deferred_close);
-
-		while (fsp->num_aio_requests != 0) {
-			/*
-			 * The destructor of the req will remove
-			 * itself from the fsp.
-			 * Don't use TALLOC_FREE here, this will overwrite
-			 * what the destructor just wrote into
-			 * aio_requests[0].
-			 */
-			talloc_free(fsp->aio_requests[0]);
+		int ret = wait_for_aio_completion(fsp);
+		if (ret) {
+			status = ntstatus_keeperror(
+				status, map_nt_error_from_unix(ret));
 		}
 	}
 
@@ -761,75 +642,6 @@
 	tmp = close_filestruct(fsp);
 	status = ntstatus_keeperror(status, tmp);
 
-	if (NT_STATUS_IS_OK(status) && fsp->op != NULL) {
-		is_durable = fsp->op->global->durable;
-	}
-
-	if (close_type != SHUTDOWN_CLOSE) {
-		is_durable = false;
-	}
-
-	if (is_durable) {
-		DATA_BLOB new_cookie = data_blob_null;
-
-		tmp = SMB_VFS_DURABLE_DISCONNECT(fsp,
-					fsp->op->global->backend_cookie,
-					fsp->op,
-					&new_cookie);
-		if (NT_STATUS_IS_OK(tmp)) {
-			struct timeval tv;
-			NTTIME now;
-
-			if (req != NULL) {
-				tv = req->request_time;
-			} else {
-				tv = timeval_current();
-			}
-			now = timeval_to_nttime(&tv);
-
-			data_blob_free(&fsp->op->global->backend_cookie);
-			fsp->op->global->backend_cookie = new_cookie;
-
-			fsp->op->compat = NULL;
-			tmp = smbXsrv_open_close(fsp->op, now);
-			if (!NT_STATUS_IS_OK(tmp)) {
-				DEBUG(1, ("Failed to update smbXsrv_open "
-					  "record when disconnecting durable "
-					  "handle for file %s: %s - "
-					  "proceeding with normal close\n",
-					  fsp_str_dbg(fsp), nt_errstr(tmp)));
-			}
-			scavenger_schedule_disconnected(fsp);
-		} else {
-			DEBUG(1, ("Failed to disconnect durable handle for "
-				  "file %s: %s - proceeding with normal "
-				  "close\n", fsp_str_dbg(fsp), nt_errstr(tmp)));
-		}
-		if (!NT_STATUS_IS_OK(tmp)) {
-			is_durable = false;
-		}
-	}
-
-	if (is_durable) {
-		/*
-		 * This is the case where we successfully disconnected
-		 * a durable handle and closed the underlying file.
-		 * In all other cases, we proceed with a genuine close.
-		 */
-		DEBUG(10, ("%s disconnected durable handle for file %s\n",
-			   conn->session_info->unix_info->unix_name,
-			   fsp_str_dbg(fsp)));
-		file_free(req, fsp);
-		return NT_STATUS_OK;
-	}
-
-	if (fsp->op != NULL) {
-		/*
-		 * Make sure the handle is not marked as durable anymore
-		 */
-		fsp->op->global->durable = false;
-	}
-
 	if (fsp->print_file) {
 		/* FIXME: return spool errors */
 		print_spool_end(fsp, close_type);
@@ -879,7 +691,7 @@
 	status = ntstatus_keeperror(status, tmp);
 
 	DEBUG(2,("%s closed file %s (numopen=%d) %s\n",
-		conn->session_info->unix_info->unix_name, fsp_str_dbg(fsp),
+		conn->session_info->unix_name, fsp_str_dbg(fsp),
 		conn->num_files_open - 1,
 		nt_errstr(status) ));
 
@@ -887,13 +699,13 @@
 	return status;
 }
 /****************************************************************************
- Function used by reply_rmdir to delete an entire directory
+ Static function used by reply_rmdir to delete an entire directory
  tree recursively. Return True on ok, False on fail.
 ****************************************************************************/
 
-bool recursive_rmdir(TALLOC_CTX *ctx,
-		     connection_struct *conn,
-		     struct smb_filename *smb_dname)
+static bool recursive_rmdir(TALLOC_CTX *ctx,
+			connection_struct *conn,
+			struct smb_filename *smb_dname)
 {
 	const char *dname = NULL;
 	char *talloced = NULL;
@@ -1010,7 +822,7 @@
 		return NT_STATUS_OK;
 	}
 
-	if(((errno == ENOTEMPTY)||(errno == EEXIST)) && *lp_veto_files(talloc_tos(), SNUM(conn))) {
+	if(((errno == ENOTEMPTY)||(errno == EEXIST)) && *lp_veto_files(SNUM(conn))) {
 		/*
 		 * Check to see if the only thing in this directory are
 		 * vetoed files/directories. If so then delete them and
@@ -1151,7 +963,6 @@
 static NTSTATUS close_directory(struct smb_request *req, files_struct *fsp,
 				enum file_close_type close_type)
 {
-	struct server_id self = messaging_server_id(fsp->conn->sconn->msg_ctx);
 	struct share_mode_lock *lck = NULL;
 	bool delete_dir = False;
 	NTSTATUS status = NT_STATUS_OK;
@@ -1164,11 +975,19 @@
 	 * reference to a directory also.
 	 */
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
+
 	if (lck == NULL) {
 		DEBUG(0, ("close_directory: Could not get share mode lock for "
 			  "%s\n", fsp_str_dbg(fsp)));
-		return NT_STATUS_INVALID_PARAMETER;
+		status = NT_STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	if (!del_share_mode(lck, fsp)) {
+		DEBUG(0, ("close_directory: Could not delete share entry for "
+			  "%s\n", fsp_str_dbg(fsp)));
 	}
 
 	if (fsp->initial_delete_on_close) {
@@ -1200,20 +1019,13 @@
 		int i;
 		/* See if others still have the dir open. If this is the
 		 * case, then don't delete. If all opens are POSIX delete now. */
-		for (i=0; i<lck->data->num_share_modes; i++) {
-			struct share_mode_entry *e = &lck->data->share_modes[i];
+		for (i=0; i<lck->num_share_modes; i++) {
+			struct share_mode_entry *e = &lck->share_modes[i];
 			if (is_valid_share_mode_entry(e) &&
 					e->name_hash == fsp->name_hash) {
 				if (fsp->posix_open && (e->flags & SHARE_MODE_FLAG_POSIX_OPEN)) {
 					continue;
 				}
-				if (serverid_equal(&self, &e->pid) &&
-				    (e->share_file_id == fsp->fh->gen_id)) {
-					continue;
-				}
-				if (share_mode_stale_pid(lck->data, i)) {
-					continue;
-				}
 				delete_dir = False;
 				break;
 			}
@@ -1235,11 +1047,6 @@
 				del_token->groups,
 				del_nt_token);
 
-		if (!del_share_mode(lck, fsp)) {
-			DEBUG(0, ("close_directory: Could not delete share entry for "
-				  "%s\n", fsp_str_dbg(fsp)));
-		}
-
 		TALLOC_FREE(lck);
 
 		if ((fsp->conn->fs_capabilities & FILE_NAMED_STREAMS)
@@ -1249,7 +1056,7 @@
 			if (!NT_STATUS_IS_OK(status)) {
 				DEBUG(5, ("delete_all_streams failed: %s\n",
 					  nt_errstr(status)));
-				return status;
+				goto out;
 			}
 		}
 
@@ -1271,11 +1078,6 @@
 			remove_pending_change_notify_requests_by_fid(fsp, NT_STATUS_DELETE_PENDING);
 		}
 	} else {
-		if (!del_share_mode(lck, fsp)) {
-			DEBUG(0, ("close_directory: Could not delete share entry for "
-				  "%s\n", fsp_str_dbg(fsp)));
-		}
-
 		TALLOC_FREE(lck);
 		remove_pending_change_notify_requests_by_fid(
 			fsp, NT_STATUS_OK);
@@ -1295,6 +1097,8 @@
 	close_filestruct(fsp);
 	file_free(req, fsp);
 
+ out:
+	TALLOC_FREE(lck);
 	if (NT_STATUS_IS_OK(status) && !NT_STATUS_IS_OK(status1)) {
 		status = status1;
 	}
@@ -1348,11 +1152,15 @@
 			struct server_id server_id,
 			DATA_BLOB *data)
 {
+	struct smbd_server_connection *sconn;
 	files_struct *fsp = NULL;
 	struct share_mode_entry e;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
+
+	sconn = msg_ctx_to_sconn(msg_ctx);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
 
 	message_to_share_mode_entry(&e, (char *)data->data);
 
Only in ../../samba-3.6.24/source3/smbd: close.o
diff -ur smbd/conn.c ../../samba-3.6.24/source3/smbd/conn.c
--- smbd/conn.c	2013-02-05 20:25:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/conn.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,84 +22,23 @@
 #include "includes.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
-#include "lib/util/bitmap.h"
+#include "rpc_server/rpc_ncacn_np.h"
 
-/*******************************************************************
- Static cache for storing per-user share access value. This really
- belongs inside the vuid_cache.array struct but we can't change the
- VFS ABI for 4.0.x. This is fixed in 4.1.x. JRA.
-********************************************************************/
+/* The connections bitmap is expanded in increments of BITMAP_BLOCK_SZ. The
+ * maximum size of the bitmap is the largest positive integer, but you will hit
+ * the "max connections" limit, looong before that.
+ */
 
-struct connection_share_access_list {
-	struct connection_share_access_list *next, *prev;
-	connection_struct *conn;
-	uint32_t vuid_cache_share_access_array[VUID_CACHE_SIZE];
-};
-
-static struct connection_share_access_list *conn_share_access_list;
-
-/*******************************************************************
- Destructor function for per-user share access value.
-********************************************************************/
-
-static int free_csal_entry(struct connection_share_access_list *csal)
-{
-	DLIST_REMOVE(conn_share_access_list, csal);
-	return 0;
-}
-
-/*******************************************************************
- Utility function to find a per-user share access value struct.
-********************************************************************/
-
-static struct connection_share_access_list *find_csal_entry(connection_struct *conn)
-{
-	struct connection_share_access_list *csal;
-
-	for (csal = conn_share_access_list; csal; csal = csal->next) {
-		if (csal->conn == conn) {
-			DLIST_PROMOTE(conn_share_access_list, csal);
-			return csal;
-		}
-	}
-	return NULL;
-}
+#define BITMAP_BLOCK_SZ 128
 
-/*******************************************************************
- Accessor functions for per-user share access value.
- These are the only two functions exposed externally.
-********************************************************************/
-
-uint32_t get_connection_share_access_list_entry(connection_struct *conn,
-						unsigned int i)
-{
-	struct connection_share_access_list *csal =
-			find_csal_entry(conn);
-
-	if (csal == NULL) {
-		/*
-		 * This is a faked up connection struct
-		 * for internal purposes.
-		 * Return full access.
-		 */
-		return SEC_RIGHTS_FILE_ALL;
-	}
-
-	return csal->vuid_cache_share_access_array[i];
-}
+/****************************************************************************
+ Init the conn structures.
+****************************************************************************/
 
-void set_connection_share_access_list_entry(connection_struct *conn,
-						unsigned int i,
-						uint32_t val)
+void conn_init(struct smbd_server_connection *sconn)
 {
-	struct connection_share_access_list *csal =
-			find_csal_entry(conn);
-
-	if (csal == NULL) {
-		return;
-	}
-
-	csal->vuid_cache_share_access_array[i] = val;
+	sconn->smb1.tcons.Connections = NULL;
+	sconn->smb1.tcons.bmap = bitmap_talloc(sconn, BITMAP_BLOCK_SZ);
 }
 
 /****************************************************************************
@@ -108,25 +47,78 @@
 
 int conn_num_open(struct smbd_server_connection *sconn)
 {
-	return sconn->num_connections;
+	return sconn->num_tcons_open;
 }
 
 /****************************************************************************
  Check if a snum is in use.
 ****************************************************************************/
 
-bool conn_snum_used(struct smbd_server_connection *sconn,
-		    int snum)
+bool conn_snum_used(int snum)
 {
-	struct connection_struct *conn;
+	struct smbd_server_connection *sconn = smbd_server_conn;
+
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *ptcon;
+
+			for (ptcon = sess->tcons.list; ptcon; ptcon = ptcon->next) {
+				if (ptcon->compat_conn &&
+						ptcon->compat_conn->params &&
+						(ptcon->compat_conn->params->service == snum)) {
+					return true;
+				}
+			}
+		}
+	} else {
+		/* SMB1 */
+		connection_struct *conn;
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=conn->next) {
+			if (conn->params->service == snum) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+/****************************************************************************
+ Find a conn given a cnum.
+****************************************************************************/
 
-	for (conn=sconn->connections; conn; conn=conn->next) {
-		if (conn->params->service == snum) {
-			return true;
+connection_struct *conn_find(struct smbd_server_connection *sconn,unsigned cnum)
+{
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *ptcon;
+
+			for (ptcon = sess->tcons.list; ptcon; ptcon = ptcon->next) {
+				if (ptcon->compat_conn &&
+						ptcon->compat_conn->cnum == cnum) {
+					return ptcon->compat_conn;
+				}
+			}
+		}
+	} else {
+		/* SMB1 */
+		int count=0;
+		connection_struct *conn;
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=conn->next,count++) {
+			if (conn->cnum == cnum) {
+				if (count > 10) {
+					DLIST_PROMOTE(sconn->smb1.tcons.Connections,
+						conn);
+				}
+				return conn;
+			}
 		}
 	}
 
-	return false;
+	return NULL;
 }
 
 /****************************************************************************
@@ -138,87 +130,254 @@
 connection_struct *conn_new(struct smbd_server_connection *sconn)
 {
 	connection_struct *conn;
-	struct connection_share_access_list *csal;
+	int i;
+        int find_offset = 1;
 
-	if (!(conn=talloc_zero(NULL, connection_struct)) ||
-	    !(conn->params = talloc(conn, struct share_params)) ||
-	    !(conn->connectpath = talloc_strdup(conn, "")) ||
-	    !(conn->origpath = talloc_strdup(conn, "")) ||
-	    !(csal = talloc_zero(conn, struct connection_share_access_list))) {
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		if (!(conn=TALLOC_ZERO_P(NULL, connection_struct)) ||
+		    !(conn->params = TALLOC_P(conn, struct share_params))) {
+			DEBUG(0,("TALLOC_ZERO() failed!\n"));
+			TALLOC_FREE(conn);
+			return NULL;
+		}
+		conn->sconn = sconn;
+		return conn;
+	}
+
+	/* SMB1 */
+find_again:
+	i = bitmap_find(sconn->smb1.tcons.bmap, find_offset);
+
+	if (i == -1) {
+                /* Expand the connections bitmap. */
+                int             oldsz = sconn->smb1.tcons.bmap->n;
+                int             newsz = sconn->smb1.tcons.bmap->n +
+					BITMAP_BLOCK_SZ;
+                struct bitmap * nbmap;
+
+                if (newsz <= oldsz) {
+                        /* Integer wrap. */
+		        DEBUG(0,("ERROR! Out of connection structures\n"));
+                        return NULL;
+                }
+
+		DEBUG(4,("resizing connections bitmap from %d to %d\n",
+                        oldsz, newsz));
+
+                nbmap = bitmap_talloc(sconn, newsz);
+		if (!nbmap) {
+			DEBUG(0,("ERROR! malloc fail.\n"));
+			return NULL;
+		}
+
+                bitmap_copy(nbmap, sconn->smb1.tcons.bmap);
+		TALLOC_FREE(sconn->smb1.tcons.bmap);
+
+                sconn->smb1.tcons.bmap = nbmap;
+                find_offset = oldsz; /* Start next search in the new portion. */
+
+                goto find_again;
+	}
+
+	/* The bitmap position is used below as the connection number
+	 * conn->cnum). This ends up as the TID field in the SMB header,
+	 * which is limited to 16 bits (we skip 0xffff which is the
+	 * NULL TID).
+	 */
+	if (i > 65534) {
+		DEBUG(0, ("Maximum connection limit reached\n"));
+		return NULL;
+	}
+
+	if (!(conn=TALLOC_ZERO_P(NULL, connection_struct)) ||
+	    !(conn->params = TALLOC_P(conn, struct share_params))) {
 		DEBUG(0,("TALLOC_ZERO() failed!\n"));
 		TALLOC_FREE(conn);
 		return NULL;
 	}
-	talloc_set_destructor(csal, free_csal_entry);
-
 	conn->sconn = sconn;
+	conn->cnum = i;
 	conn->force_group_gid = (gid_t)-1;
 
-	DLIST_ADD(sconn->connections, conn);
-	DLIST_ADD(conn_share_access_list, csal);
-	sconn->num_connections++;
+	bitmap_set(sconn->smb1.tcons.bmap, i);
+
+	sconn->num_tcons_open++;
+
+	string_set(&conn->connectpath,"");
+	string_set(&conn->origpath,"");
+
+	DLIST_ADD(sconn->smb1.tcons.Connections, conn);
 
 	return conn;
 }
 
 /****************************************************************************
- Clear a vuid out of the connection's vuid cache
+ Close all conn structures.
+ Return true if any were closed.
 ****************************************************************************/
 
-static void conn_clear_vuid_cache(connection_struct *conn, uint64_t vuid)
+bool conn_close_all(struct smbd_server_connection *sconn)
 {
-	int i;
+	bool ret = false;
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *tcon, *tc_next;
+
+			for (tcon = sess->tcons.list; tcon; tcon = tc_next) {
+				tc_next = tcon->next;
+				TALLOC_FREE(tcon);
+				ret = true;
+			}
+		}
+	} else {
+		/* SMB1 */
+		connection_struct *conn, *next;
+
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=next) {
+			next=conn->next;
+			set_current_service(conn, 0, True);
+			close_cnum(conn, conn->vuid);
+			ret = true;
+		}
+	}
+	return ret;
+}
 
-	for (i=0; i<VUID_CACHE_SIZE; i++) {
-		struct vuid_cache_entry *ent;
+/****************************************************************************
+ Update last used timestamps.
+****************************************************************************/
 
-		ent = &conn->vuid_cache.array[i];
+static void conn_lastused_update(struct smbd_server_connection *sconn,time_t t)
+{
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *ptcon;
+
+			for (ptcon = sess->tcons.list; ptcon; ptcon = ptcon->next) {
+				connection_struct *conn = ptcon->compat_conn;
+				/* Update if connection wasn't idle. */
+				if (conn && conn->lastused != conn->lastused_count) {
+					conn->lastused = t;
+					conn->lastused_count = t;
+				}
+			}
+		}
+	} else {
+		/* SMB1 */
+		connection_struct *conn;
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=conn->next) {
+			/* Update if connection wasn't idle. */
+			if (conn->lastused != conn->lastused_count) {
+				conn->lastused = t;
+				conn->lastused_count = t;
+			}
+		}
+	}
+}
 
-		if (ent->vuid == vuid) {
-			ent->vuid = UID_FIELD_INVALID;
-			/*
-			 * We need to keep conn->session_info around
-			 * if it's equal to ent->session_info as a SMBulogoff
-			 * is often followed by a SMBtdis (with an invalid
-			 * vuid). The debug code (or regular code in
-			 * vfs_full_audit) wants to refer to the
-			 * conn->session_info pointer to print debug
-			 * statements. Theoretically this is a bug,
-			 * as once the vuid is gone the session_info
-			 * on the conn struct isn't valid any more,
-			 * but there's enough code that assumes
-			 * conn->session_info is never null that
-			 * it's easier to hold onto the old pointer
-			 * until we get a new sessionsetupX.
-			 * As everything is hung off the
-			 * conn pointer as a talloc context we're not
-			 * leaking memory here. See bug #6315. JRA.
-			 */
-			if (conn->session_info == ent->session_info) {
-				ent->session_info = NULL;
-			} else {
-				TALLOC_FREE(ent->session_info);
+/****************************************************************************
+ Idle inactive connections.
+****************************************************************************/
+
+bool conn_idle_all(struct smbd_server_connection *sconn, time_t t)
+{
+	int deadtime = lp_deadtime()*60;
+
+	conn_lastused_update(sconn, t);
+
+	if (deadtime <= 0) {
+		deadtime = DEFAULT_SMBD_TIMEOUT;
+	}
+
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *ptcon;
+
+			for (ptcon = sess->tcons.list; ptcon; ptcon = ptcon->next) {
+				time_t age;
+				connection_struct *conn = ptcon->compat_conn;
+
+				if (conn == NULL) {
+					continue;
+				}
+
+				age = t - conn->lastused;
+				/* close dirptrs on connections that are idle */
+				if (age > DPTR_IDLE_TIMEOUT) {
+					dptr_idlecnum(conn);
+				}
+
+				if (conn->num_files_open > 0 || age < deadtime) {
+					return false;
+				}
+			}
+		}
+	} else {
+		/* SMB1 */
+		connection_struct *conn;
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=conn->next) {
+			time_t age = t - conn->lastused;
+
+			/* close dirptrs on connections that are idle */
+			if (age > DPTR_IDLE_TIMEOUT) {
+				dptr_idlecnum(conn);
+			}
+
+			if (conn->num_files_open > 0 || age < deadtime) {
+				return false;
 			}
-			ent->read_only = False;
 		}
 	}
+
+	/*
+	 * Check all pipes for any open handles. We cannot
+	 * idle with a handle open.
+	 */
+	if (check_open_pipes()) {
+		return false;
+	}
+
+	return true;
 }
 
 /****************************************************************************
  Clear a vuid out of the validity cache, and as the 'owner' of a connection.
-
- Called from invalidate_vuid()
 ****************************************************************************/
 
-void conn_clear_vuid_caches(struct smbd_server_connection *sconn, uint64_t vuid)
+void conn_clear_vuid_caches(struct smbd_server_connection *sconn,uint16_t vuid)
 {
 	connection_struct *conn;
 
-	for (conn=sconn->connections; conn;conn=conn->next) {
-		if (conn->vuid == vuid) {
-			conn->vuid = UID_FIELD_INVALID;
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *ptcon;
+
+			for (ptcon = sess->tcons.list; ptcon; ptcon = ptcon->next) {
+				if (ptcon->compat_conn) {
+					if (ptcon->compat_conn->vuid == vuid) {
+						ptcon->compat_conn->vuid = UID_FIELD_INVALID;
+					}
+					conn_clear_vuid_cache(ptcon->compat_conn, vuid);
+				}
+			}
+		}
+	} else {
+		/* SMB1 */
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=conn->next) {
+			if (conn->vuid == vuid) {
+				conn->vuid = UID_FIELD_INVALID;
+			}
+			conn_clear_vuid_cache(conn, vuid);
 		}
-		conn_clear_vuid_cache(conn, vuid);
 	}
 }
 
@@ -253,6 +412,9 @@
 	free_namearray(conn->veto_oplock_list);
 	free_namearray(conn->aio_write_behind_list);
 
+	string_free(&conn->connectpath);
+	string_free(&conn->origpath);
+
 	ZERO_STRUCTP(conn);
 	talloc_destroy(conn);
 }
@@ -268,9 +430,91 @@
 		return;
 	}
 
-	DLIST_REMOVE(conn->sconn->connections, conn);
-	SMB_ASSERT(conn->sconn->num_connections > 0);
-	conn->sconn->num_connections--;
+	if (conn->sconn->using_smb2) {
+		/* SMB2 */
+		conn_free_internal(conn);
+		return;
+	}
+
+	/* SMB1 */
+	DLIST_REMOVE(conn->sconn->smb1.tcons.Connections, conn);
+
+	if (conn->sconn->smb1.tcons.bmap != NULL) {
+		/*
+		 * Can be NULL for fake connections created by
+		 * create_conn_struct()
+		 */
+		bitmap_clear(conn->sconn->smb1.tcons.bmap, conn->cnum);
+	}
+
+	SMB_ASSERT(conn->sconn->num_tcons_open > 0);
+	conn->sconn->num_tcons_open--;
 
 	conn_free_internal(conn);
 }
+
+/****************************************************************************
+ Receive a smbcontrol message to forcibly unmount a share.
+ The message contains just a share name and all instances of that
+ share are unmounted.
+ The special sharename '*' forces unmount of all shares.
+****************************************************************************/
+
+void msg_force_tdis(struct messaging_context *msg,
+		    void *private_data,
+		    uint32_t msg_type,
+		    struct server_id server_id,
+		    DATA_BLOB *data)
+{
+	struct smbd_server_connection *sconn;
+	connection_struct *conn, *next;
+	fstring sharename;
+
+	sconn = msg_ctx_to_sconn(msg);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
+
+	fstrcpy(sharename, (const char *)data->data);
+
+	if (strcmp(sharename, "*") == 0) {
+		DEBUG(1,("Forcing close of all shares\n"));
+		conn_close_all(sconn);
+		goto done;
+	}
+
+	if (sconn->using_smb2) {
+		/* SMB2 */
+		struct smbd_smb2_session *sess;
+		for (sess = sconn->smb2.sessions.list; sess; sess = sess->next) {
+			struct smbd_smb2_tcon *tcon, *tc_next;
+
+			for (tcon = sess->tcons.list; tcon; tcon = tc_next) {
+				tc_next = tcon->next;
+				if (tcon->compat_conn &&
+						strequal(lp_servicename(SNUM(tcon->compat_conn)),
+								sharename)) {
+					DEBUG(1,("Forcing close of share %s cnum=%d\n",
+						sharename, tcon->compat_conn->cnum));
+					TALLOC_FREE(tcon);
+				}
+			}
+		}
+	} else {
+		/* SMB1 */
+		for (conn=sconn->smb1.tcons.Connections;conn;conn=next) {
+			next=conn->next;
+			if (strequal(lp_servicename(SNUM(conn)), sharename)) {
+				DEBUG(1,("Forcing close of share %s cnum=%d\n",
+					sharename, conn->cnum));
+				close_cnum(conn, (uint16)-1);
+			}
+		}
+	}
+
+ done:
+
+	change_to_root_user();
+	reload_services(msg, -1, true);
+}
diff -ur smbd/connection.c ../../samba-3.6.24/source3/smbd/connection.c
--- smbd/connection.c	2012-10-30 17:01:47.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/connection.c	2015-01-28 10:52:25.149068676 +0800
@@ -20,35 +20,77 @@
 #include "includes.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
-#include "dbwrap/dbwrap.h"
+#include "dbwrap.h"
 #include "auth.h"
-#include "../lib/tsocket/tsocket.h"
-#include "messages.h"
-#include "lib/conn_tdb.h"
+
+/****************************************************************************
+ Delete a connection record.
+****************************************************************************/
+
+bool yield_connection(connection_struct *conn, const char *name)
+{
+	struct db_record *rec;
+	NTSTATUS status;
+
+	DEBUG(3,("Yielding connection to %s\n",name));
+
+	rec = connections_fetch_entry(talloc_tos(), conn, name);
+	if (rec == NULL) {
+		DEBUG(0, ("connections_fetch_entry failed\n"));
+		return False;
+	}
+
+	status = rec->delete_rec(rec);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG( NT_STATUS_EQUAL(status, NT_STATUS_NOT_FOUND) ? 3 : 0,
+		       ("deleting connection record returned %s\n",
+			nt_errstr(status)));
+	}
+
+	TALLOC_FREE(rec);
+	return NT_STATUS_IS_OK(status);
+}
 
 struct count_stat {
 	int curr_connections;
 	const char *name;
-	bool verify;
+	bool Clear;
 };
 
 /****************************************************************************
  Count the entries belonging to a service in the connection db.
 ****************************************************************************/
 
-static int count_fn(struct smbXsrv_tcon_global0 *tcon,
+static int count_fn(struct db_record *rec,
+		    const struct connections_key *ckey,
+		    const struct connections_data *crec,
 		    void *udp)
 {
 	struct count_stat *cs = (struct count_stat *)udp;
 
-	if (cs->verify && !process_exists(tcon->server_id)) {
+	if (crec->cnum == -1) {
 		return 0;
 	}
 
-	if (strequal(tcon->share_name, cs->name)) {
-		cs->curr_connections++;
+	/* If the pid was not found delete the entry from connections.tdb */
+
+	if (cs->Clear && !process_exists(crec->pid) && (errno == ESRCH)) {
+		NTSTATUS status;
+		DEBUG(2,("pid %s doesn't exist - deleting connections %d [%s]\n",
+			 procid_str_static(&crec->pid), crec->cnum,
+			 crec->servicename));
+
+		status = rec->delete_rec(rec);
+		if (!NT_STATUS_IS_OK(status)) {
+			DEBUG(0,("count_fn: tdb_delete failed with error %s\n",
+				 nt_errstr(status)));
+		}
+		return 0;
 	}
 
+	if (strequal(crec->servicename, cs->name))
+		cs->curr_connections++;
+
 	return 0;
 }
 
@@ -56,41 +98,72 @@
  Claim an entry in the connections database.
 ****************************************************************************/
 
-int count_current_connections(const char *sharename, bool verify)
+int count_current_connections( const char *sharename, bool clear  )
 {
 	struct count_stat cs;
-	NTSTATUS status;
 
 	cs.curr_connections = 0;
 	cs.name = sharename;
-	cs.verify = verify;
+	cs.Clear = clear;
 
 	/*
 	 * This has a race condition, but locking the chain before hand is worse
 	 * as it leads to deadlock.
 	 */
 
-	status = smbXsrv_tcon_global_traverse(count_fn, &cs);
-
-	if (!NT_STATUS_IS_OK(status)) {
+	if (connections_forall(count_fn, &cs) == -1) {
 		DEBUG(0,("count_current_connections: traverse of "
-			 "smbXsrv_tcon_global.tdb failed - %s\n",
-			 nt_errstr(status)));
-		return 0;
+			 "connections.tdb failed\n"));
+		return False;
 	}
 
 	return cs.curr_connections;
 }
 
-bool connections_snum_used(struct smbd_server_connection *unused, int snum)
+/****************************************************************************
+ Claim an entry in the connections database.
+****************************************************************************/
+
+bool claim_connection(connection_struct *conn, const char *name)
 {
-	int active;
+	struct db_record *rec;
+	struct connections_data crec;
+	TDB_DATA dbuf;
+	NTSTATUS status;
 
-	active = count_current_connections(lp_servicename(talloc_tos(), snum),
-					   true);
-	if (active > 0) {
-		return true;
+	DEBUG(5,("claiming [%s]\n", name));
+
+	if (!(rec = connections_fetch_entry(talloc_tos(), conn, name))) {
+		DEBUG(0, ("connections_fetch_entry failed\n"));
+		return False;
+	}
+
+	/* fill in the crec */
+	ZERO_STRUCT(crec);
+	crec.magic = 0x280267;
+	crec.pid = sconn_server_id(conn->sconn);
+	crec.cnum = conn->cnum;
+	crec.uid = conn->session_info->utok.uid;
+	crec.gid = conn->session_info->utok.gid;
+	strlcpy(crec.servicename, lp_servicename(SNUM(conn)),
+		sizeof(crec.servicename));
+	crec.start = time(NULL);
+
+	strlcpy(crec.machine,get_remote_machine_name(),sizeof(crec.machine));
+	strlcpy(crec.addr, conn->sconn->client_id.addr, sizeof(crec.addr));
+
+	dbuf.dptr = (uint8 *)&crec;
+	dbuf.dsize = sizeof(crec);
+
+	status = rec->store(rec, dbuf, TDB_REPLACE);
+
+	TALLOC_FREE(rec);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(0,("claim_connection: tdb_store failed with error %s.\n",
+			 nt_errstr(status)));
+		return False;
 	}
 
-	return false;
+	return True;
 }
Only in ../../samba-3.6.24/source3/smbd: connection.o
Only in smbd: conn_idle.c
Only in smbd: conn_msg.c
Only in ../../samba-3.6.24/source3/smbd: conn.o
diff -ur smbd/dfree.c ../../samba-3.6.24/source3/smbd/dfree.c
--- smbd/dfree.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/dfree.c	2015-01-28 10:52:25.149068676 +0800
@@ -25,7 +25,7 @@
  Normalise for DOS usage.
 ****************************************************************************/
 
-void disk_norm(bool small_query, uint64_t *bsize,uint64_t *dfree,uint64_t *dsize)
+static void disk_norm(bool small_query, uint64_t *bsize,uint64_t *dfree,uint64_t *dsize)
 {
 	/* check if the disk is beyond the max disk size */
 	uint64_t maxdisksize = lp_maxdisksize();
@@ -80,7 +80,7 @@
 	 * If external disk calculation specified, use it.
 	 */
 
-	dfree_command = lp_dfree_command(talloc_tos(), SNUM(conn));
+	dfree_command = lp_dfree_command(SNUM(conn));
 	if (dfree_command && *dfree_command) {
 		const char *p;
 		char **lines = NULL;
@@ -95,7 +95,7 @@
 			return (uint64_t)-1;
 		}
 
-		DEBUG (3, ("disk_free: Running command '%s'\n", syscmd));
+		DEBUG (3, ("disk_free: Running command %s\n", syscmd));
 
 		lines = file_lines_pload(syscmd, NULL);
 		if (lines) {
@@ -123,9 +123,8 @@
 			if (!*dfree)
 				*dfree = 1024;
 		} else {
-			DEBUG (0, ("disk_free: file_lines_load() failed for "
-				   "command '%s'. Error was : %s\n",
-				   syscmd, strerror(errno) ));
+			DEBUG (0, ("disk_free: sys_popen() failed for command %s. Error was : %s\n",
+				syscmd, strerror(errno) ));
 			if (sys_fsusage(path, dfree, dsize) != 0) {
 				DEBUG (0, ("disk_free: sys_fsusage() failed. Error was : %s\n",
 					strerror(errno) ));
@@ -208,7 +207,7 @@
 
 	/* No cached info or time to refresh. */
 	if (!dfc) {
-		dfc = talloc(conn, struct dfree_cached_info);
+		dfc = TALLOC_P(conn, struct dfree_cached_info);
 		if (!dfc) {
 			return dfree_ret;
 		}
Only in ../../samba-3.6.24/source3/smbd: dfree.o
diff -ur smbd/dir.c ../../samba-3.6.24/source3/smbd/dir.c
--- smbd/dir.c	2014-02-18 17:15:49.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/dir.c	2015-01-28 10:52:25.149068676 +0800
@@ -23,8 +23,6 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "libcli/security/security.h"
-#include "lib/util/bitmap.h"
-#include "memcache.h"
 
 /*
    This module implements directory related functions for Samba.
@@ -35,11 +33,6 @@
 #define START_OF_DIRECTORY_OFFSET ((long)0)
 #define DOT_DOT_DIRECTORY_OFFSET ((long)0x80000000)
 
-/* "Special" directory offsets in 32-bit wire format. */
-#define WIRE_END_OF_DIRECTORY_OFFSET ((uint32_t)0xFFFFFFFF)
-#define WIRE_START_OF_DIRECTORY_OFFSET ((uint32_t)0)
-#define WIRE_DOT_DOT_DIRECTORY_OFFSET ((uint32_t)0x80000000)
-
 /* Make directory handle internals available. */
 
 struct name_cache_entry {
@@ -49,7 +42,7 @@
 
 struct smb_Dir {
 	connection_struct *conn;
-	DIR *dir;
+	SMB_STRUCT_DIR *dir;
 	long offset;
 	char *dir_path;
 	size_t name_cache_size;
@@ -72,9 +65,6 @@
 	char *path;
 	bool has_wild; /* Set to true if the wcard entry has MS wildcard characters in it. */
 	bool did_stat; /* Optimisation for non-wcard searches. */
-	bool priv;     /* Directory handle opened with privilege. */
-	uint32_t counter;
-	struct memcache *dptr_cache;
 };
 
 static struct smb_Dir *OpenDir_fsp(TALLOC_CTX *mem_ctx, connection_struct *conn,
@@ -92,7 +82,7 @@
 			char *buf,
 			const char *mask,
 			const char *fname,
-			off_t size,
+			SMB_OFF_T size,
 			uint32 mode,
 			time_t date,
 			bool uc)
@@ -159,8 +149,6 @@
 	if (dptr->dir_hnd) {
 		DEBUG(4,("Idling dptr dnum %d\n",dptr->dnum));
 		TALLOC_FREE(dptr->dir_hnd);
-		TALLOC_FREE(dptr->dptr_cache);
-		dptr->counter = 0;
 	}
 }
 
@@ -214,7 +202,7 @@
 					      dptr->wcard, dptr->attr))) {
 					DEBUG(4,("dptr_get: Failed to open %s (%s)\n",dptr->path,
 						strerror(errno)));
-					return NULL;
+					return False;
 				}
 			}
 			DLIST_PROMOTE(sconn->searches.dirptrs,dptr);
@@ -228,7 +216,7 @@
  Get the dir path for a dir index.
 ****************************************************************************/
 
-const char *dptr_path(struct smbd_server_connection *sconn, int key)
+char *dptr_path(struct smbd_server_connection *sconn, int key)
 {
 	struct dptr_struct *dptr = dptr_get(sconn, key, false);
 	if (dptr)
@@ -240,7 +228,7 @@
  Get the dir wcard for a dir index.
 ****************************************************************************/
 
-const char *dptr_wcard(struct smbd_server_connection *sconn, int key)
+char *dptr_wcard(struct smbd_server_connection *sconn, int key)
 {
 	struct dptr_struct *dptr = dptr_get(sconn, key, false);
 	if (dptr)
@@ -294,7 +282,11 @@
 
 done:
 	TALLOC_FREE(dptr->dir_hnd);
-	TALLOC_FREE(dptr);
+
+	/* Lanman 2 specific code */
+	SAFE_FREE(dptr->wcard);
+	SAFE_FREE(dptr->path);
+	SAFE_FREE(dptr);
 }
 
 /****************************************************************************
@@ -425,60 +417,6 @@
 }
 
 /****************************************************************************
- Safely do an OpenDir as root, ensuring we're in the right place.
-****************************************************************************/
-
-static struct smb_Dir *open_dir_with_privilege(connection_struct *conn,
-					struct smb_request *req,
-					const char *path,
-					const char *wcard,
-					uint32_t attr)
-{
-	NTSTATUS status;
-	struct smb_Dir *dir_hnd = NULL;
-	struct smb_filename *smb_fname_cwd = NULL;
-	char *saved_dir = vfs_GetWd(talloc_tos(), conn);
-	struct privilege_paths *priv_paths = req->priv_paths;
-	int ret;
-
-	if (saved_dir == NULL) {
-		return NULL;
-	}
-
-	if (vfs_ChDir(conn, path) == -1) {
-		return NULL;
-	}
-
-	/* Now check the stat value is the same. */
-	status = create_synthetic_smb_fname(talloc_tos(), ".",
-					NULL, NULL,
-					&smb_fname_cwd);
-
-	if (!NT_STATUS_IS_OK(status)) {
-		goto out;
-	}
-	ret = SMB_VFS_STAT(conn, smb_fname_cwd);
-	if (ret != 0) {
-		goto out;
-	}
-
-	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
-		DEBUG(0,("open_dir_with_privilege: stat mismatch between %s "
-			"and %s\n",
-			path,
-			smb_fname_str_dbg(&priv_paths->parent_name)));
-		goto out;
-	}
-
-	dir_hnd = OpenDir(NULL, conn, ".", wcard, attr);
-
-  out:
-
-	vfs_ChDir(conn, saved_dir);
-	return dir_hnd;
-}
-
-/****************************************************************************
  Create a new dir ptr. If the flag old_handle is true then we must allocate
  from the bitmap range 0 - 255 as old SMBsearch directory handles are only
  one byte long. If old_handle is false we allocate from the range
@@ -487,15 +425,14 @@
  wcard must not be zero.
 ****************************************************************************/
 
-NTSTATUS dptr_create(connection_struct *conn,
-		struct smb_request *req,
-		files_struct *fsp,
+NTSTATUS dptr_create(connection_struct *conn, files_struct *fsp,
 		const char *path, bool old_handle, bool expect_close,uint16 spid,
 		const char *wcard, bool wcard_has_wild, uint32 attr, struct dptr_struct **dptr_ret)
 {
 	struct smbd_server_connection *sconn = conn->sconn;
 	struct dptr_struct *dptr = NULL;
 	struct smb_Dir *dir_hnd;
+	NTSTATUS status;
 
 	if (fsp && fsp->is_directory && fsp->fh->fd != -1) {
 		path = fsp->fsp_name->base_name;
@@ -513,50 +450,13 @@
 	}
 
 	if (fsp) {
-		if (!(fsp->access_mask & SEC_DIR_LIST)) {
-			DEBUG(5,("dptr_create: directory %s "
-				"not open for LIST access\n",
-				path));
-			return NT_STATUS_ACCESS_DENIED;
-		}
 		dir_hnd = OpenDir_fsp(NULL, conn, fsp, wcard, attr);
 	} else {
-		int ret;
-		struct smb_filename *smb_dname = NULL;
-		NTSTATUS status = create_synthetic_smb_fname(talloc_tos(),
-						path,
-						NULL,
-						NULL,
-						&smb_dname);
+		status = check_name(conn,path);
 		if (!NT_STATUS_IS_OK(status)) {
 			return status;
 		}
-		if (lp_posix_pathnames()) {
-			ret = SMB_VFS_LSTAT(conn, smb_dname);
-		} else {
-			ret = SMB_VFS_STAT(conn, smb_dname);
-		}
-		if (ret == -1) {
-			return map_nt_error_from_unix(errno);
-		}
-		if (!S_ISDIR(smb_dname->st.st_ex_mode)) {
-			return NT_STATUS_NOT_A_DIRECTORY;
-		}
-		status = smbd_check_access_rights(conn,
-						smb_dname,
-						SEC_DIR_LIST);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-		if (req && req->priv_paths) {
-			dir_hnd = open_dir_with_privilege(conn,
-						req,
-						path,
-						wcard,
-						attr);
-		} else {
-			dir_hnd = OpenDir(NULL, conn, path, wcard, attr);
-		}
+		dir_hnd = OpenDir(NULL, conn, path, wcard, attr);
 	}
 
 	if (!dir_hnd) {
@@ -567,18 +467,18 @@
 		dptr_idleoldest(sconn);
 	}
 
-	dptr = talloc(NULL, struct dptr_struct);
+	dptr = SMB_MALLOC_P(struct dptr_struct);
 	if(!dptr) {
-		DEBUG(0,("talloc fail in dptr_create.\n"));
+		DEBUG(0,("malloc fail in dptr_create.\n"));
 		TALLOC_FREE(dir_hnd);
 		return NT_STATUS_NO_MEMORY;
 	}
 
 	ZERO_STRUCTP(dptr);
 
-	dptr->path = talloc_strdup(dptr, path);
+	dptr->path = SMB_STRDUP(path);
 	if (!dptr->path) {
-		TALLOC_FREE(dptr);
+		SAFE_FREE(dptr);
 		TALLOC_FREE(dir_hnd);
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -586,9 +486,10 @@
 	dptr->dir_hnd = dir_hnd;
 	dptr->spid = spid;
 	dptr->expect_close = expect_close;
-	dptr->wcard = talloc_strdup(dptr, wcard);
+	dptr->wcard = SMB_STRDUP(wcard);
 	if (!dptr->wcard) {
-		TALLOC_FREE(dptr);
+		SAFE_FREE(dptr->path);
+		SAFE_FREE(dptr);
 		TALLOC_FREE(dir_hnd);
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -627,7 +528,9 @@
 			dptr->dnum = bitmap_find(sconn->searches.dptr_bmap, 0);
 			if(dptr->dnum == -1 || dptr->dnum > 254) {
 				DEBUG(0,("dptr_create: returned %d: Error - all old dirptrs in use ?\n", dptr->dnum));
-				TALLOC_FREE(dptr);
+				SAFE_FREE(dptr->path);
+				SAFE_FREE(dptr->wcard);
+				SAFE_FREE(dptr);
 				TALLOC_FREE(dir_hnd);
 				return NT_STATUS_TOO_MANY_OPENED_FILES;
 			}
@@ -657,7 +560,9 @@
 
 			if(dptr->dnum == -1 || dptr->dnum < 255) {
 				DEBUG(0,("dptr_create: returned %d: Error - all new dirptrs in use ?\n", dptr->dnum));
-				TALLOC_FREE(dptr);
+				SAFE_FREE(dptr->path);
+				SAFE_FREE(dptr->wcard);
+				SAFE_FREE(dptr);
 				TALLOC_FREE(dir_hnd);
 				return NT_STATUS_TOO_MANY_OPENED_FILES;
 			}
@@ -717,16 +622,6 @@
 	return dptr->dnum;
 }
 
-bool dptr_get_priv(struct dptr_struct *dptr)
-{
-	return dptr->priv;
-}
-
-void dptr_set_priv(struct dptr_struct *dptr)
-{
-	dptr->priv = true;
-}
-
 /****************************************************************************
  Return the next visible file name, skipping veto'd and invisible files.
 ****************************************************************************/
@@ -914,76 +809,6 @@
 }
 
 /****************************************************************************
- Map a native directory offset to a 32-bit cookie.
-****************************************************************************/
-
-static uint32_t map_dir_offset_to_wire(struct dptr_struct *dptr, long offset)
-{
-	DATA_BLOB key;
-	DATA_BLOB val;
-
-	if (offset == END_OF_DIRECTORY_OFFSET) {
-		return WIRE_END_OF_DIRECTORY_OFFSET;
-	} else if(offset == START_OF_DIRECTORY_OFFSET) {
-		return WIRE_START_OF_DIRECTORY_OFFSET;
-	} else if (offset == DOT_DOT_DIRECTORY_OFFSET) {
-		return WIRE_DOT_DOT_DIRECTORY_OFFSET;
-	}
-	if (sizeof(long) == 4) {
-		/* 32-bit machine. We can cheat... */
-		return (uint32_t)offset;
-	}
-	if (dptr->dptr_cache == NULL) {
-		/* Lazy initialize cache. */
-		dptr->dptr_cache = memcache_init(dptr, 0);
-		if (dptr->dptr_cache == NULL) {
-			return WIRE_END_OF_DIRECTORY_OFFSET;
-		}
-	} else {
-		/* Have we seen this offset before ? */
-		key.data = (void *)&offset;
-		key.length = sizeof(offset);
-		if (memcache_lookup(dptr->dptr_cache,
-					SMB1_SEARCH_OFFSET_MAP,
-					key,
-					&val)) {
-			uint32_t wire_offset;
-			SMB_ASSERT(val.length == sizeof(wire_offset));
-			memcpy(&wire_offset, val.data, sizeof(wire_offset));
-			DEBUG(10,("found wire %u <-> offset %ld\n",
-				(unsigned int)wire_offset,
-				(long)offset));
-			return wire_offset;
-		}
-	}
-	/* Allocate a new wire cookie. */
-	do {
-		dptr->counter++;
-	} while (dptr->counter == WIRE_START_OF_DIRECTORY_OFFSET ||
-		 dptr->counter == WIRE_END_OF_DIRECTORY_OFFSET ||
-		 dptr->counter == WIRE_DOT_DOT_DIRECTORY_OFFSET);
-	/* Store it in the cache. */
-	key.data = (void *)&offset;
-	key.length = sizeof(offset);
-	val.data = (void *)&dptr->counter;
-	val.length = sizeof(dptr->counter); /* MUST BE uint32_t ! */
-	memcache_add(dptr->dptr_cache,
-			SMB1_SEARCH_OFFSET_MAP,
-			key,
-			val);
-	/* And the reverse mapping for lookup from
-	   map_wire_to_dir_offset(). */
-	memcache_add(dptr->dptr_cache,
-			SMB1_SEARCH_OFFSET_MAP,
-			val,
-			key);
-	DEBUG(10,("stored wire %u <-> offset %ld\n",
-		(unsigned int)dptr->counter,
-		(long)offset));
-	return dptr->counter;
-}
-
-/****************************************************************************
  Fill the 5 byte server reserved dptr field.
 ****************************************************************************/
 
@@ -992,62 +817,20 @@
 {
 	unsigned char *buf = (unsigned char *)buf1;
 	struct dptr_struct *dptr = dptr_get(sconn, key, false);
-	uint32_t wire_offset;
+	uint32 offset;
 	if (!dptr) {
 		DEBUG(1,("filling null dirptr %d\n",key));
 		return(False);
 	}
-	wire_offset = map_dir_offset_to_wire(dptr,TellDir(dptr->dir_hnd));
+	offset = (uint32)TellDir(dptr->dir_hnd);
 	DEBUG(6,("fill on key %u dirptr 0x%lx now at %d\n",key,
-		(long)dptr->dir_hnd,(int)wire_offset));
+		(long)dptr->dir_hnd,(int)offset));
 	buf[0] = key;
-	SIVAL(buf,1,wire_offset);
+	SIVAL(buf,1,offset);
 	return(True);
 }
 
 /****************************************************************************
- Map a 32-bit wire cookie to a native directory offset.
-****************************************************************************/
-
-static long map_wire_to_dir_offset(struct dptr_struct *dptr, uint32_t wire_offset)
-{
-	DATA_BLOB key;
-	DATA_BLOB val;
-
-	if (wire_offset == WIRE_END_OF_DIRECTORY_OFFSET) {
-		return END_OF_DIRECTORY_OFFSET;
-	} else if(wire_offset == WIRE_START_OF_DIRECTORY_OFFSET) {
-		return START_OF_DIRECTORY_OFFSET;
-	} else if (wire_offset == WIRE_DOT_DOT_DIRECTORY_OFFSET) {
-		return DOT_DOT_DIRECTORY_OFFSET;
-	}
-	if (sizeof(long) == 4) {
-		/* 32-bit machine. We can cheat... */
-		return (long)wire_offset;
-	}
-	if (dptr->dptr_cache == NULL) {
-		/* Logic error, cache should be initialized. */
-		return END_OF_DIRECTORY_OFFSET;
-	}
-	key.data = (void *)&wire_offset;
-	key.length = sizeof(wire_offset);
-	if (memcache_lookup(dptr->dptr_cache,
-				SMB1_SEARCH_OFFSET_MAP,
-				key,
-				&val)) {
-		/* Found mapping. */
-		long offset;
-		SMB_ASSERT(val.length == sizeof(offset));
-		memcpy(&offset, val.data, sizeof(offset));
-		DEBUG(10,("lookup wire %u <-> offset %ld\n",
-			(unsigned int)wire_offset,
-			(long)offset));
-		return offset;
-	}
-	return END_OF_DIRECTORY_OFFSET;
-}
-
-/****************************************************************************
  Fetch the dir ptr and seek it given the 5 byte server field.
 ****************************************************************************/
 
@@ -1056,7 +839,7 @@
 {
 	unsigned int key = *(unsigned char *)buf;
 	struct dptr_struct *dptr = dptr_get(sconn, key, false);
-	uint32_t wire_offset;
+	uint32 offset;
 	long seekoff;
 
 	if (!dptr) {
@@ -1064,8 +847,12 @@
 		return(NULL);
 	}
 	*num = key;
-	wire_offset = IVAL(buf,1);
-	seekoff = map_wire_to_dir_offset(dptr, wire_offset);
+	offset = IVAL(buf,1);
+	if (offset == (uint32)-1) {
+		seekoff = END_OF_DIRECTORY_OFFSET;
+	} else {
+		seekoff = (long)offset;
+	}
 	SeekDir(dptr->dir_hnd,seekoff);
 	DEBUG(3,("fetching dirptr %d for path %s at offset %d\n",
 		key, dptr->path, (int)seekoff));
@@ -1347,7 +1134,7 @@
 		const char *mask,
 		uint32_t dirtype,
 		char **_fname,
-		off_t *_size,
+		SMB_OFF_T *_size,
 		uint32_t *_mode,
 		struct timespec *_date,
 		bool check_descend,
@@ -1404,9 +1191,7 @@
 		return True;
 	}
 
-	return NT_STATUS_IS_OK(smbd_check_access_rights(conn,
-				smb_fname,
-				FILE_READ_DATA));
+	return can_access_file_acl(conn, smb_fname, FILE_READ_DATA);
 }
 
 /*******************************************************************
@@ -1586,7 +1371,7 @@
 			const char *mask,
 			uint32 attr)
 {
-	struct smb_Dir *dirp = talloc_zero(mem_ctx, struct smb_Dir);
+	struct smb_Dir *dirp = TALLOC_ZERO_P(mem_ctx, struct smb_Dir);
 	struct smbd_server_connection *sconn = conn->sconn;
 
 	if (!dirp) {
@@ -1630,7 +1415,7 @@
 			const char *mask,
 			uint32 attr)
 {
-	struct smb_Dir *dirp = talloc_zero(mem_ctx, struct smb_Dir);
+	struct smb_Dir *dirp = TALLOC_ZERO_P(mem_ctx, struct smb_Dir);
 	struct smbd_server_connection *sconn = conn->sconn;
 
 	if (!dirp) {
@@ -1805,7 +1590,7 @@
 	}
 
 	if (dirp->name_cache == NULL) {
-		dirp->name_cache = talloc_zero_array(
+		dirp->name_cache = TALLOC_ZERO_ARRAY(
 			dirp, struct name_cache_entry, dirp->name_cache_size);
 
 		if (dirp->name_cache == NULL) {
@@ -1876,7 +1661,6 @@
 	NTSTATUS status = NT_STATUS_OK;
 	long dirpos = 0;
 	const char *dname = NULL;
-	const char *dirname = fsp->fsp_name->base_name;
 	char *talloced = NULL;
 	SMB_STRUCT_STAT st;
 	struct connection_struct *conn = fsp->conn;
@@ -1899,12 +1683,12 @@
 			}
 		}
 
-		if (!is_visible_file(conn, dirname, dname, &st, True)) {
+		if (!is_visible_file(conn, fsp->fsp_name->base_name, dname, &st, True)) {
 			TALLOC_FREE(talloced);
 			continue;
 		}
 
-		DEBUG(10,("got name %s - can't delete\n",
+		DEBUG(10,("can_delete_directory_fsp: got name %s - can't delete\n",
 			 dname ));
 		status = NT_STATUS_DIRECTORY_NOT_EMPTY;
 		break;
Only in ../../samba-3.6.24/source3/smbd: dir.o
diff -ur smbd/dmapi.c ../../samba-3.6.24/source3/smbd/dmapi.c
--- smbd/dmapi.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/dmapi.c	2015-01-28 10:52:25.149068676 +0800
@@ -96,7 +96,7 @@
 	do {
 		dm_sessid_t *new_sessions;
 		nsessions *= 2;
-		new_sessions = talloc_realloc(tmp_ctx, sessions, 
+		new_sessions = TALLOC_REALLOC_ARRAY(tmp_ctx, sessions, 
 						    dm_sessid_t, nsessions);
 		if (new_sessions == NULL) {
 			talloc_free(tmp_ctx);
@@ -289,7 +289,7 @@
 	become_root();
 #endif
 
-	err = dm_path_to_handle(discard_const_p(char, path),
+	err = dm_path_to_handle(CONST_DISCARD(char *, path),
 		&dm_handle, &dm_handle_len);
 	if (err < 0) {
 		DEBUG(DMAPI_TRACE, ("dm_path_to_handle(%s): %s\n",
@@ -308,7 +308,7 @@
 
 		set_effective_capability(DMAPI_ACCESS_CAPABILITY);
 
-		err = dm_path_to_handle(discard_const_p(char, path),
+		err = dm_path_to_handle(CONST_DISCARD(char *, path),
 			&dm_handle, &dm_handle_len);
 		if (err < 0) {
 			DEBUG(DMAPI_TRACE,
Only in ../../samba-3.6.24/source3/smbd: dmapi.o
Only in ../../samba-3.6.24/source3/smbd: dnsregister.o
diff -ur smbd/dosmode.c ../../samba-3.6.24/source3/smbd/dosmode.c
--- smbd/dosmode.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/dosmode.c	2015-01-28 10:52:25.149068676 +0800
@@ -23,12 +23,6 @@
 #include "librpc/gen_ndr/ndr_xattr.h"
 #include "../libcli/security/security.h"
 #include "smbd/smbd.h"
-#include "lib/param/loadparm.h"
-
-static NTSTATUS get_file_handle_for_metadata(connection_struct *conn,
-				struct smb_filename *smb_fname,
-				files_struct **ret_fsp,
-				bool *need_close);
 
 static uint32_t filter_mode_by_protocol(uint32_t mode)
 {
@@ -176,12 +170,6 @@
 	int result = 0;
 	enum mapreadonly_options ro_opts = (enum mapreadonly_options)lp_map_readonly(SNUM(conn));
 
-#if defined(UF_IMMUTABLE) && defined(SF_IMMUTABLE)
-	/* if we can find out if a file is immutable we should report it r/o */
-	if (smb_fname->st.st_ex_flags & (UF_IMMUTABLE | SF_IMMUTABLE)) {
-		result |= FILE_ATTRIBUTE_READONLY;
-	}
-#endif
 	if (ro_opts == MAP_READONLY_YES) {
 		/* Original Samba method - map inverse of user "w" bit. */
 		if ((smb_fname->st.st_ex_mode & S_IWUSR) == 0) {
@@ -398,7 +386,6 @@
 			     SAMBA_XATTR_DOS_ATTRIB, blob.data, blob.length,
 			     0) == -1) {
 		bool ret = false;
-		bool need_close = false;
 		files_struct *fsp = NULL;
 
 		if((errno != EPERM) && (errno != EACCES)) {
@@ -425,22 +412,15 @@
 		if(!CAN_WRITE(conn) || !lp_dos_filemode(SNUM(conn)))
 			return false;
 
-		if (!can_write_to_file(conn, smb_fname)) {
-			return false;
-		}
-
 		/*
-		 * We need to get an open file handle to do the
-		 * metadata operation under root.
+		 * We need to open the file with write access whilst
+		 * still in our current user context. This ensures we
+		 * are not violating security in doing the setxattr.
 		 */
 
-		if (!NT_STATUS_IS_OK(get_file_handle_for_metadata(conn,
-						smb_fname,
-						&fsp,
-						&need_close))) {
+		if (!NT_STATUS_IS_OK(open_file_fchmod(conn, smb_fname,
+						      &fsp)))
 			return false;
-		}
-
 		become_root();
 		if (SMB_VFS_FSETXATTR(fsp,
 				     SAMBA_XATTR_DOS_ATTRIB, blob.data,
@@ -448,9 +428,7 @@
 			ret = true;
 		}
 		unbecome_root();
-		if (need_close) {
-			close_file(NULL, fsp, NORMAL_CLOSE);
-		}
+		close_file(NULL, fsp, NORMAL_CLOSE);
 		return ret;
 	}
 	DEBUG(10,("set_ea_dos_attribute: set EA 0x%x on file %s\n",
@@ -726,14 +704,6 @@
 	int ret = -1, lret = -1;
 	uint32_t old_mode;
 	struct timespec new_create_timespec;
-	files_struct *fsp = NULL;
-	bool need_close = false;
-	NTSTATUS status;
-
-	if (!CAN_WRITE(conn)) {
-		errno = EROFS;
-		return -1;
-	}
 
 	/* We only allow READONLY|HIDDEN|SYSTEM|DIRECTORY|ARCHIVE here. */
 	dosmode &= (SAMBA_ATTRIBUTES_MASK | FILE_ATTRIBUTE_OFFLINE);
@@ -876,38 +846,29 @@
 		bits on a file. Just like file_ntimes below.
 	*/
 
-	if (!can_write_to_file(conn, smb_fname)) {
-		errno = EACCES;
-		return -1;
-	}
-
-	/*
-	 * We need to get an open file handle to do the
-	 * metadata operation under root.
-	 */
-
-	status = get_file_handle_for_metadata(conn,
-					      smb_fname,
-					      &fsp,
-					      &need_close);
-	if (!NT_STATUS_IS_OK(status)) {
-		errno = map_errno_from_nt_status(status);
-		return -1;
-	}
-
-	become_root();
-	ret = SMB_VFS_FCHMOD(fsp, unixmode);
-	unbecome_root();
-	if (need_close) {
+	/* Check if we have write access. */
+	if (CAN_WRITE(conn)) {
+		/*
+		 * We need to open the file with write access whilst
+		 * still in our current user context. This ensures we
+		 * are not violating security in doing the fchmod.
+		 */
+		files_struct *fsp;
+		if (!NT_STATUS_IS_OK(open_file_fchmod(conn, smb_fname,
+				     &fsp)))
+			return -1;
+		become_root();
+		ret = SMB_VFS_FCHMOD(fsp, unixmode);
+		unbecome_root();
 		close_file(NULL, fsp, NORMAL_CLOSE);
-	}
-	if (!newfile) {
-		notify_fname(conn, NOTIFY_ACTION_MODIFIED,
-			     FILE_NOTIFY_CHANGE_ATTRIBUTES,
-			     smb_fname->base_name);
-	}
-	if (ret == 0) {
-		smb_fname->st.st_ex_mode = unixmode;
+		if (!newfile) {
+			notify_fname(conn, NOTIFY_ACTION_MODIFIED,
+				     FILE_NOTIFY_CHANGE_ATTRIBUTES,
+				     smb_fname->base_name);
+		}
+		if (ret == 0) {
+			smb_fname->st.st_ex_mode = unixmode;
+		}
 	}
 
 	return( ret );
@@ -927,7 +888,7 @@
 			"on readonly share[%s]\n",
 			smb_fname_str_dbg(fsp->fsp_name),
 			sparse,
-			lp_servicename(talloc_tos(), SNUM(conn))));
+			lp_servicename(SNUM(conn))));
 		return NT_STATUS_MEDIA_WRITE_PROTECTED;
 	}
 
@@ -941,19 +902,6 @@
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
-	if (fsp->is_directory) {
-		DEBUG(9, ("invalid attempt to %s sparse flag on dir %s\n",
-			  (sparse ? "set" : "clear"),
-			  smb_fname_str_dbg(fsp->fsp_name)));
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	if (IS_IPC(conn) || IS_PRINT(conn)) {
-		DEBUG(9, ("attempt to %s sparse flag over invalid conn\n",
-			  (sparse ? "set" : "clear")));
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
 	DEBUG(10,("file_set_sparse: setting sparse bit %u on file %s\n",
 		  sparse, smb_fname_str_dbg(fsp->fsp_name)));
 
@@ -1152,62 +1100,3 @@
 {
 	return smb_fname->st.st_ex_mtime;
 }
-
-/****************************************************************************
- Get a real open file handle we can do meta-data operations on. As it's
- going to be used under root access only on meta-data we should look for
- any existing open file handle first, and use that in preference (also to
- avoid kernel self-oplock breaks). If not use an INTERNAL_OPEN_ONLY handle.
-****************************************************************************/
-
-static NTSTATUS get_file_handle_for_metadata(connection_struct *conn,
-				struct smb_filename *smb_fname,
-				files_struct **ret_fsp,
-				bool *need_close)
-{
-	NTSTATUS status;
-	files_struct *fsp;
-	struct file_id file_id;
-
-	*need_close = false;
-
-	if (!VALID_STAT(smb_fname->st)) {
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	file_id = vfs_file_id_from_sbuf(conn, &smb_fname->st);
-
-	for(fsp = file_find_di_first(conn->sconn, file_id);
-			fsp;
-			fsp = file_find_di_next(fsp)) {
-		if (fsp->fh->fd != -1) {
-			*ret_fsp = fsp;
-			return NT_STATUS_OK;
-		}
-	}
-
-	/* Opens an INTERNAL_OPEN_ONLY write handle. */
-	status = SMB_VFS_CREATE_FILE(
-		conn,                                   /* conn */
-		NULL,                                   /* req */
-		0,                                      /* root_dir_fid */
-		smb_fname,                              /* fname */
-		FILE_WRITE_DATA,                        /* access_mask */
-		(FILE_SHARE_READ | FILE_SHARE_WRITE |   /* share_access */
-			FILE_SHARE_DELETE),
-		FILE_OPEN,                              /* create_disposition*/
-		0,                                      /* create_options */
-		0,                                      /* file_attributes */
-		INTERNAL_OPEN_ONLY,                     /* oplock_request */
-                0,                                      /* allocation_size */
-		0,                                      /* private_flags */
-		NULL,                                   /* sd */
-		NULL,                                   /* ea_list */
-		ret_fsp,                                /* result */
-		NULL);                                  /* pinfo */
-
-	if (NT_STATUS_IS_OK(status)) {
-		*need_close = true;
-	}
-	return status;
-}
Only in ../../samba-3.6.24/source3/smbd: dosmode.o
Only in smbd: durable.c
diff -ur smbd/error.c ../../samba-3.6.24/source3/smbd/error.c
--- smbd/error.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/error.c	2015-01-28 10:52:25.149068676 +0800
@@ -2,17 +2,17 @@
    Unix SMB/CIFS implementation.
    error packet handling
    Copyright (C) Andrew Tridgell 1992-1998
-
+   
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -21,6 +21,9 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 
+/* From lib/error.c */
+extern struct unix_error_map unix_dos_nt_errmap[];
+
 bool use_nt_status(void)
 {
 	return lp_nt_status_support() && (global_client_caps & CAP_STATUS32);
@@ -71,20 +74,17 @@
 		}
 		SIVAL(outbuf,smb_rcls,NT_STATUS_V(ntstatus));
 		SSVAL(outbuf,smb_flg2, SVAL(outbuf,smb_flg2)|FLAGS2_32_BIT_ERROR_CODES);
-		/* This must not start with the word 'error', as this
-		 * is reserved in the subunit stream protocol, causing
-		 * false errors to show up when debugging is turned
-		 * on */
-		DEBUG(3,("NT error packet at %s(%d) cmd=%d (%s) %s\n",
+		DEBUG(3,("error packet at %s(%d) cmd=%d (%s) %s\n",
 			 file, line,
 			 (int)CVAL(outbuf,smb_com),
 			 smb_fn_name(CVAL(outbuf,smb_com)),
 			 nt_errstr(ntstatus)));
 	} else {
-		/* We're returning a DOS error only,
-		 * nt_status_to_dos() pulls DOS error codes out of the
-		 * NTSTATUS */
-		if (NT_STATUS_IS_DOS(ntstatus) || (eclass == 0 && NT_STATUS_V(ntstatus))) {
+		/* We're returning a DOS error only. */
+		if (NT_STATUS_IS_DOS(ntstatus)) {
+			eclass = NT_STATUS_DOS_CLASS(ntstatus);
+			ecode = NT_STATUS_DOS_CODE(ntstatus);
+		} else 	if (eclass == 0 && NT_STATUS_V(ntstatus)) {
 			ntstatus_to_dos(ntstatus, &eclass, &ecode);
 		}
 
@@ -92,11 +92,7 @@
 		SSVAL(outbuf,smb_rcls,eclass);
 		SSVAL(outbuf,smb_err,ecode);  
 
-		/* This must not start with the word 'error', as this
-		 * is reserved in the subunit stream protocol, causing
-		 * false errors to show up when debugging is turned
-		 * on */
-		DEBUG(3,("DOS error packet at %s(%d) cmd=%d (%s) eclass=%d ecode=%d\n",
+		DEBUG(3,("error packet at %s(%d) cmd=%d (%s) eclass=%d ecode=%d\n",
 			  file, line,
 			  (int)CVAL(outbuf,smb_com),
 			  smb_fn_name(CVAL(outbuf,smb_com)),
Only in ../../samba-3.6.24/source3/smbd: error.o
diff -ur smbd/fake_file.c ../../samba-3.6.24/source3/smbd/fake_file.c
--- smbd/fake_file.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/fake_file.c	2015-01-28 10:52:25.149068676 +0800
@@ -120,7 +120,7 @@
 ****************************************************************************/
 
 NTSTATUS open_fake_file(struct smb_request *req, connection_struct *conn,
-				uint64_t current_vuid,
+				uint16_t current_vuid,
 				enum FAKE_FILE_TYPE fake_file_type,
 				const struct smb_filename *smb_fname,
 				uint32 access_mask,
@@ -130,11 +130,12 @@
 	NTSTATUS status;
 
 	status = smbd_calculate_access_mask(conn, smb_fname,
+					    false, /* fake files do not exist */
 					    access_mask, &access_mask);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(10, ("open_fake_file: smbd_calculate_access_mask "
 			"on service[%s] file[%s] returned %s\n",
-			lp_servicename(talloc_tos(), SNUM(conn)),
+			lp_servicename(SNUM(conn)),
 			smb_fname_str_dbg(smb_fname),
 			nt_errstr(status)));
 		return status;
@@ -144,9 +145,9 @@
 	if (geteuid() != sec_initial_uid()) {
 		DEBUG(3, ("open_fake_file_shared: access_denied to "
 			  "service[%s] file[%s] user[%s]\n",
-			  lp_servicename(talloc_tos(), SNUM(conn)),
+			  lp_servicename(SNUM(conn)),
 			  smb_fname_str_dbg(smb_fname),
-			  conn->session_info->unix_info->unix_name));
+			  conn->session_info->unix_name));
 		return NT_STATUS_ACCESS_DENIED;
 
 	}
@@ -156,8 +157,8 @@
 		return status;
 	}
 
-	DEBUG(5,("open_fake_file_shared: fname = %s, %s, access_mask = 0x%x\n",
-		 smb_fname_str_dbg(smb_fname), fsp_fnum_dbg(fsp),
+	DEBUG(5,("open_fake_file_shared: fname = %s, FID = %d, access_mask = 0x%x\n",
+		 smb_fname_str_dbg(smb_fname), fsp->fnum,
 		 (unsigned int)access_mask));
 
 	fsp->conn = conn;
Only in ../../samba-3.6.24/source3/smbd: fake_file.o
diff -ur smbd/file_access.c ../../samba-3.6.24/source3/smbd/file_access.c
--- smbd/file_access.c	2012-12-04 18:07:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/file_access.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,6 +27,60 @@
 #undef  DBGC_CLASS
 #define DBGC_CLASS DBGC_ACLS
 
+/**
+ * Security descriptor / NT Token level access check function.
+ */
+bool can_access_file_acl(struct connection_struct *conn,
+			 const struct smb_filename *smb_fname,
+			 uint32_t access_mask)
+{
+	NTSTATUS status;
+	uint32_t access_granted;
+	struct security_descriptor *secdesc = NULL;
+	bool ret;
+
+	if (get_current_uid(conn) == (uid_t)0) {
+		/* I'm sorry sir, I didn't know you were root... */
+		return true;
+	}
+
+	if (access_mask == DELETE_ACCESS &&
+			VALID_STAT(smb_fname->st) &&
+			S_ISLNK(smb_fname->st.st_ex_mode)) {
+		/* We can always delete a symlink. */
+		return true;
+	}
+
+	status = SMB_VFS_GET_NT_ACL(conn, smb_fname->base_name,
+				    (SECINFO_OWNER |
+				     SECINFO_GROUP |
+				     SECINFO_DACL),
+				    &secdesc);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(5, ("Could not get acl: %s\n", nt_errstr(status)));
+		ret = false;
+		goto out;
+	}
+
+	status = se_access_check(secdesc, get_current_nttok(conn),
+				 access_mask, &access_granted);
+	ret = NT_STATUS_IS_OK(status);
+
+	if (DEBUGLEVEL >= 10) {
+		DEBUG(10,("can_access_file_acl for file %s "
+			"access_mask 0x%x, access_granted 0x%x "
+			"access %s\n",
+			smb_fname_str_dbg(smb_fname),
+			(unsigned int)access_mask,
+			(unsigned int)access_granted,
+			ret ? "ALLOWED" : "DENIED" ));
+		NDR_PRINT_DEBUG(security_descriptor, secdesc);
+	}
+ out:
+	TALLOC_FREE(secdesc);
+	return ret;
+}
+
 /****************************************************************************
  Actually emulate the in-kernel access checking for delete access. We need
  this to successfully return ACCESS_DENIED on a file open for delete access.
@@ -122,9 +176,7 @@
 	 * check the file DELETE permission separately.
 	 */
 
-	ret = NT_STATUS_IS_OK(smbd_check_access_rights(conn,
-				smb_fname_parent,
-				FILE_DELETE_CHILD));
+	ret = can_access_file_acl(conn, smb_fname_parent, FILE_DELETE_CHILD);
  out:
 	TALLOC_FREE(dname);
 	TALLOC_FREE(smb_fname_parent);
@@ -132,15 +184,69 @@
 }
 
 /****************************************************************************
+ Actually emulate the in-kernel access checking for read/write access. We need
+ this to successfully check for ability to write for dos filetimes.
+ Note this doesn't take into account share write permissions.
+****************************************************************************/
+
+bool can_access_file_data(connection_struct *conn,
+			  const struct smb_filename *smb_fname,
+			  uint32 access_mask)
+{
+	if (!(access_mask & (FILE_READ_DATA|FILE_WRITE_DATA))) {
+		return False;
+	}
+	access_mask &= (FILE_READ_DATA|FILE_WRITE_DATA);
+
+	/* some fast paths first */
+
+	DEBUG(10,("can_access_file_data: requesting 0x%x on file %s\n",
+		  (unsigned int)access_mask, smb_fname_str_dbg(smb_fname)));
+
+	if (get_current_uid(conn) == (uid_t)0) {
+		/* I'm sorry sir, I didn't know you were root... */
+		return True;
+	}
+
+	SMB_ASSERT(VALID_STAT(smb_fname->st));
+
+	/* Check primary owner access. */
+	if (get_current_uid(conn) == smb_fname->st.st_ex_uid) {
+		switch (access_mask) {
+			case FILE_READ_DATA:
+				return (smb_fname->st.st_ex_mode & S_IRUSR) ?
+				    True : False;
+
+			case FILE_WRITE_DATA:
+				return (smb_fname->st.st_ex_mode & S_IWUSR) ?
+				    True : False;
+
+			default: /* FILE_READ_DATA|FILE_WRITE_DATA */
+
+				if ((smb_fname->st.st_ex_mode &
+					(S_IWUSR|S_IRUSR)) ==
+				    (S_IWUSR|S_IRUSR)) {
+					return True;
+				} else {
+					return False;
+				}
+		}
+	}
+
+	/* now for ACL checks */
+
+	return can_access_file_acl(conn, smb_fname, access_mask);
+}
+
+/****************************************************************************
  Userspace check for write access.
+ Note this doesn't take into account share write permissions.
 ****************************************************************************/
 
 bool can_write_to_file(connection_struct *conn,
 		       const struct smb_filename *smb_fname)
 {
-	return NT_STATUS_IS_OK(smbd_check_access_rights(conn,
-				smb_fname,
-				FILE_WRITE_DATA));
+	return can_access_file_data(conn, smb_fname, FILE_WRITE_DATA);
 }
 
 /****************************************************************************
@@ -149,11 +255,11 @@
 
 bool directory_has_default_acl(connection_struct *conn, const char *fname)
 {
+	/* returns talloced off tos. */
 	struct security_descriptor *secdesc = NULL;
 	unsigned int i;
 	NTSTATUS status = SMB_VFS_GET_NT_ACL(conn, fname,
-					     SECINFO_DACL, talloc_tos(),
-					     &secdesc);
+				SECINFO_DACL, &secdesc);
 
 	if (!NT_STATUS_IS_OK(status) ||
 			secdesc == NULL ||
@@ -173,61 +279,3 @@
 	TALLOC_FREE(secdesc);
 	return false;
 }
-
-/****************************************************************************
- Check if setting delete on close is allowed on this fsp.
-****************************************************************************/
-
-NTSTATUS can_set_delete_on_close(files_struct *fsp, uint32 dosmode)
-{
-	/*
-	 * Only allow delete on close for writable files.
-	 */
-
-	if ((dosmode & FILE_ATTRIBUTE_READONLY) &&
-	    !lp_delete_readonly(SNUM(fsp->conn))) {
-		DEBUG(10,("can_set_delete_on_close: file %s delete on close "
-			  "flag set but file attribute is readonly.\n",
-			  fsp_str_dbg(fsp)));
-		return NT_STATUS_CANNOT_DELETE;
-	}
-
-	/*
-	 * Only allow delete on close for writable shares.
-	 */
-
-	if (!CAN_WRITE(fsp->conn)) {
-		DEBUG(10,("can_set_delete_on_close: file %s delete on "
-			  "close flag set but write access denied on share.\n",
-			  fsp_str_dbg(fsp)));
-		return NT_STATUS_ACCESS_DENIED;
-	}
-
-	/*
-	 * Only allow delete on close for files/directories opened with delete
-	 * intent.
-	 */
-
-	if (!(fsp->access_mask & DELETE_ACCESS)) {
-		DEBUG(10,("can_set_delete_on_close: file %s delete on "
-			  "close flag set but delete access denied.\n",
-			  fsp_str_dbg(fsp)));
-		return NT_STATUS_ACCESS_DENIED;
-	}
-
-	/* Don't allow delete on close for non-empty directories. */
-	if (fsp->is_directory) {
-		SMB_ASSERT(!is_ntfs_stream_smb_fname(fsp->fsp_name));
-
-		/* Or the root of a share. */
-		if (ISDOT(fsp->fsp_name->base_name)) {
-			DEBUG(10,("can_set_delete_on_close: can't set delete on "
-				  "close for the root of a share.\n"));
-			return NT_STATUS_ACCESS_DENIED;
-		}
-
-		return can_delete_directory_fsp(fsp);
-	}
-
-	return NT_STATUS_OK;
-}
Only in ../../samba-3.6.24/source3/smbd: file_access.o
diff -ur smbd/fileio.c ../../samba-3.6.24/source3/smbd/fileio.c
--- smbd/fileio.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/fileio.c	2015-01-28 10:52:25.149068676 +0800
@@ -25,23 +25,15 @@
 #include "smbd/globals.h"
 #include "smbprofile.h"
 
-struct write_cache {
-	off_t file_size;
-	off_t offset;
-	size_t alloc_size;
-	size_t data_size;
-	char *data;
-};
-
-static bool setup_write_cache(files_struct *, off_t);
+static bool setup_write_cache(files_struct *, SMB_OFF_T);
 
 /****************************************************************************
  Read from write cache if we can.
 ****************************************************************************/
 
-static bool read_from_write_cache(files_struct *fsp,char *data,off_t pos,size_t n)
+static bool read_from_write_cache(files_struct *fsp,char *data,SMB_OFF_T pos,size_t n)
 {
-	struct write_cache *wcp = fsp->wcp;
+	write_cache *wcp = fsp->wcp;
 
 	if(!wcp) {
 		return False;
@@ -62,9 +54,9 @@
  Read from a file.
 ****************************************************************************/
 
-ssize_t read_file(files_struct *fsp,char *data,off_t pos,size_t n)
+ssize_t read_file(files_struct *fsp,char *data,SMB_OFF_T pos,size_t n)
 {
-	ssize_t ret = 0;
+	ssize_t ret=0,readret;
 
 	/* you can't read from print files */
 	if (fsp->print_file) {
@@ -87,11 +79,30 @@
 	fsp->fh->pos = pos;
 
 	if (n > 0) {
-		ret = SMB_VFS_PREAD(fsp,data,n,pos);
+#ifdef DMF_FIX
+		int numretries = 3;
+tryagain:
+		readret = SMB_VFS_PREAD(fsp,data,n,pos);
+
+		if (readret == -1) {
+			if ((errno == EAGAIN) && numretries) {
+				DEBUG(3,("read_file EAGAIN retry in 10 seconds\n"));
+				(void)sleep(10);
+				--numretries;
+				goto tryagain;
+			}
+			return -1;
+		}
+#else /* NO DMF fix. */
+		readret = SMB_VFS_PREAD(fsp,data,n,pos);
 
-		if (ret == -1) {
+		if (readret == -1) {
 			return -1;
 		}
+#endif
+		if (readret > 0) {
+			ret += readret;
+		}
 	}
 
 	DEBUG(10,("read_file (%s): pos = %.0f, size = %lu, returned %lu\n",
@@ -110,7 +121,7 @@
 static ssize_t real_write_file(struct smb_request *req,
 				files_struct *fsp,
 				const char *data,
-				off_t pos,
+				SMB_OFF_T pos,
 				size_t n)
 {
 	ssize_t ret;
@@ -152,7 +163,7 @@
 static int wcp_file_size_change(files_struct *fsp)
 {
 	int ret;
-	struct write_cache *wcp = fsp->wcp;
+	write_cache *wcp = fsp->wcp;
 
 	wcp->file_size = wcp->offset + wcp->data_size;
 	ret = SMB_VFS_FTRUNCATE(fsp, wcp->file_size);
@@ -229,9 +240,9 @@
 
 	/* trigger the update 2 seconds later */
 	fsp->update_write_time_event =
-		tevent_add_timer(fsp->conn->sconn->ev_ctx, NULL,
-				 timeval_current_ofs_usec(delay),
-				 update_write_time_handler, fsp);
+		event_add_timed(smbd_event_context(), NULL,
+				timeval_current_ofs(0, delay),
+				update_write_time_handler, fsp);
 }
 
 void trigger_write_time_update_immediate(struct files_struct *fsp)
@@ -269,37 +280,6 @@
 	(void)smb_set_file_time(fsp->conn, fsp, fsp->fsp_name, &ft, false);
 }
 
-void mark_file_modified(files_struct *fsp)
-{
-	int dosmode;
-
-	if (fsp->modified) {
-		return;
-	}
-
-	fsp->modified = true;
-
-	if (SMB_VFS_FSTAT(fsp, &fsp->fsp_name->st) != 0) {
-		return;
-	}
-	trigger_write_time_update(fsp);
-
-	if (fsp->posix_open) {
-		return;
-	}
-	if (!(lp_store_dos_attributes(SNUM(fsp->conn)) ||
-	      MAP_ARCHIVE(fsp->conn))) {
-		return;
-	}
-
-	dosmode = dos_mode(fsp->conn, fsp->fsp_name);
-	if (IS_DOS_ARCHIVE(dosmode)) {
-		return;
-	}
-	file_set_dosmode(fsp->conn, fsp->fsp_name,
-			 dosmode | FILE_ATTRIBUTE_ARCHIVE, NULL, false);
-}
-
 /****************************************************************************
  Write to a file.
 ****************************************************************************/
@@ -307,10 +287,10 @@
 ssize_t write_file(struct smb_request *req,
 			files_struct *fsp,
 			const char *data,
-			off_t pos,
+			SMB_OFF_T pos,
 			size_t n)
 {
-	struct write_cache *wcp = fsp->wcp;
+	write_cache *wcp = fsp->wcp;
 	ssize_t total_written = 0;
 	int write_path = -1;
 
@@ -331,19 +311,33 @@
 		return -1;
 	}
 
-	/*
-	 * If this is the first write and we have an exclusive oplock
-	 * then setup the write cache.
-	 */
+	if (!fsp->modified) {
+		fsp->modified = True;
 
-	if (!fsp->modified &&
-	    EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type) &&
-	    (wcp == NULL)) {
-		setup_write_cache(fsp, fsp->fsp_name->st.st_ex_size);
-		wcp = fsp->wcp;
-	}
+		if (SMB_VFS_FSTAT(fsp, &fsp->fsp_name->st) == 0) {
+			trigger_write_time_update(fsp);
+			if (!fsp->posix_open &&
+					(lp_store_dos_attributes(SNUM(fsp->conn)) ||
+					MAP_ARCHIVE(fsp->conn))) {
+				int dosmode = dos_mode(fsp->conn, fsp->fsp_name);
+				if (!IS_DOS_ARCHIVE(dosmode)) {
+					file_set_dosmode(fsp->conn, fsp->fsp_name,
+						 dosmode | FILE_ATTRIBUTE_ARCHIVE, NULL, false);
+				}
+			}
 
-	mark_file_modified(fsp);
+			/*
+			 * If this is the first write and we have an exclusive oplock then setup
+			 * the write cache.
+			 */
+
+			if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type) && !wcp) {
+				setup_write_cache(fsp,
+						 fsp->fsp_name->st.st_ex_size);
+				wcp = fsp->wcp;
+			}
+		}
+	}
 
 #ifdef WITH_PROFILE
 	DO_PROFILE_INC(writecache_total_writes);
@@ -885,7 +879,7 @@
 
 void delete_write_cache(files_struct *fsp)
 {
-	struct write_cache *wcp;
+	write_cache *wcp;
 
 	if(!fsp) {
 		return;
@@ -911,10 +905,10 @@
  Setup the write cache structure.
 ****************************************************************************/
 
-static bool setup_write_cache(files_struct *fsp, off_t file_size)
+static bool setup_write_cache(files_struct *fsp, SMB_OFF_T file_size)
 {
 	ssize_t alloc_size = lp_write_cache_size(SNUM(fsp->conn));
-	struct write_cache *wcp;
+	write_cache *wcp;
 
 	if (allocated_write_caches >= MAX_WRITE_CACHES) {
 		return False;
@@ -924,7 +918,7 @@
 		return False;
 	}
 
-	if((wcp = SMB_MALLOC_P(struct write_cache)) == NULL) {
+	if((wcp = SMB_MALLOC_P(write_cache)) == NULL) {
 		DEBUG(0,("setup_write_cache: malloc fail.\n"));
 		return False;
 	}
@@ -956,7 +950,7 @@
  Cope with a size change.
 ****************************************************************************/
 
-void set_filelen_write_cache(files_struct *fsp, off_t file_size)
+void set_filelen_write_cache(files_struct *fsp, SMB_OFF_T file_size)
 {
 	if(fsp->wcp) {
 		/* The cache *must* have been flushed before we do this. */
@@ -981,7 +975,7 @@
 
 ssize_t flush_write_cache(files_struct *fsp, enum flush_reason_enum reason)
 {
-	struct write_cache *wcp = fsp->wcp;
+	write_cache *wcp = fsp->wcp;
 	size_t data_size;
 	ssize_t ret;
 
Only in ../../samba-3.6.24/source3/smbd: fileio.o
diff -ur smbd/filename.c ../../samba-3.6.24/source3/smbd/filename.c
--- smbd/filename.c	2014-01-07 16:02:57.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/filename.c	2015-01-28 10:52:25.149068676 +0800
@@ -28,7 +28,6 @@
 #include "system/filesys.h"
 #include "fake_file.h"
 #include "smbd/smbd.h"
-#include "smbd/globals.h"
 
 static NTSTATUS build_stream_path(TALLOC_CTX *mem_ctx,
 				  connection_struct *conn,
@@ -164,11 +163,11 @@
 	 * last compnent to shorten the tree walk. */
 
 	/*
-	 * Safe to use discard_const_p
+	 * Safe to use CONST_DISCARD
 	 * here as last_component points
 	 * into our smb_fname->base_name.
 	 */
-	*pp_start = discard_const_p(char, last_component);
+	*pp_start = CONST_DISCARD(char *,last_component);
 
 	/* Update dirpath. */
 	TALLOC_FREE(*pp_dirpath);
@@ -323,11 +322,7 @@
 
 	if (conn->case_sensitive && !conn->case_preserve &&
 			!conn->short_case_preserve) {
-		if (!strnorm(smb_fname->base_name, lp_defaultcase(SNUM(conn)))) {
-			DEBUG(0, ("strnorm %s failed\n", smb_fname->base_name));
-			status = NT_STATUS_INVALID_PARAMETER;
-			goto err;
-		}
+		strnorm(smb_fname->base_name, lp_defaultcase(SNUM(conn)));
 	}
 
 	/*
@@ -720,12 +715,8 @@
 				 * ENOENT/EACCESS are the only valid errors
 				 * here.
 				 */
-
 				if (errno == EACCES) {
-					if ((ucf_flags & UCF_PREP_CREATEFILE) == 0) {
-						status = NT_STATUS_ACCESS_DENIED;
-						goto fail;
-					} else {
+					if (ucf_flags & UCF_CREATING_FILE) {
 						/*
 						 * This is the dropbox
 						 * behaviour. A dropbox is a
@@ -737,8 +728,11 @@
 						 * nevertheless want to allow
 						 * users creating a file.
 						 */
-						errno = 0;
+						status = NT_STATUS_OBJECT_PATH_NOT_FOUND;
+					} else {
+						status = NT_STATUS_ACCESS_DENIED;
 					}
+					goto fail;
 				}
 
 				if ((errno != 0) && (errno != ENOENT)) {
@@ -769,13 +763,8 @@
 				    (mangle_is_8_3(start, False,
 						   conn->params) &&
 						 !conn->short_case_preserve)) {
-					if (!strnorm(start,
-							lp_defaultcase(SNUM(conn)))) {
-						DEBUG(0, ("strnorm %s failed\n",
-							start));
-						status = NT_STATUS_INVALID_PARAMETER;
-						goto err;
-					}
+					strnorm(start,
+						lp_defaultcase(SNUM(conn)));
 				}
 
 				/*
@@ -1056,25 +1045,6 @@
 }
 
 /****************************************************************************
- Must be called as root. Creates the struct privilege_paths
- attached to the struct smb_request if this call is successful.
-****************************************************************************/
-
-static NTSTATUS check_name_with_privilege(connection_struct *conn,
-		struct smb_request *smbreq,
-		const char *name)
-{
-	NTSTATUS status = check_veto_path(conn, name);
-
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-	return check_reduced_name_with_privilege(conn,
-			name,
-			smbreq);
-}
-
-/****************************************************************************
  Check if two filenames are equal.
  This needs to be careful about whether we are case sensitive.
 ****************************************************************************/
@@ -1311,7 +1281,6 @@
  * @param ctx		talloc_ctx to allocate memory with.
  * @param conn		connection struct for vfs calls.
  * @param dfs_path	Whether this path requires dfs resolution.
- * @param smbreq	SMB request if we're using privileges.
  * @param name_in	The unconverted name.
  * @param ucf_flags	flags to pass through to unix_convert().
  *			UCF_ALWAYS_ALLOW_WCARD_LCOMP will be OR'd in if
@@ -1325,10 +1294,9 @@
  * @return NT_STATUS_OK if all operations completed succesfully, appropriate
  * 	   error otherwise.
  */
-static NTSTATUS filename_convert_internal(TALLOC_CTX *ctx,
+NTSTATUS filename_convert(TALLOC_CTX *ctx,
 				connection_struct *conn,
 				bool dfs_path,
-				struct smb_request *smbreq,
 				const char *name_in,
 				uint32_t ucf_flags,
 				bool *ppath_contains_wcard,
@@ -1344,11 +1312,10 @@
 				dfs_path,
 				name_in,
 				allow_wcards,
-				!conn->sconn->using_smb2,
 				&fname,
 				ppath_contains_wcard);
 	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10,("filename_convert_internal: resolve_dfspath failed "
+		DEBUG(10,("filename_convert: resolve_dfspath failed "
 			"for name %s with %s\n",
 			name_in,
 			nt_errstr(status) ));
@@ -1377,7 +1344,7 @@
 
 	status = unix_convert(ctx, conn, fname, pp_smb_fname, ucf_flags);
 	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10,("filename_convert_internal: unix_convert failed "
+		DEBUG(10,("filename_convert: unix_convert failed "
 			"for name %s with %s\n",
 			fname,
 			nt_errstr(status) ));
@@ -1390,13 +1357,9 @@
 		return check_veto_path(conn, (*pp_smb_fname)->base_name);
 	}
 
-	if (!smbreq) {
-		status = check_name(conn, (*pp_smb_fname)->base_name);
-	} else {
-		status = check_name_with_privilege(conn, smbreq, (*pp_smb_fname)->base_name);
-	}
+	status = check_name(conn, (*pp_smb_fname)->base_name);
 	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(3,("filename_convert_internal: check_name failed "
+		DEBUG(3,("filename_convert: check_name failed "
 			"for name %s with %s\n",
 			smb_fname_str_dbg(*pp_smb_fname),
 			nt_errstr(status) ));
@@ -1406,49 +1369,3 @@
 
 	return status;
 }
-
-/*
- * Go through all the steps to validate a filename.
- * Non-root version.
- */
-
-NTSTATUS filename_convert(TALLOC_CTX *ctx,
-				connection_struct *conn,
-				bool dfs_path,
-				const char *name_in,
-				uint32_t ucf_flags,
-				bool *ppath_contains_wcard,
-				struct smb_filename **pp_smb_fname)
-{
-	return filename_convert_internal(ctx,
-					conn,
-					dfs_path,
-					NULL,
-					name_in,
-					ucf_flags,
-					ppath_contains_wcard,
-					pp_smb_fname);
-}
-
-/*
- * Go through all the steps to validate a filename.
- * root (privileged) version.
- */
-
-NTSTATUS filename_convert_with_privilege(TALLOC_CTX *ctx,
-                                connection_struct *conn,
-				struct smb_request *smbreq,
-                                const char *name_in,
-                                uint32_t ucf_flags,
-                                bool *ppath_contains_wcard,
-                                struct smb_filename **pp_smb_fname)
-{
-	return filename_convert_internal(ctx,
-					conn,
-					smbreq->flags2 & FLAGS2_DFS_PATHNAMES,
-					smbreq,
-					name_in,
-					ucf_flags,
-					ppath_contains_wcard,
-					pp_smb_fname);
-}
Only in ../../samba-3.6.24/source3/smbd: filename.o
diff -ur smbd/files.c ../../samba-3.6.24/source3/smbd/files.c
--- smbd/files.c	2014-05-28 01:20:37.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/files.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,57 +22,36 @@
 #include "smbd/globals.h"
 #include "libcli/security/security.h"
 #include "util_tdb.h"
-#include <ccan/hash/hash.h>
-#include "lib/util/bitmap.h"
 
-#define FILE_HANDLE_OFFSET 0x1000
+#define VALID_FNUM(fnum)   (((fnum) >= 0) && ((fnum) < real_max_open_files))
 
-/**
- * create new fsp to be used for file_new or a durable handle reconnect
- */
-NTSTATUS fsp_new(struct connection_struct *conn, TALLOC_CTX *mem_ctx,
-		 files_struct **result)
-{
-	NTSTATUS status = NT_STATUS_NO_MEMORY;
-	files_struct *fsp = NULL;
-	struct smbd_server_connection *sconn = conn->sconn;
+#define FILE_HANDLE_OFFSET 0x1000
 
-	fsp = talloc_zero(mem_ctx, struct files_struct);
-	if (fsp == NULL) {
-		goto fail;
-	}
+/****************************************************************************
+ Return a unique number identifying this fsp over the life of this pid,
+ and try to make it as globally unique as possible.
+ See bug #8995 for the details.
+****************************************************************************/
 
+static unsigned long get_gen_count(struct smbd_server_connection *sconn)
+{
 	/*
-	 * This can't be a child of fsp because the file_handle can be ref'd
-	 * when doing a dos/fcb open, which will then share the file_handle
-	 * across multiple fsps.
+	 * While fsp->fh->gen_id is 'unsigned long' currently
+	 * (which might by 8 bytes),
+	 * there's some oplock code which truncates it to
+	 * uint32_t(using IVAL()).
 	 */
-	fsp->fh = talloc_zero(mem_ctx, struct fd_handle);
-	if (fsp->fh == NULL) {
-		goto fail;
+	if (sconn->file_gen_counter == 0) {
+		sconn->file_gen_counter = generate_random();
 	}
-
-	fsp->fh->ref_count = 1;
-	fsp->fh->fd = -1;
-
-	fsp->fnum = FNUM_FIELD_INVALID;
-	fsp->conn = conn;
-
-	DLIST_ADD(sconn->files, fsp);
-	sconn->num_files += 1;
-
-	conn->num_files_open++;
-
-	*result = fsp;
-	return NT_STATUS_OK;
-
-fail:
-	if (fsp != NULL) {
-		TALLOC_FREE(fsp->fh);
+	sconn->file_gen_counter += 1;
+	if (sconn->file_gen_counter >= UINT32_MAX) {
+		sconn->file_gen_counter = 0;
 	}
-	TALLOC_FREE(fsp);
-
-	return status;
+	if (sconn->file_gen_counter == 0) {
+		sconn->file_gen_counter += 1;
+	}
+	return sconn->file_gen_counter;
 }
 
 /****************************************************************************
@@ -83,36 +62,66 @@
 		  files_struct **result)
 {
 	struct smbd_server_connection *sconn = conn->sconn;
+	int i;
 	files_struct *fsp;
 	NTSTATUS status;
 
-	status = fsp_new(conn, conn, &fsp);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+	/* we want to give out file handles differently on each new
+	   connection because of a common bug in MS clients where they try to
+	   reuse a file descriptor from an earlier smb connection. This code
+	   increases the chance that the errant client will get an error rather
+	   than causing corruption */
+	if (sconn->first_file == 0) {
+		sconn->first_file = (sys_getpid() ^ (int)time(NULL));
+		sconn->first_file %= sconn->real_max_open_files;
+	}
+
+	/* TODO: Port the id-tree implementation from Samba4 */
+
+	i = bitmap_find(sconn->file_bmap, sconn->first_file);
+	if (i == -1) {
+		DEBUG(0,("ERROR! Out of file structures\n"));
+		/* TODO: We have to unconditionally return a DOS error here,
+		 * W2k3 even returns ERRDOS/ERRnofids for ntcreate&x with
+		 * NTSTATUS negotiated */
+		return NT_STATUS_TOO_MANY_OPENED_FILES;
 	}
 
-	GetTimeOfDay(&fsp->open_time);
+	/*
+	 * Make a child of the connection_struct as an fsp can't exist
+	 * independent of a connection.
+	 */
+	fsp = talloc_zero(conn, struct files_struct);
+	if (!fsp) {
+		return NT_STATUS_NO_MEMORY;
+	}
 
-	if (req) {
-		struct smbXsrv_open *op = NULL;
-		NTTIME now = timeval_to_nttime(&fsp->open_time);
-
-		status = smbXsrv_open_create(sconn->conn,
-					     conn->session_info,
-					     now, &op);
-		if (!NT_STATUS_IS_OK(status)) {
-			file_free(NULL, fsp);
-			return status;
-		}
-		fsp->op = op;
-		op->compat = fsp;
-		fsp->fnum = op->local_id;
-		fsp->fh->gen_id = smbXsrv_open_hash(op);
-	} else {
-		DEBUG(10, ("%s: req==NULL, INTERNAL_OPEN_ONLY, smbXsrv_open "
-			   "allocated\n", __func__));
+	/*
+	 * This can't be a child of fsp because the file_handle can be ref'd
+	 * when doing a dos/fcb open, which will then share the file_handle
+	 * across multiple fsps.
+	 */
+	fsp->fh = talloc_zero(conn, struct fd_handle);
+	if (!fsp->fh) {
+		TALLOC_FREE(fsp);
+		return NT_STATUS_NO_MEMORY;
 	}
 
+	fsp->fh->ref_count = 1;
+	fsp->fh->fd = -1;
+
+	fsp->conn = conn;
+	fsp->fh->gen_id = get_gen_count(sconn);
+	GetTimeOfDay(&fsp->open_time);
+
+	sconn->first_file = (i+1) % (sconn->real_max_open_files);
+
+	bitmap_set(sconn->file_bmap, i);
+	sconn->files_used += 1;
+
+	fsp->fnum = i + FILE_HANDLE_OFFSET;
+	SMB_ASSERT(fsp->fnum < 65536);
+
 	/*
 	 * Create an smb_filename with "" for the base_name.  There are very
 	 * few NULL checks, so make sure it's initialized with something. to
@@ -121,15 +130,16 @@
 	status = create_synthetic_smb_fname(fsp, "", NULL, NULL,
 					    &fsp->fsp_name);
 	if (!NT_STATUS_IS_OK(status)) {
-		file_free(NULL, fsp);
-		return status;
+		TALLOC_FREE(fsp);
+		TALLOC_FREE(fsp->fh);
 	}
 
-	DEBUG(5,("allocated file structure %s (%u used)\n",
-		 fsp_fnum_dbg(fsp), (unsigned int)sconn->num_files));
+	DLIST_ADD(sconn->files, fsp);
+
+	DEBUG(5,("allocated file structure %d, fnum = %d (%d used)\n",
+		 i, fsp->fnum, sconn->files_used));
 
 	if (req != NULL) {
-		fsp->mid = req->mid;
 		req->chain_fsp = fsp;
 	}
 
@@ -140,6 +150,8 @@
 
 	ZERO_STRUCT(sconn->fsp_fi_cache);
 
+	conn->num_files_open++;
+
 	*result = fsp;
 	return NT_STATUS_OK;
 }
@@ -154,16 +166,9 @@
 
 	for (fsp=conn->sconn->files; fsp; fsp=next) {
 		next = fsp->next;
-		if (fsp->conn != conn) {
-			continue;
-		}
-		if (fsp->op != NULL && fsp->op->global->durable) {
-			/*
-			 * A tree disconnect closes a durable handle
-			 */
-			fsp->op->global->durable = false;
+		if (fsp->conn == conn) {
+			close_file(NULL, fsp, SHUTDOWN_CLOSE);
 		}
-		close_file(NULL, fsp, SHUTDOWN_CLOSE);
 	}
 }
 
@@ -172,7 +177,7 @@
 ****************************************************************************/
 
 void file_close_pid(struct smbd_server_connection *sconn, uint16 smbpid,
-		    uint64_t vuid)
+		    int vuid)
 {
 	files_struct *fsp, *next;
 
@@ -188,54 +193,38 @@
  Initialise file structures.
 ****************************************************************************/
 
-static int files_max_open_fds;
-
-bool file_init_global(void)
+bool file_init(struct smbd_server_connection *sconn)
 {
-	int request_max = lp_max_open_files();
+	int request_max_open_files = lp_max_open_files();
 	int real_lim;
-	int real_max;
-
-	if (files_max_open_fds != 0) {
-		return true;
-	}
 
 	/*
 	 * Set the max_open files to be the requested
 	 * max plus a fudgefactor to allow for the extra
 	 * fd's we need such as log files etc...
 	 */
-	real_lim = set_maxfiles(request_max + MAX_OPEN_FUDGEFACTOR);
+	real_lim = set_maxfiles(request_max_open_files + MAX_OPEN_FUDGEFACTOR);
 
-	real_max = real_lim - MAX_OPEN_FUDGEFACTOR;
+	sconn->real_max_open_files = real_lim - MAX_OPEN_FUDGEFACTOR;
 
-	if (real_max + FILE_HANDLE_OFFSET + MAX_OPEN_PIPES > 65536) {
-		real_max = 65536 - FILE_HANDLE_OFFSET - MAX_OPEN_PIPES;
-	}
+	if (sconn->real_max_open_files + FILE_HANDLE_OFFSET + MAX_OPEN_PIPES
+	    > 65536)
+		sconn->real_max_open_files =
+			65536 - FILE_HANDLE_OFFSET - MAX_OPEN_PIPES;
 
-	if (real_max != request_max) {
-		DEBUG(1, ("file_init_global: Information only: requested %d "
+	if(sconn->real_max_open_files != request_max_open_files) {
+		DEBUG(1, ("file_init: Information only: requested %d "
 			  "open files, %d are available.\n",
-			  request_max, real_max));
+			  request_max_open_files, sconn->real_max_open_files));
 	}
 
-	SMB_ASSERT(real_max > 100);
+	SMB_ASSERT(sconn->real_max_open_files > 100);
 
-	files_max_open_fds = real_max;
-	return true;
-}
+	sconn->file_bmap = bitmap_talloc(sconn, sconn->real_max_open_files);
 
-bool file_init(struct smbd_server_connection *sconn)
-{
-	bool ok;
-
-	ok = file_init_global();
-	if (!ok) {
+	if (!sconn->file_bmap) {
 		return false;
 	}
-
-	sconn->real_max_open_files = files_max_open_fds;
-
 	return true;
 }
 
@@ -243,7 +232,7 @@
  Close files open by a specified vuid.
 ****************************************************************************/
 
-void file_close_user(struct smbd_server_connection *sconn, uint64_t vuid)
+void file_close_user(struct smbd_server_connection *sconn, int vuid)
 {
 	files_struct *fsp, *next;
 
@@ -457,13 +446,11 @@
  Free up a fsp.
 ****************************************************************************/
 
-void fsp_free(files_struct *fsp)
+void file_free(struct smb_request *req, files_struct *fsp)
 {
 	struct smbd_server_connection *sconn = fsp->conn->sconn;
 
 	DLIST_REMOVE(sconn->files, fsp);
-	SMB_ASSERT(sconn->num_files > 0);
-	sconn->num_files--;
 
 	TALLOC_FREE(fsp->fake_file_handle);
 
@@ -473,35 +460,28 @@
 		fsp->fh->ref_count--;
 	}
 
-	fsp->conn->num_files_open--;
-
-	/* this is paranoia, just in case someone tries to reuse the
-	   information */
-	ZERO_STRUCTP(fsp);
-
-	/* fsp->fsp_name is a talloc child and is free'd automatically. */
-	TALLOC_FREE(fsp);
-}
-
-void file_free(struct smb_request *req, files_struct *fsp)
-{
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	uint64_t fnum = fsp->fnum;
-
 	if (fsp->notify) {
-		struct notify_context *notify_ctx =
-			fsp->conn->sconn->notify_ctx;
-		notify_remove(notify_ctx, fsp);
+		if (fsp->is_directory) {
+			notify_remove_onelevel(fsp->conn->notify_ctx,
+					       &fsp->file_id, fsp);
+		}
+		notify_remove(fsp->conn->notify_ctx, fsp);
 		TALLOC_FREE(fsp->notify);
 	}
 
 	/* Ensure this event will never fire. */
+	TALLOC_FREE(fsp->oplock_timeout);
+
+	/* Ensure this event will never fire. */
 	TALLOC_FREE(fsp->update_write_time_event);
 
-	if (fsp->op != NULL) {
-		fsp->op->compat = NULL;
-	}
-	TALLOC_FREE(fsp->op);
+	bitmap_clear(sconn->file_bmap, fsp->fnum - FILE_HANDLE_OFFSET);
+	sconn->files_used--;
+
+	DEBUG(5,("freed files structure %d (%d used)\n",
+		 fsp->fnum, sconn->files_used));
+
+	fsp->conn->num_files_open--;
 
 	if ((req != NULL) && (fsp == req->chain_fsp)) {
 		req->chain_fsp = NULL;
@@ -521,12 +501,37 @@
 	}
 
 	/* Drop all remaining extensions. */
-	vfs_remove_all_fsp_extensions(fsp);
+	while (fsp->vfs_extension) {
+		vfs_remove_fsp_extension(fsp->vfs_extension->owner, fsp);
+	}
 
-	fsp_free(fsp);
+	/* this is paranoia, just in case someone tries to reuse the
+	   information */
+	ZERO_STRUCTP(fsp);
 
-	DEBUG(5,("freed files structure %llu (%u used)\n",
-		 (unsigned long long)fnum, (unsigned int)sconn->num_files));
+	/* fsp->fsp_name is a talloc child and is free'd automatically. */
+	TALLOC_FREE(fsp);
+}
+
+/****************************************************************************
+ Get an fsp from a 16 bit fnum.
+****************************************************************************/
+
+static struct files_struct *file_fnum(struct smbd_server_connection *sconn,
+				      uint16 fnum)
+{
+	files_struct *fsp;
+	int count=0;
+
+	for (fsp=sconn->files; fsp; fsp=fsp->next, count++) {
+		if (fsp->fnum == fnum) {
+			if (count > 10) {
+				DLIST_PROMOTE(sconn->files, fsp);
+			}
+			return fsp;
+		}
+	}
+	return NULL;
 }
 
 /****************************************************************************
@@ -535,9 +540,6 @@
 
 files_struct *file_fsp(struct smb_request *req, uint16 fid)
 {
-	struct smbXsrv_open *op;
-	NTSTATUS status;
-	NTTIME now = 0;
 	files_struct *fsp;
 
 	if (req == NULL) {
@@ -554,88 +556,78 @@
 	}
 
 	if (req->chain_fsp != NULL) {
-		if (req->chain_fsp->deferred_close) {
-			return NULL;
-		}
 		return req->chain_fsp;
 	}
 
-	if (req->sconn->conn == NULL) {
-		return NULL;
-	}
-
-	now = timeval_to_nttime(&req->request_time);
-
-	status = smb1srv_open_lookup(req->sconn->conn,
-				     fid, now, &op);
-	if (!NT_STATUS_IS_OK(status)) {
-		return NULL;
+	fsp = file_fnum(req->sconn, fid);
+	if (fsp != NULL) {
+		req->chain_fsp = fsp;
 	}
+	return fsp;
+}
 
-	fsp = op->compat;
-	if (fsp == NULL) {
-		return NULL;
-	}
+uint64_t fsp_persistent_id(const struct files_struct *fsp)
+{
+	uint64_t persistent_id;
 
-	if (fsp->deferred_close) {
-		return NULL;
-	}
+	/*
+	 * This calculates a number that is most likely
+	 * globally unique. In future we will have a database
+	 * to make it completely unique.
+	 *
+	 * 32-bit random gen_id
+	 * 16-bit truncated open_time
+	 * 16-bit fnum (valatile_id)
+	 */
+	persistent_id = fsp->fh->gen_id & UINT32_MAX;
+	persistent_id <<= 16;
+	persistent_id &= 0x0000FFFFFFFF0000LLU;
+	persistent_id |= fsp->open_time.tv_usec & UINT16_MAX;
+	persistent_id <<= 16;
+	persistent_id &= 0xFFFFFFFFFFFF0000LLU;
+	persistent_id |= fsp->fnum & UINT16_MAX;
 
-	req->chain_fsp = fsp;
-	return fsp;
+	return persistent_id;
 }
 
 struct files_struct *file_fsp_smb2(struct smbd_smb2_request *smb2req,
 				   uint64_t persistent_id,
 				   uint64_t volatile_id)
 {
-	struct smbXsrv_open *op;
-	NTSTATUS status;
-	NTTIME now = 0;
 	struct files_struct *fsp;
+	uint64_t fsp_persistent;
 
 	if (smb2req->compat_chain_fsp != NULL) {
-		if (smb2req->compat_chain_fsp->deferred_close) {
-			return NULL;
-		}
 		return smb2req->compat_chain_fsp;
 	}
 
-	now = timeval_to_nttime(&smb2req->request_time);
-
-	status = smb2srv_open_lookup(smb2req->sconn->conn,
-				     persistent_id, volatile_id,
-				     now, &op);
-	if (!NT_STATUS_IS_OK(status)) {
+	if (volatile_id > UINT16_MAX) {
 		return NULL;
 	}
 
-	fsp = op->compat;
+	fsp = file_fnum(smb2req->sconn, (uint16_t)volatile_id);
 	if (fsp == NULL) {
 		return NULL;
 	}
+	fsp_persistent = fsp_persistent_id(fsp);
 
-	if (smb2req->tcon == NULL) {
-		return NULL;
-	}
-
-	if (smb2req->tcon->compat != fsp->conn) {
+	if (persistent_id != fsp_persistent) {
 		return NULL;
 	}
 
-	if (smb2req->session == NULL) {
+	if (smb2req->tcon == NULL) {
 		return NULL;
 	}
 
-	if (smb2req->session->compat == NULL) {
+	if (smb2req->tcon->compat_conn != fsp->conn) {
 		return NULL;
 	}
 
-	if (smb2req->session->compat->vuid != fsp->vuid) {
+	if (smb2req->session == NULL) {
 		return NULL;
 	}
 
-	if (fsp->deferred_close) {
+	if (smb2req->session->vuid != fsp->vuid) {
 		return NULL;
 	}
 
@@ -651,9 +643,6 @@
 		      uint32 access_mask, uint32 share_access,
 		      uint32 create_options, files_struct *to)
 {
-	/* this can never happen for print files */
-	SMB_ASSERT(from->print_file == NULL);
-
 	TALLOC_FREE(to->fh);
 
 	to->fh = from->fh;
@@ -661,6 +650,7 @@
 
 	to->file_id = from->file_id;
 	to->initial_allocation_size = from->initial_allocation_size;
+	to->mode = from->mode;
 	to->file_pid = from->file_pid;
 	to->vuid = from->vuid;
 	to->open_time = from->open_time;
@@ -668,14 +658,24 @@
 	to->share_access = share_access;
 	to->oplock_type = from->oplock_type;
 	to->can_lock = from->can_lock;
-	to->can_read = ((access_mask & FILE_READ_DATA) != 0);
-	to->can_write =
-		CAN_WRITE(from->conn) &&
-		((access_mask & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0);
+	to->can_read = (access_mask & (FILE_READ_DATA)) ? True : False;
+	if (!CAN_WRITE(from->conn)) {
+		to->can_write = False;
+	} else {
+		to->can_write = (access_mask & (FILE_WRITE_DATA | FILE_APPEND_DATA)) ? True : False;
+	}
 	to->modified = from->modified;
 	to->is_directory = from->is_directory;
 	to->aio_write_behind = from->aio_write_behind;
 
+	if (from->print_file) {
+		to->print_file = talloc(to, struct print_file_data);
+		if (!to->print_file) return NT_STATUS_NO_MEMORY;
+		to->print_file->rap_jobid = from->print_file->rap_jobid;
+	} else {
+		to->print_file = NULL;
+	}
+
 	return fsp_set_smb_fname(to, from->fsp_name);
 }
 
@@ -686,6 +686,7 @@
 NTSTATUS file_name_hash(connection_struct *conn,
 			const char *name, uint32_t *p_name_hash)
 {
+	TDB_DATA key;
 	char *fullpath = NULL;
 
 	/* Set the hash of the full pathname. */
@@ -696,7 +697,8 @@
 	if (!fullpath) {
 		return NT_STATUS_NO_MEMORY;
 	}
-	*p_name_hash = hash(fullpath, talloc_get_size(fullpath), 0);
+	key = string_term_tdb_data(fullpath);
+	*p_name_hash = tdb_jenkins_hash(&key);
 
 	DEBUG(10,("file_name_hash: %s hash 0x%x\n",
 		fullpath,
Only in ../../samba-3.6.24/source3/smbd: files.o
diff -ur smbd/globals.c ../../samba-3.6.24/source3/smbd/globals.c
--- smbd/globals.c	2012-10-30 17:01:47.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/globals.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,10 +22,14 @@
 #include "smbd/globals.h"
 #include "memcache.h"
 #include "messages.h"
-#include "tdb_compat.h"
+#include <tdb.h>
 
-int aio_pending_size = 100;	/* tevent supports 100 signals SA_SIGINFO */
+#if defined(WITH_AIO)
+struct aio_extra *aio_list_head = NULL;
+struct tevent_signal *aio_signal_event = NULL;
+int aio_pending_size = 0;
 int outstanding_aio_calls = 0;
+#endif
 
 #ifdef USE_DMAPI
 struct smbd_dmapi_context *dmapi_ctx = NULL;
@@ -49,20 +53,21 @@
 */
 unsigned mangle_prefix = 0;
 
+struct msg_state *smbd_msg_state = NULL;
+
 bool logged_ioctl_message = false;
 
 time_t last_smb_conf_reload_time = 0;
 time_t last_printer_reload_time = 0;
-pid_t background_lpq_updater_pid = -1;
-
 /****************************************************************************
  structure to hold a linked list of queued messages.
  for processing.
 ****************************************************************************/
+struct pending_message_list *deferred_open_queue = NULL;
 uint32_t common_flags2 = FLAGS2_LONG_PATH_COMPONENTS|FLAGS2_32_BIT_ERROR_CODES|FLAGS2_EXTENDED_ATTRIBUTES;
 
-struct smb_trans_enc_state *partial_srv_trans_enc_ctx = NULL;
-struct smb_trans_enc_state *srv_trans_enc_ctx = NULL;
+struct smb_srv_trans_enc_ctx *partial_srv_trans_enc_ctx = NULL;
+struct smb_srv_trans_enc_ctx *srv_trans_enc_ctx = NULL;
 
 /* A stack of security contexts.  We include the current context as being
    the first one, so there is room for another MAX_SEC_CTX_DEPTH more. */
@@ -86,11 +91,41 @@
 char *sparse_buf = NULL;
 char *LastDir = NULL;
 
-struct smbd_parent_context *am_parent = NULL;
+/* Current number of oplocks we have outstanding. */
+int32_t exclusive_oplocks_open = 0;
+int32_t level_II_oplocks_open = 0;
+struct kernel_oplocks *koplocks = NULL;
+
+int am_parent = 1;
 struct memcache *smbd_memcache_ctx = NULL;
 bool exit_firsttime = true;
+struct child_pid *children = 0;
+int num_children = 0;
+
+struct smbd_server_connection *smbd_server_conn = NULL;
+
+struct smbd_server_connection *msg_ctx_to_sconn(struct messaging_context *msg_ctx)
+{
+	struct server_id my_id, msg_id;
+
+	my_id = messaging_server_id(smbd_server_conn->msg_ctx);
+	msg_id = messaging_server_id(msg_ctx);
+
+	if (!procid_equal(&my_id, &msg_id)) {
+		return NULL;
+	}
+	return smbd_server_conn;
+}
 
-struct smbXsrv_connection *global_smbXsrv_connection = NULL;
+struct messaging_context *smbd_messaging_context(void)
+{
+	struct messaging_context *msg_ctx = server_messaging_context();
+	if (likely(msg_ctx != NULL)) {
+		return msg_ctx;
+	}
+	smb_panic("Could not init smbd's messaging context.\n");
+	return NULL;
+}
 
 struct memcache *smbd_memcache(void)
 {
@@ -110,9 +145,18 @@
 	return smbd_memcache_ctx;
 }
 
+
 void smbd_init_globals(void)
 {
 	ZERO_STRUCT(conn_ctx_stack);
 
 	ZERO_STRUCT(sec_ctx_stack);
+
+	smbd_server_conn = talloc_zero(smbd_event_context(), struct smbd_server_connection);
+	if (!smbd_server_conn) {
+		exit_server("failed to create smbd_server_connection");
+	}
+
+	smbd_server_conn->smb1.echo_handler.trusted_fd = -1;
+	smbd_server_conn->smb1.echo_handler.socket_lock_fd = -1;
 }
diff -ur smbd/globals.h ../../samba-3.6.24/source3/smbd/globals.h
--- smbd/globals.h	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/globals.h	2015-01-28 10:52:25.149068676 +0800
@@ -19,10 +19,14 @@
 */
 
 #include "system/select.h"
-#include "librpc/gen_ndr/smbXsrv.h"
 
+#if defined(WITH_AIO)
+struct aio_extra;
+extern struct aio_extra *aio_list_head;
+extern struct tevent_signal *aio_signal_event;
 extern int aio_pending_size;
 extern int outstanding_aio_calls;
+#endif
 
 #ifdef USE_DMAPI
 struct smbd_dmapi_context;
@@ -54,6 +58,7 @@
 extern unsigned mangle_prefix;
 
 struct msg_state;
+extern struct msg_state *smbd_msg_state;
 
 extern bool logged_ioctl_message;
 
@@ -61,16 +66,17 @@
 
 extern time_t last_smb_conf_reload_time;
 extern time_t last_printer_reload_time;
-extern pid_t background_lpq_updater_pid;
-
 /****************************************************************************
  structure to hold a linked list of queued messages.
  for processing.
 ****************************************************************************/
+struct pending_message_list;
+extern struct pending_message_list *deferred_open_queue;
 extern uint32_t common_flags2;
 
-extern struct smb_trans_enc_state *partial_srv_trans_enc_ctx;
-extern struct smb_trans_enc_state *srv_trans_enc_ctx;
+struct smb_srv_trans_enc_ctx;
+extern struct smb_srv_trans_enc_ctx *partial_srv_trans_enc_ctx;
+extern struct smb_srv_trans_enc_ctx *srv_trans_enc_ctx;
 
 struct sec_ctx {
 	struct security_unix_token ut;
@@ -92,7 +98,7 @@
 
 struct conn_ctx {
 	connection_struct *conn;
-	uint64_t vuid;
+	uint16 vuid;
 };
 /* A stack of current_user connection contexts. */
 extern struct conn_ctx conn_ctx_stack[MAX_SEC_CTX_DEPTH];
@@ -103,19 +109,37 @@
 extern char *sparse_buf;
 extern char *LastDir;
 
-struct smbd_parent_context;
-extern struct smbd_parent_context *am_parent;
+/* Current number of oplocks we have outstanding. */
+extern int32_t exclusive_oplocks_open;
+extern int32_t level_II_oplocks_open;
+extern struct kernel_oplocks *koplocks;
+
+extern int am_parent;
+extern struct event_context *smbd_event_ctx;
+extern struct messaging_context *smbd_msg_ctx;
 extern struct memcache *smbd_memcache_ctx;
 extern bool exit_firsttime;
+struct child_pid;
+extern struct child_pid *children;
+extern int num_children;
 
 struct tstream_context;
 struct smbd_smb2_request;
+struct smbd_smb2_session;
+struct smbd_smb2_tcon;
 
 DATA_BLOB negprot_spnego(TALLOC_CTX *ctx, struct smbd_server_connection *sconn);
 
 void smbd_lock_socket(struct smbd_server_connection *sconn);
 void smbd_unlock_socket(struct smbd_server_connection *sconn);
 
+NTSTATUS smb2_signing_sign_pdu(DATA_BLOB session_key,
+			       struct iovec *vector,
+			       int count);
+NTSTATUS smb2_signing_check_pdu(DATA_BLOB session_key,
+				const struct iovec *vector,
+				int count);
+
 NTSTATUS smbd_do_locking(struct smb_request *req,
 			 files_struct *fsp,
 			 uint8_t type,
@@ -205,8 +229,13 @@
 
 NTSTATUS smbd_calculate_access_mask(connection_struct *conn,
 				    const struct smb_filename *smb_fname,
+				    bool file_existed,
 				    uint32_t access_mask,
 				    uint32_t *access_mask_out);
+NTSTATUS smbd_check_open_rights(struct connection_struct *conn,
+				const struct smb_filename *smb_fname,
+				uint32_t access_mask,
+				uint32_t *access_granted);
 
 void smbd_notify_cancel_by_smbreq(const struct smb_request *smbreq);
 
@@ -216,13 +245,14 @@
 #define smbd_server_connection_terminate(sconn, reason) \
 	smbd_server_connection_terminate_ex(sconn, reason, __location__)
 
+struct server_id sconn_server_id(const struct smbd_server_connection *sconn);
+
 const char *smb2_opcode_name(uint16_t opcode);
 bool smbd_is_smb2_header(const uint8_t *inbuf, size_t size);
 
 void reply_smb2002(struct smb_request *req, uint16_t choice);
-void reply_smb20ff(struct smb_request *req, uint16_t choice);
 void smbd_smb2_first_negprot(struct smbd_server_connection *sconn,
-			     uint8_t *inbuf, size_t size);
+			     const uint8_t *inbuf, size_t size);
 
 NTSTATUS smbd_smb2_request_error_ex(struct smbd_smb2_request *req,
 				    NTSTATUS status,
@@ -238,22 +268,19 @@
 	smbd_smb2_request_done_ex(req, NT_STATUS_OK, body, dyn, __location__)
 
 NTSTATUS smbd_smb2_send_oplock_break(struct smbd_server_connection *sconn,
-				     struct smbXsrv_session *session,
-				     struct smbXsrv_tcon *tcon,
-				     struct smbXsrv_open *op,
+				     uint64_t file_id_persistent,
+				     uint64_t file_id_volatile,
 				     uint8_t oplock_level);
 
 NTSTATUS smbd_smb2_request_pending_queue(struct smbd_smb2_request *req,
-					 struct tevent_req *subreq,
-					 uint32_t defer_time);
+					 struct tevent_req *subreq);
+
+NTSTATUS smbd_smb2_request_check_session(struct smbd_smb2_request *req);
+NTSTATUS smbd_smb2_request_check_tcon(struct smbd_smb2_request *req);
 
 struct smb_request *smbd_smb2_fake_smb_request(struct smbd_smb2_request *req);
-size_t smbd_smb2_unread_bytes(struct smbd_smb2_request *req);
 void remove_smb2_chained_fsp(files_struct *fsp);
 
-NTSTATUS smbd_smb2_request_verify_creditcharge(struct smbd_smb2_request *req,
-					       uint32_t data_length);
-
 NTSTATUS smbd_smb2_request_verify_sizes(struct smbd_smb2_request *req,
 					size_t expected_body_size);
 
@@ -269,8 +296,6 @@
 NTSTATUS smb2_read_complete(struct tevent_req *req, ssize_t nread, int err);
 NTSTATUS smbd_smb2_request_process_write(struct smbd_smb2_request *req);
 NTSTATUS smb2_write_complete(struct tevent_req *req, ssize_t nwritten, int err);
-NTSTATUS smb2_write_complete_nosync(struct tevent_req *req, ssize_t nwritten,
-				    int err);
 NTSTATUS smbd_smb2_request_process_lock(struct smbd_smb2_request *req);
 NTSTATUS smbd_smb2_request_process_ioctl(struct smbd_smb2_request *req);
 NTSTATUS smbd_smb2_request_process_keepalive(struct smbd_smb2_request *req);
@@ -312,7 +337,7 @@
 			    uint64_t mid);
 void remove_deferred_open_message_smb2(
 	struct smbd_server_connection *sconn, uint64_t mid);
-bool schedule_deferred_open_message_smb2(
+void schedule_deferred_open_message_smb2(
 	struct smbd_server_connection *sconn, uint64_t mid);
 bool push_deferred_open_message_smb2(struct smbd_smb2_request *smb2req,
 			struct timeval request_time,
@@ -321,196 +346,28 @@
 			char *private_data,
 			size_t priv_len);
 
-struct smbXsrv_connection {
-	struct smbd_server_connection *sconn;
-
-	const struct tsocket_address *local_address;
-	const struct tsocket_address *remote_address;
-	const char *remote_hostname;
-
-	struct tevent_context *ev_ctx;
-	struct messaging_context *msg_ctx;
-
-	enum protocol_types protocol;
-
-	struct {
-		struct {
-			uint32_t capabilities;
-			struct GUID guid;
-			uint16_t security_mode;
-			uint16_t num_dialects;
-			uint16_t *dialects;
-		} client;
-		struct {
-			uint32_t capabilities;
-			struct GUID guid;
-			uint16_t security_mode;
-			uint16_t dialect;
-			uint32_t max_trans;
-			uint32_t max_read;
-			uint32_t max_write;
-		} server;
-	} smb2;
-
-	struct msg_state *msg_state;
-
-	/*
-	 * Link into libasys for asynchronous operations
-	 */
-	struct asys_context *asys_ctx;
-	struct tevent_fd *asys_fde;
-
-	uint64_t smbd_idle_profstamp;
-
-	/*
-	 * this session_table is used for SMB1 and SMB2,
-	 */
-	struct smbXsrv_session_table *session_table;
-	uint64_t last_session_id;
-	/*
-	 * this tcon_table is only used for SMB1.
-	 */
-	struct smbXsrv_tcon_table *tcon_table;
-	/*
-	 * this open_table is used for SMB1 and SMB2,
-	 * because we have a global sconn->real_max_open_files
-	 * limit.
-	 */
-	struct smbXsrv_open_table *open_table;
-};
-
-NTSTATUS smbXsrv_version_global_init(const struct server_id *server_id);
-uint32_t smbXsrv_version_global_current(void);
-
-NTSTATUS smbXsrv_connection_init_tables(struct smbXsrv_connection *conn,
-					enum protocol_types protocol);
-
-NTSTATUS smbXsrv_session_global_init(void);
-NTSTATUS smbXsrv_session_create(struct smbXsrv_connection *conn,
-				NTTIME now,
-				struct smbXsrv_session **_session);
-NTSTATUS smbXsrv_session_update(struct smbXsrv_session *session);
-NTSTATUS smbXsrv_session_logoff(struct smbXsrv_session *session);
-NTSTATUS smbXsrv_session_logoff_all(struct smbXsrv_connection *conn);
-NTSTATUS smb1srv_session_table_init(struct smbXsrv_connection *conn);
-NTSTATUS smb1srv_session_lookup(struct smbXsrv_connection *conn,
-				uint16_t vuid, NTTIME now,
-				struct smbXsrv_session **session);
-NTSTATUS smb2srv_session_table_init(struct smbXsrv_connection *conn);
-NTSTATUS smb2srv_session_lookup(struct smbXsrv_connection *conn,
-				uint64_t session_id, NTTIME now,
-				struct smbXsrv_session **session);
-struct smbXsrv_session_global0;
-NTSTATUS smbXsrv_session_global_traverse(
-			int (*fn)(struct smbXsrv_session_global0 *, void *),
-			void *private_data);
-struct tevent_req *smb2srv_session_close_previous_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbXsrv_connection *conn,
-					struct auth_session_info *session_info,
-					uint64_t previous_session_id,
-					uint64_t current_session_id);
-NTSTATUS smb2srv_session_close_previous_recv(struct tevent_req *req);
-
-NTSTATUS smbXsrv_tcon_global_init(void);
-NTSTATUS smbXsrv_tcon_update(struct smbXsrv_tcon *tcon);
-NTSTATUS smbXsrv_tcon_disconnect(struct smbXsrv_tcon *tcon, uint64_t vuid);
-NTSTATUS smb1srv_tcon_table_init(struct smbXsrv_connection *conn);
-NTSTATUS smb1srv_tcon_create(struct smbXsrv_connection *conn,
-			     NTTIME now,
-			     struct smbXsrv_tcon **_tcon);
-NTSTATUS smb1srv_tcon_lookup(struct smbXsrv_connection *conn,
-			     uint16_t tree_id, NTTIME now,
-			     struct smbXsrv_tcon **tcon);
-NTSTATUS smb1srv_tcon_disconnect_all(struct smbXsrv_connection *conn);
-NTSTATUS smb2srv_tcon_table_init(struct smbXsrv_session *session);
-NTSTATUS smb2srv_tcon_create(struct smbXsrv_session *session,
-			     NTTIME now,
-			     struct smbXsrv_tcon **_tcon);
-NTSTATUS smb2srv_tcon_lookup(struct smbXsrv_session *session,
-			     uint32_t tree_id, NTTIME now,
-			     struct smbXsrv_tcon **tcon);
-NTSTATUS smb2srv_tcon_disconnect_all(struct smbXsrv_session *session);
-struct smbXsrv_tcon_global0;
-NTSTATUS smbXsrv_tcon_global_traverse(
-			int (*fn)(struct smbXsrv_tcon_global0 *, void *),
-			void *private_data);
-
-NTSTATUS smbXsrv_open_global_init(void);
-NTSTATUS smbXsrv_open_create(struct smbXsrv_connection *conn,
-			     struct auth_session_info *session_info,
-			     NTTIME now,
-			     struct smbXsrv_open **_open);
-uint32_t smbXsrv_open_hash(struct smbXsrv_open *_open);
-NTSTATUS smbXsrv_open_update(struct smbXsrv_open *_open);
-NTSTATUS smbXsrv_open_close(struct smbXsrv_open *op, NTTIME now);
-NTSTATUS smb1srv_open_table_init(struct smbXsrv_connection *conn);
-NTSTATUS smb1srv_open_lookup(struct smbXsrv_connection *conn,
-			     uint16_t fnum, NTTIME now,
-			     struct smbXsrv_open **_open);
-NTSTATUS smb2srv_open_table_init(struct smbXsrv_connection *conn);
-NTSTATUS smb2srv_open_lookup(struct smbXsrv_connection *conn,
-			     uint64_t persistent_id,
-			     uint64_t volatile_id,
-			     NTTIME now,
-			     struct smbXsrv_open **_open);
-NTSTATUS smb2srv_open_recreate(struct smbXsrv_connection *conn,
-			       struct auth_session_info *session_info,
-			       uint64_t persistent_id,
-			       struct GUID create_guid,
-			       NTTIME now,
-			       struct smbXsrv_open **_open);
-struct smbXsrv_open_global0;
-NTSTATUS smbXsrv_open_global_traverse(
-	int (*fn)(struct smbXsrv_open_global0 *, void *),
-	void *private_data);
-
-NTSTATUS smbXsrv_open_cleanup(uint64_t persistent_id);
-
-struct smbd_smb2_send_queue {
-	struct smbd_smb2_send_queue *prev, *next;
-
-	DATA_BLOB *sendfile_header;
-	struct iovec *vector;
-	int count;
-
-	TALLOC_CTX *mem_ctx;
-};
-
 struct smbd_smb2_request {
 	struct smbd_smb2_request *prev, *next;
 
-	struct smbd_server_connection *sconn;
+	TALLOC_CTX *mem_pool;
+	struct smbd_smb2_request **parent;
 
-	struct smbd_smb2_send_queue queue_entry;
+	struct smbd_server_connection *sconn;
 
 	/* the session the request operates on, maybe NULL */
-	struct smbXsrv_session *session;
+	struct smbd_smb2_session *session;
 	uint64_t last_session_id;
 
 	/* the tcon the request operates on, maybe NULL */
-	struct smbXsrv_tcon *tcon;
+	struct smbd_smb2_tcon *tcon;
 	uint32_t last_tid;
 
 	int current_idx;
 	bool do_signing;
-	bool do_encryption;
-	struct tevent_timer *async_te;
+	bool async;
+	bool cancelled;
 	bool compound_related;
 
-	/*
-	 * the encryption key for the whole
-	 * compound chain
-	 */
-	DATA_BLOB first_key;
-	/*
-	 * the signing key for the last
-	 * request/response of a compound chain
-	 */
-	DATA_BLOB last_key;
-
-	struct timeval request_time;
-
 	/* fake smb1 request. */
 	struct smb_request *smb1req;
 	struct files_struct *compat_chain_fsp;
@@ -521,64 +378,21 @@
 	 */
 	struct tevent_req *subreq;
 
-#define SMBD_SMB2_TF_IOV_OFS 0
-#define SMBD_SMB2_HDR_IOV_OFS 1
-#define SMBD_SMB2_BODY_IOV_OFS 2
-#define SMBD_SMB2_DYN_IOV_OFS 3
-
-#define SMBD_SMB2_NUM_IOV_PER_REQ 4
-
-#define SMBD_SMB2_IOV_IDX_OFS(req,dir,idx,ofs) \
-	(&req->dir.vector[(idx)+(ofs)])
-
-#define SMBD_SMB2_IDX_TF_IOV(req,dir,idx) \
-	SMBD_SMB2_IOV_IDX_OFS(req,dir,idx,SMBD_SMB2_TF_IOV_OFS)
-#define SMBD_SMB2_IDX_HDR_IOV(req,dir,idx) \
-	SMBD_SMB2_IOV_IDX_OFS(req,dir,idx,SMBD_SMB2_HDR_IOV_OFS)
-#define SMBD_SMB2_IDX_BODY_IOV(req,dir,idx) \
-	SMBD_SMB2_IOV_IDX_OFS(req,dir,idx,SMBD_SMB2_BODY_IOV_OFS)
-#define SMBD_SMB2_IDX_DYN_IOV(req,dir,idx) \
-	SMBD_SMB2_IOV_IDX_OFS(req,dir,idx,SMBD_SMB2_DYN_IOV_OFS)
-
-#define SMBD_SMB2_IN_TF_IOV(req)    SMBD_SMB2_IDX_TF_IOV(req,in,req->current_idx)
-#define SMBD_SMB2_IN_TF_PTR(req)    (uint8_t *)(SMBD_SMB2_IN_TF_IOV(req)->iov_base)
-#define SMBD_SMB2_IN_HDR_IOV(req)    SMBD_SMB2_IDX_HDR_IOV(req,in,req->current_idx)
-#define SMBD_SMB2_IN_HDR_PTR(req)    (uint8_t *)(SMBD_SMB2_IN_HDR_IOV(req)->iov_base)
-#define SMBD_SMB2_IN_BODY_IOV(req)   SMBD_SMB2_IDX_BODY_IOV(req,in,req->current_idx)
-#define SMBD_SMB2_IN_BODY_PTR(req)   (uint8_t *)(SMBD_SMB2_IN_BODY_IOV(req)->iov_base)
-#define SMBD_SMB2_IN_BODY_LEN(req)   (SMBD_SMB2_IN_BODY_IOV(req)->iov_len)
-#define SMBD_SMB2_IN_DYN_IOV(req)    SMBD_SMB2_IDX_DYN_IOV(req,in,req->current_idx)
-#define SMBD_SMB2_IN_DYN_PTR(req)    (uint8_t *)(SMBD_SMB2_IN_DYN_IOV(req)->iov_base)
-#define SMBD_SMB2_IN_DYN_LEN(req)    (SMBD_SMB2_IN_DYN_IOV(req)->iov_len)
-
-#define SMBD_SMB2_OUT_TF_IOV(req)   SMBD_SMB2_IDX_TF_IOV(req,out,req->current_idx)
-#define SMBD_SMB2_OUT_TF_PTR(req)   (uint8_t *)(SMBD_SMB2_OUT_TF_IOV(req)->iov_base)
-#define SMBD_SMB2_OUT_HDR_IOV(req)   SMBD_SMB2_IDX_HDR_IOV(req,out,req->current_idx)
-#define SMBD_SMB2_OUT_HDR_PTR(req)   (uint8_t *)(SMBD_SMB2_OUT_HDR_IOV(req)->iov_base)
-#define SMBD_SMB2_OUT_BODY_IOV(req)  SMBD_SMB2_IDX_BODY_IOV(req,out,req->current_idx)
-#define SMBD_SMB2_OUT_BODY_PTR(req)  (uint8_t *)(SMBD_SMB2_OUT_BODY_IOV(req)->iov_base)
-#define SMBD_SMB2_OUT_BODY_LEN(req)  (SMBD_SMB2_OUT_BODY_IOV(req)->iov_len)
-#define SMBD_SMB2_OUT_DYN_IOV(req)   SMBD_SMB2_IDX_DYN_IOV(req,out,req->current_idx)
-#define SMBD_SMB2_OUT_DYN_PTR(req)   (uint8_t *)(SMBD_SMB2_OUT_DYN_IOV(req)->iov_base)
-#define SMBD_SMB2_OUT_DYN_LEN(req)   (SMBD_SMB2_OUT_DYN_IOV(req)->iov_len)
-
-#define SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN (SMB2_HDR_BODY + 0x30)
-
 	struct {
+		/* the NBT header is not allocated */
+		uint8_t nbt_hdr[4];
 		/*
-		 * vector[0] TRANSPORT HEADER (empty)
+		 * vector[0] NBT
 		 * .
-		 * vector[1] SMB2_TRANSFORM (optional)
-		 * vector[2] SMB2
-		 * vector[3] fixed body
-		 * vector[4] dynamic body
+		 * vector[1] SMB2
+		 * vector[2] fixed body
+		 * vector[3] dynamic body
 		 * .
 		 * .
 		 * .
-		 * vector[5] SMB2_TRANSFORM (optional)
-		 * vector[6] SMB2
-		 * vector[7] fixed body
-		 * vector[8] dynamic body
+		 * vector[4] SMB2
+		 * vector[5] fixed body
+		 * vector[6] dynamic body
 		 * .
 		 * .
 		 * .
@@ -590,19 +404,17 @@
 		/* the NBT header is not allocated */
 		uint8_t nbt_hdr[4];
 		/*
-		 * vector[0] TRANSPORT HEADER
+		 * vector[0] NBT
 		 * .
-		 * vector[1] SMB2_TRANSFORM (optional)
-		 * vector[2] SMB2
-		 * vector[3] fixed body
-		 * vector[4] dynamic body
+		 * vector[1] SMB2
+		 * vector[2] fixed body
+		 * vector[3] dynamic body
 		 * .
 		 * .
 		 * .
-		 * vector[5] SMB2_TRANSFORM (empty)
-		 * vector[6] SMB2
-		 * vector[7] fixed body
-		 * vector[8] dynamic body
+		 * vector[4] SMB2
+		 * vector[5] fixed body
+		 * vector[6] dynamic body
 		 * .
 		 * .
 		 * .
@@ -613,54 +425,68 @@
 };
 
 struct smbd_server_connection;
-struct user_struct;
 
-struct pending_message_list;
-struct pending_auth_data;
+struct smbd_smb2_session {
+	struct smbd_smb2_session *prev, *next;
+	struct smbd_server_connection *sconn;
+	NTSTATUS status;
+	uint64_t vuid;
+	struct auth_ntlmssp_state *auth_ntlmssp_state;
+	struct auth_serversupplied_info *session_info;
+	DATA_BLOB session_key;
+	bool do_signing;
 
-struct user_struct {
-	struct user_struct *next, *prev;
-	uint64_t vuid; /* Tag for this entry. */
+	user_struct *compat_vuser;
 
-	char *session_keystr; /* used by utmp and pam session code.
-				 TDB key string */
-	int homes_snum;
+	struct {
+		/* an id tree used to allocate tids */
+		struct idr_context *idtree;
+
+		/* this is the limit of tid values for this connection */
+		uint32_t limit;
 
-	struct auth_session_info *session_info;
+		struct smbd_smb2_tcon *list;
+	} tcons;
+};
 
-	struct smbXsrv_session *session;
+struct smbd_smb2_tcon {
+	struct smbd_smb2_tcon *prev, *next;
+	struct smbd_smb2_session *session;
+	uint32_t tid;
+	int snum;
+	connection_struct *compat_conn;
 };
 
+struct pending_auth_data;
+
 struct smbd_server_connection {
-	NTSTATUS status;
 	int sock;
+	struct client_address client_id;
 	const struct tsocket_address *local_address;
 	const struct tsocket_address *remote_address;
-	const char *remote_hostname;
-	struct tevent_context *ev_ctx;
 	struct messaging_context *msg_ctx;
-	struct sys_notify_context *sys_notify_ctx;
-	struct notify_context *notify_ctx;
 	struct {
 		bool got_session;
 	} nbt;
 	bool using_smb2;
 	int trans_num;
 
-	size_t num_users;
-	struct user_struct *users;
-
-	size_t num_connections;
-	struct connection_struct *connections;
+	/*
+	 * Cache for calling poll(2) to avoid allocations in our
+	 * central event loop
+	 */
+	struct pollfd *pfds;
 
-	size_t num_files;
 	struct files_struct *files;
-
+	struct bitmap *file_bmap;
 	int real_max_open_files;
+	int files_used;
 	struct fsp_singleton_cache fsp_fi_cache;
+	unsigned long file_gen_counter;
+	int first_file;
 
-	struct pending_message_list *deferred_open_queue;
-
+	/* number of open connections (tcons) */
+	int num_tcons_open;
 
 	/* open directory handles. */
 	struct {
@@ -671,13 +497,6 @@
 
 	uint64_t num_requests;
 
-	/* Current number of oplocks we have outstanding. */
-	struct {
-		int32_t exclusive_open;
-		int32_t level_II_open;
-		struct kernel_oplocks *kernel_ops;
-	} oplocks;
-
 	struct {
 		struct fd_event *fde;
 
@@ -708,7 +527,7 @@
 		struct {
 			bool encrypted_passwords;
 			bool spnego;
-			struct auth4_context *auth_context;
+			struct auth_context *auth_context;
 			bool done;
 			/*
 			 * Size of the data we can receive. Set by us.
@@ -718,13 +537,6 @@
 		} negprot;
 
 		struct {
-			uint16_t client_major;
-			uint16_t client_minor;
-			uint32_t client_cap_low;
-			uint32_t client_cap_high;
-		} unix_info;
-
-		struct {
 			bool done_sesssetup;
 			/*
 			 * Size of data we can send to client. Set
@@ -732,8 +544,28 @@
 			 *  Set by us for CORE protocol.
 			 */
 			int max_send;
+			uint16_t last_session_tag;
+
+			/* users from session setup */
+			char *session_userlist;
+			/* workgroup from session setup. */
+			char *session_workgroup;
+			/*
+			 * this holds info on user ids that are already
+			 * validated for this VC
+			 */
+			user_struct *validated_users;
+			uint16_t next_vuid;
+			int num_validated_vuids;
 		} sessions;
+		struct {
+			connection_struct *Connections;
+			/* number of open connections */
+			struct bitmap *bmap;
+		} tcons;
 		struct smb_signing_state *signing_state;
+		/* List to store partial SPNEGO auth fragments. */
+		struct pending_auth_data *pd_list;
 
 		struct notify_mid_map *notify_mid_maps;
 
@@ -751,22 +583,21 @@
 		} locks;
 	} smb1;
 	struct {
-		struct smbd_smb2_request_read_state {
-			struct smbd_smb2_request *req;
-			struct {
-				uint8_t nbt[NBT_HDR_SIZE];
-				bool done;
-			} hdr;
-			struct iovec vector;
-			bool doing_receivefile;
-			size_t min_recv_size;
-			size_t pktlen;
-			uint8_t *pktbuf;
-		} request_read_state;
-		struct smbd_smb2_send_queue *send_queue;
-		size_t send_queue_len;
-		struct tevent_fd *fde;
-		bool negprot_2ff;
+		struct tevent_context *event_ctx;
+		struct tevent_queue *recv_queue;
+		struct tevent_queue *send_queue;
+		struct tstream_context *stream;
+		struct {
+			/* an id tree used to allocate vuids */
+			/* this holds info on session vuids that are already
+			 * validated for this VC */
+			struct idr_context *idtree;
+
+			/* this is the limit of vuid values for this connection */
+			uint64_t limit;
+
+			struct smbd_smb2_session *list;
+		} sessions;
 		struct {
 			/* The event that makes us process our blocking lock queue */
 			struct timed_event *brl_timeout;
@@ -815,15 +646,14 @@
 		 * a bitmap of size max_credits
 		 */
 		struct bitmap *credits_bitmap;
-		bool supports_multicredit;
 		uint32_t max_trans;
 		uint32_t max_read;
 		uint32_t max_write;
 	} smb2;
-
-	struct smbXsrv_connection *conn;
 };
 
-extern struct smbXsrv_connection *global_smbXsrv_connection;
+extern struct smbd_server_connection *smbd_server_conn;
+
+struct smbd_server_connection *msg_ctx_to_sconn(struct messaging_context *msg_ctx);
 
 void smbd_init_globals(void);
Only in ../../samba-3.6.24/source3/smbd: globals.o
diff -ur smbd/ipc.c ../../samba-3.6.24/source3/smbd/ipc.c
--- smbd/ipc.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/ipc.c	2015-01-28 10:52:25.149068676 +0800
@@ -79,17 +79,6 @@
 		memcpy(copy_into, &rdata[data_offset], data_len);
 }
 
-NTSTATUS nt_status_np_pipe(NTSTATUS status)
-{
-	if (NT_STATUS_EQUAL(status, NT_STATUS_CONNECTION_DISCONNECTED)) {
-		status = NT_STATUS_PIPE_DISCONNECTED;
-	} else if (NT_STATUS_EQUAL(status, NT_STATUS_CONNECTION_RESET)) {
-		status = NT_STATUS_PIPE_BROKEN;
-	}
-
-	return status;
-}
-
 /****************************************************************************
  Send a trans reply.
  ****************************************************************************/
@@ -109,14 +98,12 @@
 	int lparam = rparam ? rparam_len : 0;
 	struct smbd_server_connection *sconn = req->sconn;
 	int max_send = sconn->smb1.sessions.max_send;
-	/* HACK: make sure we send at least 128 byte in one go */
-	int hdr_overhead = SMB_BUFFER_SIZE_MIN - 128;
 
 	if (buffer_too_large)
 		DEBUG(5,("send_trans_reply: buffer %d too large\n", ldata ));
 
-	this_lparam = MIN(lparam,max_send - hdr_overhead);
-	this_ldata  = MIN(ldata,max_send - (hdr_overhead+this_lparam));
+	this_lparam = MIN(lparam,max_send - 500); /* hack */
+	this_ldata  = MIN(ldata,max_send - (500+this_lparam));
 
 	align = ((this_lparam)%4);
 
@@ -165,9 +152,9 @@
 	while (tot_data_sent < ldata || tot_param_sent < lparam)
 	{
 		this_lparam = MIN(lparam-tot_param_sent,
-				  max_send - hdr_overhead);
+				  max_send - 500); /* hack */
 		this_ldata  = MIN(ldata -tot_data_sent,
-				  max_send - (hdr_overhead+this_lparam));
+				  max_send - (500+this_lparam));
 
 		if(this_lparam < 0)
 			this_lparam = 0;
@@ -281,7 +268,7 @@
 	state->num_data = length;
 	state->max_read = max_read;
 
-	subreq = np_write_send(state, req->sconn->ev_ctx, state->handle,
+	subreq = np_write_send(state, smbd_event_context(), state->handle,
 			       state->data, length);
 	if (subreq == NULL) {
 		TALLOC_FREE(state);
@@ -303,34 +290,22 @@
 
 	status = np_write_recv(subreq, &nwritten);
 	TALLOC_FREE(subreq);
-	if (!NT_STATUS_IS_OK(status)) {
-		NTSTATUS old = status;
-		status = nt_status_np_pipe(old);
-
-		DEBUG(10, ("Could not write to pipe: %s%s%s\n",
-			   nt_errstr(old),
-			   NT_STATUS_EQUAL(old, status)?"":" => ",
-			   NT_STATUS_EQUAL(old, status)?"":nt_errstr(status)));
-		reply_nterror(req, status);
-		goto send;
-	}
-	if (nwritten != state->num_data) {
-		status = NT_STATUS_PIPE_NOT_AVAILABLE;
-		DEBUG(10, ("Could not write to pipe: (%d/%d) => %s\n",
-			   (int)state->num_data,
-			   (int)nwritten, nt_errstr(status)));
-		reply_nterror(req, status);
+	if (!NT_STATUS_IS_OK(status) || (nwritten != state->num_data)) {
+		DEBUG(10, ("Could not write to pipe: %s (%d/%d)\n",
+			   nt_errstr(status), (int)state->num_data,
+			   (int)nwritten));
+		reply_nterror(req, NT_STATUS_PIPE_NOT_AVAILABLE);
 		goto send;
 	}
 
-	state->data = talloc_realloc(state, state->data, uint8_t,
+	state->data = TALLOC_REALLOC_ARRAY(state, state->data, uint8_t,
 					   state->max_read);
 	if (state->data == NULL) {
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
 		goto send;
 	}
 
-	subreq = np_read_send(state, req->sconn->ev_ctx,
+	subreq = np_read_send(req->conn, smbd_event_context(),
 			      state->handle, state->data, state->max_read);
 	if (subreq == NULL) {
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
@@ -365,13 +340,8 @@
 	TALLOC_FREE(subreq);
 
 	if (!NT_STATUS_IS_OK(status)) {
-		NTSTATUS old = status;
-		status = nt_status_np_pipe(old);
-
-		DEBUG(10, ("Could not read from to pipe: %s%s%s\n",
-			   nt_errstr(old),
-			   NT_STATUS_EQUAL(old, status)?"":" => ",
-			   NT_STATUS_EQUAL(old, status)?"":nt_errstr(status)));
+		DEBUG(10, ("Could not read from to pipe: %s\n",
+			   nt_errstr(status)));
 		reply_nterror(req, status);
 
 		if (!srv_send_smb(req->sconn, (char *)req->outbuf,
@@ -451,7 +421,7 @@
  Handle remote api calls delivered to a named pipe already opened.
  ****************************************************************************/
 
-static void api_fd_reply(connection_struct *conn, uint64_t vuid,
+static void api_fd_reply(connection_struct *conn, uint16 vuid,
 			 struct smb_request *req,
 			 uint16 *setup, uint8_t *data, char *params,
 			 int suwcnt, int tdscnt, int tpscnt,
@@ -495,9 +465,8 @@
 	}
 
 	if (vuid != fsp->vuid) {
-		DEBUG(1, ("Got pipe request (pnum %x) using invalid VUID %llu, "
-			  "expected %llu\n", pnum, (unsigned long long)vuid,
-			  (unsigned long long)fsp->vuid));
+		DEBUG(1, ("Got pipe request (pnum %x) using invalid VUID %d, "
+			  "expected %d\n", pnum, vuid, fsp->vuid));
 		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
 		return;
 	}
@@ -532,7 +501,7 @@
  Handle named pipe commands.
 ****************************************************************************/
 
-static void named_pipe(connection_struct *conn, uint64_t vuid,
+static void named_pipe(connection_struct *conn, uint16 vuid,
 		       struct smb_request *req,
 		       const char *name, uint16 *setup,
 		       char *data, char *params,
@@ -633,30 +602,8 @@
 		   state->max_param_return);
 
 	if (state->close_on_completion) {
-		struct smbXsrv_tcon *tcon;
-		NTSTATUS status;
-
-		tcon = conn->tcon;
+		close_cnum(conn,state->vuid);
 		req->conn = NULL;
-		conn = NULL;
-
-		/*
-		 * TODO: cancel all outstanding requests on the tcon
-		 */
-		status = smbXsrv_tcon_disconnect(tcon, state->vuid);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0, ("handle_trans: "
-				  "smbXsrv_tcon_disconnect() failed: %s\n",
-				  nt_errstr(status)));
-			/*
-			 * If we hit this case, there is something completely
-			 * wrong, so we better disconnect the transport connection.
-			 */
-			exit_server(__location__ ": smbXsrv_tcon_disconnect failed");
-			return;
-		}
-
-		TALLOC_FREE(tcon);
 	}
 
 	return;
@@ -698,7 +645,7 @@
 		return;
 	}
 
-	if ((state = talloc(conn, struct trans_state)) == NULL) {
+	if ((state = TALLOC_P(conn, struct trans_state)) == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
 		END_PROFILE(SMBtrans);
@@ -795,7 +742,7 @@
 			goto bad_param;
 		}
 
-		if((state->setup = talloc_array(
+		if((state->setup = TALLOC_ARRAY(
 			    state, uint16, state->setup_count)) == NULL) {
 			DEBUG(0,("reply_trans: setup malloc fail for %u "
 				 "bytes !\n", (unsigned int)
@@ -861,7 +808,7 @@
 
 	START_PROFILE(SMBtranss);
 
-	show_msg((const char *)req->inbuf);
+	show_msg((char *)req->inbuf);
 
 	if (req->wct < 8) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
Only in ../../samba-3.6.24/source3/smbd: ipc.o
diff -ur smbd/lanman.c ../../samba-3.6.24/source3/smbd/lanman.c
--- smbd/lanman.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/lanman.c	2015-01-28 10:52:25.149068676 +0800
@@ -79,7 +79,7 @@
 }
 
 static bool api_Unsupported(struct smbd_server_connection *sconn,
-			    connection_struct *conn, uint64_t vuid,
+			    connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt, int mprcnt,
@@ -87,7 +87,7 @@
 				int *rdata_len, int *rparam_len);
 
 static bool api_TooSmall(struct smbd_server_connection *sconn,
-			 connection_struct *conn, uint64_t vuid, char *param, char *data,
+			 connection_struct *conn, uint16 vuid, char *param, char *data,
 			 int mdrcnt, int mprcnt,
 			 char **rdata, char **rparam,
 			 int *rdata_len, int *rparam_len);
@@ -110,18 +110,18 @@
 		*p_space_remaining = 0;
 		return 0;
 	}
-	buf = talloc_string_sub(ctx, buf,"%S", lp_servicename(ctx, snum));
+	buf = talloc_string_sub(ctx, buf,"%S",lp_servicename(snum));
 	if (!buf) {
 		*p_space_remaining = 0;
 		return 0;
 	}
 	buf = talloc_sub_advanced(ctx,
-				  lp_servicename(ctx, SNUM(conn)),
-				conn->session_info->unix_info->unix_name,
+				lp_servicename(SNUM(conn)),
+				conn->session_info->unix_name,
 				conn->connectpath,
-				conn->session_info->unix_token->gid,
-				conn->session_info->unix_info->sanitized_username,
-				conn->session_info->info->domain_name,
+				conn->session_info->utok.gid,
+				conn->session_info->sanitized_username,
+				conn->session_info->info3->base.domain.string,
 				buf);
 	if (!buf) {
 		*p_space_remaining = 0;
@@ -162,17 +162,17 @@
 	if (!buf) {
 		return 0;
 	}
-	buf = talloc_string_sub(ctx,buf,"%S",lp_servicename(ctx, snum));
+	buf = talloc_string_sub(ctx,buf,"%S",lp_servicename(snum));
 	if (!buf) {
 		return 0;
 	}
 	buf = talloc_sub_advanced(ctx,
-				  lp_servicename(ctx, SNUM(conn)),
-				conn->session_info->unix_info->unix_name,
+				lp_servicename(SNUM(conn)),
+				conn->session_info->unix_name,
 				conn->connectpath,
-				conn->session_info->unix_token->gid,
-				conn->session_info->unix_info->sanitized_username,
-				conn->session_info->info->domain_name,
+				conn->session_info->utok.gid,
+				conn->session_info->sanitized_username,
+				conn->session_info->info3->base.domain.string,
 				buf);
 	if (!buf) {
 		return 0;
@@ -612,9 +612,9 @@
 {
 	int 				i;
 	fstring 			location;
-	trim_string(discard_const_p(char, driver->driver_path), "\\print$\\WIN40\\0\\", 0);
-	trim_string(discard_const_p(char, driver->data_file), "\\print$\\WIN40\\0\\", 0);
-	trim_string(discard_const_p(char, driver->help_file), "\\print$\\WIN40\\0\\", 0);
+	trim_string((char *)driver->driver_path, "\\print$\\WIN40\\0\\", 0);
+	trim_string((char *)driver->data_file, "\\print$\\WIN40\\0\\", 0);
+	trim_string((char *)driver->help_file, "\\print$\\WIN40\\0\\", 0);
 
 	PACKI(desc, "W", 0x0400);                     /* don't know */
 	PACKS(desc, "z", driver->driver_name);        /* long printer name */
@@ -641,7 +641,7 @@
 
 	for ( i=0; i<count && driver->dependent_files && *driver->dependent_files[i]; i++)
 	{
-		trim_string(discard_const_p(char, driver->dependent_files[i]), "\\print$\\WIN40\\0\\", 0);
+		trim_string((char *)driver->dependent_files[i], "\\print$\\WIN40\\0\\", 0);
 		PACKS(desc,"z",driver->dependent_files[i]);         /* driver files to copy */
 		DEBUG(3,("Dependent File: %s:\n", driver->dependent_files[i]));
 	}
@@ -756,7 +756,7 @@
 }
 
 static bool api_DosPrintQGetInfo(struct smbd_server_connection *sconn,
-				 connection_struct *conn, uint64_t vuid,
+				 connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -834,7 +834,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -971,7 +971,7 @@
 ****************************************************************************/
 
 static bool api_DosPrintQEnum(struct smbd_server_connection *sconn,
-			      connection_struct *conn, uint64_t vuid,
+			      connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt, int mprcnt,
@@ -1031,7 +1031,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -1159,8 +1159,8 @@
 		}
 	}
 
- out:
 	SAFE_FREE(subcntarr);
+ out:
 	*rdata_len = desc.usedlen;
 	*rparam_len = 8;
 	*rparam = smb_realloc_limit(*rparam,*rparam_len);
@@ -1427,7 +1427,7 @@
 
 static int srv_comp(struct srv_info_struct *s1,struct srv_info_struct *s2)
 {
-	return strcasecmp_m(s1->name,s2->name);
+	return StrCaseCmp(s1->name,s2->name);
 }
 
 /****************************************************************************
@@ -1436,7 +1436,7 @@
 ****************************************************************************/
 
 static bool api_RNetServerEnum2(struct smbd_server_connection *sconn,
-				connection_struct *conn, uint64_t vuid,
+				connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt, int mprcnt, char **rdata,
@@ -1596,7 +1596,7 @@
 	 *  the server will return a list of servers that exist on
 	 *  the network greater than or equal to the FirstNameToReturn.
 	 */
-	int ret = strcasecmp_m(n1, n2);
+	int ret = StrCaseCmp(n1, n2);
 
 	if (ret <= 0) {
 		return 0;
@@ -1606,7 +1606,7 @@
 }
 
 static bool api_RNetServerEnum3(struct smbd_server_connection *sconn,
-				connection_struct *conn, uint64_t vuid,
+				connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt, int mprcnt, char **rdata,
@@ -1708,7 +1708,7 @@
 			 */
 			for (;first > 0;) {
 				int ret;
-				ret = strcasecmp_m(first_name,
+				ret = StrCaseCmp(first_name,
 						 servers[first-1].name);
 				if (ret > 0) {
 					break;
@@ -1799,7 +1799,7 @@
   ****************************************************************************/
 
 static bool api_RNetGroupGetUsers(struct smbd_server_connection *sconn,
-				  connection_struct *conn, uint64_t vuid,
+				  connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt, int mprcnt, char **rdata,
@@ -1906,10 +1906,10 @@
 		len = 0;
 
 		if (uLevel > 0) {
-			len += StrlenExpanded(conn,snum,lp_comment(talloc_tos(), snum));
+			len += StrlenExpanded(conn,snum,lp_comment(snum));
 		}
 		if (uLevel > 1) {
-			len += strlen(lp_pathname(talloc_tos(), snum)) + 1;
+			len += strlen(lp_pathname(snum)) + 1;
 		}
 		if (buflen) {
 			*buflen = struct_len;
@@ -1938,7 +1938,7 @@
 		baseaddr = p;
 	}
 
-	push_ascii(p,lp_servicename(talloc_tos(), snum),13, STR_TERMINATE);
+	push_ascii(p,lp_servicename(snum),13, STR_TERMINATE);
 
 	if (uLevel > 0) {
 		int type;
@@ -1948,12 +1948,12 @@
 		if (lp_print_ok(snum)) {
 			type = STYPE_PRINTQ;
 		}
-		if (strequal("IPC",lp_fstype(talloc_tos(),snum))) {
+		if (strequal("IPC",lp_fstype(snum))) {
 			type = STYPE_IPC;
 		}
 		SSVAL(p,14,type);		/* device type */
 		SIVAL(p,16,PTR_DIFF(p2,baseaddr));
-		len += CopyExpanded(conn,snum,&p2,lp_comment(talloc_tos(),snum),&l2);
+		len += CopyExpanded(conn,snum,&p2,lp_comment(snum),&l2);
 	}
 
 	if (uLevel > 1) {
@@ -1961,7 +1961,7 @@
 		SSVALS(p,22,-1);		/* max uses */
 		SSVAL(p,24,1); /* current uses */
 		SIVAL(p,26,PTR_DIFF(p2,baseaddr)); /* local pathname */
-		len += CopyAndAdvance(&p2,lp_pathname(talloc_tos(),snum),&l2);
+		len += CopyAndAdvance(&p2,lp_pathname(snum),&l2);
 		memset(p+30,0,SHPWLEN+2); /* passwd (reserved), pad field */
 	}
 
@@ -1990,7 +1990,7 @@
 }
 
 static bool api_RNetShareGetInfo(struct smbd_server_connection *sconn,
-				 connection_struct *conn,uint64_t vuid,
+				 connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -2005,7 +2005,7 @@
 	int uLevel = get_safe_SVAL(param,tpscnt,p,0,-1);
 	int snum;
 
-	if (!str1 || !str2 || !netname_in || !p) {
+	if (!str1 || !str2 || !netname || !p) {
 		return False;
 	}
 
@@ -2055,7 +2055,7 @@
  ****************************************************************************/
 
 static bool api_RNetShareEnum(struct smbd_server_connection *sconn,
-			      connection_struct *conn, uint64_t vuid,
+			      connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int                mdrcnt,
@@ -2091,9 +2091,8 @@
 
 	/* Ensure all the usershares are loaded. */
 	become_root();
-	delete_and_reload_printers(sconn->ev_ctx, sconn->msg_ctx);
 	load_registry_shares();
-	count = load_usershare_shares(NULL, connections_snum_used);
+	count = load_usershare_shares();
 	unbecome_root();
 
 	data_len = fixed_len = string_len = 0;
@@ -2102,7 +2101,7 @@
 		if (!(lp_browseable(i) && lp_snum_ok(i))) {
 			continue;
 		}
-		push_ascii_fstring(servicename_dos, lp_servicename(talloc_tos(), i));
+		push_ascii_fstring(servicename_dos, lp_servicename(i));
 		/* Maximum name length = 13. */
 		if( lp_browseable( i ) && lp_snum_ok( i ) && (strlen(servicename_dos) < 13)) {
 			total++;
@@ -2134,8 +2133,7 @@
 			continue;
 		}
 
-		push_ascii_fstring(servicename_dos,
-				   lp_servicename(talloc_tos(), i));
+		push_ascii_fstring(servicename_dos, lp_servicename(i));
 		if (lp_browseable(i) && lp_snum_ok(i) && (strlen(servicename_dos) < 13)) {
 			if (fill_share_info( conn,i,uLevel,&p,&f_len,&p2,&s_len,*rdata ) < 0) {
 				break;
@@ -2165,7 +2163,7 @@
   ****************************************************************************/
 
 static bool api_RNetShareAdd(struct smbd_server_connection *sconn,
-			     connection_struct *conn,uint64_t vuid,
+			     connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -2258,7 +2256,7 @@
 
 	status = rpc_pipe_open_interface(mem_ctx, &ndr_table_srvsvc.syntax_id,
 					conn->session_info,
-					conn->sconn->remote_address,
+					&conn->sconn->client_id,
 					conn->sconn->msg_ctx,
 					&cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2326,7 +2324,7 @@
   ****************************************************************************/
 
 static bool api_RNetGroupEnum(struct smbd_server_connection *sconn,
-			      connection_struct *conn,uint64_t vuid,
+			      connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -2369,7 +2367,7 @@
 
 	status = rpc_pipe_open_interface(
 		talloc_tos(), &ndr_table_samr.syntax_id,
-		conn->session_info, conn->sconn->remote_address,
+		conn->session_info, &conn->sconn->client_id,
 		conn->sconn->msg_ctx, &samr_pipe);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("api_RNetUserEnum: Could not connect to samr: %s\n",
@@ -2379,7 +2377,7 @@
 
 	b = samr_pipe->binding_handle;
 
-	status = dcerpc_samr_Connect2(b, talloc_tos(), lp_netbios_name(),
+	status = dcerpc_samr_Connect2(b, talloc_tos(), global_myname(),
 				      SAMR_ACCESS_LOOKUP_DOMAIN, &samr_handle,
 				      &result);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2508,7 +2506,7 @@
 ******************************************************************/
 
 static bool api_NetUserGetGroups(struct smbd_server_connection *sconn,
-				 connection_struct *conn,uint64_t vuid,
+				 connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -2575,7 +2573,7 @@
 
 	status = rpc_pipe_open_interface(
 		talloc_tos(), &ndr_table_samr.syntax_id,
-		conn->session_info, conn->sconn->remote_address,
+		conn->session_info, &conn->sconn->client_id,
 		conn->sconn->msg_ctx, &samr_pipe);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("api_RNetUserEnum: Could not connect to samr: %s\n",
@@ -2585,7 +2583,7 @@
 
 	b = samr_pipe->binding_handle;
 
-	status = dcerpc_samr_Connect2(b, talloc_tos(), lp_netbios_name(),
+	status = dcerpc_samr_Connect2(b, talloc_tos(), global_myname(),
 				      SAMR_ACCESS_LOOKUP_DOMAIN, &samr_handle,
 				      &result);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2711,7 +2709,7 @@
 ******************************************************************/
 
 static bool api_RNetUserEnum(struct smbd_server_connection *sconn,
-			     connection_struct *conn, uint64_t vuid,
+			     connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -2775,7 +2773,7 @@
 
 	status = rpc_pipe_open_interface(
 		talloc_tos(), &ndr_table_samr.syntax_id,
-		conn->session_info, conn->sconn->remote_address,
+		conn->session_info, &conn->sconn->client_id,
 		conn->sconn->msg_ctx, &samr_pipe);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("api_RNetUserEnum: Could not connect to samr: %s\n",
@@ -2785,7 +2783,7 @@
 
 	b = samr_pipe->binding_handle;
 
-	status = dcerpc_samr_Connect2(b, talloc_tos(), lp_netbios_name(),
+	status = dcerpc_samr_Connect2(b, talloc_tos(), global_myname(),
 				      SAMR_ACCESS_LOOKUP_DOMAIN, &samr_handle,
 				      &result);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2894,7 +2892,7 @@
 ****************************************************************************/
 
 static bool api_NetRemoteTOD(struct smbd_server_connection *sconn,
-			     connection_struct *conn,uint64_t vuid,
+			     connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -2953,7 +2951,7 @@
 ****************************************************************************/
 
 static bool api_SamOEMChangePassword(struct smbd_server_connection *sconn,
-				     connection_struct *conn,uint64_t vuid,
+				     connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -3039,7 +3037,7 @@
 
 	status = rpc_pipe_open_interface(mem_ctx, &ndr_table_samr.syntax_id,
 					conn->session_info,
-					conn->sconn->remote_address,
+					&conn->sconn->client_id,
 					conn->sconn->msg_ctx,
 					&cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -3051,7 +3049,7 @@
 
 	b = cli->binding_handle;
 
-	init_lsa_AsciiString(&server, lp_netbios_name());
+	init_lsa_AsciiString(&server, global_myname());
 	init_lsa_AsciiString(&account, user);
 
 	status = dcerpc_samr_OemChangePasswordUser2(b, mem_ctx,
@@ -3083,7 +3081,7 @@
   ****************************************************************************/
 
 static bool api_RDosPrintJobDel(struct smbd_server_connection *sconn,
-				connection_struct *conn,uint64_t vuid,
+				connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -3136,7 +3134,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -3216,7 +3214,7 @@
   ****************************************************************************/
 
 static bool api_WPrintQueueCtrl(struct smbd_server_connection *sconn,
-				connection_struct *conn,uint64_t vuid,
+				connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -3264,7 +3262,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -3378,7 +3376,7 @@
 }
 
 static bool api_PrintJobInfo(struct smbd_server_connection *sconn,
-			     connection_struct *conn, uint64_t vuid,
+			     connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -3446,7 +3444,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -3538,7 +3536,7 @@
 ****************************************************************************/
 
 static bool api_RNetServerGetInfo(struct smbd_server_connection *sconn,
-				  connection_struct *conn,uint64_t vuid,
+				  connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -3623,7 +3621,7 @@
 
 	status = rpc_pipe_open_interface(mem_ctx, &ndr_table_srvsvc.syntax_id,
 					conn->session_info,
-					conn->sconn->remote_address,
+					&conn->sconn->client_id,
 					conn->sconn->msg_ctx,
 					&cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -3710,7 +3708,7 @@
 ****************************************************************************/
 
 static bool api_NetWkstaGetInfo(struct smbd_server_connection *sconn,
-				connection_struct *conn,uint64_t vuid,
+				connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -3760,9 +3758,7 @@
 
 	SIVAL(p,0,PTR_DIFF(p2,*rdata)); /* host name */
 	strlcpy(p2,get_local_machine_name(),PTR_DIFF(endp,p2));
-	if (!strupper_m(p2)) {
-		return false;
-	}
+	strupper_m(p2);
 	p2 = skip_string(*rdata,*rdata_len,p2);
 	if (!p2) {
 		return False;
@@ -3770,7 +3766,7 @@
 	p += 4;
 
 	SIVAL(p,0,PTR_DIFF(p2,*rdata));
-	strlcpy(p2,conn->session_info->unix_info->sanitized_username,PTR_DIFF(endp,p2));
+	strlcpy(p2,conn->session_info->sanitized_username,PTR_DIFF(endp,p2));
 	p2 = skip_string(*rdata,*rdata_len,p2);
 	if (!p2) {
 		return False;
@@ -3779,17 +3775,15 @@
 
 	SIVAL(p,0,PTR_DIFF(p2,*rdata)); /* login domain */
 	strlcpy(p2,lp_workgroup(),PTR_DIFF(endp,p2));
-	if (!strupper_m(p2)) {
-		return false;
-	}
+	strupper_m(p2);
 	p2 = skip_string(*rdata,*rdata_len,p2);
 	if (!p2) {
 		return False;
 	}
 	p += 4;
 
-	SCVAL(p,0,SAMBA_MAJOR_NBT_ANNOUNCE_VERSION); /* system version - e.g 4 in 4.1 */
-	SCVAL(p,1,SAMBA_MINOR_NBT_ANNOUNCE_VERSION); /* system version - e.g .1 in 4.1 */
+	SCVAL(p,0,lp_major_announce_version()); /* system version - e.g 4 in 4.1 */
+	SCVAL(p,1,lp_minor_announce_version()); /* system version - e.g .1 in 4.1 */
 	p += 2;
 
 	SIVAL(p,0,PTR_DIFF(p2,*rdata));
@@ -3976,7 +3970,7 @@
 #define usri11_end            86
 
 static bool api_RNetUserGetInfo(struct smbd_server_connection *sconn,
-				connection_struct *conn, uint64_t vuid,
+				connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -4054,7 +4048,7 @@
 
 	status = rpc_pipe_open_interface(mem_ctx, &ndr_table_samr.syntax_id,
 					conn->session_info,
-					conn->sconn->remote_address,
+					&conn->sconn->client_id,
 					conn->sconn->msg_ctx,
 					&cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -4067,7 +4061,7 @@
 	b = cli->binding_handle;
 
 	status = dcerpc_samr_Connect2(b, mem_ctx,
-				      lp_netbios_name(),
+				      global_myname(),
 				      SAMR_ACCESS_CONNECT_TO_SERVER |
 				      SAMR_ACCESS_ENUM_DOMAINS |
 				      SAMR_ACCESS_LOOKUP_DOMAIN,
@@ -4373,7 +4367,7 @@
 }
 
 static bool api_WWkstaUserLogon(struct smbd_server_connection *sconn,
-				connection_struct *conn,uint64_t vuid,
+				connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -4388,7 +4382,7 @@
 	char* name;
 		/* With share level security vuid will always be zero.
 		   Don't depend on vuser being non-null !!. JRA */
-	struct user_struct *vuser = get_valid_user_struct(sconn, vuid);
+	user_struct *vuser = get_valid_user_struct(sconn, vuid);
 
 	if (!str1 || !str2 || !p) {
 		return False;
@@ -4396,8 +4390,8 @@
 
 	if(vuser != NULL) {
 		DEBUG(3,("  Username of UID %d is %s\n",
-			 (int)vuser->session_info->unix_token->uid,
-			 vuser->session_info->unix_info->unix_name));
+			 (int)vuser->session_info->utok.uid,
+			 vuser->session_info->unix_name));
 	}
 
 	uLevel = get_safe_SVAL(param,tpscnt,p,0,-1);
@@ -4451,15 +4445,13 @@
 			fstring mypath;
 			fstrcpy(mypath,"\\\\");
 			fstrcat(mypath,get_local_machine_name());
-			if (!strupper_m(mypath)) {
-				return false;
-			}
+			strupper_m(mypath);
 			PACKS(&desc,"z",mypath); /* computer */
 		}
 
 		PACKS(&desc,"z",lp_workgroup());/* domain */
 		PACKS(&desc,"z", vuser ?
-		      vuser->session_info->info->logon_script
+			vuser->session_info->info3->base.logon_script.string
 			: ""); /* script path */
 		PACKI(&desc,"D",0x00000000);		/* reserved */
 	}
@@ -4484,7 +4476,7 @@
 ****************************************************************************/
 
 static bool api_WAccessGetUserPerms(struct smbd_server_connection *sconn,
-				    connection_struct *conn,uint64_t vuid,
+				    connection_struct *conn,uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -4530,7 +4522,7 @@
   ****************************************************************************/
 
 static bool api_WPrintJobGetInfo(struct smbd_server_connection *sconn,
-				 connection_struct *conn, uint64_t vuid,
+				 connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -4583,7 +4575,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -4668,7 +4660,7 @@
 }
 
 static bool api_WPrintJobEnumerate(struct smbd_server_connection *sconn,
-				   connection_struct *conn, uint64_t vuid,
+				   connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -4725,7 +4717,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -4844,7 +4836,7 @@
 
 	strncpy(buf, info2->printername, sizeof(buf)-1);
 	buf[sizeof(buf)-1] = 0;
-	(void)strupper_m(buf);
+	strupper_m(buf);
 
 	if (uLevel <= 1) {
 		PACKS(desc,"B9",buf);	/* szName */
@@ -4874,7 +4866,7 @@
 }
 
 static bool api_WPrintDestGetInfo(struct smbd_server_connection *sconn,
-				  connection_struct *conn, uint64_t vuid,
+				  connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -4925,7 +4917,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -5012,7 +5004,7 @@
 }
 
 static bool api_WPrintDestEnum(struct smbd_server_connection *sconn,
-			       connection_struct *conn, uint64_t vuid,
+			       connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -5057,7 +5049,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_spoolss.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -5123,7 +5115,7 @@
 }
 
 static bool api_WPrintDriverEnum(struct smbd_server_connection *sconn,
-				 connection_struct *conn, uint64_t vuid,
+				 connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -5187,7 +5179,7 @@
 }
 
 static bool api_WPrintQProcEnum(struct smbd_server_connection *sconn,
-				connection_struct *conn, uint64_t vuid,
+				connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -5251,7 +5243,7 @@
 }
 
 static bool api_WPrintPortEnum(struct smbd_server_connection *sconn,
-			       connection_struct *conn, uint64_t vuid,
+			       connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -5321,7 +5313,7 @@
  ****************************************************************************/
 
 static bool api_RNetSessionEnum(struct smbd_server_connection *sconn,
-				connection_struct *conn, uint64_t vuid,
+				connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt,int mprcnt,
@@ -5368,7 +5360,7 @@
 	status = rpc_pipe_open_interface(conn,
 					 &ndr_table_srvsvc.syntax_id,
 					 conn->session_info,
-					 conn->sconn->remote_address,
+					 &conn->sconn->client_id,
 					 conn->sconn->msg_ctx,
 					 &cli);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -5460,7 +5452,7 @@
  ****************************************************************************/
 
 static bool api_TooSmall(struct smbd_server_connection *sconn,
-			 connection_struct *conn,uint64_t vuid, char *param, char *data,
+			 connection_struct *conn,uint16 vuid, char *param, char *data,
 			 int mdrcnt, int mprcnt,
 			 char **rdata, char **rparam,
 			 int *rdata_len, int *rparam_len)
@@ -5485,7 +5477,7 @@
  ****************************************************************************/
 
 static bool api_Unsupported(struct smbd_server_connection *sconn,
-			    connection_struct *conn, uint64_t vuid,
+			    connection_struct *conn, uint16 vuid,
 				char *param, int tpscnt,
 				char *data, int tdscnt,
 				int mdrcnt, int mprcnt,
@@ -5512,7 +5504,7 @@
 	const char *name;
 	int id;
 	bool (*fn)(struct smbd_server_connection *sconn,
-		   connection_struct *, uint64_t,
+		   connection_struct *, uint16,
 			char *, int,
 			char *, int,
 			int,int,char **,char **,int *,int *);
@@ -5563,7 +5555,7 @@
  Handle remote api calls.
 ****************************************************************************/
 
-void api_reply(connection_struct *conn, uint64_t vuid,
+void api_reply(connection_struct *conn, uint16 vuid,
 	       struct smb_request *req,
 	       char *data, char *params,
 	       int tdscnt, int tpscnt,
@@ -5617,9 +5609,9 @@
 	/* Check whether this api call can be done anonymously */
 
 	if (api_commands[i].auth_user && lp_restrict_anonymous()) {
-		struct user_struct *user = get_valid_user_struct(req->sconn, vuid);
+		user_struct *user = get_valid_user_struct(req->sconn, vuid);
 
-		if (!user || security_session_user_level(user->session_info, NULL) < SECURITY_USER) {
+		if (!user || user->session_info->guest) {
 			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 			return;
 		}
Only in ../../samba-3.6.24/source3/smbd: lanman.o
diff -ur smbd/mangle.c ../../samba-3.6.24/source3/smbd/mangle.c
--- smbd/mangle.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/mangle.c	2015-01-28 10:52:25.149068676 +0800
@@ -45,7 +45,7 @@
 	if (mangle_fns)
 		return;
 
-	method = lp_mangling_method(talloc_tos());
+	method = lp_mangling_method();
 
 	/* find the first mangling method that manages to initialise and
 	   matches the "mangling method" parameter */
diff -ur smbd/mangle_hash2.c ../../samba-3.6.24/source3/smbd/mangle_hash2.c
--- smbd/mangle_hash2.c	2013-10-07 16:49:10.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/mangle_hash2.c	2015-01-28 10:52:25.149068676 +0800
@@ -291,7 +291,7 @@
 	length = MIN(length,sizeof(fstring)-1);
 	strncpy(str, key, length);
 	str[length] = 0;
-	(void)strupper_m(str);
+	strupper_m(str);
 
 	/* the length of a multi-byte string can change after a strupper_m */
 	length = strlen(str);
@@ -629,9 +629,11 @@
 			size_t size = 0;
 			(void)next_codepoint(name, &size);
 			/*
-			 * Note that we're only looking for multibyte
-			 * encoding here. No encoding with a length > 1
-			 * contains invalid characters.
+			 * Note that if CH_UNIX is utf8 a string may be 3
+			 * bytes, but this is ok as mb utf8 characters don't
+			 * contain embedded ascii bytes. We are really checking
+			 * for mb UNIX asian characters like Japanese (SJIS) here.
+			 * JRA.
 			 */
 			if (size > 1) {
 				/* Was a mb string. */
@@ -701,7 +703,7 @@
 		/* if the name is already a valid 8.3 name then we don't need to
 		 * change anything */
 		if (is_legal_name(name) && is_8_3(name, False, False, p)) {
-			strlcpy(new_name, name, 13);
+			safe_strcpy(new_name, name, 12);
 			return True;
 		}
 	}
Only in ../../samba-3.6.24/source3/smbd: mangle_hash2.o
diff -ur smbd/mangle_hash.c ../../samba-3.6.24/source3/smbd/mangle_hash.c
--- smbd/mangle_hash.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/mangle_hash.c	2015-01-28 10:52:25.149068676 +0800
@@ -26,7 +26,6 @@
 #include "smbd/globals.h"
 #include "mangle.h"
 #include "util_tdb.h"
-#include "lib/param/loadparm.h"
 
 /* -------------------------------------------------------------------------- **
  * Other stuff...
@@ -67,40 +66,6 @@
 
 /* -------------------------------------------------------------------- */
 
-
-/*******************************************************************
- Determine if a character is valid in a 8.3 name.
-********************************************************************/
-
-/**
- * Load the valid character map table from <tt>valid.dat</tt> or
- * create from the configured codepage.
- *
- * This function is called whenever the configuration is reloaded.
- * However, the valid character table is not changed if it's loaded
- * from a file, because we can't unmap files.
- **/
-
-static uint8 *valid_table;
-static void init_valid_table(void)
-{
-	if (valid_table) {
-		return;
-	}
-
-	valid_table = (uint8 *)map_file(data_path(talloc_tos(), "valid.dat"), 0x10000);
-	if (!valid_table) {
-		smb_panic("Could not load valid.dat file required for mangle method=hash");
-		return;
-	}
-}
-
-static bool isvalid83_w(smb_ucs2_t c)
-{
-	init_valid_table();
-	return valid_table[SVAL(&c,0)] != 0;
-}
-
 static NTSTATUS has_valid_83_chars(const smb_ucs2_t *s, bool allow_wildcards)
 {
 	if (!*s) {
@@ -145,25 +110,6 @@
 	return NT_STATUS_OK;
 }
 
-/*******************************************************************
- Duplicate string.
-********************************************************************/
-
-static smb_ucs2_t *strdup_w(const smb_ucs2_t *src)
-{
-	smb_ucs2_t *dest;
-	size_t len = strlen_w(src);
-	dest = SMB_MALLOC_ARRAY(smb_ucs2_t, len + 1);
-	if (!dest) {
-		DEBUG(0,("strdup_w: out of memory!\n"));
-		return NULL;
-	}
-
-	memcpy(dest, src, len * sizeof(smb_ucs2_t));
-	dest[len] = 0;
-	return dest;
-}
-
 /* return False if something fail and
  * return 2 alloced unicode strings that contain prefix and extension
  */
@@ -334,6 +280,9 @@
 	smb_ucs2_t *ucs2name;
 	NTSTATUS ret = NT_STATUS_UNSUCCESSFUL;
 	size_t size;
+	char magic_char;
+
+	magic_char = lp_magicchar(p);
 
 	if (!fname || !*fname)
 		return False;
@@ -472,7 +421,7 @@
 		return;
 
 	/* Init the string lengths. */
-	strlcpy(mangled_name_key, mangled_name, sizeof(mangled_name_key));
+	safe_strcpy(mangled_name_key, mangled_name, sizeof(mangled_name_key)-1);
 
 	/* See if the extensions are unmangled.  If so, store the entry
 	 * without the extension, thus creating a "group" reverse map.
@@ -532,6 +481,9 @@
 	TDB_DATA data_val;
 	char *saved_ext = NULL;
 	char *s = talloc_strdup(ctx, in);
+	char magic_char;
+
+	magic_char = lp_magicchar(p);
 
 	/* If the cache isn't initialized, give up. */
 	if(!s || !tdb_mangled_cache ) {
@@ -583,19 +535,6 @@
 	return *out ? True : False;
 }
 
-/**
- Check if a string is in "normal" case.
-**/
-
-static bool strisnormal(const char *s, int case_default)
-{
-	if (case_default == CASE_UPPER)
-		return(!strhaslower(s));
-
-	return(!strhasupper(s));
-}
-
-
 /*****************************************************************************
  Do the actual mangling to 8.3 format.
 *****************************************************************************/
@@ -630,14 +569,11 @@
 	} else
 		csum = str_checksum(s);
 
-	if (!strupper_m( s )) {
-		SAFE_FREE(s);
-		return false;
-	}
+	strupper_m( s );
 
 	if( p ) {
 		if( p == s )
-			strlcpy( extension, "___", 4);
+			safe_strcpy( extension, "___", 3 );
 		else {
 			*p++ = 0;
 			while( *p && extlen < 3 ) {
@@ -669,7 +605,7 @@
 
 	if( *extension ) {
 		out[baselen+3] = '.';
-		strlcpy(&out[baselen+4], extension, 4);
+		safe_strcpy(&out[baselen+4], extension, 3);
 	}
 
 	SAFE_FREE(s);
@@ -682,6 +618,9 @@
 	smb_ucs2_t *name_ucs2 = NULL;
 	NTSTATUS status;
 	size_t converted_size;
+	char magic_char;
+
+	magic_char = lp_magicchar(p);
 
 	if (!push_ucs2_talloc(NULL, &name_ucs2, name, &converted_size)) {
 		DEBUG(0, ("push_ucs2_talloc failed!\n"));
@@ -734,7 +673,7 @@
 	if (NT_STATUS_IS_OK(is_valid_name(in_ucs2, False, False)) &&
 				NT_STATUS_IS_OK(is_8_3_w(in_ucs2, False))) {
 		TALLOC_FREE(in_ucs2);
-		strlcpy(out, in, 13);
+		safe_strcpy(out, in, 12);
 		return True;
 	}
 
@@ -767,10 +706,6 @@
 {
 	mangle_reset();
 
-	if (chartest == NULL) {
-		init_chartest();
-	}
-
 	/* Create the in-memory tdb using our custom hash function. */
 	tdb_mangled_cache = tdb_open_ex("mangled_cache", 1031, TDB_INTERNAL,
 				(O_RDWR|O_CREAT), 0644, NULL, fast_string_hash);
Only in ../../samba-3.6.24/source3/smbd: mangle_hash.o
Only in ../../samba-3.6.24/source3/smbd: mangle.o
diff -ur smbd/message.c ../../samba-3.6.24/source3/smbd/message.c
--- smbd/message.c	2012-10-02 16:24:43.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/message.c	2015-01-28 10:52:25.149068676 +0800
@@ -51,7 +51,7 @@
 	fstring alpha_buf;
 	char *s;
 
-	if (! (*lp_msg_command(frame))) {
+	if (! (*lp_msg_command())) {
 		DEBUG(1,("no messaging command specified\n"));
 		goto done;
 	}
@@ -75,7 +75,7 @@
 
 	if (!convert_string_talloc(talloc_tos(), CH_DOS, CH_UNIX, state->msg,
 				   talloc_get_size(state->msg), (void *)&msg,
-				   &len)) {
+				   &len, true)) {
 		DEBUG(3, ("Conversion failed, delivering message in DOS "
 			  "codepage format\n"));
 		msg = state->msg;
@@ -96,7 +96,7 @@
 	close(fd);
 
 	/* run the command */
-	s = lp_msg_command(frame);
+	s = talloc_strdup(talloc_tos(), lp_msg_command());
 	if (s == NULL) {
 		goto done;
 	}
@@ -146,7 +146,7 @@
 
 	START_PROFILE(SMBsends);
 
-	if (!(*lp_msg_command(talloc_tos()))) {
+	if (!(*lp_msg_command())) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsends);
 		return;
@@ -194,17 +194,17 @@
 
 	START_PROFILE(SMBsendstrt);
 
-	if (!(*lp_msg_command(talloc_tos()))) {
+	if (!(*lp_msg_command())) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsendstrt);
 		return;
 	}
 
-	TALLOC_FREE(req->sconn->conn->msg_state);
+	TALLOC_FREE(smbd_msg_state);
 
-	req->sconn->conn->msg_state = talloc_zero(NULL, struct msg_state);
+	smbd_msg_state = TALLOC_ZERO_P(NULL, struct msg_state);
 
-	if (req->sconn->conn->msg_state == NULL) {
+	if (smbd_msg_state == NULL) {
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
 		END_PROFILE(SMBsendstrt);
 		return;
@@ -212,17 +212,14 @@
 
 	p = (const char *)req->buf+1;
 	p += srvstr_pull_req_talloc(
-		req->sconn->conn->msg_state, req,
-		&req->sconn->conn->msg_state->from, p,
+		smbd_msg_state, req, &smbd_msg_state->from, p,
 		STR_ASCII|STR_TERMINATE) + 1;
 	p += srvstr_pull_req_talloc(
-		req->sconn->conn->msg_state, req,
-		&req->sconn->conn->msg_state->to, p,
+		smbd_msg_state, req, &smbd_msg_state->to, p,
 		STR_ASCII|STR_TERMINATE) + 1;
 
-	DEBUG(3, ("SMBsendstrt (from %s to %s)\n",
-		  req->sconn->conn->msg_state->from,
-		  req->sconn->conn->msg_state->to));
+	DEBUG( 3, ( "SMBsendstrt (from %s to %s)\n", smbd_msg_state->from,
+		    smbd_msg_state->to ) );
 
 	reply_outbuf(req, 0, 0);
 
@@ -244,13 +241,13 @@
 
 	START_PROFILE(SMBsendtxt);
 
-	if (! (*lp_msg_command(talloc_tos()))) {
+	if (! (*lp_msg_command())) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsendtxt);
 		return;
 	}
 
-	if ((req->sconn->conn->msg_state == NULL) || (req->buflen < 3)) {
+	if ((smbd_msg_state == NULL) || (req->buflen < 3)) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
 		END_PROFILE(SMBsendtxt);
 		return;
@@ -258,13 +255,12 @@
 
 	msg = (const char *)req->buf + 1;
 
-	old_len = talloc_get_size(req->sconn->conn->msg_state->msg);
+	old_len = talloc_get_size(smbd_msg_state->msg);
 
 	len = MIN(SVAL(msg, 0), smbreq_bufrem(req, msg+2));
 
-	tmp = talloc_realloc(req->sconn->conn->msg_state,
-			     req->sconn->conn->msg_state->msg,
-			     char, old_len + len);
+	tmp = TALLOC_REALLOC_ARRAY(smbd_msg_state, smbd_msg_state->msg,
+				   char, old_len + len);
 
 	if (tmp == NULL) {
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
@@ -272,9 +268,9 @@
 		return;
 	}
 
-	req->sconn->conn->msg_state->msg = tmp;
+	smbd_msg_state->msg = tmp;
 
-	memcpy(&req->sconn->conn->msg_state->msg[old_len], msg+2, len);
+	memcpy(&smbd_msg_state->msg[old_len], msg+2, len);
 
 	DEBUG( 3, ( "SMBsendtxt\n" ) );
 
@@ -293,7 +289,7 @@
 {
 	START_PROFILE(SMBsendend);
 
-	if (! (*lp_msg_command(talloc_tos()))) {
+	if (! (*lp_msg_command())) {
 		reply_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
 		END_PROFILE(SMBsendend);
 		return;
@@ -301,9 +297,9 @@
 
 	DEBUG(3,("SMBsendend\n"));
 
-	msg_deliver(req->sconn->conn->msg_state);
+	msg_deliver(smbd_msg_state);
 
-	TALLOC_FREE(req->sconn->conn->msg_state);
+	TALLOC_FREE(smbd_msg_state);
 
 	reply_outbuf(req, 0, 0);
 
Only in ../../samba-3.6.24/source3/smbd: message.o
diff -ur smbd/msdfs.c ../../samba-3.6.24/source3/smbd/msdfs.c
--- smbd/msdfs.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/msdfs.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,9 +27,7 @@
 #include "smbd/globals.h"
 #include "msdfs.h"
 #include "auth.h"
-#include "lib/param/loadparm.h"
 #include "libcli/security/security.h"
-#include "librpc/gen_ndr/ndr_dfsblobs.h"
 
 /**********************************************************************
  Parse a DFS pathname of the form \hostname\service\reqpath
@@ -54,10 +52,10 @@
 static NTSTATUS parse_dfs_path(connection_struct *conn,
 				const char *pathname,
 				bool allow_wcards,
-				bool allow_broken_path,
 				struct dfs_path *pdp, /* MUST BE TALLOCED */
 				bool *ppath_contains_wcard)
 {
+	struct smbd_server_connection *sconn = smbd_server_conn;
 	char *pathname_local;
 	char *p,*temp;
 	char *servicename;
@@ -85,7 +83,7 @@
 
 	sepchar = pdp->posix_path ? '/' : '\\';
 
-	if (allow_broken_path && (*pathname != sepchar)) {
+	if (!sconn->using_smb2 && (*pathname != sepchar)) {
 		DEBUG(10,("parse_dfs_path: path %s doesn't start with %c\n",
 			pathname, sepchar ));
 		/*
@@ -147,9 +145,9 @@
 	}
 
 	/* Is this really our servicename ? */
-	if (conn && !( strequal(servicename, lp_servicename(talloc_tos(), SNUM(conn)))
+	if (conn && !( strequal(servicename, lp_servicename(SNUM(conn)))
 			|| (strequal(servicename, HOMES_NAME)
-			&& strequal(lp_servicename(talloc_tos(), SNUM(conn)),
+			&& strequal(lp_servicename(SNUM(conn)),
 				get_current_username()) )) ) {
 		DEBUG(10,("parse_dfs_path: %s is not our servicename\n",
 			servicename));
@@ -218,26 +216,23 @@
 }
 
 /********************************************************
- Fake up a connection struct for the VFS layer, for use in
- applications (such as the python bindings), that do not want the
- global working directory changed under them.
-
- SMB_VFS_CONNECT requires root privileges.
+ Fake up a connection struct for the VFS layer.
+ Note: this performs a vfs connect and CHANGES CWD !!!! JRA.
 *********************************************************/
 
-static NTSTATUS create_conn_struct_as_root(TALLOC_CTX *ctx,
-			    struct tevent_context *ev,
-			    struct messaging_context *msg,
-			    connection_struct **pconn,
-			    int snum,
-			    const char *path,
-			    const struct auth_session_info *session_info)
+NTSTATUS create_conn_struct(TALLOC_CTX *ctx,
+				connection_struct **pconn,
+				int snum,
+				const char *path,
+				const struct auth_serversupplied_info *session_info,
+				char **poldcwd)
 {
 	connection_struct *conn;
 	char *connpath;
+	char *oldcwd;
 	const char *vfs_user;
 
-	conn = talloc_zero(ctx, connection_struct);
+	conn = TALLOC_ZERO_P(ctx, connection_struct);
 	if (conn == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -248,48 +243,35 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 	connpath = talloc_string_sub(conn,
-				     connpath,
-				     "%S",
-				     lp_servicename(talloc_tos(), snum));
+				connpath,
+				"%S",
+				lp_servicename(snum));
 	if (!connpath) {
 		TALLOC_FREE(conn);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	conn->sconn = talloc_zero(conn, struct smbd_server_connection);
-	if (conn->sconn == NULL) {
-		TALLOC_FREE(conn);
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	conn->sconn->ev_ctx = ev;
-	conn->sconn->msg_ctx = msg;
-	conn->sconn->sock = -1;
-	conn->sconn->smb1.echo_handler.trusted_fd = -1;
-	conn->sconn->smb1.echo_handler.socket_lock_fd = -1;
-
 	/* needed for smbd_vfs_init() */
 
-	if (!(conn->params = talloc_zero(conn, struct share_params))) {
+	if (!(conn->params = TALLOC_ZERO_P(conn, struct share_params))) {
 		DEBUG(0, ("TALLOC failed\n"));
 		TALLOC_FREE(conn);
 		return NT_STATUS_NO_MEMORY;
 	}
 
 	conn->params->service = snum;
-	conn->cnum = TID_FIELD_INVALID;
 
-	DLIST_ADD(conn->sconn->connections, conn);
-	conn->sconn->num_connections++;
+	conn->sconn = smbd_server_conn;
+	conn->sconn->num_tcons_open++;
 
 	if (session_info != NULL) {
-		conn->session_info = copy_session_info(conn, session_info);
+		conn->session_info = copy_serverinfo(conn, session_info);
 		if (conn->session_info == NULL) {
 			DEBUG(0, ("copy_serverinfo failed\n"));
 			TALLOC_FREE(conn);
 			return NT_STATUS_NO_MEMORY;
 		}
-		vfs_user = conn->session_info->unix_info->unix_name;
+		vfs_user = conn->session_info->unix_name;
 	} else {
 		/* use current authenticated user in absence of session_info */
 		vfs_user = get_current_username();
@@ -305,8 +287,7 @@
 	 */
 	if (conn->session_info) {
 		share_access_check(conn->session_info->security_token,
-				   lp_servicename(talloc_tos(), snum),
-				   MAXIMUM_ALLOWED_ACCESS,
+				   lp_servicename(snum), MAXIMUM_ALLOWED_ACCESS,
 				   &conn->share_access);
 
 		if ((conn->share_access & FILE_WRITE_DATA) == 0) {
@@ -315,7 +296,7 @@
 				DEBUG(0,("create_conn_struct: connection to %s "
 					 "denied due to security "
 					 "descriptor.\n",
-					 lp_servicename(talloc_tos(), snum)));
+					 lp_servicename(snum)));
 				conn_free(conn);
 				return NT_STATUS_ACCESS_DENIED;
 			} else {
@@ -335,71 +316,13 @@
 	}
 
 	/* this must be the first filesystem operation that we do */
-	if (SMB_VFS_CONNECT(conn, lp_servicename(talloc_tos(), snum), vfs_user) < 0) {
+	if (SMB_VFS_CONNECT(conn, lp_servicename(snum), vfs_user) < 0) {
 		DEBUG(0,("VFS connect failed!\n"));
 		conn_free(conn);
 		return NT_STATUS_UNSUCCESSFUL;
 	}
 
 	conn->fs_capabilities = SMB_VFS_FS_CAPABILITIES(conn, &conn->ts_res);
-	*pconn = conn;
-
-	return NT_STATUS_OK;
-}
-
-/********************************************************
- Fake up a connection struct for the VFS layer, for use in
- applications (such as the python bindings), that do not want the
- global working directory changed under them.
-
- SMB_VFS_CONNECT requires root privileges.
-*********************************************************/
-
-NTSTATUS create_conn_struct(TALLOC_CTX *ctx,
-			    struct tevent_context *ev,
-			    struct messaging_context *msg,
-			    connection_struct **pconn,
-			    int snum,
-			    const char *path,
-			    const struct auth_session_info *session_info)
-{
-	NTSTATUS status;
-	become_root();
-	status = create_conn_struct_as_root(ctx, ev,
-					    msg, pconn,
-					    snum, path,
-					    session_info);
-	unbecome_root();
-
-	return status;
-}
-
-/********************************************************
- Fake up a connection struct for the VFS layer.
- Note: this performs a vfs connect and CHANGES CWD !!!! JRA.
-
- The old working directory is returned on *poldcwd, allocated on ctx.
-*********************************************************/
-
-NTSTATUS create_conn_struct_cwd(TALLOC_CTX *ctx,
-				struct tevent_context *ev,
-				struct messaging_context *msg,
-				connection_struct **pconn,
-				int snum,
-				const char *path,
-				const struct auth_session_info *session_info,
-				char **poldcwd)
-{
-	connection_struct *conn;
-	char *oldcwd;
-
-	NTSTATUS status = create_conn_struct(ctx, ev,
-					     msg, &conn,
-					     snum, path,
-					     session_info);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
 
 	/*
 	 * Windows seems to insist on doing trans2getdfsreferral() calls on
@@ -409,14 +332,14 @@
 
 	oldcwd = vfs_GetWd(ctx, conn);
 	if (oldcwd == NULL) {
-		status = map_nt_error_from_unix(errno);
+		NTSTATUS status = map_nt_error_from_unix(errno);
 		DEBUG(3, ("vfs_GetWd failed: %s\n", strerror(errno)));
 		conn_free(conn);
 		return status;
 	}
 
 	if (vfs_ChDir(conn,conn->connectpath) != 0) {
-		status = map_nt_error_from_unix(errno);
+		NTSTATUS status = map_nt_error_from_unix(errno);
 		DEBUG(3,("create_conn_struct: Can't ChDir to new conn path %s. "
 			"Error was %s\n",
 			conn->connectpath, strerror(errno) ));
@@ -471,7 +394,7 @@
 		return False;
 	}
 
-	alt_path = talloc_array(ctx, char *, MAX_REFERRAL_COUNT);
+	alt_path = TALLOC_ARRAY(ctx, char *, MAX_REFERRAL_COUNT);
 	if (!alt_path) {
 		return False;
 	}
@@ -485,7 +408,7 @@
 	DEBUG(10,("parse_msdfs_symlink: count=%d\n", count));
 
 	if (count) {
-		reflist = *preflist = talloc_zero_array(ctx,
+		reflist = *preflist = TALLOC_ZERO_ARRAY(ctx,
 				struct referral, count);
 		if(reflist == NULL) {
 			TALLOC_FREE(alt_path);
@@ -550,7 +473,7 @@
 
 	if (pp_link_target) {
 		bufsize = 1024;
-		link_target = talloc_array(ctx, char, bufsize);
+		link_target = TALLOC_ARRAY(ctx, char, bufsize);
 		if (!link_target) {
 			return False;
 		}
@@ -652,7 +575,7 @@
 		conn->connectpath, pdp->reqpath));
 
 	/*
- 	 * Note the unix path conversion here we're doing we
+	 * Note the unix path conversion here we're doing we
 	 * throw away. We're looking for a symlink for a dfs
 	 * resolution, if we don't find it we'll do another
 	 * unix_convert later in the codepath.
@@ -786,19 +709,17 @@
 			connection_struct *conn,
 			const char *path_in,
 			bool search_wcard_flag,
-			bool allow_broken_path,
 			char **pp_path_out,
 			bool *ppath_contains_wcard)
 {
 	NTSTATUS status;
-	struct dfs_path *pdp = talloc(ctx, struct dfs_path);
+	struct dfs_path *pdp = TALLOC_P(ctx, struct dfs_path);
 
 	if (!pdp) {
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = parse_dfs_path(conn, path_in, search_wcard_flag,
-				allow_broken_path, pdp,
+	status = parse_dfs_path(conn, path_in, search_wcard_flag, pdp,
 			ppath_contains_wcard);
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(pdp);
@@ -839,10 +760,10 @@
 		return NT_STATUS_OK;
 	}
 
-	if (!( strequal(pdp->servicename, lp_servicename(talloc_tos(), SNUM(conn)))
+	if (!( strequal(pdp->servicename, lp_servicename(SNUM(conn)))
 			|| (strequal(pdp->servicename, HOMES_NAME)
-			&& strequal(lp_servicename(talloc_tos(), SNUM(conn)),
-				conn->session_info->unix_info->sanitized_username) )) ) {
+			&& strequal(lp_servicename(SNUM(conn)),
+				conn->session_info->sanitized_username) )) ) {
 
 		/* The given sharename doesn't match this connection. */
 		TALLOC_FREE(pdp);
@@ -894,13 +815,12 @@
 	*self_referralp = True;
 
 	jucn->referral_count = 1;
-	if((ref = talloc_zero(ctx, struct referral)) == NULL) {
+	if((ref = TALLOC_ZERO_P(ctx, struct referral)) == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
 
 	ref->alternate_path = talloc_strdup(ctx, dfs_path);
 	if (!ref->alternate_path) {
-		TALLOC_FREE(ref);
 		return NT_STATUS_NO_MEMORY;
 	}
 	ref->proximity = 0;
@@ -917,7 +837,6 @@
 
 NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 			const char *dfs_path,
-			bool allow_broken_path,
 			struct junction_map *jucn,
 			int *consumedcntp,
 			bool *self_referralp)
@@ -927,7 +846,7 @@
 	int snum;
 	NTSTATUS status = NT_STATUS_NOT_FOUND;
 	bool dummy;
-	struct dfs_path *pdp = talloc(ctx, struct dfs_path);
+	struct dfs_path *pdp = TALLOC_P(ctx, struct dfs_path);
 	char *oldpath;
 
 	if (!pdp) {
@@ -936,8 +855,7 @@
 
 	*self_referralp = False;
 
-	status = parse_dfs_path(NULL, dfs_path, False, allow_broken_path,
-				pdp, &dummy);
+	status = parse_dfs_path(NULL, dfs_path, False, pdp, &dummy);
 	if (!NT_STATUS_IS_OK(status)) {
 		return status;
 	}
@@ -967,7 +885,7 @@
 		}
 	}
 
-	if (!lp_msdfs_root(snum) && (*lp_msdfs_proxy(talloc_tos(), snum) == '\0')) {
+	if (!lp_msdfs_root(snum) && (*lp_msdfs_proxy(snum) == '\0')) {
 		DEBUG(3,("get_referred_path: |%s| in dfs path %s is not "
 			"a dfs root.\n",
 			pdp->servicename, dfs_path));
@@ -987,7 +905,7 @@
 		char *tmp;
 		struct referral *ref;
 
-		if (*lp_msdfs_proxy(talloc_tos(), snum) == '\0') {
+		if (*lp_msdfs_proxy(snum) == '\0') {
 			TALLOC_FREE(pdp);
 			return self_ref(ctx,
 					dfs_path,
@@ -1002,12 +920,12 @@
  		 */
 
 		jucn->referral_count = 1;
-		if ((ref = talloc_zero(ctx, struct referral)) == NULL) {
+		if ((ref = TALLOC_ZERO_P(ctx, struct referral)) == NULL) {
 			TALLOC_FREE(pdp);
 			return NT_STATUS_NO_MEMORY;
 		}
 
-		if (!(tmp = talloc_strdup(ctx, lp_msdfs_proxy(talloc_tos(), snum)))) {
+		if (!(tmp = talloc_strdup(ctx, lp_msdfs_proxy(snum)))) {
 			TALLOC_FREE(pdp);
 			return NT_STATUS_NO_MEMORY;
 		}
@@ -1040,11 +958,8 @@
 		return NT_STATUS_OK;
 	}
 
-	status = create_conn_struct_cwd(ctx,
-					server_event_context(),
-					server_messaging_context(),
-					&conn, snum,
-					lp_pathname(talloc_tos(), snum), NULL, &oldpath);
+	status = create_conn_struct(ctx, &conn, snum, lp_pathname(snum),
+				    NULL, &oldpath);
 	if (!NT_STATUS_IS_OK(status)) {
 		TALLOC_FREE(pdp);
 		return status;
@@ -1094,6 +1009,215 @@
 	return status;
 }
 
+static int setup_ver2_dfs_referral(const char *pathname,
+				char **ppdata,
+				struct junction_map *junction,
+				bool self_referral)
+{
+	char* pdata = *ppdata;
+
+	smb_ucs2_t *uni_requestedpath = NULL;
+	int uni_reqpathoffset1,uni_reqpathoffset2;
+	int uni_curroffset;
+	int requestedpathlen=0;
+	int offset;
+	int reply_size = 0;
+	int i=0;
+
+	DEBUG(10,("Setting up version2 referral\nRequested path:\n"));
+
+	requestedpathlen = rpcstr_push_talloc(talloc_tos(),
+					&uni_requestedpath, pathname);
+	if (uni_requestedpath == NULL || requestedpathlen == 0) {
+		return -1;
+	}
+
+	if (DEBUGLVL(10)) {
+		dump_data(0, (unsigned char *)uni_requestedpath,
+			requestedpathlen);
+	}
+
+	DEBUG(10,("ref count = %u\n",junction->referral_count));
+
+	uni_reqpathoffset1 = REFERRAL_HEADER_SIZE +
+			VERSION2_REFERRAL_SIZE * junction->referral_count;
+
+	uni_reqpathoffset2 = uni_reqpathoffset1 + requestedpathlen;
+
+	uni_curroffset = uni_reqpathoffset2 + requestedpathlen;
+
+	reply_size = REFERRAL_HEADER_SIZE +
+			VERSION2_REFERRAL_SIZE*junction->referral_count +
+			2 * requestedpathlen;
+	DEBUG(10,("reply_size: %u\n",reply_size));
+
+	/* add up the unicode lengths of all the referral paths */
+	for(i=0;i<junction->referral_count;i++) {
+		DEBUG(10,("referral %u : %s\n",
+			i,
+			junction->referral_list[i].alternate_path));
+		reply_size +=
+			(strlen(junction->referral_list[i].alternate_path)+1)*2;
+	}
+
+	DEBUG(10,("reply_size = %u\n",reply_size));
+	/* add the unexplained 0x16 bytes */
+	reply_size += 0x16;
+
+	pdata = (char *)SMB_REALLOC(pdata,reply_size);
+	if(pdata == NULL) {
+		DEBUG(0,("Realloc failed!\n"));
+		return -1;
+	}
+	*ppdata = pdata;
+
+	/* copy in the dfs requested paths.. required for offset calculations */
+	memcpy(pdata+uni_reqpathoffset1,uni_requestedpath,requestedpathlen);
+	memcpy(pdata+uni_reqpathoffset2,uni_requestedpath,requestedpathlen);
+
+	/* create the header */
+	SSVAL(pdata,0,requestedpathlen - 2); /* UCS2 of path consumed minus
+						2 byte null */
+	/* number of referral in this pkt */
+	SSVAL(pdata,2,junction->referral_count);
+	if(self_referral) {
+		SIVAL(pdata,4,DFSREF_REFERRAL_SERVER | DFSREF_STORAGE_SERVER);
+	} else {
+		SIVAL(pdata,4,DFSREF_STORAGE_SERVER);
+	}
+
+	offset = 8;
+	/* add the referral elements */
+	for(i=0;i<junction->referral_count;i++) {
+		struct referral* ref = &junction->referral_list[i];
+		int unilen;
+
+		SSVAL(pdata,offset,2); /* version 2 */
+		SSVAL(pdata,offset+2,VERSION2_REFERRAL_SIZE);
+		if(self_referral) {
+			SSVAL(pdata,offset+4,1);
+		} else {
+			SSVAL(pdata,offset+4,0);
+		}
+
+		/* ref_flags :use path_consumed bytes? */
+		SSVAL(pdata,offset+6,0);
+		SIVAL(pdata,offset+8,ref->proximity);
+		SIVAL(pdata,offset+12,ref->ttl);
+
+		SSVAL(pdata,offset+16,uni_reqpathoffset1-offset);
+		SSVAL(pdata,offset+18,uni_reqpathoffset2-offset);
+		/* copy referred path into current offset */
+		unilen = rpcstr_push(pdata+uni_curroffset,
+					ref->alternate_path,
+					reply_size - uni_curroffset,
+					STR_UNICODE);
+
+		SSVAL(pdata,offset+20,uni_curroffset-offset);
+
+		uni_curroffset += unilen;
+		offset += VERSION2_REFERRAL_SIZE;
+	}
+	/* add in the unexplained 22 (0x16) bytes at the end */
+	memset(pdata+uni_curroffset,'\0',0x16);
+	return reply_size;
+}
+
+static int setup_ver3_dfs_referral(const char *pathname,
+				char **ppdata,
+				struct junction_map *junction,
+				bool self_referral)
+{
+	char *pdata = *ppdata;
+
+	smb_ucs2_t *uni_reqpath = NULL;
+	int uni_reqpathoffset1, uni_reqpathoffset2;
+	int uni_curroffset;
+	int reply_size = 0;
+
+	int reqpathlen = 0;
+	int offset,i=0;
+
+	DEBUG(10,("setting up version3 referral\n"));
+
+	reqpathlen = rpcstr_push_talloc(talloc_tos(), &uni_reqpath, pathname);
+	if (uni_reqpath == NULL || reqpathlen == 0) {
+		return -1;
+	}
+
+	if (DEBUGLVL(10)) {
+		dump_data(0, (unsigned char *)uni_reqpath,
+			reqpathlen);
+	}
+
+	uni_reqpathoffset1 = REFERRAL_HEADER_SIZE +
+			VERSION3_REFERRAL_SIZE * junction->referral_count;
+	uni_reqpathoffset2 = uni_reqpathoffset1 + reqpathlen;
+	reply_size = uni_curroffset = uni_reqpathoffset2 + reqpathlen;
+
+	for(i=0;i<junction->referral_count;i++) {
+		DEBUG(10,("referral %u : %s\n",
+			i,
+			junction->referral_list[i].alternate_path));
+		reply_size +=
+			(strlen(junction->referral_list[i].alternate_path)+1)*2;
+	}
+
+	pdata = (char *)SMB_REALLOC(pdata,reply_size);
+	if(pdata == NULL) {
+		DEBUG(0,("version3 referral setup:"
+			"malloc failed for Realloc!\n"));
+		return -1;
+	}
+	*ppdata = pdata;
+
+	/* create the header */
+	SSVAL(pdata,0,reqpathlen - 2); /* UCS2 of path consumed minus
+					  2 byte null */
+	SSVAL(pdata,2,junction->referral_count); /* number of referral */
+	if(self_referral) {
+		SIVAL(pdata,4,DFSREF_REFERRAL_SERVER | DFSREF_STORAGE_SERVER);
+	} else {
+		SIVAL(pdata,4,DFSREF_STORAGE_SERVER);
+	}
+
+	/* copy in the reqpaths */
+	memcpy(pdata+uni_reqpathoffset1,uni_reqpath,reqpathlen);
+	memcpy(pdata+uni_reqpathoffset2,uni_reqpath,reqpathlen);
+
+	offset = 8;
+	for(i=0;i<junction->referral_count;i++) {
+		struct referral* ref = &(junction->referral_list[i]);
+		int unilen;
+
+		SSVAL(pdata,offset,3); /* version 3 */
+		SSVAL(pdata,offset+2,VERSION3_REFERRAL_SIZE);
+		if(self_referral) {
+			SSVAL(pdata,offset+4,1);
+		} else {
+			SSVAL(pdata,offset+4,0);
+		}
+
+		/* ref_flags :use path_consumed bytes? */
+		SSVAL(pdata,offset+6,0);
+		SIVAL(pdata,offset+8,ref->ttl);
+
+		SSVAL(pdata,offset+12,uni_reqpathoffset1-offset);
+		SSVAL(pdata,offset+14,uni_reqpathoffset2-offset);
+		/* copy referred path into current offset */
+		unilen = rpcstr_push(pdata+uni_curroffset,ref->alternate_path,
+					reply_size - uni_curroffset,
+					STR_UNICODE | STR_TERMINATE);
+		SSVAL(pdata,offset+16,uni_curroffset-offset);
+		/* copy 0x10 bytes of 00's in the ServiceSite GUID */
+		memset(pdata+offset+18,'\0',16);
+
+		uni_curroffset += unilen;
+		offset += VERSION3_REFERRAL_SIZE;
+	}
+	return reply_size;
+}
+
 /******************************************************************
  Set up the DFS referral for the dfs pathname. This call returns
  the amount of the path covered by this server, and where the
@@ -1106,55 +1230,110 @@
 			int max_referral_level,
 			char **ppdata, NTSTATUS *pstatus)
 {
-	char *pdata = *ppdata;
+	struct junction_map *junction = NULL;
+	int consumedcnt = 0;
+	bool self_referral = False;
 	int reply_size = 0;
-	struct dfs_GetDFSReferral *r;
-	DATA_BLOB blob = data_blob_null;
-	NTSTATUS status;
-	enum ndr_err_code ndr_err;
+	char *pathnamep = NULL;
+	char *local_dfs_path = NULL;
+	TALLOC_CTX *ctx;
 
-	r = talloc_zero(talloc_tos(), struct dfs_GetDFSReferral);
-	if (r == NULL) {
+	if (!(ctx=talloc_init("setup_dfs_referral"))) {
 		*pstatus = NT_STATUS_NO_MEMORY;
 		return -1;
 	}
 
-	r->in.req.max_referral_level = max_referral_level;
-	r->in.req.servername = talloc_strdup(r, dfs_path);
-	if (r->in.req.servername == NULL) {
-		talloc_free(r);
+	/* get the junction entry */
+	if (!dfs_path) {
+		talloc_destroy(ctx);
+		*pstatus = NT_STATUS_NOT_FOUND;
+		return -1;
+	}
+
+	/*
+	 * Trim pathname sent by client so it begins with only one backslash.
+	 * Two backslashes confuse some dfs clients
+	 */
+
+	local_dfs_path = talloc_strdup(ctx,dfs_path);
+	if (!local_dfs_path) {
 		*pstatus = NT_STATUS_NO_MEMORY;
+		talloc_destroy(ctx);
 		return -1;
 	}
+	pathnamep = local_dfs_path;
+	while (IS_DIRECTORY_SEP(pathnamep[0]) &&
+			IS_DIRECTORY_SEP(pathnamep[1])) {
+		pathnamep++;
+	}
 
-	status = SMB_VFS_GET_DFS_REFERRALS(orig_conn, r);
-	if (!NT_STATUS_IS_OK(status)) {
-		talloc_free(r);
-		*pstatus = status;
+	junction = TALLOC_ZERO_P(ctx, struct junction_map);
+	if (!junction) {
+		*pstatus = NT_STATUS_NO_MEMORY;
+		talloc_destroy(ctx);
 		return -1;
 	}
 
-	ndr_err = ndr_push_struct_blob(&blob, r,
-				r->out.resp,
-				(ndr_push_flags_fn_t)ndr_push_dfs_referral_resp);
-	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		TALLOC_FREE(r);
-		*pstatus = NT_STATUS_INVALID_PARAMETER;
+	/* The following call can change cwd. */
+	*pstatus = get_referred_path(ctx, pathnamep, junction,
+			&consumedcnt, &self_referral);
+	if (!NT_STATUS_IS_OK(*pstatus)) {
+		vfs_ChDir(orig_conn,orig_conn->connectpath);
+		talloc_destroy(ctx);
 		return -1;
 	}
+	vfs_ChDir(orig_conn,orig_conn->connectpath);
 
-	pdata = (char *)SMB_REALLOC(pdata, blob.length);
-	if(pdata == NULL) {
-		TALLOC_FREE(r);
-		DEBUG(0,("referral setup:"
-			 "malloc failed for Realloc!\n"));
+	if (!self_referral) {
+		pathnamep[consumedcnt] = '\0';
+
+		if( DEBUGLVL( 3 ) ) {
+			int i=0;
+			dbgtext("setup_dfs_referral: Path %s to "
+				"alternate path(s):",
+				pathnamep);
+			for(i=0;i<junction->referral_count;i++)
+				dbgtext(" %s",
+				junction->referral_list[i].alternate_path);
+			dbgtext(".\n");
+		}
+	}
+
+	/* create the referral depeding on version */
+	DEBUG(10,("max_referral_level :%d\n",max_referral_level));
+
+	if (max_referral_level < 2) {
+		max_referral_level = 2;
+	}
+	if (max_referral_level > 3) {
+		max_referral_level = 3;
+	}
+
+	switch(max_referral_level) {
+	case 2:
+		reply_size = setup_ver2_dfs_referral(pathnamep,
+					ppdata, junction,
+					self_referral);
+		break;
+	case 3:
+		reply_size = setup_ver3_dfs_referral(pathnamep, ppdata,
+					junction, self_referral);
+		break;
+	default:
+		DEBUG(0,("setup_dfs_referral: Invalid dfs referral "
+			"version: %d\n",
+			max_referral_level));
+		talloc_destroy(ctx);
+		*pstatus = NT_STATUS_INVALID_LEVEL;
 		return -1;
 	}
-	*ppdata = pdata;
-	reply_size = blob.length;
-	memcpy(pdata, blob.data, blob.length);
-	TALLOC_FREE(r);
 
+	if (DEBUGLVL(10)) {
+		DEBUGADD(0,("DFS Referral pdata:\n"));
+		dump_data(0,(uint8 *)*ppdata,reply_size);
+	}
+
+	talloc_destroy(ctx);
 	*pstatus = NT_STATUS_OK;
 	return reply_size;
 }
@@ -1169,19 +1348,17 @@
 
 bool create_junction(TALLOC_CTX *ctx,
 		const char *dfs_path,
-		bool allow_broken_path,
 		struct junction_map *jucn)
 {
 	int snum;
 	bool dummy;
-	struct dfs_path *pdp = talloc(ctx,struct dfs_path);
+	struct dfs_path *pdp = TALLOC_P(ctx,struct dfs_path);
 	NTSTATUS status;
 
 	if (!pdp) {
 		return False;
 	}
-	status = parse_dfs_path(NULL, dfs_path, False, allow_broken_path,
-				pdp, &dummy);
+	status = parse_dfs_path(NULL, dfs_path, False, pdp, &dummy);
 	if (!NT_STATUS_IS_OK(status)) {
 		return False;
 	}
@@ -1207,7 +1384,7 @@
 
 	jucn->service_name = talloc_strdup(ctx, pdp->servicename);
 	jucn->volume_name = talloc_strdup(ctx, pdp->reqpath);
-	jucn->comment = lp_comment(ctx, snum);
+	jucn->comment = talloc_strdup(ctx, lp_comment(snum));
 
 	TALLOC_FREE(pdp);
 	if (!jucn->service_name || !jucn->volume_name || ! jucn->comment) {
@@ -1232,18 +1409,15 @@
 	if(snum < 0) {
 		return False;
 	}
-	status = create_conn_struct_cwd(talloc_tos(),
-					server_event_context(),
-					server_messaging_context(),
-					conn_out,
-					snum, lp_pathname(talloc_tos(), snum), NULL, oldpath);
+	status = create_conn_struct(talloc_tos(), conn_out, snum,
+				    lp_pathname(snum), NULL, oldpath);
 	if (!NT_STATUS_IS_OK(status)) {
 		return False;
 	}
 
 	*pp_path_out = talloc_asprintf(*conn_out,
 			"%s/%s",
-			lp_pathname(talloc_tos(), snum),
+			lp_pathname(snum),
 			jucn->volume_name);
 	if (!*pp_path_out) {
 		vfs_ChDir(*conn_out, *oldpath);
@@ -1380,11 +1554,11 @@
 static int count_dfs_links(TALLOC_CTX *ctx, int snum)
 {
 	size_t cnt = 0;
-	DIR *dirp = NULL;
+	SMB_STRUCT_DIR *dirp = NULL;
 	const char *dname = NULL;
 	char *talloced = NULL;
-	const char *connect_path = lp_pathname(talloc_tos(), snum);
-	const char *msdfs_proxy = lp_msdfs_proxy(talloc_tos(), snum);
+	const char *connect_path = lp_pathname(snum);
+	const char *msdfs_proxy = lp_msdfs_proxy(snum);
 	connection_struct *conn;
 	NTSTATUS status;
 	char *cwd;
@@ -1397,11 +1571,8 @@
 	 * Fake up a connection struct for the VFS layer.
 	 */
 
-	status = create_conn_struct_cwd(talloc_tos(),
-					server_event_context(),
-					server_messaging_context(),
-					&conn,
-					snum, connect_path, NULL, &cwd);
+	status = create_conn_struct(talloc_tos(), &conn, snum, connect_path,
+				    NULL, &cwd);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(3, ("create_conn_struct failed: %s\n",
 			  nt_errstr(status)));
@@ -1450,12 +1621,12 @@
 				size_t jn_remain)
 {
 	size_t cnt = 0;
-	DIR *dirp = NULL;
+	SMB_STRUCT_DIR *dirp = NULL;
 	const char *dname = NULL;
 	char *talloced = NULL;
-	const char *connect_path = lp_pathname(talloc_tos(), snum);
-	char *service_name = lp_servicename(talloc_tos(), snum);
-	const char *msdfs_proxy = lp_msdfs_proxy(talloc_tos(), snum);
+	const char *connect_path = lp_pathname(snum);
+	char *service_name = lp_servicename(snum);
+	const char *msdfs_proxy = lp_msdfs_proxy(snum);
 	connection_struct *conn;
 	struct referral *ref = NULL;
 	char *cwd;
@@ -1473,11 +1644,8 @@
 	 * Fake up a connection struct for the VFS layer.
 	 */
 
-	status = create_conn_struct_cwd(ctx,
-					server_event_context(),
-					server_messaging_context(),
-					&conn, snum, connect_path, NULL,
-					&cwd);
+	status = create_conn_struct(ctx, &conn, snum, connect_path, NULL,
+				    &cwd);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(3, ("create_conn_struct failed: %s\n",
 			  nt_errstr(status)));
@@ -1496,7 +1664,7 @@
 	jucn[cnt].comment = "";
 	jucn[cnt].referral_count = 1;
 
-	ref = jucn[cnt].referral_list = talloc_zero(ctx, struct referral);
+	ref = jucn[cnt].referral_list = TALLOC_ZERO_P(ctx, struct referral);
 	if (jucn[cnt].referral_list == NULL) {
 		goto out;
 	}
@@ -1590,7 +1758,7 @@
 	/* Ensure all the usershares are loaded. */
 	become_root();
 	load_registry_shares();
-	sharecount = load_usershare_shares(NULL, connections_snum_used);
+	sharecount = load_usershare_shares();
 	unbecome_root();
 
 	for(i=0;i < sharecount;i++) {
@@ -1601,7 +1769,7 @@
 	if (jn_count == 0) {
 		return NULL;
 	}
-	jn = talloc_array(ctx,  struct junction_map, jn_count);
+	jn = TALLOC_ARRAY(ctx,  struct junction_map, jn_count);
 	if (!jn) {
 		return NULL;
 	}
@@ -1629,7 +1797,6 @@
 				bool dfs_pathnames,
 				const char *name_in,
 				bool allow_wcards,
-				bool allow_broken_path,
 				char **pp_name_out,
 				bool *ppath_contains_wcard)
 {
@@ -1641,7 +1808,6 @@
 					conn,
 					name_in,
 					allow_wcards,
-					allow_broken_path,
 					pp_name_out,
 					&path_contains_wcard);
 
@@ -1654,7 +1820,7 @@
 		 * Once srvstr_get_path() uses talloc it'll
 		 * be a talloced ptr anyway.
 		 */
-		*pp_name_out = discard_const_p(char, name_in);
+		*pp_name_out = CONST_DISCARD(char *,name_in);
 	}
 	return status;
 }
Only in ../../samba-3.6.24/source3/smbd: msdfs.o
Only in ../../samba-3.6.24/source3/smbd: msg_idmap.c
Only in ../../samba-3.6.24/source3/smbd: msg_idmap.o
diff -ur smbd/negprot.c ../../samba-3.6.24/source3/smbd/negprot.c
--- smbd/negprot.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/negprot.c	2015-01-28 10:52:25.149068676 +0800
@@ -26,8 +26,6 @@
 #include "auth.h"
 #include "messages.h"
 #include "smbprofile.h"
-#include "auth/gensec/gensec.h"
-#include "../libcli/smb/smb_signing.h"
 
 extern fstring remote_proto;
 
@@ -44,7 +42,7 @@
 	}
 
 	DEBUG(10, ("get challenge: creating negprot_global_auth_context\n"));
-	nt_status = make_auth4_context(
+	nt_status = make_auth_context_subsystem(
 		sconn, &sconn->smb1.negprot.auth_context);
 	if (!NT_STATUS_IS_OK(nt_status)) {
 		DEBUG(0, ("make_auth_context_subsystem returned %s",
@@ -57,6 +55,38 @@
 }
 
 /****************************************************************************
+ Reply for the core protocol.
+****************************************************************************/
+
+static void reply_corep(struct smb_request *req, uint16 choice)
+{
+	reply_outbuf(req, 1, 0);
+	SSVAL(req->outbuf, smb_vwv0, choice);
+
+	set_Protocol(PROTOCOL_CORE);
+}
+
+/****************************************************************************
+ Reply for the coreplus protocol.
+****************************************************************************/
+
+static void reply_coreplus(struct smb_request *req, uint16 choice)
+{
+	int raw = (lp_readraw()?1:0) | (lp_writeraw()?2:0);
+
+	reply_outbuf(req, 13, 0);
+
+	SSVAL(req->outbuf,smb_vwv0,choice);
+	SSVAL(req->outbuf,smb_vwv5,raw); /* tell redirector we support
+			readbraw and writebraw (possibly) */
+	/* Reply, SMBlockread, SMBwritelock supported. */
+	SCVAL(req->outbuf,smb_flg,FLAG_REPLY|FLAG_SUPPORT_LOCKREAD);
+	SSVAL(req->outbuf,smb_vwv1,0x1); /* user level security, don't
+					  * encrypt */
+	set_Protocol(PROTOCOL_COREPLUS);
+}
+
+/****************************************************************************
  Reply for the lanman 1.0 protocol.
 ****************************************************************************/
 
@@ -69,7 +99,9 @@
 
 	sconn->smb1.negprot.encrypted_passwords = lp_encrypted_passwords();
 
-	secword |= NEGOTIATE_SECURITY_USER_LEVEL;
+	if (lp_security()>=SEC_USER) {
+		secword |= NEGOTIATE_SECURITY_USER_LEVEL;
+	}
 	if (sconn->smb1.negprot.encrypted_passwords) {
 		secword |= NEGOTIATE_SECURITY_CHALLENGE_RESPONSE;
 	}
@@ -84,16 +116,16 @@
 		SSVAL(req->outbuf,smb_vwv11, 8);
 	}
 
-	smbXsrv_connection_init_tables(req->sconn->conn, PROTOCOL_LANMAN1);
+	set_Protocol(PROTOCOL_LANMAN1);
 
 	/* Reply, SMBlockread, SMBwritelock supported. */
-	SCVAL(req->outbuf,smb_flg, FLAG_REPLY|FLAG_SUPPORT_LOCKREAD);
-	SSVAL(req->outbuf,smb_vwv2, sconn->smb1.negprot.max_recv);
-	SSVAL(req->outbuf,smb_vwv3, lp_maxmux()); /* maxmux */
-	SSVAL(req->outbuf,smb_vwv4, 1);
-	SSVAL(req->outbuf,smb_vwv5, raw); /* tell redirector we support
+	SCVAL(req->outbuf,smb_flg,FLAG_REPLY|FLAG_SUPPORT_LOCKREAD);
+	SSVAL(req->outbuf,smb_vwv2,sconn->smb1.negprot.max_recv);
+	SSVAL(req->outbuf,smb_vwv3,lp_maxmux()); /* maxmux */
+	SSVAL(req->outbuf,smb_vwv4,1);
+	SSVAL(req->outbuf,smb_vwv5,raw); /* tell redirector we support
 		readbraw writebraw (possibly) */
-	SIVAL(req->outbuf,smb_vwv6, getpid());
+	SIVAL(req->outbuf,smb_vwv6,sys_getpid());
 	SSVAL(req->outbuf,smb_vwv10, set_server_zone_offset(t)/60);
 
 	srv_put_dos_date((char *)req->outbuf,smb_vwv8,t);
@@ -114,16 +146,18 @@
 
 	sconn->smb1.negprot.encrypted_passwords = lp_encrypted_passwords();
 
-	secword |= NEGOTIATE_SECURITY_USER_LEVEL;
+	if (lp_security()>=SEC_USER) {
+		secword |= NEGOTIATE_SECURITY_USER_LEVEL;
+	}
 	if (sconn->smb1.negprot.encrypted_passwords) {
 		secword |= NEGOTIATE_SECURITY_CHALLENGE_RESPONSE;
 	}
 
 	reply_outbuf(req, 13, sconn->smb1.negprot.encrypted_passwords?8:0);
 
-	SSVAL(req->outbuf,smb_vwv0, choice);
-	SSVAL(req->outbuf,smb_vwv1, secword);
-	SIVAL(req->outbuf,smb_vwv6, getpid());
+	SSVAL(req->outbuf,smb_vwv0,choice);
+	SSVAL(req->outbuf,smb_vwv1,secword);
+	SIVAL(req->outbuf,smb_vwv6,sys_getpid());
 
 	/* Create a token value and add it to the outgoing packet. */
 	if (sconn->smb1.negprot.encrypted_passwords) {
@@ -131,7 +165,7 @@
 		SSVAL(req->outbuf,smb_vwv11, 8);
 	}
 
-	smbXsrv_connection_init_tables(req->sconn->conn, PROTOCOL_LANMAN2);
+	set_Protocol(PROTOCOL_LANMAN2);
 
 	/* Reply, SMBlockread, SMBwritelock supported. */
 	SCVAL(req->outbuf,smb_flg,FLAG_REPLY|FLAG_SUPPORT_LOCKREAD);
@@ -153,33 +187,16 @@
 	DATA_BLOB blob_out = data_blob_null;
 	nstring dos_name;
 	fstring unix_name;
-	NTSTATUS status;
 #ifdef DEVELOPER
 	size_t slen;
 #endif
-	struct gensec_security *gensec_security;
-
-	/* See if we can get an SPNEGO blob */
-	status = auth_generic_prepare(talloc_tos(),
-				      sconn->remote_address,
-				      &gensec_security);
-	if (NT_STATUS_IS_OK(status)) {
-		status = gensec_start_mech_by_oid(gensec_security, GENSEC_OID_SPNEGO);
-		if (NT_STATUS_IS_OK(status)) {
-			status = gensec_update(gensec_security, ctx,
-					       NULL, data_blob_null, &blob);
-			/* If we get the list of OIDs, the 'OK' answer
-			 * is NT_STATUS_MORE_PROCESSING_REQUIRED */
-			if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-				DEBUG(0, ("Failed to start SPNEGO handler for negprot OID list!\n"));
-				blob = data_blob_null;
-			}
-		}
-		TALLOC_FREE(gensec_security);
-	}
+	const char *OIDs_krb5[] = {OID_KERBEROS5,
+				   OID_KERBEROS5_OLD,
+				   OID_NTLMSSP,
+				   NULL};
+	const char *OIDs_ntlm[] = {OID_NTLMSSP, NULL};
 
 	sconn->smb1.negprot.spnego = true;
-
 	/* strangely enough, NT does not sent the single OID NTLMSSP when
 	   not a ADS member, it sends no OIDs at all
 
@@ -193,6 +210,30 @@
 
 	*/
 
+	if (lp_security() != SEC_ADS && !USE_KERBEROS_KEYTAB) {
+#if 0
+		/* Code for PocketPC client */
+		blob = data_blob(guid, 16);
+#else
+		/* Code for standalone WXP client */
+		blob = spnego_gen_negTokenInit(ctx, OIDs_ntlm, NULL, "NONE");
+#endif
+	} else if (!lp_send_spnego_principal()) {
+		/* By default, Windows 2008 and later sends not_defined_in_RFC4178@please_ignore */
+		blob = spnego_gen_negTokenInit(ctx, OIDs_krb5, NULL, ADS_IGNORE_PRINCIPAL);
+	} else {
+		fstring myname;
+		char *host_princ_s = NULL;
+		name_to_fqdn(myname, global_myname());
+		strlower_m(myname);
+		if (asprintf(&host_princ_s, "cifs/%s@%s", myname, lp_realm())
+		    == -1) {
+			return data_blob_null;
+		}
+		blob = spnego_gen_negTokenInit(ctx, OIDs_krb5, NULL, host_princ_s);
+		SAFE_FREE(host_princ_s);
+	}
+
 	if (blob.length == 0 || blob.data == NULL) {
 		return data_blob_null;
 	}
@@ -205,8 +246,8 @@
 
 	memset(blob_out.data, '\0', 16);
 
-	checked_strlcpy(unix_name, lp_netbios_name(), sizeof(unix_name));
-	(void)strlower_m(unix_name);
+	safe_strcpy(unix_name, global_myname(), sizeof(unix_name)-1);
+	strlower_m(unix_name);
 	push_ascii_nstring(dos_name, unix_name);
 	strlcpy((char *)blob_out.data, dos_name, 17);
 
@@ -240,8 +281,6 @@
 	struct timespec ts;
 	ssize_t ret;
 	struct smbd_server_connection *sconn = req->sconn;
-	bool signing_enabled = false;
-	bool signing_required = false;
 
 	sconn->smb1.negprot.encrypted_passwords = lp_encrypted_passwords();
 
@@ -250,10 +289,9 @@
 	   distinguish from NT which doesn't set it either. */
 
 	if ( (req->flags2 & FLAGS2_EXTENDED_SECURITY) &&
-		((req->flags2 & FLAGS2_SMB_SECURITY_SIGNATURES_REQUIRED) == 0) )
+		((req->flags2 & FLAGS2_UNKNOWN_BIT4) == 0) )
 	{
-		if ((get_remote_arch() != RA_SAMBA) &&
-				(get_remote_arch() != RA_CIFSFS)) {
+		if (get_remote_arch() != RA_SAMBA) {
 			set_remote_arch( RA_VISTA );
 		}
 	}
@@ -264,6 +302,7 @@
 	   supports it and we can do encrypted passwords */
 
 	if (sconn->smb1.negprot.encrypted_passwords &&
+	    (lp_security() != SEC_SHARE) &&
 	    lp_use_spnego() &&
 	    (req->flags2 & FLAGS2_EXTENDED_SECURITY)) {
 		negotiate_spnego = True;
@@ -275,20 +314,17 @@
 		      req->flags2 | FLAGS2_EXTENDED_SECURITY);
 	}
 
-	capabilities |= CAP_NT_SMBS|CAP_RPC_REMOTE_APIS;
-
-	if (lp_unicode()) {
-		capabilities |= CAP_UNICODE;
-	}
+	capabilities |= CAP_NT_SMBS|CAP_RPC_REMOTE_APIS|CAP_UNICODE;
 
 	if (lp_unix_extensions()) {
 		capabilities |= CAP_UNIX;
 	}
 
-	if (lp_large_readwrite())
+	if (lp_large_readwrite() && (SMB_OFF_T_BITS == 64))
 		capabilities |= CAP_LARGE_READX|CAP_LARGE_WRITEX|CAP_W2K_SMBS;
 
-	capabilities |= CAP_LARGE_FILES;
+	if (SMB_OFF_T_BITS == 64)
+		capabilities |= CAP_LARGE_FILES;
 
 	if (lp_readraw() && lp_writeraw())
 		capabilities |= CAP_RAW_MODE;
@@ -299,35 +335,41 @@
 	if (lp_host_msdfs())
 		capabilities |= CAP_DFS;
 
-	secword |= NEGOTIATE_SECURITY_USER_LEVEL;
+	if (lp_security() >= SEC_USER) {
+		secword |= NEGOTIATE_SECURITY_USER_LEVEL;
+	}
 	if (sconn->smb1.negprot.encrypted_passwords) {
 		secword |= NEGOTIATE_SECURITY_CHALLENGE_RESPONSE;
 	}
 
-	signing_enabled = smb_signing_is_allowed(req->sconn->smb1.signing_state);
-	signing_required = smb_signing_is_mandatory(req->sconn->smb1.signing_state);
-
-	if (signing_enabled) {
-		secword |= NEGOTIATE_SECURITY_SIGNATURES_ENABLED;
-		/* No raw mode with smb signing. */
-		capabilities &= ~CAP_RAW_MODE;
-		if (signing_required) {
-			secword |=NEGOTIATE_SECURITY_SIGNATURES_REQUIRED;
+	if (lp_server_signing()) {
+	       	if (lp_security() >= SEC_USER) {
+			secword |= NEGOTIATE_SECURITY_SIGNATURES_ENABLED;
+			/* No raw mode with smb signing. */
+			capabilities &= ~CAP_RAW_MODE;
+			if (lp_server_signing() == Required)
+				secword |=NEGOTIATE_SECURITY_SIGNATURES_REQUIRED;
+			srv_set_signing_negotiated(sconn);
+		} else {
+			DEBUG(0,("reply_nt1: smb signing is incompatible with share level security !\n"));
+			if (lp_server_signing() == Required) {
+				exit_server_cleanly("reply_nt1: smb signing required and share level security selected.");
+			}
 		}
 	}
 
 	SSVAL(req->outbuf,smb_vwv0,choice);
 	SCVAL(req->outbuf,smb_vwv1,secword);
 
-	smbXsrv_connection_init_tables(req->sconn->conn, PROTOCOL_NT1);
+	set_Protocol(PROTOCOL_NT1);
 
-	SSVAL(req->outbuf,smb_vwv1+1, lp_maxmux()); /* maxmpx */
-	SSVAL(req->outbuf,smb_vwv2+1, 1); /* num vcs */
+	SSVAL(req->outbuf,smb_vwv1+1,lp_maxmux()); /* maxmpx */
+	SSVAL(req->outbuf,smb_vwv2+1,1); /* num vcs */
 	SIVAL(req->outbuf,smb_vwv3+1,
 	      sconn->smb1.negprot.max_recv); /* max buffer. LOTS! */
-	SIVAL(req->outbuf,smb_vwv5+1, 0x10000); /* raw size. full 64k */
-	SIVAL(req->outbuf,smb_vwv7+1, getpid()); /* session key */
-	SIVAL(req->outbuf,smb_vwv9+1, capabilities); /* capabilities */
+	SIVAL(req->outbuf,smb_vwv5+1,0x10000); /* raw size. full 64k */
+	SIVAL(req->outbuf,smb_vwv7+1,sys_getpid()); /* session key */
+	SIVAL(req->outbuf,smb_vwv9+1,capabilities); /* capabilities */
 	clock_gettime(CLOCK_REALTIME,&ts);
 	put_long_date_timespec(TIMESTAMP_SET_NT_OR_BETTER,(char *)req->outbuf+smb_vwv11+1,ts);
 	SSVALS(req->outbuf,smb_vwv15+1,set_server_zone_offset(ts.tv_sec)/60);
@@ -356,14 +398,6 @@
 			reply_nterror(req, NT_STATUS_NO_MEMORY);
 			return;
 		}
-		ret = message_push_string(&req->outbuf, lp_netbios_name(),
-					  STR_UNICODE|STR_TERMINATE
-					  |STR_NOALIGN);
-		if (ret == -1) {
-			DEBUG(0, ("Could not push netbios name string\n"));
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
-		}
 		DEBUG(3,("not using SPNEGO\n"));
 	} else {
 		DATA_BLOB spnego_blob = negprot_spnego(req, req->sconn);
@@ -476,8 +510,7 @@
 	void (*proto_reply_fn)(struct smb_request *req, uint16 choice);
 	int protocol_level;
 } supported_protocols[] = {
-	{"SMB 2.???",               "SMB2_FF",  reply_smb20ff,  PROTOCOL_SMB2_10},
-	{"SMB 2.002",               "SMB2_02",  reply_smb2002,  PROTOCOL_SMB2_02},
+	{"SMB 2.002",               "SMB2",     reply_smb2002,  PROTOCOL_SMB2},
 	{"NT LANMAN 1.0",           "NT1",      reply_nt1,      PROTOCOL_NT1},
 	{"NT LM 0.12",              "NT1",      reply_nt1,      PROTOCOL_NT1},
 	{"POSIX 2",                 "NT1",      reply_nt1,      PROTOCOL_NT1},
@@ -487,6 +520,8 @@
 	{"DOS LM1.2X002",           "LANMAN2",  reply_lanman2,  PROTOCOL_LANMAN2},
 	{"LANMAN1.0",               "LANMAN1",  reply_lanman1,  PROTOCOL_LANMAN1},
 	{"MICROSOFT NETWORKS 3.0",  "LANMAN1",  reply_lanman1,  PROTOCOL_LANMAN1},
+	{"MICROSOFT NETWORKS 1.03", "COREPLUS", reply_coreplus, PROTOCOL_COREPLUS},
+	{"PC NETWORK PROGRAM 1.0",  "CORE",     reply_corep,    PROTOCOL_CORE}, 
 	{NULL,NULL,NULL,0},
 };
 
@@ -498,7 +533,6 @@
 void reply_negprot(struct smb_request *req)
 {
 	int choice= -1;
-	int chosen_level = -1;
 	int protocol;
 	const char *p;
 	int arch = ARCH_ALL;
@@ -539,7 +573,7 @@
 
 		char **tmp;
 
-		tmp = talloc_realloc(talloc_tos(), cliprotos, char *,
+		tmp = TALLOC_REALLOC_ARRAY(talloc_tos(), cliprotos, char *,
 					   num_cliprotos+1);
 		if (tmp == NULL) {
 			DEBUG(0, ("talloc failed\n"));
@@ -639,26 +673,24 @@
 	}
 
 	/* possibly reload - change of architecture */
-	reload_services(sconn, conn_snum_used, true);
+	reload_services(sconn->msg_ctx, sconn->sock, True);
 
 	/* moved from the netbios session setup code since we don't have that 
 	   when the client connects to port 445.  Of course there is a small
 	   window where we are listening to messages   -- jerry */
 
-	serverid_register(messaging_server_id(sconn->msg_ctx),
+	serverid_register(sconn_server_id(sconn),
 			  FLAG_MSG_GENERAL|FLAG_MSG_SMBD
 			  |FLAG_MSG_PRINT_GENERAL);
 
 	/* Check for protocols, most desirable first */
 	for (protocol = 0; supported_protocols[protocol].proto_name; protocol++) {
 		i = 0;
-		if ((supported_protocols[protocol].protocol_level <= lp_srv_maxprotocol()) &&
-				(supported_protocols[protocol].protocol_level >= lp_srv_minprotocol()))
+		if ((supported_protocols[protocol].protocol_level <= lp_maxprotocol()) &&
+				(supported_protocols[protocol].protocol_level >= lp_minprotocol()))
 			while (i < num_cliprotos) {
-				if (strequal(cliprotos[i],supported_protocols[protocol].proto_name)) {
+				if (strequal(cliprotos[i],supported_protocols[protocol].proto_name))
 					choice = i;
-					chosen_level = supported_protocols[protocol].protocol_level;
-				}
 				i++;
 			}
 		if(choice != -1)
@@ -667,7 +699,7 @@
 
 	if(choice != -1) {
 		fstrcpy(remote_proto,supported_protocols[protocol].short_name);
-		reload_services(sconn, conn_snum_used, true);
+		reload_services(sconn->msg_ctx, sconn->sock, True);
 		supported_protocols[protocol].proto_reply_fn(req, choice);
 		DEBUG(3,("Selected protocol %s\n",supported_protocols[protocol].proto_name));
 	} else {
@@ -678,15 +710,14 @@
 
 	DEBUG( 5, ( "negprot index=%d\n", choice ) );
 
-	if ((lp_server_signing() == SMB_SIGNING_REQUIRED)
-	    && (chosen_level < PROTOCOL_NT1)) {
+	if ((lp_server_signing() == Required) && (get_Protocol() < PROTOCOL_NT1)) {
 		exit_server_cleanly("SMB signing is required and "
 			"client negotiated a downlevel protocol");
 	}
 
 	TALLOC_FREE(cliprotos);
 
-	if (lp_async_smb_echo_handler() && (chosen_level < PROTOCOL_SMB2_02) &&
+	if (lp_async_smb_echo_handler() && (get_Protocol() < PROTOCOL_SMB2) &&
 	    !fork_echo_handler(sconn)) {
 		exit_server("Failed to fork echo handler");
 	}
Only in ../../samba-3.6.24/source3/smbd: negprot.o
Only in ../../samba-3.6.24/source3/smbd: noquotas.c
diff -ur smbd/notify.c ../../samba-3.6.24/source3/smbd/notify.c
--- smbd/notify.c	2012-10-02 16:24:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/notify.c	2015-01-28 10:52:25.149068676 +0800
@@ -24,26 +24,6 @@
 #include "smbd/globals.h"
 #include "../librpc/gen_ndr/ndr_notify.h"
 
-struct notify_change_buf {
-	/*
-	 * If no requests are pending, changes are queued here. Simple array,
-	 * we only append.
-	 */
-
-	/*
-	 * num_changes == -1 means that we have got a catch-all change, when
-	 * asked we just return NT_STATUS_OK without specific changes.
-	 */
-	int num_changes;
-	struct notify_change *changes;
-
-	/*
-	 * If no changes are around requests are queued here. Using a linked
-	 * list, because we have to append at the end and delete from the top.
-	 */
-	struct notify_change_request *requests;
-};
-
 struct notify_change_request {
 	struct notify_change_request *prev, *next;
 	struct files_struct *fsp;	/* backpointer for cancel by mid */
@@ -59,23 +39,6 @@
 
 static void notify_fsp(files_struct *fsp, uint32 action, const char *name);
 
-bool change_notify_fsp_has_changes(struct files_struct *fsp)
-{
-	if (fsp == NULL) {
-		return false;
-	}
-
-	if (fsp->notify == NULL) {
-		return false;
-	}
-
-	if (fsp->notify->num_changes == 0) {
-		return false;
-	}
-
-	return true;
-}
-
 /*
  * For NTCancel, we need to find the notify_change_request indexed by
  * mid. Separate list here.
@@ -211,73 +174,41 @@
 	notify_fsp(fsp, e->action, e->path);
 }
 
-static void sys_notify_callback(struct sys_notify_context *ctx,
-				void *private_data,
-				struct notify_event *e)
-{
-	files_struct *fsp = (files_struct *)private_data;
-	DEBUG(10, ("sys_notify_callback called for %s\n", fsp_str_dbg(fsp)));
-	notify_fsp(fsp, e->action, e->path);
-}
-
 NTSTATUS change_notify_create(struct files_struct *fsp, uint32 filter,
 			      bool recursive)
 {
 	char *fullpath;
-	size_t len;
-	uint32_t subdir_filter;
-	NTSTATUS status = NT_STATUS_NOT_IMPLEMENTED;
+	struct notify_entry e;
+	NTSTATUS status;
 
-	if (fsp->notify != NULL) {
-		DEBUG(1, ("change_notify_create: fsp->notify != NULL, "
-			  "fname = %s\n", fsp->fsp_name->base_name));
-		return NT_STATUS_INVALID_PARAMETER;
-	}
+	SMB_ASSERT(fsp->notify == NULL);
 
-	if (!(fsp->notify = talloc_zero(NULL, struct notify_change_buf))) {
+	if (!(fsp->notify = TALLOC_ZERO_P(NULL, struct notify_change_buf))) {
 		DEBUG(0, ("talloc failed\n"));
 		return NT_STATUS_NO_MEMORY;
 	}
 
 	/* Do notify operations on the base_name. */
-	fullpath = talloc_asprintf(
-		talloc_tos(), "%s/%s", fsp->conn->connectpath,
-		fsp->fsp_name->base_name);
-	if (fullpath == NULL) {
-		DEBUG(0, ("talloc_asprintf failed\n"));
+	if (asprintf(&fullpath, "%s/%s", fsp->conn->connectpath,
+		     fsp->fsp_name->base_name) == -1) {
+		DEBUG(0, ("asprintf failed\n"));
 		TALLOC_FREE(fsp->notify);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/*
-	 * Avoid /. at the end of the path name. notify can't deal with it.
-	 */
-	len = strlen(fullpath);
-	if (len > 1 && fullpath[len-1] == '.' && fullpath[len-2] == '/') {
-		fullpath[len-2] = '\0';
+	ZERO_STRUCT(e);
+	e.path = fullpath;
+	e.dir_fd = fsp->fh->fd;
+	e.dir_id = fsp->file_id;
+	e.filter = filter;
+	e.subdir_filter = 0;
+	if (recursive) {
+		e.subdir_filter = filter;
 	}
 
-	subdir_filter = recursive ? filter : 0;
+	status = notify_add(fsp->conn->notify_ctx, &e, notify_callback, fsp);
+	SAFE_FREE(fullpath);
 
-	if (fsp->conn->sconn->sys_notify_ctx != NULL) {
-		void *sys_notify_handle = NULL;
-
-		status = SMB_VFS_NOTIFY_WATCH(
-			fsp->conn, fsp->conn->sconn->sys_notify_ctx,
-			fullpath, &filter, &subdir_filter,
-			sys_notify_callback, fsp, &sys_notify_handle);
-
-		if (NT_STATUS_IS_OK(status)) {
-			talloc_steal(fsp->notify, sys_notify_handle);
-		}
-	}
-
-	if ((filter != 0) || (subdir_filter != 0)) {
-		status = notify_add(fsp->conn->sconn->notify_ctx,
-				    fullpath, filter, subdir_filter,
-				    notify_callback, fsp);
-	}
-	TALLOC_FREE(fullpath);
 	return status;
 }
 
@@ -414,22 +345,60 @@
 	}
 }
 
+static void notify_parent_dir(connection_struct *conn,
+			      uint32 action, uint32 filter,
+			      const char *path)
+{
+	struct smb_filename smb_fname_parent;
+	char *parent;
+	const char *name;
+	char *oldwd;
+
+	if (!parent_dirname(talloc_tos(), path, &parent, &name)) {
+		return;
+	}
+
+	ZERO_STRUCT(smb_fname_parent);
+	smb_fname_parent.base_name = parent;
+
+	oldwd = vfs_GetWd(parent, conn);
+	if (oldwd == NULL) {
+		goto done;
+	}
+	if (vfs_ChDir(conn, conn->connectpath) == -1) {
+		goto done;
+	}
+
+	if (SMB_VFS_STAT(conn, &smb_fname_parent) == -1) {
+		goto chdir_done;
+	}
+
+	notify_onelevel(conn->notify_ctx, action, filter,
+			SMB_VFS_FILE_ID_CREATE(conn, &smb_fname_parent.st),
+			name);
+chdir_done:
+	vfs_ChDir(conn, oldwd);
+done:
+	TALLOC_FREE(parent);
+}
+
 void notify_fname(connection_struct *conn, uint32 action, uint32 filter,
 		  const char *path)
 {
-	struct notify_context *notify_ctx = conn->sconn->notify_ctx;
 	char *fullpath;
 
 	if (path[0] == '.' && path[1] == '/') {
 		path += 2;
 	}
+	notify_parent_dir(conn, action, filter, path);
+
 	fullpath = talloc_asprintf(talloc_tos(), "%s/%s", conn->connectpath,
 				   path);
 	if (fullpath == NULL) {
 		DEBUG(0, ("asprintf failed\n"));
 		return;
 	}
-	notify_trigger(notify_ctx, action, filter, fullpath);
+	notify_trigger(conn->notify_ctx, action, filter, fullpath);
 	TALLOC_FREE(fullpath);
 }
 
@@ -479,7 +448,7 @@
 		return;
 	}
 
-	if (!(changes = talloc_realloc(
+	if (!(changes = TALLOC_REALLOC_ARRAY(
 		      fsp->notify, fsp->notify->changes,
 		      struct notify_change, fsp->notify->num_changes+1))) {
 		DEBUG(0, ("talloc_realloc failed\n"));
@@ -569,17 +538,31 @@
 	return result;
 }
 
-struct sys_notify_context *sys_notify_context_create(TALLOC_CTX *mem_ctx,
+struct sys_notify_context *sys_notify_context_create(connection_struct *conn,
+						     TALLOC_CTX *mem_ctx, 
 						     struct event_context *ev)
 {
 	struct sys_notify_context *ctx;
 
-	if (!(ctx = talloc(mem_ctx, struct sys_notify_context))) {
+	if (!(ctx = TALLOC_P(mem_ctx, struct sys_notify_context))) {
 		DEBUG(0, ("talloc failed\n"));
 		return NULL;
 	}
 
 	ctx->ev = ev;
+	ctx->conn = conn;
 	ctx->private_data = NULL;
 	return ctx;
 }
+
+NTSTATUS sys_notify_watch(struct sys_notify_context *ctx,
+			  struct notify_entry *e,
+			  void (*callback)(struct sys_notify_context *ctx, 
+					   void *private_data,
+					   struct notify_event *ev),
+			  void *private_data, void *handle)
+{
+	return SMB_VFS_NOTIFY_WATCH(ctx->conn, ctx, e, callback, private_data,
+				    handle);
+}
+
diff -ur smbd/notify_inotify.c ../../samba-3.6.24/source3/smbd/notify_inotify.c
--- smbd/notify_inotify.c	2012-10-02 16:24:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/notify_inotify.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,9 +27,45 @@
 
 #ifdef HAVE_INOTIFY
 
+#if HAVE_SYS_INOTIFY_H
 #include <sys/inotify.h>
+#else
 
-/* glibc < 2.5 headers don't have these defines */
+#ifdef HAVE_ASM_TYPES_H
+#include <asm/types.h>
+#endif
+
+#ifndef HAVE_INOTIFY_INIT
+
+#include <linux/inotify.h>
+#include <asm/unistd.h>
+
+
+/*
+  glibc doesn't define these functions yet (as of March 2006)
+*/
+static int inotify_init(void)
+{
+	return syscall(__NR_inotify_init);
+}
+
+static int inotify_add_watch(int fd, const char *path, __u32 mask)
+{
+	return syscall(__NR_inotify_add_watch, fd, path, mask);
+}
+
+static int inotify_rm_watch(int fd, int wd)
+{
+	return syscall(__NR_inotify_rm_watch, fd, wd);
+}
+#else
+
+#include <sys/inotify.h>
+
+#endif
+#endif
+
+/* older glibc headers don't have these defines either */
 #ifndef IN_ONLYDIR
 #define IN_ONLYDIR 0x01000000
 #endif
@@ -292,14 +328,14 @@
 	{FILE_NOTIFY_CHANGE_SECURITY,    IN_ATTRIB}
 };
 
-static uint32_t inotify_map(uint32_t *filter)
+static uint32_t inotify_map(struct notify_entry *e)
 {
 	int i;
 	uint32_t out=0;
 	for (i=0;i<ARRAY_SIZE(inotify_mapping);i++) {
-		if (inotify_mapping[i].notify_mask & *filter) {
+		if (inotify_mapping[i].notify_mask & e->filter) {
 			out |= inotify_mapping[i].inotify_mask;
-			*filter &= ~inotify_mapping[i].notify_mask;
+			e->filter &= ~inotify_mapping[i].notify_mask;
 		}
 	}
 	return out;
@@ -335,9 +371,7 @@
   talloc_free() on *handle
 */
 NTSTATUS inotify_watch(struct sys_notify_context *ctx,
-		       const char *path,
-		       uint32_t *filter,
-		       uint32_t *subdir_filter,
+		       struct notify_entry *e,
 		       void (*callback)(struct sys_notify_context *ctx, 
 					void *private_data,
 					struct notify_event *ev),
@@ -348,7 +382,7 @@
 	int wd;
 	uint32_t mask;
 	struct inotify_watch_context *w;
-	uint32_t orig_filter = *filter;
+	uint32_t filter = e->filter;
 	void **handle = (void **)handle_p;
 
 	/* maybe setup the inotify fd */
@@ -360,31 +394,31 @@
 
 	in = talloc_get_type(ctx->private_data, struct inotify_private);
 
-	mask = inotify_map(filter);
+	mask = inotify_map(e);
 	if (mask == 0) {
 		/* this filter can't be handled by inotify */
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
 	/* using IN_MASK_ADD allows us to cope with inotify() returning the same
-	   watch descriptor for multiple watches on the same path */
+	   watch descriptor for muliple watches on the same path */
 	mask |= (IN_MASK_ADD | IN_ONLYDIR);
 
 	/* get a new watch descriptor for this path */
-	wd = inotify_add_watch(in->fd, path, mask);
+	wd = inotify_add_watch(in->fd, e->path, mask);
 	if (wd == -1) {
-		*filter = orig_filter;
+		e->filter = filter;
 		DEBUG(1, ("inotify_add_watch returned %s\n", strerror(errno)));
 		return map_nt_error_from_unix(errno);
 	}
 
 	DEBUG(10, ("inotify_add_watch for %s mask %x returned wd %d\n",
-		   path, mask, wd));
+		   e->path, mask, wd));
 
 	w = talloc(in, struct inotify_watch_context);
 	if (w == NULL) {
 		inotify_rm_watch(in->fd, wd);
-		*filter = orig_filter;
+		e->filter = filter;
 		return NT_STATUS_NO_MEMORY;
 	}
 
@@ -393,11 +427,11 @@
 	w->callback = callback;
 	w->private_data = private_data;
 	w->mask = mask;
-	w->filter = orig_filter;
-	w->path = talloc_strdup(w, path);
+	w->filter = filter;
+	w->path = talloc_strdup(w, e->path);
 	if (w->path == NULL) {
 		inotify_rm_watch(in->fd, wd);
-		*filter = orig_filter;
+		e->filter = filter;
 		return NT_STATUS_NO_MEMORY;
 	}
 
Only in ../../samba-3.6.24/source3/smbd: notify_inotify.o
diff -ur smbd/notify_internal.c ../../samba-3.6.24/source3/smbd/notify_internal.c
--- smbd/notify_internal.c	2012-10-02 16:24:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/notify_internal.c	2015-01-28 10:52:25.149068676 +0800
@@ -1,8 +1,7 @@
-/*
+/* 
    Unix SMB/CIFS implementation.
 
    Copyright (C) Andrew Tridgell 2006
-   Copyright (C) Volker Lendecke 2012
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -27,1202 +26,1002 @@
 #include "includes.h"
 #include "system/filesys.h"
 #include "librpc/gen_ndr/ndr_notify.h"
-#include "dbwrap/dbwrap.h"
-#include "dbwrap/dbwrap_open.h"
-#include "dbwrap/dbwrap_tdb.h"
+#include "dbwrap.h"
 #include "smbd/smbd.h"
 #include "messages.h"
-#include "lib/tdb_wrap/tdb_wrap.h"
+#include "lib/util/tdb_wrap.h"
 #include "util_tdb.h"
-#include "lib/param/param.h"
-#include "lib/dbwrap/dbwrap_cache.h"
-#include "ctdb_srvids.h"
-#include "ctdbd_conn.h"
-#include "ctdb_conn.h"
-#include "lib/util/tevent_unix.h"
+
+struct notify_context {
+	struct db_context *db_recursive;
+	struct db_context *db_onelevel;
+	struct server_id server;
+	struct messaging_context *messaging_ctx;
+	struct notify_list *list;
+	struct notify_array *array;
+	int seqnum;
+	struct sys_notify_context *sys_notify_ctx;
+	TDB_DATA key;
+};
+
 
 struct notify_list {
 	struct notify_list *next, *prev;
-	const char *path;
-	void (*callback)(void *, const struct notify_event *);
 	void *private_data;
+	void (*callback)(void *, const struct notify_event *);
+	void *sys_notify_handle;
+	int depth;
 };
 
-struct notify_context {
-	struct messaging_context *msg;
-	struct notify_list *list;
+#define NOTIFY_KEY "notify array"
 
-	/*
-	 * The notify database is split up into two databases: One
-	 * relatively static index db and the real notify db with the
-	 * volatile entries.
-	 */
+#define NOTIFY_ENABLE		"notify:enable"
+#define NOTIFY_ENABLE_DEFAULT	True
 
-	/*
-	 * "db_notify" is indexed by pathname. Per record it stores an
-	 * array of notify_db_entry structs. These represent the
-	 * notify records as requested by the smb client. This
-	 * database is always held locally, it is never clustered.
-	 */
-	struct db_context *db_notify;
+static NTSTATUS notify_remove_all(struct notify_context *notify,
+				  const struct server_id *server);
+static void notify_handler(struct messaging_context *msg_ctx, void *private_data, 
+			   uint32_t msg_type, struct server_id server_id, DATA_BLOB *data);
 
-	/*
-	 * "db_index" is indexed by pathname. The records are an array
-	 * of VNNs which have any interest in notifies for this path
-	 * name.
-	 *
-	 * In the non-clustered case this database is cached in RAM by
-	 * means of db_cache_open, which maintains a cache per
-	 * process. Cache consistency is maintained by the tdb
-	 * sequence number.
-	 *
-	 * In the clustered case right now we can not use the tdb
-	 * sequence number, but by means of read only records we
-	 * should be able to avoid a lot of full migrations.
-	 *
-	 * In both cases, it is important to keep the update
-	 * operations to db_index to a minimum. This is achieved by
-	 * delayed deletion. When a db_notify is initially created,
-	 * the db_index record is also created. When more notifies are
-	 * add for a path, then only the db_notify record needs to be
-	 * modified, the db_index record is not touched. When the last
-	 * entry from the db_notify record is deleted, the db_index
-	 * record is not immediately deleted. Instead, the db_notify
-	 * record is replaced with a current timestamp. A regular
-	 * cleanup process will delete all db_index records that are
-	 * older than a minute.
-	 */
-	struct db_context *db_index;
-};
+/*
+  destroy the notify context
+*/
+static int notify_destructor(struct notify_context *notify)
+{
+	messaging_deregister(notify->messaging_ctx, MSG_PVFS_NOTIFY, notify);
+
+	if (notify->list != NULL) {
+		notify_remove_all(notify, &notify->server);
+	}
 
-static void notify_trigger_local(struct notify_context *notify,
-				 uint32_t action, uint32_t filter,
-				 const char *path, size_t path_len,
-				 bool recursive);
-static NTSTATUS notify_send(struct notify_context *notify,
-			    struct server_id *pid,
-			    const char *path, uint32_t action,
-			    void *private_data);
-static NTSTATUS notify_add_entry(struct db_record *rec,
-				 const struct notify_db_entry *e,
-				 bool *p_add_idx);
-static NTSTATUS notify_add_idx(struct db_record *rec, uint32_t vnn);
-
-static NTSTATUS notify_del_entry(struct db_record *rec,
-				 const struct server_id *pid,
-				 void *private_data);
-static NTSTATUS notify_del_idx(struct db_record *rec, uint32_t vnn);
-
-static int notify_context_destructor(struct notify_context *notify);
-
-static void notify_handler(struct messaging_context *msg_ctx,
-			   void *private_data, uint32_t msg_type,
-			   struct server_id server_id, DATA_BLOB *data);
-
-struct notify_context *notify_init(TALLOC_CTX *mem_ctx,
-				   struct messaging_context *msg,
-				   struct event_context *ev)
+	return 0;
+}
+
+/*
+  Open up the notify.tdb database. You should close it down using
+  talloc_free(). We need the messaging_ctx to allow for notifications
+  via internal messages
+*/
+struct notify_context *notify_init(TALLOC_CTX *mem_ctx, struct server_id server, 
+				   struct messaging_context *messaging_ctx,
+				   struct event_context *ev,
+				   connection_struct *conn)
 {
-	struct loadparm_context *lp_ctx;
 	struct notify_context *notify;
 
+	if (!lp_change_notify(conn->params)) {
+		return NULL;
+	}
+
 	notify = talloc(mem_ctx, struct notify_context);
 	if (notify == NULL) {
-		goto fail;
+		return NULL;
 	}
-	notify->msg = msg;
-	notify->list = NULL;
 
-	lp_ctx = loadparm_init_s3(notify, loadparm_s3_helpers());
-	notify->db_notify = db_open_tdb(
-		notify, lp_ctx, lock_path("notify.tdb"),
-		0, TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
-		O_RDWR|O_CREAT, 0644, DBWRAP_LOCK_ORDER_2);
-		talloc_unlink(notify, lp_ctx);
-	if (notify->db_notify == NULL) {
-		goto fail;
-	}
-	notify->db_index = db_open(
-		notify, lock_path("notify_index.tdb"),
-		0, TDB_SEQNUM|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
-		O_RDWR|O_CREAT, 0644, DBWRAP_LOCK_ORDER_3);
-	if (notify->db_index == NULL) {
-		goto fail;
-	}
-	if (!lp_clustering()) {
-		notify->db_index = db_open_cache(notify, notify->db_index);
-		if (notify->db_index == NULL) {
-			goto fail;
-		}
+	notify->db_recursive = db_open(notify, lock_path("notify.tdb"),
+				       0, TDB_SEQNUM|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+				       O_RDWR|O_CREAT, 0644);
+	if (notify->db_recursive == NULL) {
+		talloc_free(notify);
+		return NULL;
 	}
 
-	if (notify->msg != NULL) {
-		NTSTATUS status;
-
-		status = messaging_register(notify->msg, notify,
-					    MSG_PVFS_NOTIFY, notify_handler);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(1, ("messaging_register returned %s\n",
-				  nt_errstr(status)));
-			goto fail;
-		}
+	notify->db_onelevel = db_open(notify, lock_path("notify_onelevel.tdb"),
+				      0, TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+				      O_RDWR|O_CREAT, 0644);
+	if (notify->db_onelevel == NULL) {
+		talloc_free(notify);
+		return NULL;
 	}
 
-	talloc_set_destructor(notify, notify_context_destructor);
-
-	return notify;
-fail:
-	TALLOC_FREE(notify);
-	return NULL;
-}
+	notify->server = server;
+	notify->messaging_ctx = messaging_ctx;
+	notify->list = NULL;
+	notify->array = NULL;
+	notify->seqnum = notify->db_recursive->get_seqnum(
+		notify->db_recursive);
+	notify->key = string_term_tdb_data(NOTIFY_KEY);
+
+	talloc_set_destructor(notify, notify_destructor);
+
+	/* register with the messaging subsystem for the notify
+	   message type */
+	messaging_register(notify->messaging_ctx, notify, 
+			   MSG_PVFS_NOTIFY, notify_handler);
 
-static int notify_context_destructor(struct notify_context *notify)
-{
-	DEBUG(10, ("notify_context_destructor called\n"));
+	notify->sys_notify_ctx = sys_notify_context_create(conn, notify, ev);
 
-	if (notify->msg != NULL) {
-		messaging_deregister(notify->msg, MSG_PVFS_NOTIFY, notify);
-	}
-
-	while (notify->list != NULL) {
-		DEBUG(10, ("Removing private_data=%p\n",
-			   notify->list->private_data));
-		notify_remove(notify, notify->list->private_data);
-	}
-	return 0;
+	return notify;
 }
 
-NTSTATUS notify_add(struct notify_context *notify,
-		    const char *path, uint32_t filter, uint32_t subdir_filter,
-		    void (*callback)(void *, const struct notify_event *),
-		    void *private_data)
+bool notify_internal_parent_init(TALLOC_CTX *mem_ctx)
 {
-	struct notify_db_entry e;
-	struct notify_list *listel;
-	struct db_record *notify_rec, *idx_rec;
-	bool add_idx;
-	NTSTATUS status;
-	TDB_DATA key, notify_copy;
-
-	if (notify == NULL) {
-		return NT_STATUS_NOT_IMPLEMENTED;
-	}
-
-	DEBUG(10, ("notify_add: path=[%s], private_data=%p\n", path,
-		   private_data));
-
-	listel = talloc(notify, struct notify_list);
-	if (listel == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	listel->callback = callback;
-	listel->private_data = private_data;
-	listel->path = talloc_strdup(listel, path);
-	if (listel->path == NULL) {
-		TALLOC_FREE(listel);
-		return NT_STATUS_NO_MEMORY;
-	}
-	DLIST_ADD(notify->list, listel);
+	struct tdb_wrap *db1, *db2;
 
-	ZERO_STRUCT(e);
-	e.filter = filter;
-	e.subdir_filter = subdir_filter;
-	e.server = messaging_server_id(notify->msg);
-	e.private_data = private_data;
-
-	key = string_tdb_data(path);
-
-	notify_rec = dbwrap_fetch_locked(notify->db_notify,
-					 talloc_tos(), key);
-	if (notify_rec == NULL) {
-		status = NT_STATUS_INTERNAL_DB_CORRUPTION;
-		goto fail;
+	if (lp_clustering()) {
+		return true;
 	}
 
 	/*
-	 * Make a copy of the notify_rec for easy restore in case
-	 * updating the index_rec fails;
+	 * Open the tdbs in the parent process (smbd) so that our
+	 * CLEAR_IF_FIRST optimization in tdb_reopen_all can properly
+	 * work.
 	 */
-	notify_copy = dbwrap_record_get_value(notify_rec);
-	if (notify_copy.dsize != 0) {
-		notify_copy.dptr = (uint8_t *)talloc_memdup(
-			notify_rec, notify_copy.dptr,
-			notify_copy.dsize);
-		if (notify_copy.dptr == NULL) {
-			TALLOC_FREE(notify_rec);
-			status = NT_STATUS_NO_MEMORY;
-			goto fail;
-		}
-	}
 
-	if (DEBUGLEVEL >= 10) {
-		NDR_PRINT_DEBUG(notify_db_entry, &e);
-	}
-
-	status = notify_add_entry(notify_rec, &e, &add_idx);
-	if (!NT_STATUS_IS_OK(status)) {
-		goto fail;
+	db1 = tdb_wrap_open(mem_ctx, lock_path("notify.tdb"),
+			    0, TDB_SEQNUM|TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH,
+			   O_RDWR|O_CREAT, 0644);
+	if (db1 == NULL) {
+		DEBUG(1, ("could not open notify.tdb: %s\n", strerror(errno)));
+		return false;
 	}
-	if (!add_idx) {
-		/*
-		 * Someone else has added the idx entry already
-		 */
-		TALLOC_FREE(notify_rec);
-		return NT_STATUS_OK;
+	db2 = tdb_wrap_open(mem_ctx, lock_path("notify_onelevel.tdb"),
+			    0, TDB_CLEAR_IF_FIRST|TDB_INCOMPATIBLE_HASH, O_RDWR|O_CREAT, 0644);
+	if (db2 == NULL) {
+		DEBUG(1, ("could not open notify_onelevel.tdb: %s\n",
+			  strerror(errno)));
+		TALLOC_FREE(db1);
+		return false;
 	}
+	return true;
+}
 
-	idx_rec = dbwrap_fetch_locked(notify->db_index,
-				      talloc_tos(), key);
-	if (idx_rec == NULL) {
-		status = NT_STATUS_INTERNAL_DB_CORRUPTION;
-		goto restore_notify;
-	}
-	status = notify_add_idx(idx_rec, get_my_vnn());
-	if (!NT_STATUS_IS_OK(status)) {
-		goto restore_notify;
+/*
+  lock and fetch the record
+*/
+static NTSTATUS notify_fetch_locked(struct notify_context *notify, struct db_record **rec)
+{
+	*rec = notify->db_recursive->fetch_locked(notify->db_recursive,
+						  notify, notify->key);
+	if (*rec == NULL) {
+		return NT_STATUS_INTERNAL_DB_CORRUPTION;
 	}
-
-	TALLOC_FREE(idx_rec);
-	TALLOC_FREE(notify_rec);
 	return NT_STATUS_OK;
-
-restore_notify:
-	if (notify_copy.dsize != 0) {
-		dbwrap_record_store(notify_rec, notify_copy, 0);
-	} else {
-		dbwrap_record_delete(notify_rec);
-	}
-	TALLOC_FREE(notify_rec);
-fail:
-	DLIST_REMOVE(notify->list, listel);
-	TALLOC_FREE(listel);
-	return status;
 }
 
-static NTSTATUS notify_add_entry(struct db_record *rec,
-				 const struct notify_db_entry *e,
-				 bool *p_add_idx)
+/*
+  load the notify array
+*/
+static NTSTATUS notify_load(struct notify_context *notify, struct db_record *rec)
 {
-	TDB_DATA value = dbwrap_record_get_value(rec);
-	struct notify_db_entry *entries;
-	size_t num_entries;
-	bool add_idx = true;
+	TDB_DATA dbuf;
+	DATA_BLOB blob;
 	NTSTATUS status;
+	int seqnum;
 
-	if (value.dsize == sizeof(time_t)) {
-		DEBUG(10, ("Re-using deleted entry\n"));
-		value.dsize = 0;
-		add_idx = false;
-	}
+	seqnum = notify->db_recursive->get_seqnum(notify->db_recursive);
 
-	if ((value.dsize % sizeof(struct notify_db_entry)) != 0) {
-		DEBUG(1, ("Invalid value.dsize = %u\n",
-			  (unsigned)value.dsize));
-		return NT_STATUS_INTERNAL_DB_CORRUPTION;
+	if (seqnum == notify->seqnum && notify->array != NULL) {
+		return NT_STATUS_OK;
 	}
-	num_entries = value.dsize / sizeof(struct notify_db_entry);
 
-	if (num_entries != 0) {
-		add_idx = false;
-	}
+	notify->seqnum = seqnum;
 
-	entries = talloc_array(rec, struct notify_db_entry, num_entries + 1);
-	if (entries == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	talloc_free(notify->array);
+	notify->array = TALLOC_ZERO_P(notify, struct notify_array);
+	NT_STATUS_HAVE_NO_MEMORY(notify->array);
+
+	if (!rec) {
+		if (notify->db_recursive->fetch(notify->db_recursive, notify,
+						notify->key, &dbuf) != 0) {
+			return NT_STATUS_INTERNAL_DB_CORRUPTION;
+		}
+	} else {
+		dbuf = rec->value;
 	}
-	memcpy(entries, value.dptr, value.dsize);
 
-	entries[num_entries] = *e;
-	value = make_tdb_data((uint8_t *)entries, talloc_get_size(entries));
-	status = dbwrap_record_store(rec, value, 0);
-	TALLOC_FREE(entries);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-	*p_add_idx = add_idx;
-	return NT_STATUS_OK;
-}
+	blob.data = (uint8 *)dbuf.dptr;
+	blob.length = dbuf.dsize;
 
-static NTSTATUS notify_add_idx(struct db_record *rec, uint32_t vnn)
-{
-	TDB_DATA value = dbwrap_record_get_value(rec);
-	uint32_t *vnns;
-	size_t i, num_vnns;
-	NTSTATUS status;
-
-	if ((value.dsize % sizeof(uint32_t)) != 0) {
-		DEBUG(1, ("Invalid value.dsize = %u\n",
-			  (unsigned)value.dsize));
-		return NT_STATUS_INTERNAL_DB_CORRUPTION;
-	}
-	num_vnns = value.dsize / sizeof(uint32_t);
-	vnns = (uint32_t *)value.dptr;
+	status = NT_STATUS_OK;
+	if (blob.length > 0) {
+		enum ndr_err_code ndr_err;
+		ndr_err = ndr_pull_struct_blob(&blob, notify->array, notify->array,
+					       (ndr_pull_flags_fn_t)ndr_pull_notify_array);
+		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+			/* 1. log that we got a corrupt notify_array
+			 * 2. clear the variable the garbage was stored into to not trip
+			 *  over it next time this method is entered with the same seqnum
+			 * 3. delete it from the database */
+			DEBUG(2, ("notify_array is corrupt, discarding it\n"));
+
+			ZERO_STRUCTP(notify->array);
+			if (rec != NULL) {
+				rec->delete_rec(rec);
+			}
 
-	for (i=0; i<num_vnns; i++) {
-		if (vnns[i] == vnn) {
-			return NT_STATUS_OK;
-		}
-		if (vnns[i] > vnn) {
-			break;
+		} else {
+			if (DEBUGLEVEL >= 10) {
+				DEBUG(10, ("notify_load:\n"));
+				NDR_PRINT_DEBUG(notify_array, notify->array);
+			}
 		}
 	}
 
-	value.dptr = (uint8_t *)talloc_realloc(
-		rec, value.dptr, uint32_t, num_vnns + 1);
-	if (value.dptr == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	value.dsize = talloc_get_size(value.dptr);
 
-	vnns = (uint32_t *)value.dptr;
+	if (!rec) {
+		talloc_free(dbuf.dptr);
+	}
 
-	memmove(&vnns[i+1], &vnns[i], sizeof(uint32_t) * (num_vnns - i));
-	vnns[i] = vnn;
+	return status;
+}
 
-	status = dbwrap_record_store(rec, value, 0);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-	return NT_STATUS_OK;
+/*
+  compare notify entries for sorting
+*/
+static int notify_compare(const struct notify_entry *e1, const struct notify_entry *e2)
+{
+	return strcmp(e1->path, e2->path);
 }
 
-NTSTATUS notify_remove(struct notify_context *notify, void *private_data)
+/*
+  save the notify array
+*/
+static NTSTATUS notify_save(struct notify_context *notify, struct db_record *rec)
 {
-	struct server_id pid;
-	struct notify_list *listel;
-	struct db_record *notify_rec;
+	TDB_DATA dbuf;
+	DATA_BLOB blob;
 	NTSTATUS status;
+	enum ndr_err_code ndr_err;
+	TALLOC_CTX *tmp_ctx;
 
-	if ((notify == NULL) || (notify->msg == NULL)) {
-		return NT_STATUS_NOT_IMPLEMENTED;
+	/* if possible, remove some depth arrays */
+	while (notify->array->num_depths > 0 &&
+	       notify->array->depth[notify->array->num_depths-1].num_entries == 0) {
+		notify->array->num_depths--;
 	}
 
-	DEBUG(10, ("notify_remove: private_data=%p\n", private_data));
+	/* we might just be able to delete the record */
+	if (notify->array->num_depths == 0) {
+		return rec->delete_rec(rec);
+	}
 
-	pid = messaging_server_id(notify->msg);
+	tmp_ctx = talloc_new(notify);
+	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
 
-	for (listel=notify->list;listel;listel=listel->next) {
-		if (listel->private_data == private_data) {
-			DLIST_REMOVE(notify->list, listel);
-			break;
-		}
-	}
-	if (listel == NULL) {
-		DEBUG(10, ("%p not found\n", private_data));
-		return NT_STATUS_NOT_FOUND;
-	}
-	notify_rec = dbwrap_fetch_locked(notify->db_notify, talloc_tos(),
-					 string_tdb_data(listel->path));
-	TALLOC_FREE(listel);
-	if (notify_rec == NULL) {
-		return NT_STATUS_INTERNAL_DB_CORRUPTION;
+	ndr_err = ndr_push_struct_blob(&blob, tmp_ctx, notify->array,
+				      (ndr_push_flags_fn_t)ndr_push_notify_array);
+	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		talloc_free(tmp_ctx);
+		return ndr_map_error2ntstatus(ndr_err);
 	}
-	status = notify_del_entry(notify_rec, &pid, private_data);
-	DEBUG(10, ("del_entry returned %s\n", nt_errstr(status)));
-	TALLOC_FREE(notify_rec);
-	return status;
-}
 
-static NTSTATUS notify_del_entry(struct db_record *rec,
-				 const struct server_id *pid,
-				 void *private_data)
-{
-	TDB_DATA value = dbwrap_record_get_value(rec);
-	struct notify_db_entry *entries;
-	size_t i, num_entries;
-	time_t now;
-
-	DEBUG(10, ("del_entry called for %s %p\n", procid_str_static(pid),
-		   private_data));
-
-	if ((value.dsize % sizeof(struct notify_db_entry)) != 0) {
-		DEBUG(1, ("Invalid value.dsize = %u\n",
-			  (unsigned)value.dsize));
-		return NT_STATUS_INTERNAL_DB_CORRUPTION;
+	if (DEBUGLEVEL >= 10) {
+		DEBUG(10, ("notify_save:\n"));
+		NDR_PRINT_DEBUG(notify_array, notify->array);
 	}
-	num_entries = value.dsize / sizeof(struct notify_db_entry);
-	entries = (struct notify_db_entry *)value.dptr;
 
-	for (i=0; i<num_entries; i++) {
-		struct notify_db_entry *e = &entries[i];
+	dbuf.dptr = blob.data;
+	dbuf.dsize = blob.length;
 
-		if (DEBUGLEVEL >= 10) {
-			NDR_PRINT_DEBUG(notify_db_entry, e);
-		}
+	status = rec->store(rec, dbuf, TDB_REPLACE);
+	talloc_free(tmp_ctx);
 
-		if (e->private_data != private_data) {
-			continue;
-		}
-		if (serverid_equal(&e->server, pid)) {
-			break;
-		}
-	}
-	if (i == num_entries) {
-		return NT_STATUS_NOT_FOUND;
-	}
-	entries[i] = entries[num_entries-1];
-	value.dsize -= sizeof(struct notify_db_entry);
-
-	if (value.dsize == 0) {
-		now = time(NULL);
-		value.dptr = (uint8_t *)&now;
-		value.dsize = sizeof(now);
-	}
-	return dbwrap_record_store(rec, value, 0);
+	return status;
 }
 
-struct notify_trigger_index_state {
-	TALLOC_CTX *mem_ctx;
-	uint32_t *vnns;
-	uint32_t my_vnn;
-	bool found_my_vnn;
-};
 
-static void notify_trigger_index_parser(TDB_DATA key, TDB_DATA data,
-					void *private_data)
+/*
+  handle incoming notify messages
+*/
+static void notify_handler(struct messaging_context *msg_ctx, void *private_data, 
+			   uint32_t msg_type, struct server_id server_id, DATA_BLOB *data)
 {
-	struct notify_trigger_index_state *state =
-		(struct notify_trigger_index_state *)private_data;
-	uint32_t *new_vnns;
-	size_t i, num_vnns, num_new_vnns;
-
-	if ((data.dsize % sizeof(uint32_t)) != 0) {
-		DEBUG(1, ("Invalid record size in notify index db: %u\n",
-			  (unsigned)data.dsize));
+	struct notify_context *notify = talloc_get_type(private_data, struct notify_context);
+	enum ndr_err_code ndr_err;
+	struct notify_event ev;
+	TALLOC_CTX *tmp_ctx = talloc_new(notify);
+	struct notify_list *listel;
+
+	if (tmp_ctx == NULL) {
 		return;
 	}
-	new_vnns = (uint32_t *)data.dptr;
-	num_new_vnns = data.dsize / sizeof(uint32_t);
 
-	num_vnns = talloc_array_length(state->vnns);
+	ndr_err = ndr_pull_struct_blob(data, tmp_ctx, &ev,
+				       (ndr_pull_flags_fn_t)ndr_pull_notify_event);
+	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		talloc_free(tmp_ctx);
+		return;
+	}
 
-	for (i=0; i<num_new_vnns; i++) {
-		if (new_vnns[i] == state->my_vnn) {
-			state->found_my_vnn = true;
+	for (listel=notify->list;listel;listel=listel->next) {
+		if (listel->private_data == ev.private_data) {
+			listel->callback(listel->private_data, &ev);
+			break;
 		}
 	}
 
-	state->vnns = talloc_realloc(state->mem_ctx, state->vnns, uint32_t,
-				     num_vnns + num_new_vnns);
-	if ((num_vnns + num_new_vnns != 0) && (state->vnns == NULL)) {
-		DEBUG(1, ("talloc_realloc failed\n"));
-		return;
-	}
-	memcpy(&state->vnns[num_vnns], data.dptr, data.dsize);
+	talloc_free(tmp_ctx);	
 }
 
-static int vnn_cmp(const void *p1, const void *p2)
+/*
+  callback from sys_notify telling us about changes from the OS
+*/
+static void sys_notify_callback(struct sys_notify_context *ctx, 
+				void *ptr, struct notify_event *ev)
 {
-	const uint32_t *vnn1 = (const uint32_t *)p1;
-	const uint32_t *vnn2 = (const uint32_t *)p2;
+	struct notify_list *listel = talloc_get_type(ptr, struct notify_list);
+	ev->private_data = listel;
+	DEBUG(10, ("sys_notify_callback called with action=%d, for %s\n",
+		   ev->action, ev->path));
+	listel->callback(listel->private_data, ev);
+}
 
-	if (*vnn1 < *vnn2) {
-		return -1;
-	}
-	if (*vnn1 == *vnn2) {
-		return 0;
+/*
+  add an entry to the notify array
+*/
+static NTSTATUS notify_add_array(struct notify_context *notify, struct db_record *rec,
+				 struct notify_entry *e,
+				 void *private_data, int depth)
+{
+	int i;
+	struct notify_depth *d;
+	struct notify_entry *ee;
+
+	/* possibly expand the depths array */
+	if (depth >= notify->array->num_depths) {
+		d = talloc_realloc(notify->array, notify->array->depth, 
+				   struct notify_depth, depth+1);
+		NT_STATUS_HAVE_NO_MEMORY(d);
+		for (i=notify->array->num_depths;i<=depth;i++) {
+			ZERO_STRUCT(d[i]);
+		}
+		notify->array->depth = d;
+		notify->array->num_depths = depth+1;
+	}
+	d = &notify->array->depth[depth];
+
+	/* expand the entries array */
+	ee = talloc_realloc(notify->array->depth, d->entries, struct notify_entry,
+			    d->num_entries+1);
+	NT_STATUS_HAVE_NO_MEMORY(ee);
+	d->entries = ee;
+
+	d->entries[d->num_entries] = *e;
+	d->entries[d->num_entries].private_data = private_data;
+	d->entries[d->num_entries].server = notify->server;
+	d->entries[d->num_entries].path_len = strlen(e->path);
+	d->num_entries++;
+
+	d->max_mask |= e->filter;
+	d->max_mask_subdir |= e->subdir_filter;
+
+	TYPESAFE_QSORT(d->entries, d->num_entries, notify_compare);
+
+	/* recalculate the maximum masks */
+	d->max_mask = 0;
+	d->max_mask_subdir = 0;
+
+	for (i=0;i<d->num_entries;i++) {
+		d->max_mask |= d->entries[i].filter;
+		d->max_mask_subdir |= d->entries[i].subdir_filter;
 	}
-	return 1;
+
+	return notify_save(notify, rec);
 }
 
-static bool notify_push_remote_blob(TALLOC_CTX *mem_ctx, uint32_t action,
-				    uint32_t filter, const char *path,
-				    uint8_t **pblob, size_t *pblob_len)
+/*
+  Add a non-recursive watch
+*/
+
+static void notify_add_onelevel(struct notify_context *notify,
+				struct notify_entry *e, void *private_data)
 {
-	struct notify_remote_event ev;
-	DATA_BLOB data;
+	struct notify_entry_array *array;
+	struct db_record *rec;
+	DATA_BLOB blob;
+	TDB_DATA dbuf;
 	enum ndr_err_code ndr_err;
+	NTSTATUS status;
 
-	ev.action = action;
-	ev.filter = filter;
-	ev.path = path;
-
-	if (DEBUGLEVEL >= 10) {
-		NDR_PRINT_DEBUG(notify_remote_event, &ev);
+	array = talloc_zero(talloc_tos(), struct notify_entry_array);
+	if (array == NULL) {
+		return;
 	}
 
-	ndr_err = ndr_push_struct_blob(
-		&data, mem_ctx, &ev,
-		(ndr_push_flags_fn_t)ndr_push_notify_remote_event);
-	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		return false;
+	rec = notify->db_onelevel->fetch_locked(
+		notify->db_onelevel, talloc_tos(),
+		make_tdb_data((uint8_t *)&e->dir_id, sizeof(e->dir_id)));
+	if (rec == NULL) {
+		DEBUG(10, ("notify_add_onelevel: fetch_locked for %s failed"
+			   "\n", file_id_string_tos(&e->dir_id)));
+		TALLOC_FREE(array);
+		return;
 	}
-	*pblob = data.data;
-	*pblob_len = data.length;
-	return true;
-}
 
-static bool notify_pull_remote_blob(TALLOC_CTX *mem_ctx,
-				    const uint8_t *blob, size_t blob_len,
-				    uint32_t *paction, uint32_t *pfilter,
-				    char **path)
-{
-	struct notify_remote_event *ev;
-	enum ndr_err_code ndr_err;
-	DATA_BLOB data;
-	char *p;
+	blob.data = (uint8_t *)rec->value.dptr;
+	blob.length = rec->value.dsize;
 
-	data.data = discard_const_p(uint8_t, blob);
-	data.length = blob_len;
+	if (blob.length > 0) {
+		ndr_err = ndr_pull_struct_blob(&blob, array, array,
+			(ndr_pull_flags_fn_t)ndr_pull_notify_entry_array);
+		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+			DEBUG(10, ("ndr_pull_notify_entry_array failed: %s\n",
+				   ndr_errstr(ndr_err)));
+			TALLOC_FREE(array);
+			return;
+		}
+		if (DEBUGLEVEL >= 10) {
+			DEBUG(10, ("notify_add_onelevel:\n"));
+			NDR_PRINT_DEBUG(notify_entry_array, array);
+		}
+	}
 
-	ev = talloc(mem_ctx, struct notify_remote_event);
-	if (ev == NULL) {
-		return false;
+	array->entries = talloc_realloc(array, array->entries,
+					struct notify_entry,
+					array->num_entries+1);
+	if (array->entries == NULL) {
+		TALLOC_FREE(array);
+		return;
 	}
+	array->entries[array->num_entries] = *e;
+	array->entries[array->num_entries].private_data = private_data;
+	array->entries[array->num_entries].server = notify->server;
+	array->num_entries += 1;
 
-	ndr_err = ndr_pull_struct_blob(
-		&data, ev, ev,
-		(ndr_pull_flags_fn_t)ndr_pull_notify_remote_event);
+	ndr_err = ndr_push_struct_blob(&blob, rec, array,
+		(ndr_push_flags_fn_t)ndr_push_notify_entry_array);
 	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		TALLOC_FREE(ev);
-		return false;
+		DEBUG(10, ("ndr_push_notify_entry_array failed: %s\n",
+			   ndr_errstr(ndr_err)));
+		TALLOC_FREE(array);
+		return;
 	}
+
 	if (DEBUGLEVEL >= 10) {
-		NDR_PRINT_DEBUG(notify_remote_event, ev);
+		DEBUG(10, ("notify_add_onelevel:\n"));
+		NDR_PRINT_DEBUG(notify_entry_array, array);
 	}
-	*paction = ev->action;
-	*pfilter = ev->filter;
-	p = discard_const_p(char, ev->path);
-	*path = talloc_move(mem_ctx, &p);
 
-	TALLOC_FREE(ev);
-	return true;
+	dbuf.dptr = blob.data;
+	dbuf.dsize = blob.length;
+
+	status = rec->store(rec, dbuf, TDB_REPLACE);
+	TALLOC_FREE(array);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(10, ("notify_add_onelevel: store failed: %s\n",
+			   nt_errstr(status)));
+		return;
+	}
+	e->filter = 0;
+	return;
 }
 
-void notify_trigger(struct notify_context *notify,
-		    uint32_t action, uint32_t filter, const char *path)
-{
-	struct ctdbd_connection *ctdbd_conn;
-	struct notify_trigger_index_state idx_state;
-	const char *p, *next_p;
-	size_t i, num_vnns;
-	uint32_t last_vnn;
-	uint8_t *remote_blob = NULL;
-	size_t remote_blob_len = 0;
 
-	DEBUG(10, ("notify_trigger called action=0x%x, filter=0x%x, "
-		   "path=%s\n", (unsigned)action, (unsigned)filter, path));
+/*
+  add a notify watch. This is called when a notify is first setup on a open
+  directory handle.
+*/
+NTSTATUS notify_add(struct notify_context *notify, struct notify_entry *e0,
+		    void (*callback)(void *, const struct notify_event *), 
+		    void *private_data)
+{
+	struct notify_entry e = *e0;
+	NTSTATUS status;
+	char *tmp_path = NULL;
+	struct notify_list *listel;
+	size_t len;
+	int depth;
+	struct db_record *rec;
 
 	/* see if change notify is enabled at all */
 	if (notify == NULL) {
-		return;
+		return NT_STATUS_NOT_IMPLEMENTED;
 	}
 
-	idx_state.mem_ctx = talloc_tos();
-	idx_state.vnns = NULL;
-	idx_state.my_vnn = get_my_vnn();
-
-	for (p = path; p != NULL; p = next_p) {
-		ptrdiff_t path_len = p - path;
-		bool recursive;
-
-		next_p = strchr(p+1, '/');
-		recursive = (next_p != NULL);
-
-		idx_state.found_my_vnn = false;
+	status = notify_fetch_locked(notify, &rec);
+	NT_STATUS_NOT_OK_RETURN(status);
 
-		dbwrap_parse_record(
-			notify->db_index,
-			make_tdb_data(discard_const_p(uint8_t, path), path_len),
-			notify_trigger_index_parser, &idx_state);
+	status = notify_load(notify, rec);
+	if (!NT_STATUS_IS_OK(status)) {
+		talloc_free(rec);
+		return status;
+	}
 
-		if (!idx_state.found_my_vnn) {
-			continue;
+	/* cope with /. on the end of the path */
+	len = strlen(e.path);
+	if (len > 1 && e.path[len-1] == '.' && e.path[len-2] == '/') {
+		tmp_path = talloc_strndup(notify, e.path, len-2);
+		if (tmp_path == NULL) {
+			status = NT_STATUS_NO_MEMORY;
+			goto done;
 		}
-		notify_trigger_local(notify, action, filter,
-				     path, path_len, recursive);
+		e.path = tmp_path;
 	}
 
-	ctdbd_conn = messaging_ctdbd_connection();
-	if (ctdbd_conn == NULL) {
+	depth = count_chars(e.path, '/');
+
+	listel = TALLOC_ZERO_P(notify, struct notify_list);
+	if (listel == NULL) {
+		status = NT_STATUS_NO_MEMORY;
 		goto done;
 	}
 
-	num_vnns = talloc_array_length(idx_state.vnns);
-	qsort(idx_state.vnns, num_vnns, sizeof(uint32_t), vnn_cmp);
-
-	last_vnn = 0xffffffff;
-	remote_blob = NULL;
-
-	for (i=0; i<num_vnns; i++) {
-		uint32_t vnn = idx_state.vnns[i];
-		NTSTATUS status;
-
-		if (vnn == last_vnn) {
-			continue;
-		}
-		if (vnn == idx_state.my_vnn) {
-			continue;
-		}
-		if ((remote_blob == NULL) &&
-		    !notify_push_remote_blob(
-			    talloc_tos(), action, filter,
-			    path, &remote_blob, &remote_blob_len)) {
-			break;
-		}
+	listel->private_data = private_data;
+	listel->callback = callback;
+	listel->depth = depth;
+	DLIST_ADD(notify->list, listel);
 
-		status = ctdbd_messaging_send_blob(
-			ctdbd_conn, vnn, CTDB_SRVID_SAMBA_NOTIFY_PROXY,
-			remote_blob, remote_blob_len);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(10, ("ctdbd_messaging_send_blob to vnn %d "
-				   "returned %s, ignoring\n", (int)vnn,
-				   nt_errstr(status)));
+	/* ignore failures from sys_notify */
+	if (notify->sys_notify_ctx != NULL) {
+		/*
+		  this call will modify e.filter and e.subdir_filter
+		  to remove bits handled by the backend
+		*/
+		status = sys_notify_watch(notify->sys_notify_ctx, &e,
+					  sys_notify_callback, listel, 
+					  &listel->sys_notify_handle);
+		if (NT_STATUS_IS_OK(status)) {
+			talloc_steal(listel, listel->sys_notify_handle);
 		}
+	}
 
-		last_vnn = vnn;
+	if (e.filter != 0) {
+		notify_add_onelevel(notify, &e, private_data);
+		status = NT_STATUS_OK;
+	}
+
+	/* if the system notify handler couldn't handle some of the
+	   filter bits, or couldn't handle a request for recursion
+	   then we need to install it in the array used for the
+	   intra-samba notify handling */
+	if (e.filter != 0 || e.subdir_filter != 0) {
+		status = notify_add_array(notify, rec, &e, private_data, depth);
 	}
 
 done:
-	TALLOC_FREE(remote_blob);
-	TALLOC_FREE(idx_state.vnns);
+	talloc_free(rec);
+	talloc_free(tmp_path);
+
+	return status;
 }
 
-static void notify_trigger_local(struct notify_context *notify,
-				 uint32_t action, uint32_t filter,
-				 const char *path, size_t path_len,
-				 bool recursive)
-{
-	TDB_DATA data;
-	struct notify_db_entry *entries;
-	size_t i, num_entries;
+NTSTATUS notify_remove_onelevel(struct notify_context *notify,
+				const struct file_id *fid,
+				void *private_data)
+{
+	struct notify_entry_array *array;
+	struct db_record *rec;
+	DATA_BLOB blob;
+	TDB_DATA dbuf;
+	enum ndr_err_code ndr_err;
 	NTSTATUS status;
+	int i;
 
-	DEBUG(10, ("notify_trigger_local called for %*s, path_len=%d, "
-		   "filter=%d\n", (int)path_len, path, (int)path_len,
-		   (int)filter));
-
-	status = dbwrap_fetch(
-		notify->db_notify, talloc_tos(),
-		make_tdb_data(discard_const_p(uint8_t, path), path_len), &data);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10, ("dbwrap_fetch returned %s\n",
-			   nt_errstr(status)));
-		return;
-	}
-	if (data.dsize == sizeof(time_t)) {
-		DEBUG(10, ("Got deleted record\n"));
-		goto done;
-	}
-	if ((data.dsize % sizeof(struct notify_db_entry)) != 0) {
-		DEBUG(1, ("Invalid data.dsize = %u\n",
-			  (unsigned)data.dsize));
-		goto done;
+	if (notify == NULL) {
+		return NT_STATUS_NOT_IMPLEMENTED;
 	}
 
-	entries = (struct notify_db_entry *)data.dptr;
-	num_entries = data.dsize / sizeof(struct notify_db_entry);
-
-	DEBUG(10, ("recursive = %s pathlen=%d (%c)\n",
-		   recursive ? "true" : "false", (int)path_len,
-		   path[path_len]));
-
-	for (i=0; i<num_entries; i++) {
-		struct notify_db_entry *e = &entries[i];
-		uint32_t e_filter;
+	array = talloc_zero(talloc_tos(), struct notify_entry_array);
+	if (array == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
 
-		if (DEBUGLEVEL >= 10) {
-			NDR_PRINT_DEBUG(notify_db_entry, e);
-		}
+	rec = notify->db_onelevel->fetch_locked(
+		notify->db_onelevel, array,
+		make_tdb_data((uint8_t *)fid, sizeof(*fid)));
+	if (rec == NULL) {
+		DEBUG(10, ("notify_remove_onelevel: fetch_locked for %s failed"
+			   "\n", file_id_string_tos(fid)));
+		TALLOC_FREE(array);
+		return NT_STATUS_INTERNAL_DB_CORRUPTION;
+	}
 
-		e_filter = recursive ? e->subdir_filter : e->filter;
+	blob.data = (uint8_t *)rec->value.dptr;
+	blob.length = rec->value.dsize;
 
-		if ((filter & e_filter) == 0) {
-			continue;
+	if (blob.length > 0) {
+		ndr_err = ndr_pull_struct_blob(&blob, array, array,
+			(ndr_pull_flags_fn_t)ndr_pull_notify_entry_array);
+		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+			DEBUG(10, ("ndr_pull_notify_entry_array failed: %s\n",
+				   ndr_errstr(ndr_err)));
+			TALLOC_FREE(array);
+			return ndr_map_error2ntstatus(ndr_err);
 		}
-
-		if (!procid_is_local(&e->server)) {
-			DEBUG(1, ("internal error: Non-local pid %s in "
-				  "notify.tdb\n",
-				  procid_str_static(&e->server)));
-			continue;
+		if (DEBUGLEVEL >= 10) {
+			DEBUG(10, ("notify_remove_onelevel:\n"));
+			NDR_PRINT_DEBUG(notify_entry_array, array);
 		}
+	}
 
-		status = notify_send(notify, &e->server, path + path_len + 1,
-				     action, e->private_data);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(10, ("notify_send returned %s\n",
-				   nt_errstr(status)));
+	for (i=0; i<array->num_entries; i++) {
+		if ((private_data == array->entries[i].private_data) &&
+		    cluster_id_equal(&notify->server,
+				     &array->entries[i].server)) {
+			break;
 		}
 	}
 
-done:
-	TALLOC_FREE(data.dptr);
-}
+	if (i == array->num_entries) {
+		TALLOC_FREE(array);
+		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+	}
 
-static NTSTATUS notify_send(struct notify_context *notify,
-			    struct server_id *pid,
-			    const char *path, uint32_t action,
-			    void *private_data)
-{
-	struct notify_event ev;
-	DATA_BLOB data;
-	NTSTATUS status;
-	enum ndr_err_code ndr_err;
+	array->entries[i] = array->entries[array->num_entries-1];
+	array->num_entries -= 1;
 
-	ev.action = action;
-	ev.path = path;
-	ev.private_data = private_data;
+	if (array->num_entries == 0) {
+		rec->delete_rec(rec);
+		TALLOC_FREE(array);
+		return NT_STATUS_OK;
+	}
 
-	ndr_err = ndr_push_struct_blob(
-		&data, talloc_tos(), &ev,
-		(ndr_push_flags_fn_t)ndr_push_notify_event);
+	ndr_err = ndr_push_struct_blob(&blob, rec, array,
+		(ndr_push_flags_fn_t)ndr_push_notify_entry_array);
 	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		DEBUG(10, ("ndr_push_notify_entry_array failed: %s\n",
+			   ndr_errstr(ndr_err)));
+		TALLOC_FREE(array);
 		return ndr_map_error2ntstatus(ndr_err);
 	}
-	status = messaging_send(notify->msg, *pid, MSG_PVFS_NOTIFY,
-				&data);
-	TALLOC_FREE(data.data);
-	return status;
+
+	if (DEBUGLEVEL >= 10) {
+		DEBUG(10, ("notify_add_onelevel:\n"));
+		NDR_PRINT_DEBUG(notify_entry_array, array);
+	}
+
+	dbuf.dptr = blob.data;
+	dbuf.dsize = blob.length;
+
+	status = rec->store(rec, dbuf, TDB_REPLACE);
+	TALLOC_FREE(array);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(10, ("notify_add_onelevel: store failed: %s\n",
+			   nt_errstr(status)));
+		return status;
+	}
+	return NT_STATUS_OK;
 }
 
-static void notify_handler(struct messaging_context *msg_ctx,
-			   void *private_data, uint32_t msg_type,
-			   struct server_id server_id, DATA_BLOB *data)
+/*
+  remove a notify watch. Called when the directory handle is closed
+*/
+NTSTATUS notify_remove(struct notify_context *notify, void *private_data)
 {
-	struct notify_context *notify = talloc_get_type_abort(
-		private_data, struct notify_context);
-	enum ndr_err_code ndr_err;
-	struct notify_event *n;
+	NTSTATUS status;
 	struct notify_list *listel;
+	int i, depth;
+	struct notify_depth *d;
+	struct db_record *rec;
 
-	n = talloc(talloc_tos(), struct notify_event);
-	if (n == NULL) {
-		DEBUG(1, ("talloc failed\n"));
-		return;
-	}
-
-	ndr_err = ndr_pull_struct_blob(
-		data, n, n, (ndr_pull_flags_fn_t)ndr_pull_notify_event);
-	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
-		TALLOC_FREE(n);
-		return;
-	}
-	if (DEBUGLEVEL >= 10) {
-		NDR_PRINT_DEBUG(notify_event, n);
+	/* see if change notify is enabled at all */
+	if (notify == NULL) {
+		return NT_STATUS_NOT_IMPLEMENTED;
 	}
 
 	for (listel=notify->list;listel;listel=listel->next) {
-		if (listel->private_data == n->private_data) {
-			listel->callback(listel->private_data, n);
+		if (listel->private_data == private_data) {
+			DLIST_REMOVE(notify->list, listel);
 			break;
 		}
 	}
-	TALLOC_FREE(n);
-}
-
-struct notify_walk_idx_state {
-	void (*fn)(const char *path,
-		   uint32_t *vnns, size_t num_vnns,
-		   void *private_data);
-	void *private_data;
-};
-
-static int notify_walk_idx_fn(struct db_record *rec, void *private_data)
-{
-	struct notify_walk_idx_state *state =
-		(struct notify_walk_idx_state *)private_data;
-	TDB_DATA key, value;
-	char *path;
-
-	key = dbwrap_record_get_key(rec);
-	value = dbwrap_record_get_value(rec);
-
-	if ((value.dsize % sizeof(uint32_t)) != 0) {
-		DEBUG(1, ("invalid value size in notify index db: %u\n",
-			  (unsigned)(value.dsize)));
-		return 0;
-	}
-
-	path = talloc_strndup(talloc_tos(), (char *)key.dptr, key.dsize);
-	if (path == NULL) {
-		DEBUG(1, ("talloc_strndup failed\n"));
-		return 0;
-	}
-	state->fn(path, (uint32_t *)value.dptr, value.dsize/sizeof(uint32_t),
-		  state->private_data);
-	TALLOC_FREE(path);
-	return 0;
-}
+	if (listel == NULL) {
+		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+	}
 
-void notify_walk_idx(struct notify_context *notify,
-		     void (*fn)(const char *path,
-				uint32_t *vnns, size_t num_vnns,
-				void *private_data),
-		     void *private_data)
-{
-	struct notify_walk_idx_state state;
-	state.fn = fn;
-	state.private_data = private_data;
-	dbwrap_traverse_read(notify->db_index, notify_walk_idx_fn, &state,
-			     NULL);
-}
+	depth = listel->depth;
 
-struct notify_walk_state {
-	void (*fn)(const char *path,
-		   struct notify_db_entry *entries, size_t num_entries,
-		   time_t deleted_time, void *private_data);
-	void *private_data;
-};
+	talloc_free(listel);
 
-static int notify_walk_fn(struct db_record *rec, void *private_data)
-{
-	struct notify_walk_state *state =
-		(struct notify_walk_state *)private_data;
-	TDB_DATA key, value;
-	struct notify_db_entry *entries;
-	size_t num_entries;
-	time_t deleted_time;
-	char *path;
-
-	key = dbwrap_record_get_key(rec);
-	value = dbwrap_record_get_value(rec);
-
-	if (value.dsize == sizeof(deleted_time)) {
-		memcpy(&deleted_time, value.dptr, sizeof(deleted_time));
-		entries = NULL;
-		num_entries = 0;
-	} else {
-		if ((value.dsize % sizeof(struct notify_db_entry)) != 0) {
-			DEBUG(1, ("invalid value size in notify db: %u\n",
-				  (unsigned)(value.dsize)));
-			return 0;
-		}
-		entries = (struct notify_db_entry *)value.dptr;
-		num_entries = value.dsize / sizeof(struct notify_db_entry);
-		deleted_time = 0;
-	}
-
-	path = talloc_strndup(talloc_tos(), (char *)key.dptr, key.dsize);
-	if (path == NULL) {
-		DEBUG(1, ("talloc_strndup failed\n"));
-		return 0;
-	}
-	state->fn(path, entries, num_entries, deleted_time,
-		  state->private_data);
-	TALLOC_FREE(path);
-	return 0;
-}
+	status = notify_fetch_locked(notify, &rec);
+	NT_STATUS_NOT_OK_RETURN(status);
 
-void notify_walk(struct notify_context *notify,
-		 void (*fn)(const char *path,
-			    struct notify_db_entry *entries,
-			    size_t num_entries,
-			    time_t deleted_time, void *private_data),
-		 void *private_data)
-{
-	struct notify_walk_state state;
-	state.fn = fn;
-	state.private_data = private_data;
-	dbwrap_traverse_read(notify->db_notify, notify_walk_fn, &state,
-			     NULL);
-}
+	status = notify_load(notify, rec);
+	if (!NT_STATUS_IS_OK(status)) {
+		talloc_free(rec);
+		return status;
+	}
 
-struct notify_cleanup_state {
-	TALLOC_CTX *mem_ctx;
-	time_t delete_before;
-	ssize_t array_size;
-	uint32_t num_paths;
-	char **paths;
-};
+	if (depth >= notify->array->num_depths) {
+		talloc_free(rec);
+		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
+	}
 
-static void notify_cleanup_collect(
-	const char *path, struct notify_db_entry *entries, size_t num_entries,
-	time_t deleted_time, void *private_data)
-{
-	struct notify_cleanup_state *state =
-		(struct notify_cleanup_state *)private_data;
-	char *p;
+	/* we only have to search at the depth of this element */
+	d = &notify->array->depth[depth];
 
-	if (num_entries != 0) {
-		return;
+	for (i=0;i<d->num_entries;i++) {
+		if (private_data == d->entries[i].private_data &&
+		    cluster_id_equal(&notify->server, &d->entries[i].server)) {
+			break;
+		}
 	}
-	if (deleted_time >= state->delete_before) {
-		return;
+	if (i == d->num_entries) {
+		talloc_free(rec);
+		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
 
-	p = talloc_strdup(state->mem_ctx, path);
-	if (p == NULL) {
-		DEBUG(1, ("talloc_strdup failed\n"));
-		return;
-	}
-	add_to_large_array(state->mem_ctx, sizeof(p), (void *)&p,
-			   &state->paths, &state->num_paths,
-			   &state->array_size);
-	if (state->array_size == -1) {
-		TALLOC_FREE(p);
+	if (i < d->num_entries-1) {
+		memmove(&d->entries[i], &d->entries[i+1], 
+			sizeof(d->entries[i])*(d->num_entries-(i+1)));
 	}
-}
-
-static bool notify_cleanup_path(struct notify_context *notify,
-			      const char *path, time_t delete_before);
-
-void notify_cleanup(struct notify_context *notify)
-{
-	struct notify_cleanup_state state;
-	uint32_t failure_pool;
-
-	ZERO_STRUCT(state);
-	state.mem_ctx = talloc_stackframe();
+	d->num_entries--;
 
-	state.delete_before = time(NULL)
-		- lp_parm_int(-1, "smbd", "notify cleanup interval", 60);
+	status = notify_save(notify, rec);
 
-	notify_walk(notify, notify_cleanup_collect, &state);
+	talloc_free(rec);
 
-	failure_pool = state.num_paths;
+	return status;
+}
 
-	while (state.num_paths != 0) {
-		size_t idx;
+/*
+  remove all notify watches for a messaging server
+*/
+static NTSTATUS notify_remove_all(struct notify_context *notify,
+				  const struct server_id *server)
+{
+	NTSTATUS status;
+	int i, depth, del_count=0;
+	struct db_record *rec;
 
-		/*
-		 * This loop is designed to be as kind as possible to
-		 * ctdb. ctdb does not like it if many smbds hammer on a
-		 * single record. If on many nodes the cleanup process starts
-		 * running, it can happen that all of them need to clean up
-		 * records in the same order. This would generate a ctdb
-		 * migrate storm on these records. Randomizing the load across
-		 * multiple records reduces the load on the individual record.
-		 */
+	status = notify_fetch_locked(notify, &rec);
+	NT_STATUS_NOT_OK_RETURN(status);
 
-		generate_random_buffer((uint8_t *)&idx, sizeof(idx));
-		idx = idx % state.num_paths;
+	status = notify_load(notify, rec);
+	if (!NT_STATUS_IS_OK(status)) {
+		talloc_free(rec);
+		return status;
+	}
 
-		if (!notify_cleanup_path(notify, state.paths[idx],
-					 state.delete_before)) {
-			/*
-			 * notify_cleanup_path failed, the most likely reason
-			 * is that dbwrap_try_fetch_locked failed due to
-			 * contention. We allow one failed attempt per deleted
-			 * path on average before we give up.
-			 */
-			failure_pool -= 1;
-			if (failure_pool == 0) {
-				/*
-				 * Too many failures. We will come back here,
-				 * maybe next time there is less contention.
-				 */
-				break;
+	/* we have to search for all entries across all depths, looking for matches
+	   for the server id */
+	for (depth=0;depth<notify->array->num_depths;depth++) {
+		struct notify_depth *d = &notify->array->depth[depth];
+		for (i=0;i<d->num_entries;i++) {
+			if (cluster_id_equal(server, &d->entries[i].server)) {
+				if (i < d->num_entries-1) {
+					memmove(&d->entries[i], &d->entries[i+1], 
+						sizeof(d->entries[i])*(d->num_entries-(i+1)));
+				}
+				i--;
+				d->num_entries--;
+				del_count++;
 			}
 		}
+	}
 
-		TALLOC_FREE(state.paths[idx]);
-		state.paths[idx] = state.paths[state.num_paths-1];
-		state.num_paths -= 1;
+	if (del_count > 0) {
+		status = notify_save(notify, rec);
 	}
-	TALLOC_FREE(state.mem_ctx);
-}
 
-static bool notify_cleanup_path(struct notify_context *notify,
-				const char *path, time_t delete_before)
-{
-	struct db_record *notify_rec = NULL;
-	struct db_record *idx_rec = NULL;
-	TDB_DATA key = string_tdb_data(path);
-	TDB_DATA value;
-	time_t deleted;
-	NTSTATUS status;
+	talloc_free(rec);
 
-	notify_rec = dbwrap_fetch_locked(notify->db_notify, talloc_tos(), key);
-	if (notify_rec == NULL) {
-		DEBUG(10, ("Could not fetch notify_rec\n"));
-		return false;
-	}
-	value = dbwrap_record_get_value(notify_rec);
+	return status;
+}
 
-	if (value.dsize != sizeof(deleted)) {
-		DEBUG(10, ("record %s has been re-used\n", path));
-		goto done;
-	}
-	memcpy(&deleted, value.dptr, sizeof(deleted));
 
-	if (deleted >= delete_before) {
-		DEBUG(10, ("record %s too young\n", path));
-		goto done;
-	}
+/*
+  send a notify message to another messaging server
+*/
+static NTSTATUS notify_send(struct notify_context *notify, struct notify_entry *e,
+			    const char *path, uint32_t action)
+{
+	struct notify_event ev;
+	DATA_BLOB data;
+	NTSTATUS status;
+	enum ndr_err_code ndr_err;
+	TALLOC_CTX *tmp_ctx;
 
-	/*
-	 * Be kind to ctdb and only try one dmaster migration at most.
-	 */
-	idx_rec = dbwrap_try_fetch_locked(notify->db_index, talloc_tos(), key);
-	if (idx_rec == NULL) {
-		DEBUG(10, ("Could not fetch idx_rec\n"));
-		goto done;
-	}
+	ev.action = action;
+	ev.path = path;
+	ev.private_data = e->private_data;
 
-	status = dbwrap_record_delete(notify_rec);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10, ("Could not delete notify_rec: %s\n",
-			   nt_errstr(status)));
-	}
+	tmp_ctx = talloc_new(notify);
 
-	status = notify_del_idx(idx_rec, get_my_vnn());
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10, ("Could not delete idx_rec: %s\n",
-			   nt_errstr(status)));
+	ndr_err = ndr_push_struct_blob(&data, tmp_ctx, &ev,
+				       (ndr_push_flags_fn_t)ndr_push_notify_event);
+	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+		talloc_free(tmp_ctx);
+		return ndr_map_error2ntstatus(ndr_err);
 	}
 
-done:
-	TALLOC_FREE(idx_rec);
-	TALLOC_FREE(notify_rec);
-	return true;
+	status = messaging_send(notify->messaging_ctx, e->server, 
+				MSG_PVFS_NOTIFY, &data);
+	talloc_free(tmp_ctx);
+	return status;
 }
 
-static NTSTATUS notify_del_idx(struct db_record *rec, uint32_t vnn)
+void notify_onelevel(struct notify_context *notify, uint32_t action,
+		     uint32_t filter, struct file_id fid, const char *name)
 {
-	TDB_DATA value = dbwrap_record_get_value(rec);
-	uint32_t *vnns;
-	size_t i, num_vnns;
-
-	if ((value.dsize % sizeof(uint32_t)) != 0) {
-		DEBUG(1, ("Invalid value.dsize = %u\n",
-			  (unsigned)value.dsize));
-		return NT_STATUS_INTERNAL_DB_CORRUPTION;
+	struct notify_entry_array *array;
+	TDB_DATA dbuf;
+	DATA_BLOB blob;
+	bool have_dead_entries = false;
+	int i;
+
+	if (notify == NULL) {
+		return;
 	}
-	num_vnns = value.dsize / sizeof(uint32_t);
-	vnns = (uint32_t *)value.dptr;
 
-	for (i=0; i<num_vnns; i++) {
-		if (vnns[i] == vnn) {
-			break;
-		}
+	array = talloc_zero(talloc_tos(), struct notify_entry_array);
+	if (array == NULL) {
+		return;
 	}
 
-	if (i == num_vnns) {
-		/*
-		 * Not found. Should not happen, but okay...
-		 */
-		return NT_STATUS_OK;
+	if (notify->db_onelevel->fetch(
+		    notify->db_onelevel, array,
+		    make_tdb_data((uint8_t *)&fid, sizeof(fid)),
+		    &dbuf) == -1) {
+		TALLOC_FREE(array);
+		return;
 	}
 
-	memmove(&vnns[i], &vnns[i+1], sizeof(uint32_t) * (num_vnns - i - 1));
-	value.dsize -= sizeof(uint32_t);
+	blob.data = (uint8 *)dbuf.dptr;
+	blob.length = dbuf.dsize;
 
-	if (value.dsize == 0) {
-		return dbwrap_record_delete(rec);
+	if (blob.length > 0) {
+		enum ndr_err_code ndr_err;
+		ndr_err = ndr_pull_struct_blob(&blob, array, array,
+			(ndr_pull_flags_fn_t)ndr_pull_notify_entry_array);
+		if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
+			DEBUG(10, ("ndr_pull_notify_entry_array failed: %s\n",
+				   ndr_errstr(ndr_err)));
+			TALLOC_FREE(array);
+			return;
+		}
+		if (DEBUGLEVEL >= 10) {
+			DEBUG(10, ("notify_onelevel:\n"));
+			NDR_PRINT_DEBUG(notify_entry_array, array);
+		}
 	}
-	return dbwrap_record_store(rec, value, 0);
-}
 
-struct notify_cluster_proxy_state {
-	struct tevent_context *ev;
-	struct notify_context *notify;
-	struct ctdb_msg_channel *chan;
-};
+	for (i=0; i<array->num_entries; i++) {
+		struct notify_entry *e = &array->entries[i];
 
-static void notify_cluster_proxy_got_chan(struct tevent_req *subreq);
-static void notify_cluster_proxy_got_msg(struct tevent_req *subreq);
-static void notify_cluster_proxy_trigger(struct notify_context *notify,
-					 uint32_t action, uint32_t filter,
-					 char *path);
-
-struct tevent_req *notify_cluster_proxy_send(
-	TALLOC_CTX *mem_ctx, struct tevent_context *ev,
-	struct notify_context *notify)
-{
-	struct tevent_req *req, *subreq;
-	struct notify_cluster_proxy_state *state;
+		if ((e->filter & filter) != 0) {
+			NTSTATUS status;
 
-	req = tevent_req_create(mem_ctx, &state,
-				struct notify_cluster_proxy_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->ev = ev;
-	state->notify = notify;
-
-	subreq = ctdb_msg_channel_init_send(
-		state, state->ev,  lp_ctdbd_socket(),
-		CTDB_SRVID_SAMBA_NOTIFY_PROXY);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
+			status = notify_send(notify, e, name, action);
+			if (NT_STATUS_EQUAL(
+				    status, NT_STATUS_INVALID_HANDLE)) {
+				/*
+				 * Mark the entry as dead. All entries have a
+				 * path set. The marker used here is setting
+				 * that to NULL.
+				 */
+				e->path = NULL;
+				have_dead_entries = true;
+			}
+		}
 	}
-	tevent_req_set_callback(subreq, notify_cluster_proxy_got_chan, req);
-	return req;
-}
 
-static void notify_cluster_proxy_got_chan(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct notify_cluster_proxy_state *state = tevent_req_data(
-		req, struct notify_cluster_proxy_state);
-	int ret;
-
-	ret = ctdb_msg_channel_init_recv(subreq, state, &state->chan);
-	TALLOC_FREE(subreq);
-	if (ret != 0) {
-		tevent_req_error(req, ret);
+	if (!have_dead_entries) {
+		TALLOC_FREE(array);
 		return;
 	}
-	subreq = ctdb_msg_read_send(state, state->ev, state->chan);
-	if (tevent_req_nomem(subreq, req)) {
-		return;
+
+	for (i=0; i<array->num_entries; i++) {
+		struct notify_entry *e = &array->entries[i];
+		if (e->path != NULL) {
+			continue;
+		}
+		DEBUG(10, ("Deleting notify entries for process %s because "
+			   "it's gone\n", procid_str_static(&e->server)));
+		/*
+		 * Potential TODO: This might need optimizing,
+		 * notify_remove_onelevel() does a fetch_locked() operation at
+		 * every call. But this would only matter if a process with
+		 * MANY notifies has died without shutting down properly.
+		 */
+		notify_remove_onelevel(notify, &e->dir_id, e->private_data);
 	}
-	tevent_req_set_callback(subreq, notify_cluster_proxy_got_msg, req);
+
+	TALLOC_FREE(array);
+	return;
 }
 
-static void notify_cluster_proxy_got_msg(struct tevent_req *subreq)
+/*
+  trigger a notify message for anyone waiting on a matching event
+
+  This function is called a lot, and needs to be very fast. The unusual data structure
+  and traversal is designed to be fast in the average case, even for large numbers of
+  notifies
+*/
+void notify_trigger(struct notify_context *notify,
+		    uint32_t action, uint32_t filter, const char *path)
 {
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct notify_cluster_proxy_state *state = tevent_req_data(
-		req, struct notify_cluster_proxy_state);
-	uint8_t *msg;
-	size_t msg_len;
-	uint32_t action, filter;
-	char *path;
-	int ret;
-	bool res;
-
-	ret = ctdb_msg_read_recv(subreq, talloc_tos(), &msg, &msg_len);
-	TALLOC_FREE(subreq);
-	if (ret != 0) {
-		tevent_req_error(req, ret);
-		return;
-	}
+	NTSTATUS status;
+	int depth;
+	const char *p, *next_p;
+
+	DEBUG(10, ("notify_trigger called action=0x%x, filter=0x%x, "
+		   "path=%s\n", (unsigned)action, (unsigned)filter, path));
 
-	res = notify_pull_remote_blob(talloc_tos(), msg, msg_len,
-				      &action, &filter, &path);
-	TALLOC_FREE(msg);
-	if (!res) {
-		tevent_req_error(req, EIO);
+	/* see if change notify is enabled at all */
+	if (notify == NULL) {
 		return;
 	}
-	notify_cluster_proxy_trigger(state->notify, action, filter, path);
-	TALLOC_FREE(path);
 
-	subreq = ctdb_msg_read_send(state, state->ev, state->chan);
-	if (tevent_req_nomem(subreq, req)) {
+ again:
+	status = notify_load(notify, NULL);
+	if (!NT_STATUS_IS_OK(status)) {
 		return;
 	}
-	tevent_req_set_callback(subreq, notify_cluster_proxy_got_msg, req);
-}
 
-static void notify_cluster_proxy_trigger(struct notify_context *notify,
-					 uint32_t action, uint32_t filter,
-					 char *path)
-{
-	const char *p, *next_p;
+	/* loop along the given path, working with each directory depth separately */
+	for (depth=0,p=path;
+	     p && depth < notify->array->num_depths;
+	     p=next_p,depth++) {
+		int p_len = p - path;
+		int min_i, max_i, i;
+		struct notify_depth *d = &notify->array->depth[depth];
+		next_p = strchr(p+1, '/');
 
-	for (p = path; p != NULL; p = next_p) {
-		ptrdiff_t path_len = p - path;
-		bool recursive;
+		/* see if there are any entries at this depth */
+		if (d->num_entries == 0) continue;
 
-		next_p = strchr(p+1, '/');
-		recursive = (next_p != NULL);
+		/* try to skip based on the maximum mask. If next_p is
+		 NULL then we know it will be a 'this directory'
+		 match, otherwise it must be a subdir match */
+		if (next_p != NULL) {
+			if (0 == (filter & d->max_mask_subdir)) {
+				continue;
+			}
+		} else {
+			if (0 == (filter & d->max_mask)) {
+				continue;
+			}
+		}
 
-		notify_trigger_local(notify, action, filter,
-				     path, path_len, recursive);
-	}
-}
+		/* we know there is an entry here worth looking
+		 for. Use a bisection search to find the first entry
+		 with a matching path */
+		min_i = 0;
+		max_i = d->num_entries-1;
+
+		while (min_i < max_i) {
+			struct notify_entry *e;
+			int cmp;
+			i = (min_i+max_i)/2;
+			e = &d->entries[i];
+			cmp = strncmp(path, e->path, p_len);
+			if (cmp == 0) {
+				if (p_len == e->path_len) {
+					max_i = i;
+				} else {
+					max_i = i-1;
+				}
+			} else if (cmp < 0) {
+				max_i = i-1;
+			} else {
+				min_i = i+1;
+			}
+		}
 
-int notify_cluster_proxy_recv(struct tevent_req *req)
-{
-	int err;
+		if (min_i != max_i) {
+			/* none match */
+			continue;
+		}
+
+		/* we now know that the entries start at min_i */
+		for (i=min_i;i<d->num_entries;i++) {
+			struct notify_entry *e = &d->entries[i];
+			if (p_len != e->path_len ||
+			    strncmp(path, e->path, p_len) != 0) break;
+			if (next_p != NULL) {
+				if (0 == (filter & e->subdir_filter)) {
+					continue;
+				}
+			} else {
+				if (0 == (filter & e->filter)) {
+					continue;
+				}
+			}
+			status = notify_send(notify, e,	path + e->path_len + 1,
+					     action);
 
-	if (tevent_req_is_unix_error(req, &err)) {
-		return err;
+			if (NT_STATUS_EQUAL(
+				    status, NT_STATUS_INVALID_HANDLE)) {
+				struct server_id server = e->server;
+
+				DEBUG(10, ("Deleting notify entries for "
+					   "process %s because it's gone\n",
+					   procid_str_static(&e->server)));
+				notify_remove_all(notify, &server);
+				goto again;
+			}
+		}
 	}
-	return 0;
 }
Only in ../../samba-3.6.24/source3/smbd: notify_internal.o
Only in ../../samba-3.6.24/source3/smbd: notify.o
diff -ur smbd/ntquotas.c ../../samba-3.6.24/source3/smbd/ntquotas.c
--- smbd/ntquotas.c	2012-10-02 16:24:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/ntquotas.c	2015-01-28 10:52:25.149068676 +0800
@@ -176,8 +176,8 @@
 		return (-1);
 	}
 
-	setpwent();
-	while ((usr = getpwent()) != NULL) {
+	sys_setpwent();
+	while ((usr = sys_getpwent()) != NULL) {
 		SMB_NTQUOTA_STRUCT tmp_qt;
 		SMB_NTQUOTA_LIST *tmp_list_ent;
 		struct dom_sid	sid;
@@ -201,14 +201,14 @@
 		DEBUG(15,("quota entry for id[%s] path[%s]\n",
 			  sid_string_dbg(&sid), fsp->conn->connectpath));
 
-		if ((tmp_list_ent=talloc_zero(mem_ctx,SMB_NTQUOTA_LIST))==NULL) {
+		if ((tmp_list_ent=TALLOC_ZERO_P(mem_ctx,SMB_NTQUOTA_LIST))==NULL) {
 			DEBUG(0,("TALLOC_ZERO() failed\n"));
 			*qt_list = NULL;
 			talloc_destroy(mem_ctx);
 			return (-1);
 		}
 
-		if ((tmp_list_ent->quotas=talloc_zero(mem_ctx,SMB_NTQUOTA_STRUCT))==NULL) {
+		if ((tmp_list_ent->quotas=TALLOC_ZERO_P(mem_ctx,SMB_NTQUOTA_STRUCT))==NULL) {
 			DEBUG(0,("TALLOC_ZERO() failed\n"));
 			*qt_list = NULL;
 			talloc_destroy(mem_ctx);
@@ -222,7 +222,7 @@
 		DLIST_ADD((*qt_list),tmp_list_ent);
 		
 	}
-	endpwent();
+	sys_endpwent();
 
 	return 0;
 }
@@ -239,9 +239,9 @@
 	SMB_NTQUOTA_HANDLE *qt_handle;
 
 	if (!mem_ctx)
-		return NULL;
+		return False;
 
-	qt_handle = talloc_zero(mem_ctx,SMB_NTQUOTA_HANDLE);
+	qt_handle = TALLOC_ZERO_P(mem_ctx,SMB_NTQUOTA_HANDLE);
 	if (qt_handle==NULL) {
 		DEBUG(0,("TALLOC_ZERO() failed\n"));
 		return NULL;
Only in ../../samba-3.6.24/source3/smbd: ntquotas.o
diff -ur smbd/nttrans.c ../../samba-3.6.24/source3/smbd/nttrans.c
--- smbd/nttrans.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/nttrans.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,6 +27,7 @@
 #include "../librpc/gen_ndr/ndr_security.h"
 #include "passdb/lookup_sid.h"
 #include "auth.h"
+#include "ntioctl.h"
 #include "smbprofile.h"
 #include "libsmb/libsmb.h"
 
@@ -53,10 +54,10 @@
  HACK ! Always assumes smb_setup field is zero.
 ****************************************************************************/
 
-static void send_nt_replies(connection_struct *conn,
-			    struct smb_request *req, NTSTATUS nt_error,
-			    char *params, int paramsize,
-			    char *pdata, int datasize)
+void send_nt_replies(connection_struct *conn,
+			struct smb_request *req, NTSTATUS nt_error,
+		     char *params, int paramsize,
+		     char *pdata, int datasize)
 {
 	int data_to_send = datasize;
 	int params_to_send = paramsize;
@@ -279,17 +280,15 @@
 ****************************************************************************/
 
 static void nt_open_pipe(char *fname, connection_struct *conn,
-			 struct smb_request *req, uint16_t *ppnum)
+			 struct smb_request *req, int *ppnum)
 {
 	files_struct *fsp;
 	NTSTATUS status;
 
 	DEBUG(4,("nt_open_pipe: Opening pipe %s.\n", fname));
 
-	/* Strip \\ off the name if present. */
-	while (fname[0] == '\\') {
-		fname++;
-	}
+	/* Strip \\ off the name. */
+	fname++;
 
 	status = open_np_file(req, fname, &fsp);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -314,7 +313,7 @@
 				  struct smb_request *req)
 {
 	char *fname = NULL;
-	uint16_t pnum = FNUM_FIELD_INVALID;
+	int pnum = -1;
 	char *p = NULL;
 	uint32 flags = IVAL(req->vwv+3, 1);
 	TALLOC_CTX *ctx = talloc_tos();
@@ -340,7 +339,7 @@
 	if (flags & EXTENDED_RESPONSE_REQUIRED) {
 		/* This is very strange. We
  		 * return 50 words, but only set
-		 * the wcnt to 42 ? It's definitely
+ 		 * the wcnt to 42 ? It's definately
  		 * what happens on the wire....
  		 */
 		reply_outbuf(req, 50, 0);
@@ -349,9 +348,6 @@
 		reply_outbuf(req, 34, 0);
 	}
 
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	p = (char *)req->outbuf + smb_vwv2;
 	p++;
 	SSVAL(p,0,pnum);
@@ -379,6 +375,8 @@
 	}
 
 	DEBUG(5,("do_ntcreate_pipe_open: open pipe = %s\n", fname));
+
+	chain_reply(req);
 }
 
 struct case_semantics_state {
@@ -448,7 +446,7 @@
 	/* Breakout the oplock request bits so we can set the
 	   reply bits separately. */
 	uint32 fattr=0;
-	off_t file_len = 0;
+	SMB_OFF_T file_len = 0;
 	int info = 0;
 	files_struct *fsp = NULL;
 	char *p = NULL;
@@ -538,7 +536,8 @@
 				conn,
 				req->flags2 & FLAGS2_DFS_PATHNAMES,
 				fname,
-				UCF_PREP_CREATEFILE,
+				(create_disposition == FILE_CREATE)
+					? UCF_CREATING_FILE : 0,
 				NULL,
 				&smb_fname);
 
@@ -581,7 +580,7 @@
 		&info);					/* pinfo */
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call, no error. */
 			goto out;
 		}
@@ -623,7 +622,7 @@
 	if (flags & EXTENDED_RESPONSE_REQUIRED) {
 		/* This is very strange. We
  		 * return 50 words, but only set
-		 * the wcnt to 42 ? It's definitely
+ 		 * the wcnt to 42 ? It's definately
  		 * what happens on the wire....
  		 */
 		reply_outbuf(req, 50, 0);
@@ -632,9 +631,6 @@
 		reply_outbuf(req, 34, 0);
 	}
 
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	p = (char *)req->outbuf + smb_vwv2;
 
 	SCVAL(p, 0, oplock_granted);
@@ -726,9 +722,10 @@
 		SIVAL(p,0,perms);
 	}
 
-	DEBUG(5,("reply_ntcreate_and_X: %s, open name = %s\n",
-		fsp_fnum_dbg(fsp), smb_fname_str_dbg(smb_fname)));
+	DEBUG(5,("reply_ntcreate_and_X: fnum = %d, open name = %s\n",
+		fsp->fnum, smb_fname_str_dbg(smb_fname)));
 
+	chain_reply(req);
  out:
 	END_PROFILE(SMBntcreateX);
 	return;
@@ -746,7 +743,7 @@
 {
 	char *fname = NULL;
 	char *params = *ppparams;
-	uint16_t pnum = FNUM_FIELD_INVALID;
+	int pnum = -1;
 	char *p = NULL;
 	NTSTATUS status;
 	size_t param_len;
@@ -1023,7 +1020,7 @@
 	char *data = *ppdata;
 	/* Breakout the oplock request bits so we can set the reply bits separately. */
 	uint32 fattr=0;
-	off_t file_len = 0;
+	SMB_OFF_T file_len = 0;
 	int info = 0;
 	files_struct *fsp = NULL;
 	char *p = NULL;
@@ -1097,43 +1094,6 @@
 	 */
 	create_options &= ~NTCREATEX_OPTIONS_MUST_IGNORE_MASK;
 
-	srvstr_get_path(ctx, params, req->flags2, &fname,
-			params+53, parameter_count-53,
-			STR_TERMINATE, &status);
-	if (!NT_STATUS_IS_OK(status)) {
-		reply_nterror(req, status);
-		goto out;
-	}
-
-	if (file_attributes & FILE_FLAG_POSIX_SEMANTICS) {
-		case_state = set_posix_case_semantics(ctx, conn);
-		if (!case_state) {
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			goto out;
-		}
-	}
-
-	status = filename_convert(ctx,
-				conn,
-				req->flags2 & FLAGS2_DFS_PATHNAMES,
-				fname,
-				UCF_PREP_CREATEFILE,
-				NULL,
-				&smb_fname);
-
-	TALLOC_FREE(case_state);
-
-	if (!NT_STATUS_IS_OK(status)) {
-		if (NT_STATUS_EQUAL(status,NT_STATUS_PATH_NOT_COVERED)) {
-			reply_botherror(req,
-				NT_STATUS_PATH_NOT_COVERED,
-				ERRSRV, ERRbadpath);
-			goto out;
-		}
-		reply_nterror(req, status);
-		goto out;
-	}
-
 	/* Ensure the data_len is correct for the sd and ea values given. */
 	if ((ea_len + sd_len > data_count)
 	    || (ea_len > data_count) || (sd_len > data_count)
@@ -1184,26 +1144,44 @@
 			reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
 			goto out;
 		}
+	}
 
-		if (ea_list_has_invalid_name(ea_list)) {
-			/* Realloc the size of parameters and data we will return */
-			if (flags & EXTENDED_RESPONSE_REQUIRED) {
-				/* Extended response is 32 more byyes. */
-				param_len = 101;
-			} else {
-				param_len = 69;
-			}
-			params = nttrans_realloc(ppparams, param_len);
-			if(params == NULL) {
-				reply_nterror(req, NT_STATUS_NO_MEMORY);
-				goto out;
-			}
+	srvstr_get_path(ctx, params, req->flags2, &fname,
+			params+53, parameter_count-53,
+			STR_TERMINATE, &status);
+	if (!NT_STATUS_IS_OK(status)) {
+		reply_nterror(req, status);
+		goto out;
+	}
+
+	if (file_attributes & FILE_FLAG_POSIX_SEMANTICS) {
+		case_state = set_posix_case_semantics(ctx, conn);
+		if (!case_state) {
+			reply_nterror(req, NT_STATUS_NO_MEMORY);
+			goto out;
+		}
+	}
+
+	status = filename_convert(ctx,
+				conn,
+				req->flags2 & FLAGS2_DFS_PATHNAMES,
+				fname,
+				(create_disposition == FILE_CREATE)
+					? UCF_CREATING_FILE : 0,
+				NULL,
+				&smb_fname);
+
+	TALLOC_FREE(case_state);
 
-			memset(params, '\0', param_len);
-			send_nt_replies(conn, req, STATUS_INVALID_EA_NAME,
-				params, param_len, NULL, 0);
+	if (!NT_STATUS_IS_OK(status)) {
+		if (NT_STATUS_EQUAL(status,NT_STATUS_PATH_NOT_COVERED)) {
+			reply_botherror(req,
+				NT_STATUS_PATH_NOT_COVERED,
+				ERRSRV, ERRbadpath);
 			goto out;
 		}
+		reply_nterror(req, status);
+		goto out;
 	}
 
 	oplock_request = (flags & REQUEST_OPLOCK) ? EXCLUSIVE_OPLOCK : 0;
@@ -1238,7 +1216,7 @@
 		&info);					/* pinfo */
 
 	if(!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call, no error. */
 			return;
 		}
@@ -1426,7 +1404,7 @@
 	files_struct *fsp1,*fsp2;
 	uint32 fattr;
 	int info;
-	off_t ret=-1;
+	SMB_OFF_T ret=-1;
 	NTSTATUS status = NT_STATUS_OK;
 	char *parent;
 
@@ -1541,7 +1519,7 @@
 	file_set_dosmode(conn, smb_fname_dst, fattr, parent, false);
 	TALLOC_FREE(parent);
 
-	if (ret < (off_t)smb_fname_src->st.st_ex_size) {
+	if (ret < (SMB_OFF_T)smb_fname_src->st.st_ex_size) {
 		status = NT_STATUS_DISK_FULL;
 		goto out;
 	}
@@ -1721,7 +1699,7 @@
 	}
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -1812,7 +1790,7 @@
 		}
 	}
 
-	if (change_notify_fsp_has_changes(fsp)) {
+	if (fsp->notify->num_changes != 0) {
 
 		/*
 		 * We've got changes pending, respond immediately
@@ -1932,7 +1910,6 @@
 {
 	NTSTATUS status;
 	struct security_descriptor *psd = NULL;
-	TALLOC_CTX *frame = talloc_stackframe();
 
 	/*
 	 * Get the permissions to return.
@@ -1940,15 +1917,11 @@
 
 	if ((security_info_wanted & SECINFO_SACL) &&
 			!(fsp->access_mask & SEC_FLAG_SYSTEM_SECURITY)) {
-		DEBUG(10, ("Access to SACL denied.\n"));
-		TALLOC_FREE(frame);
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
 	if ((security_info_wanted & (SECINFO_DACL|SECINFO_OWNER|SECINFO_GROUP)) &&
 			!(fsp->access_mask & SEC_STD_READ_CONTROL)) {
-		DEBUG(10, ("Access to DACL, OWNER, or GROUP denied.\n"));
-		TALLOC_FREE(frame);
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
@@ -1960,16 +1933,15 @@
 	}
 
 	if (!lp_nt_acl_support(SNUM(conn))) {
-		status = get_null_nt_acl(frame, &psd);
+		status = get_null_nt_acl(mem_ctx, &psd);
 	} else if (security_info_wanted & SECINFO_LABEL) {
 		/* Like W2K3 return a null object. */
-		status = get_null_nt_acl(frame, &psd);
+		status = get_null_nt_acl(mem_ctx, &psd);
 	} else {
 		status = SMB_VFS_FGET_NT_ACL(
-			fsp, security_info_wanted, frame, &psd);
+			fsp, security_info_wanted, &psd);
 	}
 	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(frame);
 		return status;
 	}
 
@@ -2018,7 +1990,7 @@
 	}
 
 	if (max_data_count < *psd_size) {
-		TALLOC_FREE(frame);
+		TALLOC_FREE(psd);
 		return NT_STATUS_BUFFER_TOO_SMALL;
 	}
 
@@ -2026,11 +1998,11 @@
 				   ppmarshalled_sd, psd_size);
 
 	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(frame);
+		TALLOC_FREE(psd);
 		return status;
 	}
 
-	TALLOC_FREE(frame);
+	TALLOC_FREE(psd);
 	return NT_STATUS_OK;
 }
 
@@ -2086,8 +2058,7 @@
 	status = smbd_do_query_security_desc(conn,
 					talloc_tos(),
 					fsp,
-					security_info_wanted &
-					SMB_SUPPORTED_SECINFO_FLAGS,
+					security_info_wanted,
 					max_data_count,
 					&marshalled_sd,
 					&sd_size);
@@ -2180,8 +2151,8 @@
 		return;
 	}
 
-	status = set_sd_blob(fsp, (uint8 *)data, data_count,
-			     security_info_sent & SMB_SUPPORTED_SECINFO_FLAGS);
+	status = set_sd_blob(fsp, (uint8 *)data, data_count, security_info_sent);
+
 	if (!NT_STATUS_IS_OK(status)) {
 		reply_nterror(req, status);
 		return;
@@ -2192,6 +2163,343 @@
 	return;
 }
 
+/*
+ * Implement the default fsctl operation.
+ */
+
+static bool vfswrap_logged_ioctl_message = false;
+
+/*
+ * In 3.6 we do not have a SMB_VFS_FSCTL() function
+ * it's just faked to make it more look like
+ * master (4.0)
+ */
+NTSTATUS smb_fsctl(struct files_struct *fsp,
+		       TALLOC_CTX *ctx,
+		       uint32_t function,
+		       uint16_t req_flags,  /* Needed for UNICODE ... */
+		       const uint8_t *_in_data,
+		       uint32_t in_len,
+		       uint8_t **_out_data,
+		       uint32_t max_out_len,
+		       uint32_t *out_len)
+{
+	const char *in_data = (const char *)_in_data;
+	char **out_data = (char **)_out_data;
+
+	switch (function) {
+	case FSCTL_SET_SPARSE:
+	{
+		bool set_sparse = true;
+		NTSTATUS status;
+
+		if (in_len >= 1 && in_data[0] == 0) {
+			set_sparse = false;
+		}
+
+		status = file_set_sparse(fsp->conn, fsp, set_sparse);
+
+		DEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,
+		      ("FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\n",
+		       smb_fname_str_dbg(fsp->fsp_name), set_sparse,
+		       nt_errstr(status)));
+
+		return status;
+	}
+
+	case FSCTL_CREATE_OR_GET_OBJECT_ID:
+	{
+		unsigned char objid[16];
+		char *return_data = NULL;
+
+		/* This should return the object-id on this file.
+		 * I think I'll make this be the inode+dev. JRA.
+		 */
+
+		DEBUG(10,("FSCTL_CREATE_OR_GET_OBJECT_ID: called on FID[0x%04X]\n",fsp->fnum));
+
+		*out_len = (max_out_len >= 64) ? 64 : max_out_len;
+		/* Hmmm, will this cause problems if less data asked for? */
+		return_data = talloc_array(ctx, char, 64);
+		if (return_data == NULL) {
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		/* For backwards compatibility only store the dev/inode. */
+		push_file_id_16(return_data, &fsp->file_id);
+		memcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);
+		push_file_id_16(return_data+32, &fsp->file_id);
+		*out_data = return_data;
+		return NT_STATUS_OK;
+	}
+
+	case FSCTL_GET_REPARSE_POINT:
+	{
+		/* Fail it with STATUS_NOT_A_REPARSE_POINT */
+		DEBUG(10, ("FSCTL_GET_REPARSE_POINT: called on FID[0x%04X] Status: NOT_IMPLEMENTED\n", fsp->fnum));
+		return NT_STATUS_NOT_A_REPARSE_POINT;
+	}
+
+	case FSCTL_SET_REPARSE_POINT:
+	{
+		/* Fail it with STATUS_NOT_A_REPARSE_POINT */
+		DEBUG(10, ("FSCTL_SET_REPARSE_POINT: called on FID[0x%04X] Status: NOT_IMPLEMENTED\n", fsp->fnum));
+		return NT_STATUS_NOT_A_REPARSE_POINT;
+	}
+
+	case FSCTL_GET_SHADOW_COPY_DATA:
+	{
+		/*
+		 * This is called to retrieve the number of Shadow Copies (a.k.a. snapshots)
+		 * and return their volume names.  If max_data_count is 16, then it is just
+		 * asking for the number of volumes and length of the combined names.
+		 *
+		 * pdata is the data allocated by our caller, but that uses
+		 * total_data_count (which is 0 in our case) rather than max_data_count.
+		 * Allocate the correct amount and return the pointer to let
+		 * it be deallocated when we return.
+		 */
+		struct shadow_copy_data *shadow_data = NULL;
+		bool labels = False;
+		uint32 labels_data_count = 0;
+		uint32 i;
+		char *cur_pdata = NULL;
+
+		if (max_out_len < 16) {
+			DEBUG(0,("FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\n",
+				max_out_len));
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		if (max_out_len > 16) {
+			labels = True;
+		}
+
+		shadow_data = talloc_zero(ctx, struct shadow_copy_data);
+		if (shadow_data == NULL) {
+			DEBUG(0,("TALLOC_ZERO() failed!\n"));
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		/*
+		 * Call the VFS routine to actually do the work.
+		 */
+		if (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {
+			TALLOC_FREE(shadow_data);
+			if (errno == ENOSYS) {
+				DEBUG(5,("FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\n", 
+					fsp->conn->connectpath));
+				return NT_STATUS_NOT_SUPPORTED;
+			} else {
+				DEBUG(0,("FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\n", 
+					fsp->conn->connectpath));
+				return NT_STATUS_UNSUCCESSFUL;
+			}
+		}
+
+		labels_data_count = (shadow_data->num_volumes * 2 *
+					sizeof(SHADOW_COPY_LABEL)) + 2;
+
+		if (!labels) {
+			*out_len = 16;
+		} else {
+			*out_len = 12 + labels_data_count + 4;
+		}
+
+		if (max_out_len < *out_len) {
+			DEBUG(0,("FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\n",
+				max_out_len, *out_len));
+			TALLOC_FREE(shadow_data);
+			return NT_STATUS_BUFFER_TOO_SMALL;
+		}
+
+		cur_pdata = talloc_array(ctx, char, *out_len);
+		if (cur_pdata == NULL) {
+			TALLOC_FREE(shadow_data);
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		*out_data = cur_pdata;
+
+		/* num_volumes 4 bytes */
+		SIVAL(cur_pdata, 0, shadow_data->num_volumes);
+
+		if (labels) {
+			/* num_labels 4 bytes */
+			SIVAL(cur_pdata, 4, shadow_data->num_volumes);
+		}
+
+		/* needed_data_count 4 bytes */
+		SIVAL(cur_pdata, 8, labels_data_count + 4);
+
+		cur_pdata += 12;
+
+		DEBUG(10,("FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\n",
+			  shadow_data->num_volumes, fsp_str_dbg(fsp)));
+		if (labels && shadow_data->labels) {
+			for (i=0; i<shadow_data->num_volumes; i++) {
+				srvstr_push(cur_pdata, req_flags,
+					    cur_pdata, shadow_data->labels[i],
+					    2 * sizeof(SHADOW_COPY_LABEL),
+					    STR_UNICODE|STR_TERMINATE);
+				cur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);
+				DEBUGADD(10,("Label[%u]: '%s'\n",i,shadow_data->labels[i]));
+			}
+		}
+
+		TALLOC_FREE(shadow_data);
+
+		return NT_STATUS_OK;
+	}
+
+	case FSCTL_FIND_FILES_BY_SID:
+	{
+		/* pretend this succeeded -
+		 *
+		 * we have to send back a list with all files owned by this SID
+		 *
+		 * but I have to check that --metze
+		 */
+		struct dom_sid sid;
+		uid_t uid;
+		size_t sid_len;
+
+		DEBUG(10,("FSCTL_FIND_FILES_BY_SID: called on FID[0x%04X]\n", fsp->fnum));
+
+		if (in_len < 8) {
+			/* NT_STATUS_BUFFER_TOO_SMALL maybe? */
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		sid_len = MIN(in_len - 4,SID_MAX_SIZE);
+
+		/* unknown 4 bytes: this is not the length of the sid :-(  */
+		/*unknown = IVAL(pdata,0);*/
+
+		if (!sid_parse(in_data + 4, sid_len, &sid)) {
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+		DEBUGADD(10, ("for SID: %s\n", sid_string_dbg(&sid)));
+
+		if (!sid_to_uid(&sid, &uid)) {
+			DEBUG(0,("sid_to_uid: failed, sid[%s] sid_len[%lu]\n",
+				 sid_string_dbg(&sid),
+				 (unsigned long)sid_len));
+			uid = (-1);
+		}
+
+		/* we can take a look at the find source :-)
+		 *
+		 * find ./ -uid $uid  -name '*'   is what we need here
+		 *
+		 *
+		 * and send 4bytes len and then NULL terminated unicode strings
+		 * for each file
+		 *
+		 * but I don't know how to deal with the paged results
+		 * (maybe we can hang the result anywhere in the fsp struct)
+		 *
+		 * but I don't know how to deal with the paged results
+		 * (maybe we can hang the result anywhere in the fsp struct)
+		 *
+		 * we don't send all files at once
+		 * and at the next we should *not* start from the beginning,
+		 * so we have to cache the result
+		 *
+		 * --metze
+		 */
+
+		/* this works for now... */
+		return NT_STATUS_OK;
+	}
+
+	case FSCTL_QUERY_ALLOCATED_RANGES:
+	{
+		/* FIXME: This is just a dummy reply, telling that all of the
+		 * file is allocated. MKS cp needs that.
+		 * Adding the real allocated ranges via FIEMAP on Linux
+		 * and SEEK_DATA/SEEK_HOLE on Solaris is needed to make
+		 * this FSCTL correct for sparse files.
+		 */
+		NTSTATUS status;
+		uint64_t offset, length;
+		char *out_data_tmp = NULL;
+
+		if (in_len != 16) {
+			DEBUG(0,("FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\n",
+				in_len));
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		if (max_out_len < 16) {
+			DEBUG(0,("FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\n",
+				max_out_len));
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		offset = BVAL(in_data,0);
+		length = BVAL(in_data,8);
+
+		if (offset + length < offset) {
+			/* No 64-bit integer wrap. */
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		/* Shouldn't this be SMB_VFS_STAT ... ? */
+		status = vfs_stat_fsp(fsp);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+
+		*out_len = 16;
+		out_data_tmp = talloc_array(ctx, char, *out_len);
+		if (out_data_tmp == NULL) {
+			DEBUG(10, ("unable to allocate memory for response\n"));
+			return NT_STATUS_NO_MEMORY;
+		}
+
+		if (offset > fsp->fsp_name->st.st_ex_size ||
+				fsp->fsp_name->st.st_ex_size == 0 ||
+				length == 0) {
+			memset(out_data_tmp, 0, *out_len);
+		} else {
+			uint64_t end = offset + length;
+			end = MIN(end, fsp->fsp_name->st.st_ex_size);
+			SBVAL(out_data_tmp, 0, 0);
+			SBVAL(out_data_tmp, 8, end);
+		}
+
+		*out_data = out_data_tmp;
+
+		return NT_STATUS_OK;
+	}
+
+	case FSCTL_IS_VOLUME_DIRTY:
+	{
+		DEBUG(10,("FSCTL_IS_VOLUME_DIRTY: called on FID[0x%04X] "
+			  "(but not implemented)\n", fsp->fnum));
+		/*
+		 * http://msdn.microsoft.com/en-us/library/cc232128%28PROT.10%29.aspx
+		 * says we have to respond with NT_STATUS_INVALID_PARAMETER
+		 */
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	default:
+		/*
+		 * Only print once ... unfortunately there could be lots of
+		 * different FSCTLs that are called.
+		 */
+		if (!vfswrap_logged_ioctl_message) {
+			vfswrap_logged_ioctl_message = true;
+			DEBUG(2, ("%s (0x%x): Currently not implemented.\n",
+			__FUNCTION__, function));
+		}
+	}
+
+	return NT_STATUS_NOT_SUPPORTED;
+}
+
 /****************************************************************************
  Reply to NT IOCTL
 ****************************************************************************/
@@ -2225,7 +2533,7 @@
 	isFSctl = CVAL(*ppsetup, 6);
 	compfilter = CVAL(*ppsetup, 7);
 
-	DEBUG(10, ("call_nt_transact_ioctl: function[0x%08X] FID[0x%04X] isFSctl[0x%02X] compfilter[0x%02X]\n", 
+	DEBUG(10, ("call_nt_transact_ioctl: function[0x%08X] FID[0x%04X] isFSctl[0x%02X] compfilter[0x%02X]\n",
 		 function, fidnum, isFSctl, compfilter));
 
 	fsp=file_fsp(req, fidnum);
@@ -2245,18 +2553,16 @@
 		return;
 	}
 
-	SMB_PERFCOUNT_SET_IOCTL(&req->pcd, function);
-
 	/*
 	 * out_data might be allocated by the VFS module, but talloc should be
 	 * used, and should be cleaned up when the request ends.
 	 */
-	status = SMB_VFS_FSCTL(fsp, 
+	status = smb_fsctl(fsp,
 			       ctx,
-			       function, 
+			       function,
 			       req->flags2,
-			       (uint8_t *)pdata, 
-			       data_count, 
+			       (uint8_t *)pdata,
+			       data_count,
 			       (uint8_t **)&out_data,
 			       max_data_count,
 			       &out_data_len);
@@ -2304,8 +2610,8 @@
 	/* access check */
 	if (get_current_uid(conn) != 0) {
 		DEBUG(1,("get_user_quota: access_denied service [%s] user "
-			 "[%s]\n", lp_servicename(talloc_tos(), SNUM(conn)),
-			 conn->session_info->unix_info->unix_name));
+			 "[%s]\n", lp_servicename(SNUM(conn)),
+			 conn->session_info->unix_name));
 		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 		return;
 	}
@@ -2537,9 +2843,7 @@
 			break;
 
 		default:
-			DEBUG(0, ("do_nt_transact_get_user_quota: %s: unknown "
-				  "level 0x%04hX\n",
-				  fsp_fnum_dbg(fsp), level));
+			DEBUG(0,("do_nt_transact_get_user_quota: fnum %d unknown level 0x%04hX\n",fsp->fnum,level));
 			reply_nterror(req, NT_STATUS_INVALID_LEVEL);
 			return;
 			break;
@@ -2576,8 +2880,8 @@
 	/* access check */
 	if (get_current_uid(conn) != 0) {
 		DEBUG(1,("set_user_quota: access_denied service [%s] user "
-			 "[%s]\n", lp_servicename(talloc_tos(), SNUM(conn)),
-			 conn->session_info->unix_info->unix_name));
+			 "[%s]\n", lp_servicename(SNUM(conn)),
+			 conn->session_info->unix_name));
 		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 		return;
 	}
@@ -2658,7 +2962,7 @@
 {
 	if (get_Protocol() >= PROTOCOL_NT1) {
 		req->flags2 |= 0x40; /* IS_LONG_NAME */
-		SSVAL(discard_const_p(uint8_t, req->inbuf),smb_flg2,req->flags2);
+		SSVAL(req->inbuf,smb_flg2,req->flags2);
 	}
 
 
@@ -2826,7 +3130,7 @@
 		return;
 	}
 
-	if ((state = talloc(conn, struct trans_state)) == NULL) {
+	if ((state = TALLOC_P(conn, struct trans_state)) == NULL) {
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
 		END_PROFILE(SMBnttrans);
 		return;
@@ -3000,7 +3304,7 @@
 
 	START_PROFILE(SMBnttranss);
 
-	show_msg((const char *)req->inbuf);
+	show_msg((char *)req->inbuf);
 
 	/* Windows clients expect all replies to
 	   an NT transact secondary (SMBnttranss 0xA1)
Only in ../../samba-3.6.24/source3/smbd: nttrans.o
diff -ur smbd/open.c ../../samba-3.6.24/source3/smbd/open.c
--- smbd/open.c	2014-05-28 01:20:37.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/open.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,80 +27,78 @@
 #include "fake_file.h"
 #include "../libcli/security/security.h"
 #include "../librpc/gen_ndr/ndr_security.h"
-#include "../librpc/gen_ndr/open_files.h"
-#include "../librpc/gen_ndr/idmap.h"
-#include "passdb/lookup_sid.h"
 #include "auth.h"
-#include "serverid.h"
 #include "messages.h"
 
 extern const struct generic_mapping file_generic_mapping;
 
 struct deferred_open_record {
         bool delayed_for_oplocks;
-	bool async_open;
         struct file_id id;
 };
 
 /****************************************************************************
- If the requester wanted DELETE_ACCESS and was rejected because
- the file ACL didn't include DELETE_ACCESS, see if the parent ACL
- overrides this.
+ SMB1 file varient of se_access_check. Never test FILE_READ_ATTRIBUTES.
 ****************************************************************************/
 
-static bool parent_override_delete(connection_struct *conn,
-					const struct smb_filename *smb_fname,
-					uint32_t access_mask,
-					uint32_t rejected_mask)
+NTSTATUS smb1_file_se_access_check(struct connection_struct *conn,
+				const struct security_descriptor *sd,
+				const struct security_token *token,
+				uint32_t access_desired,
+				uint32_t *access_granted)
 {
-	if ((access_mask & DELETE_ACCESS) &&
-		    (rejected_mask & DELETE_ACCESS) &&
-		    can_delete_file_in_directory(conn, smb_fname)) {
-		return true;
+	*access_granted = 0;
+
+	if (get_current_uid(conn) == (uid_t)0) {
+		/* I'm sorry sir, I didn't know you were root... */
+		*access_granted = access_desired;
+		if (access_desired & SEC_FLAG_MAXIMUM_ALLOWED) {
+			*access_granted |= FILE_GENERIC_ALL;
+		}
+		return NT_STATUS_OK;
 	}
-	return false;
+
+	/*
+	 * If we can access the path to this file, by
+	 * default we have FILE_READ_ATTRIBUTES from the
+	 * containing directory. See the section:
+	 * "Algorithm to Check Access to an Existing File"
+	 * in MS-FSA.pdf.
+	 */
+	return se_access_check(sd,
+				token,
+				(access_desired & ~FILE_READ_ATTRIBUTES),
+				access_granted);
 }
 
 /****************************************************************************
  Check if we have open rights.
 ****************************************************************************/
 
-NTSTATUS smbd_check_access_rights(struct connection_struct *conn,
+NTSTATUS smbd_check_open_rights(struct connection_struct *conn,
 				const struct smb_filename *smb_fname,
-				uint32_t access_mask)
+				uint32_t access_mask,
+				uint32_t *access_granted)
 {
 	/* Check if we have rights to open. */
 	NTSTATUS status;
 	struct security_descriptor *sd = NULL;
 	uint32_t rejected_share_access;
-	uint32_t rejected_mask = access_mask;
-	uint32_t do_not_check_mask = 0;
 
 	rejected_share_access = access_mask & ~(conn->share_access);
 
 	if (rejected_share_access) {
-		DEBUG(10, ("smbd_check_access_rights: rejected share access 0x%x "
-			"on %s (0x%x)\n",
-			(unsigned int)access_mask,
-			smb_fname_str_dbg(smb_fname),
-			(unsigned int)rejected_share_access ));
+		*access_granted = rejected_share_access;
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
-	if (get_current_uid(conn) == (uid_t)0) {
-		/* I'm sorry sir, I didn't know you were root... */
-		DEBUG(10,("smbd_check_access_rights: root override "
-			"on %s. Granting 0x%x\n",
-			smb_fname_str_dbg(smb_fname),
-			(unsigned int)access_mask ));
-		return NT_STATUS_OK;
-	}
-
 	if ((access_mask & DELETE_ACCESS) && !lp_acl_check_permissions(SNUM(conn))) {
-		DEBUG(10,("smbd_check_access_rights: not checking ACL "
+		*access_granted = access_mask;
+
+		DEBUG(10,("smbd_check_open_rights: not checking ACL "
 			"on DELETE_ACCESS on file %s. Granting 0x%x\n",
 			smb_fname_str_dbg(smb_fname),
-			(unsigned int)access_mask ));
+			(unsigned int)*access_granted ));
 		return NT_STATUS_OK;
 	}
 
@@ -108,7 +106,7 @@
 			VALID_STAT(smb_fname->st) &&
 			S_ISLNK(smb_fname->st.st_ex_mode)) {
 		/* We can always delete a symlink. */
-		DEBUG(10,("smbd_check_access_rights: not checking ACL "
+		DEBUG(10,("smbd_check_open_rights: not checking ACL "
 			"on DELETE_ACCESS on symlink %s.\n",
 			smb_fname_str_dbg(smb_fname) ));
 		return NT_STATUS_OK;
@@ -117,60 +115,32 @@
 	status = SMB_VFS_GET_NT_ACL(conn, smb_fname->base_name,
 			(SECINFO_OWNER |
 			SECINFO_GROUP |
-			 SECINFO_DACL), talloc_tos(), &sd);
+			SECINFO_DACL),&sd);
 
 	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10, ("smbd_check_access_rights: Could not get acl "
+		DEBUG(10, ("smbd_check_open_rights: Could not get acl "
 			"on %s: %s\n",
 			smb_fname_str_dbg(smb_fname),
 			nt_errstr(status)));
-
-		if (NT_STATUS_EQUAL(status, NT_STATUS_ACCESS_DENIED)) {
-			goto access_denied;
-		}
-
 		return status;
 	}
 
- 	/*
-	 * If we can access the path to this file, by
-	 * default we have FILE_READ_ATTRIBUTES from the
-	 * containing directory. See the section:
-	 * "Algorithm to Check Access to an Existing File"
-	 * in MS-FSA.pdf.
-	 *
-	 * se_file_access_check() also takes care of
-	 * owner WRITE_DAC and READ_CONTROL.
-	 */
-	do_not_check_mask = FILE_READ_ATTRIBUTES;
-
-	/*
-	 * Samba 3.6 and earlier granted execute access even
-	 * if the ACL did not contain execute rights.
-	 * Samba 4.0 is more correct and checks it.
-	 * The compatibilty mode allows to skip this check
-	 * to smoothen upgrades.
-	 */
-	if (lp_acl_allow_execute_always(SNUM(conn))) {
-		do_not_check_mask |= FILE_EXECUTE;
-	}
-
-	status = se_file_access_check(sd,
+	status = smb1_file_se_access_check(conn,
+				sd,
 				get_current_nttok(conn),
-				false,
-				(access_mask & ~do_not_check_mask),
-				&rejected_mask);
+				access_mask,
+				access_granted);
 
-	DEBUG(10,("smbd_check_access_rights: file %s requesting "
+	DEBUG(10,("smbd_check_open_rights: file %s requesting "
 		"0x%x returning 0x%x (%s)\n",
 		smb_fname_str_dbg(smb_fname),
 		(unsigned int)access_mask,
-		(unsigned int)rejected_mask,
+		(unsigned int)*access_granted,
 		nt_errstr(status) ));
 
 	if (!NT_STATUS_IS_OK(status)) {
 		if (DEBUGLEVEL >= 10) {
-			DEBUG(10,("smbd_check_access_rights: acl for %s is:\n",
+			DEBUG(10,("smbd_check_open_rights: acl for %s is:\n",
 				smb_fname_str_dbg(smb_fname) ));
 			NDR_PRINT_DEBUG(security_descriptor, sd);
 		}
@@ -178,125 +148,7 @@
 
 	TALLOC_FREE(sd);
 
-	if (NT_STATUS_IS_OK(status) ||
-			!NT_STATUS_EQUAL(status, NT_STATUS_ACCESS_DENIED)) {
-		return status;
-	}
-
-	/* Here we know status == NT_STATUS_ACCESS_DENIED. */
-
-  access_denied:
-
-	if ((access_mask & FILE_WRITE_ATTRIBUTES) &&
-			(rejected_mask & FILE_WRITE_ATTRIBUTES) &&
-			!lp_store_dos_attributes(SNUM(conn)) &&
-			(lp_map_readonly(SNUM(conn)) ||
-			lp_map_archive(SNUM(conn)) ||
-			lp_map_hidden(SNUM(conn)) ||
-			lp_map_system(SNUM(conn)))) {
-		rejected_mask &= ~FILE_WRITE_ATTRIBUTES;
-
-		DEBUG(10,("smbd_check_access_rights: "
-			"overrode "
-			"FILE_WRITE_ATTRIBUTES "
-			"on file %s\n",
-			smb_fname_str_dbg(smb_fname)));
-	}
-
-	if (parent_override_delete(conn,
-				smb_fname,
-				access_mask,
-				rejected_mask)) {
-		/* Were we trying to do an open
-		 * for delete and didn't get DELETE
-		 * access (only) ? Check if the
-		 * directory allows DELETE_CHILD.
-		 * See here:
-		 * http://blogs.msdn.com/oldnewthing/archive/2004/06/04/148426.aspx
-		 * for details. */
-
-		rejected_mask &= ~DELETE_ACCESS;
-
-		DEBUG(10,("smbd_check_access_rights: "
-			"overrode "
-			"DELETE_ACCESS on "
-			"file %s\n",
-			smb_fname_str_dbg(smb_fname)));
-	}
-
-	if (rejected_mask != 0) {
-		return NT_STATUS_ACCESS_DENIED;
-	}
-	return NT_STATUS_OK;
-}
-
-static NTSTATUS check_parent_access(struct connection_struct *conn,
-				struct smb_filename *smb_fname,
-				uint32_t access_mask)
-{
-	NTSTATUS status;
-	char *parent_dir = NULL;
-	struct security_descriptor *parent_sd = NULL;
-	uint32_t access_granted = 0;
-
-	if (!parent_dirname(talloc_tos(),
-				smb_fname->base_name,
-				&parent_dir,
-				NULL)) {
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	if (get_current_uid(conn) == (uid_t)0) {
-		/* I'm sorry sir, I didn't know you were root... */
-		DEBUG(10,("check_parent_access: root override "
-			"on %s. Granting 0x%x\n",
-			smb_fname_str_dbg(smb_fname),
-			(unsigned int)access_mask ));
-		return NT_STATUS_OK;
-	}
-
-	status = SMB_VFS_GET_NT_ACL(conn,
-				parent_dir,
-				SECINFO_DACL,
-				    talloc_tos(),
-				&parent_sd);
-
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(5,("check_parent_access: SMB_VFS_GET_NT_ACL failed for "
-			"%s with error %s\n",
-			parent_dir,
-			nt_errstr(status)));
-		return status;
-	}
-
- 	/*
-	 * If we can access the path to this file, by
-	 * default we have FILE_READ_ATTRIBUTES from the
-	 * containing directory. See the section:
-	 * "Algorithm to Check Access to an Existing File"
-	 * in MS-FSA.pdf.
-	 *
-	 * se_file_access_check() also takes care of
-	 * owner WRITE_DAC and READ_CONTROL.
-	 */
-	status = se_file_access_check(parent_sd,
-				get_current_nttok(conn),
-				false,
-				(access_mask & ~FILE_READ_ATTRIBUTES),
-				&access_granted);
-	if(!NT_STATUS_IS_OK(status)) {
-		DEBUG(5,("check_parent_access: access check "
-			"on directory %s for "
-			"path %s for mask 0x%x returned (0x%x) %s\n",
-			parent_dir,
-			smb_fname->base_name,
-			access_mask,
-			access_granted,
-			nt_errstr(status) ));
-		return status;
-	}
-
-	return NT_STATUS_OK;
+	return status;
 }
 
 /****************************************************************************
@@ -308,9 +160,11 @@
 				struct smb_filename *smb_fname,
 				uint32_t access_mask)
 {
+	uint32_t access_granted = 0;
 	NTSTATUS status;
 
 	status = smbd_calculate_access_mask(conn, smb_fname,
+					false,
 					access_mask,
 					&access_mask);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -327,24 +181,26 @@
 			return NT_STATUS_ACCESS_DENIED;
 		}
 		dosattrs = dos_mode(conn, smb_fname);
-		if (IS_DOS_READONLY(dosattrs)) {
+ 		if (IS_DOS_READONLY(dosattrs)) {
 			return NT_STATUS_ACCESS_DENIED;
 		}
 	}
 
-	return smbd_check_access_rights(conn,
-					smb_fname,
-					access_mask);
+
+	return smbd_check_open_rights(conn,
+				smb_fname,
+				access_mask,
+				&access_granted);
 }
 
 /****************************************************************************
  fd support routines - attempt to do a dos_open.
 ****************************************************************************/
 
-NTSTATUS fd_open(struct connection_struct *conn,
-		 files_struct *fsp,
-		 int flags,
-		 mode_t mode)
+static NTSTATUS fd_open(struct connection_struct *conn,
+		    files_struct *fsp,
+		    int flags,
+		    mode_t mode)
 {
 	struct smb_filename *smb_fname = fsp->fsp_name;
 	NTSTATUS status = NT_STATUS_OK;
@@ -362,26 +218,7 @@
 
 	fsp->fh->fd = SMB_VFS_OPEN(conn, smb_fname, fsp, flags, mode);
 	if (fsp->fh->fd == -1) {
-		int posix_errno = errno;
-#ifdef O_NOFOLLOW
-#if defined(ENOTSUP) && defined(OSF1)
-		/* handle special Tru64 errno */
-		if (errno == ENOTSUP) {
-			posix_errno = ELOOP;
-		}
-#endif /* ENOTSUP */
-#ifdef EFTYPE
-		/* fix broken NetBSD errno */
-		if (errno == EFTYPE) {
-			posix_errno = ELOOP;
-		}
-#endif /* EFTYPE */
-		/* fix broken FreeBSD errno */
-		if (errno == EMLINK) {
-			posix_errno = ELOOP;
-		}
-#endif /* O_NOFOLLOW */
-		status = map_nt_error_from_unix(posix_errno);
+		status = map_nt_error_from_unix(errno);
 		if (errno == EMFILE) {
 			static time_t last_warned = 0L;
 
@@ -479,8 +316,8 @@
 			 strerror(errno) ));
 	} else {
 		DEBUG(10,("change_file_owner_to_parent: changed new file %s to "
-			"parent directory uid %u.\n", fsp_str_dbg(fsp),
-			(unsigned int)smb_fname_parent->st.st_ex_uid));
+		  "parent directory uid %u.\n", fsp_str_dbg(fsp),
+		  (unsigned int)smb_fname_parent->st.st_ex_uid));
 		/* Ensure the uid entry is updated. */
 		fsp->fsp_name->st.st_ex_uid = smb_fname_parent->st.st_ex_uid;
 	}
@@ -587,14 +424,13 @@
 			  "Error was %s\n", fname,
 			  (unsigned int)smb_fname_parent->st.st_ex_uid,
 			  strerror(errno) ));
-	} else {
-		DEBUG(10,("change_dir_owner_to_parent: changed ownership of new "
-			"directory %s to parent directory uid %u.\n",
-			fname, (unsigned int)smb_fname_parent->st.st_ex_uid ));
-		/* Ensure the uid entry is updated. */
-		psbuf->st_ex_uid = smb_fname_parent->st.st_ex_uid;
+		goto chdir;
 	}
 
+	DEBUG(10,("change_dir_owner_to_parent: changed ownership of new "
+		  "directory %s to parent directory uid %u.\n",
+		  fname, (unsigned int)smb_fname_parent->st.st_ex_uid ));
+
  chdir:
 	vfs_ChDir(conn,saved_dir);
  out:
@@ -604,106 +440,6 @@
 }
 
 /****************************************************************************
- Open a file - returning a guaranteed ATOMIC indication of if the
- file was created or not.
-****************************************************************************/
-
-static NTSTATUS fd_open_atomic(struct connection_struct *conn,
-			files_struct *fsp,
-			int flags,
-			mode_t mode,
-			bool *file_created)
-{
-	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
-	bool file_existed = VALID_STAT(fsp->fsp_name->st);
-
-	*file_created = false;
-
-	if (!(flags & O_CREAT)) {
-		/*
-		 * We're not creating the file, just pass through.
-		 */
-		return fd_open(conn, fsp, flags, mode);
-	}
-
-	if (flags & O_EXCL) {
-		/*
-		 * Fail if already exists, just pass through.
-		 */
-		status = fd_open(conn, fsp, flags, mode);
-
-		/*
-		 * Here we've opened with O_CREAT|O_EXCL. If that went
-		 * NT_STATUS_OK, we *know* we created this file.
-		 */
-		*file_created = NT_STATUS_IS_OK(status);
-
-		return status;
-	}
-
-	/*
-	 * Now it gets tricky. We have O_CREAT, but not O_EXCL.
-	 * To know absolutely if we created the file or not,
-	 * we can never call O_CREAT without O_EXCL. So if
-	 * we think the file existed, try without O_CREAT|O_EXCL.
-	 * If we think the file didn't exist, try with
-	 * O_CREAT|O_EXCL. Keep bouncing between these two
-	 * requests until either the file is created, or
-	 * opened. Either way, we keep going until we get
-	 * a returnable result (error, or open/create).
-	 */
-
-	while(1) {
-		int curr_flags = flags;
-
-		if (file_existed) {
-			/* Just try open, do not create. */
-			curr_flags &= ~(O_CREAT);
-			status = fd_open(conn, fsp, curr_flags, mode);
-			if (NT_STATUS_EQUAL(status,
-					NT_STATUS_OBJECT_NAME_NOT_FOUND)) {
-				/*
-				 * Someone deleted it in the meantime.
-				 * Retry with O_EXCL.
-				 */
-				file_existed = false;
-				DEBUG(10,("fd_open_atomic: file %s existed. "
-					"Retry.\n",
-					smb_fname_str_dbg(fsp->fsp_name)));
-					continue;
-			}
-		} else {
-			/* Try create exclusively, fail if it exists. */
-			curr_flags |= O_EXCL;
-			status = fd_open(conn, fsp, curr_flags, mode);
-			if (NT_STATUS_EQUAL(status,
-					NT_STATUS_OBJECT_NAME_COLLISION)) {
-				/*
-				 * Someone created it in the meantime.
-				 * Retry without O_CREAT.
-				 */
-				file_existed = true;
-				DEBUG(10,("fd_open_atomic: file %s "
-					"did not exist. Retry.\n",
-					smb_fname_str_dbg(fsp->fsp_name)));
-				continue;
-			}
-			if (NT_STATUS_IS_OK(status)) {
-				/*
-				 * Here we've opened with O_CREAT|O_EXCL
-				 * and got success. We *know* we created
-				 * this file.
-				 */
-				*file_created = true;
-			}
-		}
-		/* Create is done, or failed. */
-		break;
-	}
-	return status;
-}
-
-/****************************************************************************
  Open a file.
 ****************************************************************************/
 
@@ -714,14 +450,14 @@
 			  int flags,
 			  mode_t unx_mode,
 			  uint32 access_mask, /* client requested access mask. */
-			  uint32 open_access_mask, /* what we're actually using in the open. */
-			  bool *p_file_created)
+			  uint32 open_access_mask) /* what we're actually using in the open. */
 {
 	struct smb_filename *smb_fname = fsp->fsp_name;
 	NTSTATUS status = NT_STATUS_OK;
 	int accmode = (flags & O_ACCMODE);
 	int local_flags = flags;
 	bool file_existed = VALID_STAT(fsp->fsp_name->st);
+	bool file_created = false;
 
 	fsp->fh->fd = -1;
 	errno = EPERM;
@@ -776,7 +512,13 @@
 	    (!file_existed && (local_flags & O_CREAT)) ||
 	    ((local_flags & O_TRUNC) == O_TRUNC) ) {
 		const char *wild;
-		int ret;
+
+		/*
+		 * We can't actually truncate here as the file may be locked.
+		 * open_file_ntcreate will take care of the truncate later. JRA.
+		 */
+
+		local_flags &= ~O_TRUNC;
 
 #if defined(O_NONBLOCK) && defined(S_ISFIFO)
 		/*
@@ -786,7 +528,6 @@
 		 */
 
 		if (file_existed && S_ISFIFO(smb_fname->st.st_ex_mode)) {
-			local_flags &= ~O_TRUNC; /* Can't truncate a FIFO. */
 			local_flags |= O_NONBLOCK;
 		}
 #endif
@@ -806,37 +547,8 @@
 			return NT_STATUS_OBJECT_NAME_INVALID;
 		}
 
-		/* Can we access this file ? */
-		if (!fsp->base_fsp) {
-			/* Only do this check on non-stream open. */
-			if (file_existed) {
-				status = smbd_check_access_rights(conn,
-						smb_fname,
-						access_mask);
-			} else if (local_flags & O_CREAT){
-				status = check_parent_access(conn,
-						smb_fname,
-						SEC_DIR_ADD_FILE);
-			} else {
-				/* File didn't exist and no O_CREAT. */
-				return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-			}
-			if (!NT_STATUS_IS_OK(status)) {
-				DEBUG(10,("open_file: "
-					"%s on file "
-					"%s returned %s\n",
-					file_existed ?
-						"smbd_check_access_rights" :
-						"check_parent_access",
-					smb_fname_str_dbg(smb_fname),
-					nt_errstr(status) ));
-				return status;
-			}
-		}
-
 		/* Actually do the open */
-		status = fd_open_atomic(conn, fsp, local_flags,
-				unx_mode, p_file_created);
+		status = fd_open(conn, fsp, local_flags, unx_mode);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(3,("Error opening file %s (%s) (local_flags=%d) "
 				 "(flags=%d)\n", smb_fname_str_dbg(smb_fname),
@@ -844,24 +556,122 @@
 			return status;
 		}
 
-		ret = SMB_VFS_FSTAT(fsp, &smb_fname->st);
-		if (ret == -1) {
+		if ((local_flags & O_CREAT) && !file_existed) {
+			file_created = true;
+		}
+
+	} else {
+		fsp->fh->fd = -1; /* What we used to call a stat open. */
+		if (file_existed) {
+			uint32_t access_granted = 0;
+
+			status = smbd_check_open_rights(conn,
+					smb_fname,
+					access_mask,
+					&access_granted);
+			if (!NT_STATUS_IS_OK(status)) {
+				if (NT_STATUS_EQUAL(status, NT_STATUS_ACCESS_DENIED)) {
+					/*
+					 * On NT_STATUS_ACCESS_DENIED, access_granted
+					 * contains the denied bits.
+					 */
+
+					if ((access_mask & FILE_WRITE_ATTRIBUTES) &&
+							(access_granted & FILE_WRITE_ATTRIBUTES) &&
+							(lp_map_readonly(SNUM(conn)) ||
+							 lp_map_archive(SNUM(conn)) ||
+							 lp_map_hidden(SNUM(conn)) ||
+							 lp_map_system(SNUM(conn)))) {
+						access_granted &= ~FILE_WRITE_ATTRIBUTES;
+
+						DEBUG(10,("open_file: "
+							  "overrode "
+							  "FILE_WRITE_"
+							  "ATTRIBUTES "
+							  "on file %s\n",
+							  smb_fname_str_dbg(
+								  smb_fname)));
+					}
+
+					if ((access_mask & DELETE_ACCESS) &&
+					    (access_granted & DELETE_ACCESS) &&
+					    can_delete_file_in_directory(conn,
+						smb_fname)) {
+						/* Were we trying to do a stat open
+						 * for delete and didn't get DELETE
+						 * access (only) ? Check if the
+						 * directory allows DELETE_CHILD.
+						 * See here:
+						 * http://blogs.msdn.com/oldnewthing/archive/2004/06/04/148426.aspx
+						 * for details. */
+
+						access_granted &= ~DELETE_ACCESS;
+
+						DEBUG(10,("open_file: "
+							  "overrode "
+							  "DELETE_ACCESS on "
+							  "file %s\n",
+							  smb_fname_str_dbg(
+								  smb_fname)));
+					}
+
+					if (access_granted != 0) {
+						DEBUG(10,("open_file: Access "
+							  "denied on file "
+							  "%s\n",
+							  smb_fname_str_dbg(
+								  smb_fname)));
+						return status;
+					}
+				} else if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND) &&
+				    fsp->posix_open &&
+				    S_ISLNK(smb_fname->st.st_ex_mode)) {
+					/* This is a POSIX stat open for delete
+					 * or rename on a symlink that points
+					 * nowhere. Allow. */
+					DEBUG(10,("open_file: allowing POSIX "
+						  "open on bad symlink %s\n",
+						  smb_fname_str_dbg(
+							  smb_fname)));
+				} else {
+					DEBUG(10,("open_file: "
+						  "smbd_check_open_rights on file "
+						  "%s returned %s\n",
+						  smb_fname_str_dbg(smb_fname),
+						  nt_errstr(status) ));
+					return status;
+				}
+			}
+		}
+	}
+
+	if (!file_existed) {
+		int ret;
+
+		if (fsp->fh->fd == -1) {
+			ret = SMB_VFS_STAT(conn, smb_fname);
+		} else {
+			ret = SMB_VFS_FSTAT(fsp, &smb_fname->st);
 			/* If we have an fd, this stat should succeed. */
-			DEBUG(0,("Error doing fstat on open file %s "
-				"(%s)\n",
-				smb_fname_str_dbg(smb_fname),
-				strerror(errno) ));
+			if (ret == -1) {
+				DEBUG(0,("Error doing fstat on open file %s "
+					 "(%s)\n",
+					 smb_fname_str_dbg(smb_fname),
+					 strerror(errno) ));
+			}
+		}
+
+		/* For a non-io open, this stat failing means file not found. JRA */
+		if (ret == -1) {
 			status = map_nt_error_from_unix(errno);
 			fd_close(fsp);
 			return status;
 		}
 
-		if (*p_file_created) {
-			/* We created this file. */
-
+		if (file_created) {
 			bool need_re_stat = false;
 			/* Do all inheritance work after we've
-			   done a successful fstat call and filled
+			   done a successful stat call and filled
 			   in the stat struct in fsp->fsp_name. */
 
 			/* Inherit the ACL if required */
@@ -880,13 +690,17 @@
 			}
 
 			if (need_re_stat) {
-				ret = SMB_VFS_FSTAT(fsp, &smb_fname->st);
-				/* If we have an fd, this stat should succeed. */
-				if (ret == -1) {
-					DEBUG(0,("Error doing fstat on open file %s "
-						 "(%s)\n",
-						 smb_fname_str_dbg(smb_fname),
-						 strerror(errno) ));
+				if (fsp->fh->fd == -1) {
+					ret = SMB_VFS_STAT(conn, smb_fname);
+				} else {
+					ret = SMB_VFS_FSTAT(fsp, &smb_fname->st);
+					/* If we have an fd, this stat should succeed. */
+					if (ret == -1) {
+						DEBUG(0,("Error doing fstat on open file %s "
+							 "(%s)\n",
+							 smb_fname_str_dbg(smb_fname),
+							 strerror(errno) ));
+					}
 				}
 			}
 
@@ -894,37 +708,6 @@
 				     FILE_NOTIFY_CHANGE_FILE_NAME,
 				     smb_fname->base_name);
 		}
-	} else {
-		fsp->fh->fd = -1; /* What we used to call a stat open. */
-		if (!file_existed) {
-			/* File must exist for a stat open. */
-			return NT_STATUS_OBJECT_NAME_NOT_FOUND;
-		}
-
-		status = smbd_check_access_rights(conn,
-				smb_fname,
-				access_mask);
-
-		if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND) &&
-				fsp->posix_open &&
-				S_ISLNK(smb_fname->st.st_ex_mode)) {
-			/* This is a POSIX stat open for delete
-			 * or rename on a symlink that points
-			 * nowhere. Allow. */
-			DEBUG(10,("open_file: allowing POSIX "
-				  "open on bad symlink %s\n",
-				  smb_fname_str_dbg(smb_fname)));
-			status = NT_STATUS_OK;
-		}
-
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(10,("open_file: "
-				"smbd_check_access_rights on file "
-				"%s returned %s\n",
-				smb_fname_str_dbg(smb_fname),
-				nt_errstr(status) ));
-			return status;
-		}
 	}
 
 	/*
@@ -939,14 +722,18 @@
 		return NT_STATUS_FILE_IS_A_DIRECTORY;
 	}
 
+	fsp->mode = smb_fname->st.st_ex_mode;
 	fsp->file_id = vfs_file_id_from_sbuf(conn, &smb_fname->st);
 	fsp->vuid = req ? req->vuid : UID_FIELD_INVALID;
 	fsp->file_pid = req ? req->smbpid : 0;
 	fsp->can_lock = True;
-	fsp->can_read = ((access_mask & FILE_READ_DATA) != 0);
-	fsp->can_write =
-		CAN_WRITE(conn) &&
-		((access_mask & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0);
+	fsp->can_read = (access_mask & (FILE_READ_DATA)) ? True : False;
+	if (!CAN_WRITE(conn)) {
+		fsp->can_write = False;
+	} else {
+		fsp->can_write = (access_mask & (FILE_WRITE_DATA | FILE_APPEND_DATA)) ?
+			True : False;
+	}
 	fsp->print_file = NULL;
 	fsp->modified = False;
 	fsp->sent_oplock_break = NO_BREAK_SENT;
@@ -960,7 +747,7 @@
 	fsp->wcp = NULL; /* Write cache pointer. */
 
 	DEBUG(2,("%s opened file %s read=%s write=%s (numopen=%d)\n",
-		 conn->session_info->unix_info->unix_name,
+		 conn->session_info->unix_name,
 		 smb_fname_str_dbg(smb_fname),
 		 BOOLSTR(fsp->can_read), BOOLSTR(fsp->can_write),
 		 conn->num_files_open));
@@ -985,14 +772,6 @@
 		  (unsigned int)entry->share_access,
 		  (unsigned int)entry->private_options));
 
-	if (server_id_is_disconnected(&entry->pid)) {
-		/*
-		 * note: cleanup should have been done by
-		 * delay_for_batch_oplocks()
-		 */
-		return false;
-	}
-
 	DEBUG(10,("share_conflict: access_mask = 0x%x, share_access = 0x%x\n",
 		  (unsigned int)access_mask, (unsigned int)share_access));
 
@@ -1066,15 +845,14 @@
 				      int num,
 				      struct share_mode_entry *share_entry)
 {
-	struct server_id self = messaging_server_id(sconn->msg_ctx);
 	files_struct *fsp;
 
-	if (!serverid_equal(&self, &share_entry->pid)) {
+	if (!procid_is_me(&share_entry->pid)) {
 		return;
 	}
 
 	if (is_deferred_open_entry(share_entry) &&
-	    !open_was_deferred(sconn, share_entry->op_mid)) {
+	    !open_was_deferred(share_entry->op_mid)) {
 		char *str = talloc_asprintf(talloc_tos(),
 			"Got a deferred entry without a request: "
 			"PANIC: %s\n",
@@ -1082,11 +860,6 @@
 		smb_panic(str);
 	}
 
-	if (share_entry->share_file_id == 0) {
-		/* INTERNAL_OPEN_ONLY */
-		return;
-	}
-
 	if (!is_valid_share_mode_entry(share_entry)) {
 		return;
 	}
@@ -1100,7 +873,8 @@
 			  "share entry with an open file\n");
 	}
 
-	if (is_deferred_open_entry(share_entry)) {
+	if (is_deferred_open_entry(share_entry) ||
+	    is_unused_share_mode_entry(share_entry)) {
 		goto panic;
 	}
 
@@ -1158,27 +932,16 @@
 {
 	int i;
 
-	if(lck->data->num_share_modes == 0) {
+	if(lck->num_share_modes == 0) {
 		return NT_STATUS_OK;
 	}
 
+	*file_existed = True;
+
 	/* A delete on close prohibits everything */
 
 	if (is_delete_on_close_set(lck, name_hash)) {
-		/*
-		 * Check the delete on close token
-		 * is valid. It could have been left
-		 * after a server crash.
-		 */
-		for(i = 0; i < lck->data->num_share_modes; i++) {
-			if (!share_mode_stale_pid(lck->data, i)) {
-
-				*file_existed = true;
-
-				return NT_STATUS_DELETE_PENDING;
-			}
-		}
-		return NT_STATUS_OK;
+		return NT_STATUS_DELETE_PENDING;
 	}
 
 	if (is_stat_open(access_mask)) {
@@ -1192,38 +955,31 @@
 	 */
 
 #if defined(DEVELOPER)
-	for(i = 0; i < lck->data->num_share_modes; i++) {
+	for(i = 0; i < lck->num_share_modes; i++) {
 		validate_my_share_entries(conn->sconn, i,
-					  &lck->data->share_modes[i]);
+					  &lck->share_modes[i]);
 	}
 #endif
 
+	if (!lp_share_modes(SNUM(conn))) {
+		return NT_STATUS_OK;
+	}
+
 	/* Now we check the share modes, after any oplock breaks. */
-	for(i = 0; i < lck->data->num_share_modes; i++) {
+	for(i = 0; i < lck->num_share_modes; i++) {
 
-		if (!is_valid_share_mode_entry(&lck->data->share_modes[i])) {
+		if (!is_valid_share_mode_entry(&lck->share_modes[i])) {
 			continue;
 		}
 
 		/* someone else has a share lock on it, check to see if we can
 		 * too */
-		if (share_conflict(&lck->data->share_modes[i],
+		if (share_conflict(&lck->share_modes[i],
 				   access_mask, share_access)) {
-
-			if (share_mode_stale_pid(lck->data, i)) {
-				continue;
-			}
-
-			*file_existed = true;
-
 			return NT_STATUS_SHARING_VIOLATION;
 		}
 	}
 
-	if (lck->data->num_share_modes != 0) {
-		*file_existed = true;
-	}
-
 	return NT_STATUS_OK;
 }
 
@@ -1278,7 +1034,7 @@
 
 static void find_oplock_types(files_struct *fsp,
 				int oplock_request,
-				const struct share_mode_lock *lck,
+				struct share_mode_lock *lck,
 				struct share_mode_entry **pp_batch,
 				struct share_mode_entry **pp_ex_or_batch,
 				bool *got_level2,
@@ -1299,63 +1055,44 @@
 		return;
 	}
 
-	for (i=0; i<lck->data->num_share_modes; i++) {
-		struct share_mode_entry *e = &lck->data->share_modes[i];
-
-		if (!is_valid_share_mode_entry(e)) {
+	for (i=0; i<lck->num_share_modes; i++) {
+		if (!is_valid_share_mode_entry(&lck->share_modes[i])) {
 			continue;
 		}
 
-		if (e->op_type == NO_OPLOCK && is_stat_open(e->access_mask)) {
+		if (lck->share_modes[i].op_type == NO_OPLOCK &&
+				is_stat_open(lck->share_modes[i].access_mask)) {
 			/* We ignore stat opens in the table - they
 			   always have NO_OPLOCK and never get or
 			   cause breaks. JRA. */
 			continue;
 		}
 
-		if (BATCH_OPLOCK_TYPE(e->op_type)) {
+		if (BATCH_OPLOCK_TYPE(lck->share_modes[i].op_type)) {
 			/* batch - can only be one. */
-			if (share_mode_stale_pid(lck->data, i)) {
-				DEBUG(10, ("Found stale batch oplock\n"));
-				continue;
-			}
 			if (*pp_ex_or_batch || *pp_batch || *got_level2 || *got_no_oplock) {
 				smb_panic("Bad batch oplock entry.");
 			}
-			*pp_batch = e;
+			*pp_batch = &lck->share_modes[i];
 		}
 
-		if (EXCLUSIVE_OPLOCK_TYPE(e->op_type)) {
-			if (share_mode_stale_pid(lck->data, i)) {
-				DEBUG(10, ("Found stale duplicate oplock\n"));
-				continue;
-			}
+		if (EXCLUSIVE_OPLOCK_TYPE(lck->share_modes[i].op_type)) {
 			/* Exclusive or batch - can only be one. */
 			if (*pp_ex_or_batch || *got_level2 || *got_no_oplock) {
 				smb_panic("Bad exclusive or batch oplock entry.");
 			}
-			*pp_ex_or_batch = e;
+			*pp_ex_or_batch = &lck->share_modes[i];
 		}
 
-		if (LEVEL_II_OPLOCK_TYPE(e->op_type)) {
+		if (LEVEL_II_OPLOCK_TYPE(lck->share_modes[i].op_type)) {
 			if (*pp_batch || *pp_ex_or_batch) {
-				if (share_mode_stale_pid(lck->data, i)) {
-					DEBUG(10, ("Found stale LevelII "
-						   "oplock\n"));
-					continue;
-				}
 				smb_panic("Bad levelII oplock entry.");
 			}
 			*got_level2 = true;
 		}
 
-		if (e->op_type == NO_OPLOCK) {
+		if (lck->share_modes[i].op_type == NO_OPLOCK) {
 			if (*pp_batch || *pp_ex_or_batch) {
-				if (share_mode_stale_pid(lck->data, i)) {
-					DEBUG(10, ("Found stale NO_OPLOCK "
-						   "entry\n"));
-					continue;
-				}
 				smb_panic("Bad no oplock entry.");
 			}
 			*got_no_oplock = true;
@@ -1371,26 +1108,13 @@
 	if ((oplock_request & INTERNAL_OPEN_ONLY) || is_stat_open(fsp->access_mask)) {
 		return false;
 	}
-	if (batch_entry == NULL) {
-		return false;
-	}
 
-	if (server_id_is_disconnected(&batch_entry->pid)) {
-		/*
-		 * TODO: clean up.
-		 * This could be achieved by sending a break message
-		 * to ourselves. Special considerations for files
-		 * with delete_on_close flag set!
-		 *
-		 * For now we keep it simple and do not
-		 * allow delete on close for durable handles.
-		 */
-		return false;
+	if (batch_entry != NULL) {
+		/* Found a batch oplock */
+		send_break_message(fsp, batch_entry, mid, oplock_request);
+		return true;
 	}
-
-	/* Found a batch oplock */
-	send_break_message(fsp, batch_entry, mid, oplock_request);
-	return true;
+	return false;
 }
 
 static bool delay_for_exclusive_oplocks(files_struct *fsp,
@@ -1401,35 +1125,16 @@
 	if ((oplock_request & INTERNAL_OPEN_ONLY) || is_stat_open(fsp->access_mask)) {
 		return false;
 	}
-	if (ex_entry == NULL) {
-		return false;
-	}
 
-	if (server_id_is_disconnected(&ex_entry->pid)) {
-		/*
-		 * since only durable handles can get disconnected,
-		 * and we can only get durable handles with batch oplocks,
-		 * this should actually never be reached...
-		 */
-		return false;
+	if (ex_entry != NULL) {
+		send_break_message(fsp, ex_entry, mid, oplock_request);
+		return true;
 	}
-
-	send_break_message(fsp, ex_entry, mid, oplock_request);
-	return true;
-}
-
-static bool file_has_brlocks(files_struct *fsp)
-{
-	struct byte_range_lock *br_lck;
-
-	br_lck = brl_get_locks_readonly(fsp);
-	if (!br_lck)
-		return false;
-
-	return br_lck->num_locks > 0 ? true : false;
+	return false;
 }
 
 static void grant_fsp_oplock_type(files_struct *fsp,
+				const struct byte_range_lock *br_lck,
 				int oplock_request,
 				bool got_level2_oplock,
 				bool got_a_none_oplock)
@@ -1447,9 +1152,7 @@
 		DEBUG(10,("grant_fsp_oplock_type: oplock type 0x%x on file %s\n",
 			fsp->oplock_type, fsp_str_dbg(fsp)));
 		return;
-	}
-
-	if (lp_locking(fsp->conn->params) && file_has_brlocks(fsp)) {
+	} else if (br_lck && br_lck->num_locks > 0) {
 		DEBUG(10,("grant_fsp_oplock_type: file %s has byte range locks\n",
 			fsp_str_dbg(fsp)));
 		fsp->oplock_type = NO_OPLOCK;
@@ -1499,8 +1202,8 @@
 		  fsp->oplock_type, fsp_str_dbg(fsp)));
 }
 
-static bool request_timed_out(struct timeval request_time,
-			      struct timeval timeout)
+bool request_timed_out(struct timeval request_time,
+		       struct timeval timeout)
 {
 	struct timeval now, end_time;
 	GetTimeOfDay(&now);
@@ -1518,25 +1221,22 @@
 		       struct smb_request *req,
 		       struct deferred_open_record *state)
 {
-	struct server_id self = messaging_server_id(req->sconn->msg_ctx);
+	int i;
 
 	/* Paranoia check */
 
-	if (lck) {
-		int i;
+	for (i=0; i<lck->num_share_modes; i++) {
+		struct share_mode_entry *e = &lck->share_modes[i];
 
-		for (i=0; i<lck->data->num_share_modes; i++) {
-			struct share_mode_entry *e = &lck->data->share_modes[i];
+		if (!is_deferred_open_entry(e)) {
+			continue;
+		}
 
-			if (is_deferred_open_entry(e) &&
-			    serverid_equal(&self, &e->pid) &&
-			    (e->op_mid == req->mid)) {
-				DEBUG(0, ("Trying to defer an already deferred "
-					"request: mid=%llu, exiting\n",
-					(unsigned long long)req->mid));
-				TALLOC_FREE(lck);
-				exit_server("attempt to defer a deferred request");
-			}
+		if (procid_is_me(&e->pid) && (e->op_mid == req->mid)) {
+			DEBUG(0, ("Trying to defer an already deferred "
+				"request: mid=%llu, exiting\n",
+				(unsigned long long)req->mid));
+			exit_server("attempt to defer a deferred request");
 		}
 	}
 
@@ -1550,12 +1250,10 @@
 
 	if (!push_deferred_open_message_smb(req, request_time, timeout,
 				       state->id, (char *)state, sizeof(*state))) {
-		TALLOC_FREE(lck);
 		exit_server("push_deferred_open_message_smb failed");
 	}
-	if (lck) {
-		add_deferred_open(lck, req->mid, request_time, self, state->id);
-	}
+	add_deferred_open(lck, req->mid, request_time,
+			  sconn_server_id(req->sconn), state->id);
 }
 
 
@@ -1563,12 +1261,12 @@
  On overwrite open ensure that the attributes match.
 ****************************************************************************/
 
-static bool open_match_attributes(connection_struct *conn,
-				  uint32 old_dos_attr,
-				  uint32 new_dos_attr,
-				  mode_t existing_unx_mode,
-				  mode_t new_unx_mode,
-				  mode_t *returned_unx_mode)
+bool open_match_attributes(connection_struct *conn,
+			   uint32 old_dos_attr,
+			   uint32 new_dos_attr,
+			   mode_t existing_unx_mode,
+			   mode_t new_unx_mode,
+			   mode_t *returned_unx_mode)
 {
 	uint32 noarch_old_dos_attr, noarch_new_dos_attr;
 
@@ -1611,16 +1309,16 @@
  Try and find a duplicated file handle.
 ****************************************************************************/
 
-static NTSTATUS fcb_or_dos_open(struct smb_request *req,
-				connection_struct *conn,
-				files_struct *fsp_to_dup_into,
-				const struct smb_filename *smb_fname,
-				struct file_id id,
-				uint16 file_pid,
-				uint64_t vuid,
-				uint32 access_mask,
-				uint32 share_access,
-				uint32 create_options)
+NTSTATUS fcb_or_dos_open(struct smb_request *req,
+				     connection_struct *conn,
+				     files_struct *fsp_to_dup_into,
+				     const struct smb_filename *smb_fname,
+				     struct file_id id,
+				     uint16 file_pid,
+				     uint16 vuid,
+				     uint32 access_mask,
+				     uint32 share_access,
+				     uint32 create_options)
 {
 	files_struct *fsp;
 
@@ -1631,9 +1329,9 @@
 	    fsp = file_find_di_next(fsp)) {
 
 		DEBUG(10,("fcb_or_dos_open: checking file %s, fd = %d, "
-			  "vuid = %llu, file_pid = %u, private_options = 0x%x "
+			  "vuid = %u, file_pid = %u, private_options = 0x%x "
 			  "access_mask = 0x%x\n", fsp_str_dbg(fsp),
-			  fsp->fh->fd, (unsigned long long)fsp->vuid,
+			  fsp->fh->fd, (unsigned int)fsp->vuid,
 			  (unsigned int)fsp->file_pid,
 			  (unsigned int)fsp->fh->private_options,
 			  (unsigned int)fsp->access_mask ));
@@ -1698,8 +1396,7 @@
 	   a 1 second delay for share mode conflicts. */
 
 	state.delayed_for_oplocks = True;
-	state.async_open = false;
-	state.id = lck->data->id;
+	state.id = lck->id;
 
 	if (!request_timed_out(request_time, timeout)) {
 		defer_open(lck, request_time, timeout, req, &state);
@@ -1707,103 +1404,12 @@
 }
 
 /****************************************************************************
- Reschedule an open call that went asynchronous.
-****************************************************************************/
-
-static void schedule_async_open(struct timeval request_time,
-				struct smb_request *req)
-{
-	struct deferred_open_record state;
-	struct timeval timeout;
-
-	timeout = timeval_set(20, 0);
-
-	ZERO_STRUCT(state);
-	state.delayed_for_oplocks = false;
-	state.async_open = true;
-
-	if (!request_timed_out(request_time, timeout)) {
-		defer_open(NULL, request_time, timeout, req, &state);
-	}
-}
-
-/****************************************************************************
  Work out what access_mask to use from what the client sent us.
 ****************************************************************************/
 
-static NTSTATUS smbd_calculate_maximum_allowed_access(
-	connection_struct *conn,
-	const struct smb_filename *smb_fname,
-	uint32_t *p_access_mask)
-{
-	struct security_descriptor *sd;
-	uint32_t access_granted;
-	NTSTATUS status;
-
-	if (get_current_uid(conn) == (uid_t)0) {
-		*p_access_mask |= FILE_GENERIC_ALL;
-		return NT_STATUS_OK;
-	}
-
-	status = SMB_VFS_GET_NT_ACL(conn, smb_fname->base_name,
-				    (SECINFO_OWNER |
-				     SECINFO_GROUP |
-				     SECINFO_DACL),
-				    talloc_tos(), &sd);
-
-	if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND)) {
-		/*
-		 * File did not exist
-		 */
-		*p_access_mask = FILE_GENERIC_ALL;
-		return NT_STATUS_OK;
-	}
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10,("smbd_calculate_access_mask: "
-			  "Could not get acl on file %s: %s\n",
-			  smb_fname_str_dbg(smb_fname),
-			  nt_errstr(status)));
-		return NT_STATUS_ACCESS_DENIED;
-	}
-
-	/*
-	 * If we can access the path to this file, by
-	 * default we have FILE_READ_ATTRIBUTES from the
-	 * containing directory. See the section:
-	 * "Algorithm to Check Access to an Existing File"
-	 * in MS-FSA.pdf.
-	 *
-	 * se_file_access_check()
-	 * also takes care of owner WRITE_DAC and READ_CONTROL.
-	 */
-	status = se_file_access_check(sd,
-				 get_current_nttok(conn),
-				 false,
-				 (*p_access_mask & ~FILE_READ_ATTRIBUTES),
-				 &access_granted);
-
-	TALLOC_FREE(sd);
-
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(10, ("smbd_calculate_access_mask: "
-			   "Access denied on file %s: "
-			   "when calculating maximum access\n",
-			   smb_fname_str_dbg(smb_fname)));
-		return NT_STATUS_ACCESS_DENIED;
-	}
-	*p_access_mask = (access_granted | FILE_READ_ATTRIBUTES);
-
-	if (!(access_granted & DELETE_ACCESS)) {
-		if (can_delete_file_in_directory(conn, smb_fname)) {
-			*p_access_mask |= DELETE_ACCESS;
-		}
-	}
-
-	return NT_STATUS_OK;
-}
-
 NTSTATUS smbd_calculate_access_mask(connection_struct *conn,
 				    const struct smb_filename *smb_fname,
+				    bool file_existed,
 				    uint32_t access_mask,
 				    uint32_t *access_mask_out)
 {
@@ -1819,12 +1425,56 @@
 
 	/* Calculate MAXIMUM_ALLOWED_ACCESS if requested. */
 	if (access_mask & MAXIMUM_ALLOWED_ACCESS) {
+		if (file_existed) {
 
-		status = smbd_calculate_maximum_allowed_access(
-			conn, smb_fname, &access_mask);
+			struct security_descriptor *sd;
+			uint32_t access_granted = 0;
 
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
+			status = SMB_VFS_GET_NT_ACL(conn, smb_fname->base_name,
+					(SECINFO_OWNER |
+					SECINFO_GROUP |
+					SECINFO_DACL),&sd);
+
+			if (!NT_STATUS_IS_OK(status)) {
+				DEBUG(10,("smbd_calculate_access_mask: "
+					"Could not get acl on file %s: %s\n",
+					smb_fname_str_dbg(smb_fname),
+					nt_errstr(status)));
+				return NT_STATUS_ACCESS_DENIED;
+			}
+
+			status = smb1_file_se_access_check(conn,
+					sd,
+					get_current_nttok(conn),
+					access_mask,
+					&access_granted);
+
+			TALLOC_FREE(sd);
+
+			if (!NT_STATUS_IS_OK(status)) {
+				DEBUG(10, ("smbd_calculate_access_mask: "
+					"Access denied on file %s: "
+					"when calculating maximum access\n",
+					smb_fname_str_dbg(smb_fname)));
+				return NT_STATUS_ACCESS_DENIED;
+			}
+
+			if (!(access_granted & DELETE_ACCESS)) {
+				if (can_delete_file_in_directory(conn, smb_fname)) {
+					access_granted |= DELETE_ACCESS;
+				}
+			}
+
+			/*
+			 * If we can access the path to this file, by
+			 * default we have FILE_READ_ATTRIBUTES from the
+			 * containing directory. See the section.
+			 * "Algorithm to Check Access to an Existing File"
+			 * in MS-FSA.pdf.
+			 */
+			access_mask = access_granted | FILE_READ_ATTRIBUTES;
+		} else {
+			access_mask = FILE_GENERIC_ALL;
 		}
 
 		access_mask &= conn->share_access;
@@ -1854,94 +1504,63 @@
 void remove_deferred_open_entry(struct file_id id, uint64_t mid,
 				struct server_id pid)
 {
-	struct share_mode_lock *lck = get_existing_share_mode_lock(
-		talloc_tos(), id);
+	struct share_mode_lock *lck = get_share_mode_lock(talloc_tos(), id,
+			NULL, NULL, NULL);
 	if (lck == NULL) {
 		DEBUG(0, ("could not get share mode lock\n"));
-		return;
-	}
-	del_deferred_open_entry(lck, mid, pid);
-	TALLOC_FREE(lck);
-}
-
-/****************************************************************************
- Return true if this is a state pointer to an asynchronous create.
-****************************************************************************/
-
-bool is_deferred_open_async(const void *ptr)
-{
-	const struct deferred_open_record *state = (const struct deferred_open_record *)ptr;
-
-	return state->async_open;
-}
-
-static bool clear_ads(uint32_t create_disposition)
-{
-	bool ret = false;
-
-	switch (create_disposition) {
-	case FILE_SUPERSEDE:
-	case FILE_OVERWRITE_IF:
-	case FILE_OVERWRITE:
-		ret = true;
-		break;
-	default:
-		break;
+	} else {
+		del_deferred_open_entry(lck, mid, pid);
+		TALLOC_FREE(lck);
 	}
-	return ret;
 }
 
-static int disposition_to_open_flags(uint32_t create_disposition)
-{
-	int ret = 0;
-
-	/*
-	 * Currently we're using FILE_SUPERSEDE as the same as
-	 * FILE_OVERWRITE_IF but they really are
-	 * different. FILE_SUPERSEDE deletes an existing file
-	 * (requiring delete access) then recreates it.
-	 */
-
-	switch (create_disposition) {
-	case FILE_SUPERSEDE:
-	case FILE_OVERWRITE_IF:
-		/*
-		 * If file exists replace/overwrite. If file doesn't
-		 * exist create.
-		 */
-		ret = O_CREAT|O_TRUNC;
-		break;
-
-	case FILE_OPEN:
-		/*
-		 * If file exists open. If file doesn't exist error.
-		 */
-		ret = 0;
-		break;
-
-	case FILE_OVERWRITE:
-		/*
-		 * If file exists overwrite. If file doesn't exist
-		 * error.
-		 */
-		ret = O_TRUNC;
-		break;
-
-	case FILE_CREATE:
-		/*
-		 * If file exists error. If file doesn't exist create.
-		 */
-		ret = O_CREAT|O_EXCL;
-		break;
+/****************************************************************
+ Ensure we get the brlock lock followed by the share mode lock
+ in the correct order to prevent deadlocks if other smbd's are
+ using the brlock database on this file simultaneously with this open
+ (that code also gets the locks in brlock -> share mode lock order).
+****************************************************************/
+
+static bool acquire_ordered_locks(TALLOC_CTX *mem_ctx,
+				files_struct *fsp,
+				const struct file_id id,
+				const char *connectpath,
+				const struct smb_filename *smb_fname,
+				const struct timespec *p_old_write_time,
+				struct share_mode_lock **p_lck,
+				struct byte_range_lock **p_br_lck)
+{
+	/* Ordering - we must get the br_lck for this
+	   file before the share mode. */
+	if (lp_locking(fsp->conn->params)) {
+		*p_br_lck = brl_get_locks_readonly(fsp);
+		if (*p_br_lck == NULL) {
+			DEBUG(0, ("Could not get br_lock\n"));
+			return false;
+		}
+		/* Note - we don't need to free the returned
+		   br_lck explicitly as it was allocated on talloc_tos()
+		   and so will be autofreed (and release the lock)
+		   once the frame context disappears.
+
+		   If it was set to fsp->brlock_rec then it was
+		   talloc_move'd to hang off the fsp pointer and
+		   in this case is guarenteed to not be holding the
+		   lock on the brlock database. */
+	}
+
+	*p_lck = get_share_mode_lock(mem_ctx,
+				id,
+				connectpath,
+				smb_fname,
+				p_old_write_time);
 
-	case FILE_OPEN_IF:
-		/*
-		 * If file exists open. If file doesn't exist create.
-		 */
-		ret = O_CREAT;
-		break;
+	if (*p_lck == NULL) {
+		DEBUG(0, ("Could not get share mode lock\n"));
+		TALLOC_FREE(*p_br_lck);
+		return false;
 	}
-	return ret;
+	return true;
 }
 
 /****************************************************************************
@@ -1968,6 +1587,8 @@
 	bool def_acl = False;
 	bool posix_open = False;
 	bool new_file_created = False;
+	bool clear_ads = false;
+	struct file_id id;
 	NTSTATUS fsp_open = NT_STATUS_ACCESS_DENIED;
 	mode_t new_unx_mode = (mode_t)0;
 	mode_t unx_mode = (mode_t)0;
@@ -1978,7 +1599,8 @@
 	uint32 open_access_mask = access_mask;
 	NTSTATUS status;
 	char *parent_dir;
-	SMB_STRUCT_STAT saved_stat = smb_fname->st;
+
+	ZERO_STRUCT(id);
 
 	if (conn->printer) {
 		/*
@@ -2034,12 +1656,9 @@
 		   create_options, (unsigned int)unx_mode, oplock_request,
 		   (unsigned int)private_flags));
 
-	if (req == NULL) {
-		/* Ensure req == NULL means INTERNAL_OPEN_ONLY */
-		SMB_ASSERT(((oplock_request & INTERNAL_OPEN_ONLY) != 0));
-	} else {
-		/* And req != NULL means no INTERNAL_OPEN_ONLY */
-		SMB_ASSERT(((oplock_request & INTERNAL_OPEN_ONLY) == 0));
+	if ((req == NULL) && ((oplock_request & INTERNAL_OPEN_ONLY) == 0)) {
+		DEBUG(0, ("No smb request but not an internal only open!\n"));
+		return NT_STATUS_INTERNAL_ERROR;
 	}
 
 	/*
@@ -2051,26 +1670,19 @@
 		if (get_deferred_open_message_state(req,
 				&request_time,
 				&ptr)) {
+
+			struct deferred_open_record *state = (struct deferred_open_record *)ptr;
 			/* Remember the absolute time of the original
 			   request with this mid. We'll use it later to
 			   see if this has timed out. */
 
-			/* If it was an async create retry, the file
-			   didn't exist. */
-
-			if (is_deferred_open_async(ptr)) {
-				SET_STAT_INVALID(smb_fname->st);
-				file_existed = false;
-			} else {
-				struct deferred_open_record *state = (struct deferred_open_record *)ptr;
-				/* Remove the deferred open entry under lock. */
-				remove_deferred_open_entry(
-					state->id, req->mid,
-					messaging_server_id(req->sconn->msg_ctx));
-			}
+			/* Remove the deferred open entry under lock. */
+			remove_deferred_open_entry(
+				state->id, req->mid,
+				sconn_server_id(req->sconn));
 
 			/* Ensure we don't reprocess this message. */
-			remove_deferred_open_message_smb(req->sconn, req->mid);
+			remove_deferred_open_message_smb(req->mid);
 		}
 	}
 
@@ -2100,7 +1712,27 @@
 		return NT_STATUS_DOS(ERRDOS, ERRcannotopen);
 	}
 
-	switch( create_disposition ) {
+	switch( create_disposition ) {
+		/*
+		 * Currently we're using FILE_SUPERSEDE as the same as
+		 * FILE_OVERWRITE_IF but they really are
+		 * different. FILE_SUPERSEDE deletes an existing file
+		 * (requiring delete access) then recreates it.
+		 */
+		case FILE_SUPERSEDE:
+			/* If file exists replace/overwrite. If file doesn't
+			 * exist create. */
+			flags2 |= (O_CREAT | O_TRUNC);
+			clear_ads = true;
+			break;
+
+		case FILE_OVERWRITE_IF:
+			/* If file exists replace/overwrite. If file doesn't
+			 * exist create. */
+			flags2 |= (O_CREAT | O_TRUNC);
+			clear_ads = true;
+			break;
+
 		case FILE_OPEN:
 			/* If file exists open. If file doesn't exist error. */
 			if (!file_existed) {
@@ -2124,6 +1756,8 @@
 				errno = ENOENT;
 				return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 			}
+			flags2 |= O_TRUNC;
+			clear_ads = true;
 			break;
 
 		case FILE_CREATE:
@@ -2141,24 +1775,24 @@
 				}
 				return map_nt_error_from_unix(errno);
 			}
+			flags2 |= (O_CREAT|O_EXCL);
 			break;
 
-		case FILE_SUPERSEDE:
-		case FILE_OVERWRITE_IF:
 		case FILE_OPEN_IF:
+			/* If file exists open. If file doesn't exist
+			 * create. */
+			flags2 |= O_CREAT;
 			break;
+
 		default:
 			return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	flags2 = disposition_to_open_flags(create_disposition);
-
 	/* We only care about matching attributes on file exists and
 	 * overwrite. */
 
-	if (!posix_open && file_existed &&
-	    ((create_disposition == FILE_OVERWRITE) ||
-	     (create_disposition == FILE_OVERWRITE_IF))) {
+	if (!posix_open && file_existed && ((create_disposition == FILE_OVERWRITE) ||
+			     (create_disposition == FILE_OVERWRITE_IF))) {
 		if (!open_match_attributes(conn, existing_dos_attributes,
 					   new_dos_attributes,
 					   smb_fname->st.st_ex_mode,
@@ -2175,7 +1809,7 @@
 		}
 	}
 
-	status = smbd_calculate_access_mask(conn, smb_fname,
+	status = smbd_calculate_access_mask(conn, smb_fname, file_existed,
 					access_mask,
 					&access_mask); 
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2268,20 +1902,23 @@
 	}
 
 	if (file_existed) {
+		struct byte_range_lock *br_lck = NULL;
 		struct share_mode_entry *batch_entry = NULL;
 		struct share_mode_entry *exclusive_entry = NULL;
 		bool got_level2_oplock = false;
 		bool got_a_none_oplock = false;
-		struct file_id id;
 
 		struct timespec old_write_time = smb_fname->st.st_ex_mtime;
 		id = vfs_file_id_from_sbuf(conn, &smb_fname->st);
 
-		lck = get_share_mode_lock(talloc_tos(), id,
-					  conn->connectpath,
-					  smb_fname, &old_write_time);
-		if (lck == NULL) {
-			DEBUG(0, ("Could not get share mode lock\n"));
+		if (!acquire_ordered_locks(talloc_tos(),
+					fsp,
+					id,
+					conn->connectpath,
+					smb_fname,
+					&old_write_time,
+					&lck,
+					&br_lck)) {
 			return NT_STATUS_SHARING_VIOLATION;
 		}
 
@@ -2335,6 +1972,7 @@
 		}
 
 		grant_fsp_oplock_type(fsp,
+				br_lck,
                                 oplock_request,
                                 got_level2_oplock,
                                 got_a_none_oplock);
@@ -2399,8 +2037,8 @@
 
 			if (((can_access_mask & FILE_WRITE_DATA) &&
 				!CAN_WRITE(conn)) ||
-				!NT_STATUS_IS_OK(smbd_check_access_rights(conn,
-						smb_fname, can_access_mask))) {
+			    !can_access_file_data(conn, smb_fname,
+						  can_access_mask)) {
 				can_access = False;
 			}
 
@@ -2438,7 +2076,6 @@
 				   a 1 second delay for share mode conflicts. */
 
 				state.delayed_for_oplocks = False;
-				state.async_open = false;
 				state.id = id;
 
 				if ((req != NULL)
@@ -2484,49 +2121,28 @@
 		 (unsigned int)unx_mode, (unsigned int)access_mask,
 		 (unsigned int)open_access_mask));
 
+	/*
+	 * open_file strips any O_TRUNC flags itself.
+	 */
+
 	fsp_open = open_file(fsp, conn, req, parent_dir,
 			     flags|flags2, unx_mode, access_mask,
-			     open_access_mask, &new_file_created);
+			     open_access_mask);
 
 	if (!NT_STATUS_IS_OK(fsp_open)) {
-		if (NT_STATUS_EQUAL(fsp_open, NT_STATUS_RETRY)) {
-			schedule_async_open(request_time, req);
+		if (lck != NULL) {
+			TALLOC_FREE(lck);
 		}
-		TALLOC_FREE(lck);
 		return fsp_open;
 	}
 
-	if (file_existed && !check_same_dev_ino(&saved_stat, &smb_fname->st)) {
-		/*
-		 * The file did exist, but some other (local or NFS)
-		 * process either renamed/unlinked and re-created the
-		 * file with different dev/ino after we walked the path,
-		 * but before we did the open. We could retry the
-		 * open but it's a rare enough case it's easier to
-		 * just fail the open to prevent creating any problems
-		 * in the open file db having the wrong dev/ino key.
-		 */
-		TALLOC_FREE(lck);
-		fd_close(fsp);
-		DEBUG(1,("open_file_ntcreate: file %s - dev/ino mismatch. "
-			"Old (dev=0x%llu, ino =0x%llu). "
-			"New (dev=0x%llu, ino=0x%llu). Failing open "
-			" with NT_STATUS_ACCESS_DENIED.\n",
-			 smb_fname_str_dbg(smb_fname),
-			 (unsigned long long)saved_stat.st_ex_dev,
-			 (unsigned long long)saved_stat.st_ex_ino,
-			 (unsigned long long)smb_fname->st.st_ex_dev,
-			 (unsigned long long)smb_fname->st.st_ex_ino));
-		return NT_STATUS_ACCESS_DENIED;
-	}
-
 	if (!file_existed) {
+		struct byte_range_lock *br_lck = NULL;
 		struct share_mode_entry *batch_entry = NULL;
 		struct share_mode_entry *exclusive_entry = NULL;
 		bool got_level2_oplock = false;
 		bool got_a_none_oplock = false;
 		struct timespec old_write_time = smb_fname->st.st_ex_mtime;
-		struct file_id id;
 		/*
 		 * Deal with the race condition where two smbd's detect the
 		 * file doesn't exist and do the create at the same time. One
@@ -2544,15 +2160,14 @@
 
 		id = fsp->file_id;
 
-		lck = get_share_mode_lock(talloc_tos(), id,
-					  conn->connectpath,
-					  smb_fname, &old_write_time);
-
-		if (lck == NULL) {
-			DEBUG(0, ("open_file_ntcreate: Could not get share "
-				  "mode lock for %s\n",
-				  smb_fname_str_dbg(smb_fname)));
-			fd_close(fsp);
+		if (!acquire_ordered_locks(talloc_tos(),
+					fsp,
+					id,
+					conn->connectpath,
+					smb_fname,
+					&old_write_time,
+					&lck,
+					&br_lck)) {
 			return NT_STATUS_SHARING_VIOLATION;
 		}
 
@@ -2602,8 +2217,9 @@
 		if (!NT_STATUS_IS_OK(status)) {
 			struct deferred_open_record state;
 
+			fd_close(fsp);
+
 			state.delayed_for_oplocks = False;
-			state.async_open = false;
 			state.id = id;
 
 			/* Do it all over again immediately. In the second
@@ -2618,11 +2234,11 @@
 					   req, &state);
 			}
 			TALLOC_FREE(lck);
-			fd_close(fsp);
 			return status;
 		}
 
 		grant_fsp_oplock_type(fsp,
+				br_lck,
                                 oplock_request,
                                 got_level2_oplock,
                                 got_a_none_oplock);
@@ -2636,7 +2252,7 @@
 	SMB_ASSERT(lck != NULL);
 
 	/* Delete streams if create_disposition requires it */
-	if (!new_file_created && clear_ads(create_disposition) &&
+	if (file_existed && clear_ads &&
 	    !is_ntfs_stream_smb_fname(smb_fname)) {
 		status = delete_all_streams(conn, smb_fname->base_name);
 		if (!NT_STATUS_IS_OK(status)) {
@@ -2654,7 +2270,7 @@
            the kernel refuses the operations then the kernel is wrong.
 	   note that GPFS supports it as well - jmcd */
 
-	if (fsp->fh->fd != -1 && lp_kernel_share_modes(SNUM(conn))) {
+	if (fsp->fh->fd != -1) {
 		int ret_flock;
 		ret_flock = SMB_VFS_KERNEL_FLOCK(fsp, share_access, access_mask);
 		if(ret_flock == -1 ){
@@ -2673,6 +2289,24 @@
 	 */
 
 	/*
+	 * If requested, truncate the file.
+	 */
+
+	if (file_existed && (flags2&O_TRUNC)) {
+		/*
+		 * We are modifing the file after open - update the stat
+		 * struct..
+		 */
+		if ((SMB_VFS_FTRUNCATE(fsp, 0) == -1) ||
+		    (SMB_VFS_FSTAT(fsp, &smb_fname->st)==-1)) {
+			status = map_nt_error_from_unix(errno);
+			TALLOC_FREE(lck);
+			fd_close(fsp);
+			return status;
+		}
+	}
+
+	/*
 	 * According to Samba4, SEC_FILE_READ_ATTRIBUTE is always granted,
 	 * but we don't have to store this - just ignore it on access check.
 	 */
@@ -2694,16 +2328,14 @@
 		if (is_stat_open(open_access_mask)) {
 			fsp->oplock_type = NO_OPLOCK;
 		}
-	}
 
-	if (new_file_created) {
-		info = FILE_WAS_CREATED;
-	} else {
-		if (flags2 & O_TRUNC) {
-			info = FILE_WAS_OVERWRITTEN;
-		} else {
+		if (!(flags2 & O_TRUNC)) {
 			info = FILE_WAS_OPENED;
+		} else {
+			info = FILE_WAS_OVERWRITTEN;
 		}
+	} else {
+		info = FILE_WAS_CREATED;
 	}
 
 	if (pinfo) {
@@ -2715,8 +2347,7 @@
 	 * file structs.
 	 */
 
-	status = set_file_oplock(fsp, fsp->oplock_type);
-	if (!NT_STATUS_IS_OK(status)) {
+	if (!set_file_oplock(fsp, fsp->oplock_type)) {
 		/*
 		 * Could not get the kernel oplock or there are byte-range
 		 * locks on the file.
@@ -2724,6 +2355,10 @@
 		fsp->oplock_type = NO_OPLOCK;
 	}
 
+	if (info == FILE_WAS_OVERWRITTEN || info == FILE_WAS_CREATED || info == FILE_WAS_SUPERSEDED) {
+		new_file_created = True;
+	}
+
 	set_share_mode(lck, fsp, get_current_uid(conn),
 			req ? req->mid : 0,
 		       fsp->oplock_type);
@@ -2745,7 +2380,7 @@
 		fsp->initial_delete_on_close = True;
 	}
 
-	if (info != FILE_WAS_OPENED) {
+	if (new_file_created) {
 		/* Files should be initially set as archive */
 		if (lp_map_archive(SNUM(conn)) ||
 		    lp_store_dos_attributes(SNUM(conn))) {
@@ -2773,7 +2408,7 @@
 	 * selected.
 	 */
 
-	if (!posix_open && new_file_created && !def_acl) {
+	if (!posix_open && !file_existed && !def_acl) {
 
 		int saved_errno = errno; /* We might get ENOSYS in the next
 					  * call.. */
@@ -2817,30 +2452,67 @@
 	 * records. */
 	if (req != NULL) {
 		del_deferred_open_entry(lck, req->mid,
-					messaging_server_id(req->sconn->msg_ctx));
+					sconn_server_id(req->sconn));
 	}
 	TALLOC_FREE(lck);
 
 	return NT_STATUS_OK;
 }
 
+
+/****************************************************************************
+ Open a file for for write to ensure that we can fchmod it.
+****************************************************************************/
+
+NTSTATUS open_file_fchmod(connection_struct *conn,
+			  struct smb_filename *smb_fname,
+			  files_struct **result)
+{
+	if (!VALID_STAT(smb_fname->st)) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+        return SMB_VFS_CREATE_FILE(
+		conn,					/* conn */
+		NULL,					/* req */
+		0,					/* root_dir_fid */
+		smb_fname,				/* fname */
+		FILE_WRITE_DATA,			/* access_mask */
+		(FILE_SHARE_READ | FILE_SHARE_WRITE |	/* share_access */
+		    FILE_SHARE_DELETE),
+		FILE_OPEN,				/* create_disposition*/
+		0,					/* create_options */
+		0,					/* file_attributes */
+		INTERNAL_OPEN_ONLY,			/* oplock_request */
+		0,					/* allocation_size */
+		0,					/* private_flags */
+		NULL,					/* sd */
+		NULL,					/* ea_list */
+		result,					/* result */
+		NULL);					/* pinfo */
+}
+
 static NTSTATUS mkdir_internal(connection_struct *conn,
 			       struct smb_filename *smb_dname,
 			       uint32 file_attributes)
 {
 	mode_t mode;
-	char *parent_dir = NULL;
+	char *parent_dir;
 	NTSTATUS status;
 	bool posix_open = false;
 	bool need_re_stat = false;
-	uint32_t access_mask = SEC_DIR_ADD_SUBDIR;
 
-	if (!CAN_WRITE(conn) || (access_mask & ~(conn->share_access))) {
-		DEBUG(5,("mkdir_internal: failing share access "
-			 "%s\n", lp_servicename(talloc_tos(), SNUM(conn))));
+	if(!CAN_WRITE(conn)) {
+		DEBUG(5,("mkdir_internal: failing create on read-only share "
+			 "%s\n", lp_servicename(SNUM(conn))));
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
+	status = check_name(conn, smb_dname->base_name);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
 	if (!parent_dirname(talloc_tos(), smb_dname->base_name, &parent_dir,
 			    NULL)) {
 		return NT_STATUS_NO_MEMORY;
@@ -2853,18 +2525,6 @@
 		mode = unix_mode(conn, FILE_ATTRIBUTE_DIRECTORY, smb_dname, parent_dir);
 	}
 
-	status = check_parent_access(conn,
-					smb_dname,
-					access_mask);
-	if(!NT_STATUS_IS_OK(status)) {
-		DEBUG(5,("mkdir_internal: check_parent_access "
-			"on directory %s for path %s returned %s\n",
-			parent_dir,
-			smb_dname->base_name,
-			nt_errstr(status) ));
-		return status;
-	}
-
 	if (SMB_VFS_MKDIR(conn, smb_dname->base_name, mode) != 0) {
 		return map_nt_error_from_unix(errno);
 	}
@@ -2879,9 +2539,9 @@
 	}
 
 	if (!S_ISDIR(smb_dname->st.st_ex_mode)) {
-		DEBUG(0, ("Directory '%s' just created is not a directory !\n",
+		DEBUG(0, ("Directory just '%s' created is not a directory\n",
 			  smb_fname_str_dbg(smb_dname)));
-		return NT_STATUS_NOT_A_DIRECTORY;
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
 	if (lp_store_dos_attributes(SNUM(conn))) {
@@ -2937,6 +2597,22 @@
 }
 
 /****************************************************************************
+ Ensure we didn't get symlink raced on opening a directory.
+****************************************************************************/
+
+bool check_same_stat(const SMB_STRUCT_STAT *sbuf1,
+			const SMB_STRUCT_STAT *sbuf2)
+{
+	if (sbuf1->st_ex_uid != sbuf2->st_ex_uid ||
+			sbuf1->st_ex_gid != sbuf2->st_ex_gid ||
+			sbuf1->st_ex_dev != sbuf2->st_ex_dev ||
+			sbuf1->st_ex_ino != sbuf2->st_ex_ino) {
+		return false;
+	}
+	return true;
+}
+
+/****************************************************************************
  Open a directory from an NT SMB call.
 ****************************************************************************/
 
@@ -2958,11 +2634,7 @@
 	struct timespec mtimespec;
 	int info = 0;
 
-	if (is_ntfs_stream_smb_fname(smb_dname)) {
-		DEBUG(2, ("open_directory: %s is a stream name!\n",
-			  smb_fname_str_dbg(smb_dname)));
-		return NT_STATUS_NOT_A_DIRECTORY;
-	}
+	SMB_ASSERT(!is_ntfs_stream_smb_fname(smb_dname));
 
 	if (!(file_attributes & FILE_FLAG_POSIX_SEMANTICS)) {
 		/* Ensure we have a directory attribute. */
@@ -2979,7 +2651,15 @@
 		 (unsigned int)create_disposition,
 		 (unsigned int)file_attributes));
 
-	status = smbd_calculate_access_mask(conn, smb_dname,
+	if (!(file_attributes & FILE_FLAG_POSIX_SEMANTICS) &&
+			(conn->fs_capabilities & FILE_NAMED_STREAMS) &&
+			is_ntfs_stream_smb_fname(smb_dname)) {
+		DEBUG(2, ("open_directory: %s is a stream name!\n",
+			  smb_fname_str_dbg(smb_dname)));
+		return NT_STATUS_NOT_A_DIRECTORY;
+	}
+
+	status = smbd_calculate_access_mask(conn, smb_dname, dir_existed,
 					    access_mask, &access_mask);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(10, ("open_directory: smbd_calculate_access_mask "
@@ -3013,15 +2693,6 @@
 			/* If directory exists error. If directory doesn't
 			 * exist create. */
 
-			if (dir_existed) {
-				status = NT_STATUS_OBJECT_NAME_COLLISION;
-				DEBUG(2, ("open_directory: unable to create "
-					  "%s. Error was %s\n",
-					  smb_fname_str_dbg(smb_dname),
-					  nt_errstr(status)));
-				return status;
-			}
-
 			status = mkdir_internal(conn, smb_dname,
 						file_attributes);
 
@@ -3042,29 +2713,18 @@
 			 * exist create.
 			 */
 
-			if (dir_existed) {
-				status = NT_STATUS_OK;
-				info = FILE_WAS_OPENED;
-			} else {
-				status = mkdir_internal(conn, smb_dname,
+			status = mkdir_internal(conn, smb_dname,
 						file_attributes);
 
-				if (NT_STATUS_IS_OK(status)) {
-					info = FILE_WAS_CREATED;
-				} else {
-					/* Cope with create race. */
-					if (!NT_STATUS_EQUAL(status,
-							NT_STATUS_OBJECT_NAME_COLLISION)) {
-						DEBUG(2, ("open_directory: unable to create "
-							"%s. Error was %s\n",
-							smb_fname_str_dbg(smb_dname),
-							nt_errstr(status)));
-						return status;
-					}
-					info = FILE_WAS_OPENED;
-				}
+			if (NT_STATUS_IS_OK(status)) {
+				info = FILE_WAS_CREATED;
 			}
 
+			if (NT_STATUS_EQUAL(status,
+					    NT_STATUS_OBJECT_NAME_COLLISION)) {
+				info = FILE_WAS_OPENED;
+				status = NT_STATUS_OK;
+			}
 			break;
 
 		case FILE_SUPERSEDE:
@@ -3085,9 +2745,30 @@
 	}
 
 	if (info == FILE_WAS_OPENED) {
-		status = smbd_check_access_rights(conn, smb_dname, access_mask);
+		uint32_t access_granted = 0;
+		status = smbd_check_open_rights(conn, smb_dname, access_mask,
+						&access_granted);
+
+		/* Were we trying to do a directory open
+		 * for delete and didn't get DELETE
+		 * access (only) ? Check if the
+		 * directory allows DELETE_CHILD.
+		 * See here:
+		 * http://blogs.msdn.com/oldnewthing/archive/2004/06/04/148426.aspx
+		 * for details. */
+
+		if ((NT_STATUS_EQUAL(status, NT_STATUS_ACCESS_DENIED) &&
+			(access_mask & DELETE_ACCESS) &&
+			(access_granted == DELETE_ACCESS) &&
+			can_delete_file_in_directory(conn, smb_dname))) {
+			DEBUG(10,("open_directory: overrode ACCESS_DENIED "
+				"on directory %s\n",
+				smb_fname_str_dbg(smb_dname)));
+			status = NT_STATUS_OK;
+		}
+
 		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(10, ("open_directory: smbd_check_access_rights on "
+			DEBUG(10, ("open_directory: smbd_check_open_rights on "
 				"file %s failed with %s\n",
 				smb_fname_str_dbg(smb_dname),
 				nt_errstr(status)));
@@ -3104,6 +2785,7 @@
 	 * Setup the files_struct for it.
 	 */
 
+	fsp->mode = smb_dname->st.st_ex_mode;
 	fsp->file_id = vfs_file_id_from_sbuf(conn, &smb_dname->st);
 	fsp->vuid = req ? req->vuid : UID_FIELD_INVALID;
 	fsp->file_pid = req ? req->smbpid : 0;
@@ -3113,10 +2795,6 @@
 
 	fsp->share_access = share_access;
 	fsp->fh->private_options = 0;
-	/*
-	 * According to Samba4, SEC_FILE_READ_ATTRIBUTE is always granted,
-	 */
-	fsp->access_mask = access_mask | FILE_READ_ATTRIBUTES;
 	fsp->print_file = NULL;
 	fsp->modified = False;
 	fsp->oplock_type = NO_OPLOCK;
@@ -3129,14 +2807,9 @@
 		return status;
 	}
 
-	/* Don't store old timestamps for directory
-	   handles in the internal database. We don't
-	   update them in there if new objects
-	   are creaded in the directory. Currently
-	   we only update timestamps on file writes.
-	   See bug #9870.
-	*/
-	ZERO_STRUCT(mtimespec);
+	mtimespec = smb_dname->st.st_ex_mtime;
+
+	fsp->access_mask = access_mask;
 
 #ifdef O_DIRECTORY
 	status = fd_open(conn, fsp, O_RDONLY|O_DIRECTORY, 0);
@@ -3153,6 +2826,12 @@
 		return status;
 	}
 
+	/*
+	 * According to Samba4, SEC_FILE_READ_ATTRIBUTE is always granted,
+	 * Set the real access mask for later access (possibly delete).
+	 */
+	fsp->access_mask = access_mask | FILE_READ_ATTRIBUTES;
+
 	status = vfs_stat_fsp(fsp);
 	if (!NT_STATUS_IS_OK(status)) {
 		fd_close(fsp);
@@ -3171,8 +2850,7 @@
 	}
 
 	lck = get_share_mode_lock(talloc_tos(), fsp->file_id,
-				  conn->connectpath, smb_dname,
-				  &mtimespec);
+				  conn->connectpath, smb_dname, &mtimespec);
 
 	if (lck == NULL) {
 		DEBUG(0, ("open_directory: Could not get share mode lock for "
@@ -3266,6 +2944,7 @@
 			  struct server_id server_id,
 			  DATA_BLOB *data)
 {
+	struct smbd_server_connection *sconn;
 	files_struct *fsp;
 	char *frm = (char *)data->data;
 	struct file_id id;
@@ -3275,9 +2954,12 @@
 	struct smb_filename *smb_fname = NULL;
 	size_t sp_len, bn_len;
 	NTSTATUS status;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
+
+	sconn = msg_ctx_to_sconn(msg);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
 
 	if (data->data == NULL
 	    || data->length < MSG_FILE_RENAMED_MIN_SIZE + 2) {
@@ -3314,8 +2996,8 @@
 	    fsp = file_find_di_next(fsp)) {
 		if (memcmp(fsp->conn->connectpath, sharepath, sp_len) == 0) {
 
-			DEBUG(10,("msg_file_was_renamed: renaming file %s from %s -> %s\n",
-				fsp_fnum_dbg(fsp), fsp_str_dbg(fsp),
+			DEBUG(10,("msg_file_was_renamed: renaming file fnum %d from %s -> %s\n",
+				fsp->fnum, fsp_str_dbg(fsp),
 				smb_fname_str_dbg(smb_fname)));
 			status = fsp_set_smb_fname(fsp, smb_fname);
 			if (!NT_STATUS_IS_OK(status)) {
@@ -3327,10 +3009,10 @@
 			   actually within this share and adjust newname accordingly. */
 	                DEBUG(10,("msg_file_was_renamed: share mismatch (sharepath %s "
 				"not sharepath %s) "
-				"%s from %s -> %s\n",
+				"fnum %d from %s -> %s\n",
 				fsp->conn->connectpath,
 				sharepath,
-				fsp_fnum_dbg(fsp),
+				fsp->fnum,
 				fsp_str_dbg(fsp),
 				smb_fname_str_dbg(smb_fname)));
 		}
@@ -3380,7 +3062,7 @@
 		return NT_STATUS_OK;
 	}
 
-	streams = talloc_array(talloc_tos(), files_struct *, num_streams);
+	streams = TALLOC_ARRAY(talloc_tos(), files_struct *, num_streams);
 	if (streams == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		status = NT_STATUS_NO_MEMORY;
@@ -3456,208 +3138,6 @@
 	return status;
 }
 
-/*********************************************************************
- Create a default ACL by inheriting from the parent. If no inheritance
- from the parent available, don't set anything. This will leave the actual
- permissions the new file or directory already got from the filesystem
- as the NT ACL when read.
-*********************************************************************/
-
-static NTSTATUS inherit_new_acl(files_struct *fsp)
-{
-	TALLOC_CTX *frame = talloc_stackframe();
-	char *parent_name = NULL;
-	struct security_descriptor *parent_desc = NULL;
-	NTSTATUS status = NT_STATUS_OK;
-	struct security_descriptor *psd = NULL;
-	const struct dom_sid *owner_sid = NULL;
-	const struct dom_sid *group_sid = NULL;
-	uint32_t security_info_sent = (SECINFO_OWNER | SECINFO_GROUP | SECINFO_DACL);
-	struct security_token *token = fsp->conn->session_info->security_token;
-	bool inherit_owner = lp_inherit_owner(SNUM(fsp->conn));
-	bool inheritable_components = false;
-	bool try_builtin_administrators = false;
-	const struct dom_sid *BA_U_sid = NULL;
-	const struct dom_sid *BA_G_sid = NULL;
-	bool try_system = false;
-	const struct dom_sid *SY_U_sid = NULL;
-	const struct dom_sid *SY_G_sid = NULL;
-	size_t size = 0;
-
-	if (!parent_dirname(frame, fsp->fsp_name->base_name, &parent_name, NULL)) {
-		TALLOC_FREE(frame);
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	status = SMB_VFS_GET_NT_ACL(fsp->conn,
-				    parent_name,
-				    (SECINFO_OWNER | SECINFO_GROUP | SECINFO_DACL),
-				    frame,
-				    &parent_desc);
-	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(frame);
-		return status;
-	}
-
-	inheritable_components = sd_has_inheritable_components(parent_desc,
-					fsp->is_directory);
-
-	if (!inheritable_components && !inherit_owner) {
-		TALLOC_FREE(frame);
-		/* Nothing to inherit and not setting owner. */
-		return NT_STATUS_OK;
-	}
-
-	/* Create an inherited descriptor from the parent. */
-
-	if (DEBUGLEVEL >= 10) {
-		DEBUG(10,("inherit_new_acl: parent acl for %s is:\n",
-			fsp_str_dbg(fsp) ));
-		NDR_PRINT_DEBUG(security_descriptor, parent_desc);
-	}
-
-	/* Inherit from parent descriptor if "inherit owner" set. */
-	if (inherit_owner) {
-		owner_sid = parent_desc->owner_sid;
-		group_sid = parent_desc->group_sid;
-	}
-
-	if (owner_sid == NULL) {
-		if (security_token_has_builtin_administrators(token)) {
-			try_builtin_administrators = true;
-		} else if (security_token_is_system(token)) {
-			try_builtin_administrators = true;
-			try_system = true;
-		}
-	}
-
-	if (group_sid == NULL &&
-	    token->num_sids == PRIMARY_GROUP_SID_INDEX)
-	{
-		if (security_token_is_system(token)) {
-			try_builtin_administrators = true;
-			try_system = true;
-		}
-	}
-
-	if (try_builtin_administrators) {
-		struct unixid ids;
-		bool ok;
-
-		ZERO_STRUCT(ids);
-		ok = sids_to_unixids(&global_sid_Builtin_Administrators, 1, &ids);
-		if (ok) {
-			switch (ids.type) {
-			case ID_TYPE_BOTH:
-				BA_U_sid = &global_sid_Builtin_Administrators;
-				BA_G_sid = &global_sid_Builtin_Administrators;
-				break;
-			case ID_TYPE_UID:
-				BA_U_sid = &global_sid_Builtin_Administrators;
-				break;
-			case ID_TYPE_GID:
-				BA_G_sid = &global_sid_Builtin_Administrators;
-				break;
-			default:
-				break;
-			}
-		}
-	}
-
-	if (try_system) {
-		struct unixid ids;
-		bool ok;
-
-		ZERO_STRUCT(ids);
-		ok = sids_to_unixids(&global_sid_System, 1, &ids);
-		if (ok) {
-			switch (ids.type) {
-			case ID_TYPE_BOTH:
-				SY_U_sid = &global_sid_System;
-				SY_G_sid = &global_sid_System;
-				break;
-			case ID_TYPE_UID:
-				SY_U_sid = &global_sid_System;
-				break;
-			case ID_TYPE_GID:
-				SY_G_sid = &global_sid_System;
-				break;
-			default:
-				break;
-			}
-		}
-	}
-
-	if (owner_sid == NULL) {
-		owner_sid = BA_U_sid;
-	}
-
-	if (owner_sid == NULL) {
-		owner_sid = SY_U_sid;
-	}
-
-	if (group_sid == NULL) {
-		group_sid = SY_G_sid;
-	}
-
-	if (try_system && group_sid == NULL) {
-		group_sid = BA_G_sid;
-	}
-
-	if (owner_sid == NULL) {
-		owner_sid = &token->sids[PRIMARY_USER_SID_INDEX];
-	}
-	if (group_sid == NULL) {
-		if (token->num_sids == PRIMARY_GROUP_SID_INDEX) {
-			group_sid = &token->sids[PRIMARY_USER_SID_INDEX];
-		} else {
-			group_sid = &token->sids[PRIMARY_GROUP_SID_INDEX];
-		}
-	}
-
-	status = se_create_child_secdesc(frame,
-			&psd,
-			&size,
-			parent_desc,
-			owner_sid,
-			group_sid,
-			fsp->is_directory);
-	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(frame);
-		return status;
-	}
-
-	/* If inheritable_components == false,
-	   se_create_child_secdesc()
-	   creates a security desriptor with a NULL dacl
-	   entry, but with SEC_DESC_DACL_PRESENT. We need
-	   to remove that flag. */
-
-	if (!inheritable_components) {
-		security_info_sent &= ~SECINFO_DACL;
-		psd->type &= ~SEC_DESC_DACL_PRESENT;
-	}
-
-	if (DEBUGLEVEL >= 10) {
-		DEBUG(10,("inherit_new_acl: child acl for %s is:\n",
-			fsp_str_dbg(fsp) ));
-		NDR_PRINT_DEBUG(security_descriptor, psd);
-	}
-
-	if (inherit_owner) {
-		/* We need to be root to force this. */
-		become_root();
-	}
-	status = SMB_VFS_FSET_NT_ACL(fsp,
-			security_info_sent,
-			psd);
-	if (inherit_owner) {
-		unbecome_root();
-	}
-	TALLOC_FREE(frame);
-	return status;
-}
-
 /*
  * Wrapper around open_file_ntcreate and open_directory
  */
@@ -3727,6 +3207,26 @@
 		}
 	}
 
+	/* This is the correct thing to do (check every time) but can_delete
+	 * is expensive (it may have to read the parent directory
+	 * permissions). So for now we're not doing it unless we have a strong
+	 * hint the client is really going to delete this file. If the client
+	 * is forcing FILE_CREATE let the filesystem take care of the
+	 * permissions. */
+
+	/* Setting FILE_SHARE_DELETE is the hint. */
+
+	if ((create_disposition != FILE_CREATE)
+	    && (access_mask & DELETE_ACCESS)
+	    && (!(can_delete_file_in_directory(conn, smb_fname) ||
+		 can_access_file_acl(conn, smb_fname, DELETE_ACCESS)))) {
+		status = NT_STATUS_ACCESS_DENIED;
+		DEBUG(10,("create_file_unixpath: open file %s "
+			  "for delete ACCESS_DENIED\n",
+			  smb_fname_str_dbg(smb_fname)));
+		goto fail;
+	}
+
 	if ((access_mask & SEC_FLAG_SYSTEM_SECURITY) &&
 			!security_token_has_privilege(get_current_nttok(conn),
 					SEC_PRIV_SECURITY)) {
@@ -3855,20 +3355,14 @@
 			goto fail;
 		}
 
+		/*
+		 * We're opening the stream element of a base_fsp
+		 * we already opened. Set up the base_fsp pointer.
+		 */
 		if (base_fsp) {
-			/*
-			 * We're opening the stream element of a
-			 * base_fsp we already opened. Set up the
-			 * base_fsp pointer.
-			 */
 			fsp->base_fsp = base_fsp;
 		}
 
-		if (allocation_size) {
-			fsp->initial_allocation_size = smb_roundup(fsp->conn,
-							allocation_size);
-		}
-
 		status = open_file_ntcreate(conn,
 					    req,
 					    access_mask,
@@ -3920,6 +3414,41 @@
 
 	fsp->base_fsp = base_fsp;
 
+	/*
+	 * According to the MS documentation, the only time the security
+	 * descriptor is applied to the opened file is iff we *created* the
+	 * file; an existing file stays the same.
+	 *
+	 * Also, it seems (from observation) that you can open the file with
+	 * any access mask but you can still write the sd. We need to override
+	 * the granted access before we call set_sd
+	 * Patch for bug #2242 from Tom Lackemann <cessnatomny@yahoo.com>.
+	 */
+
+	if ((sd != NULL) && (info == FILE_WAS_CREATED)
+	    && lp_nt_acl_support(SNUM(conn))) {
+
+		uint32_t sec_info_sent;
+		uint32_t saved_access_mask = fsp->access_mask;
+
+		sec_info_sent = get_sec_info(sd);
+
+		fsp->access_mask = FILE_GENERIC_ALL;
+
+		if (sec_info_sent & (SECINFO_OWNER|
+					SECINFO_GROUP|
+					SECINFO_DACL|
+					SECINFO_SACL)) {
+			status = set_sd(fsp, sd, sec_info_sent);
+		}
+
+		fsp->access_mask = saved_access_mask;
+
+		if (!NT_STATUS_IS_OK(status)) {
+			goto fail;
+		}
+	}
+
 	if ((ea_list != NULL) &&
 	    ((info == FILE_WAS_CREATED) || (info == FILE_WAS_OVERWRITTEN))) {
 		status = set_ea(conn, fsp, fsp->fsp_name, ea_list);
@@ -3953,52 +3482,6 @@
 			fsp->initial_allocation_size = smb_roundup(
 				fsp->conn, (uint64_t)fsp->fsp_name->st.st_ex_size);
 		}
-	} else {
-		fsp->initial_allocation_size = 0;
-	}
-
-	if ((info == FILE_WAS_CREATED) && lp_nt_acl_support(SNUM(conn)) &&
-				fsp->base_fsp == NULL) {
-		if (sd != NULL) {
-			/*
-			 * According to the MS documentation, the only time the security
-			 * descriptor is applied to the opened file is iff we *created* the
-			 * file; an existing file stays the same.
-			 *
-			 * Also, it seems (from observation) that you can open the file with
-			 * any access mask but you can still write the sd. We need to override
-			 * the granted access before we call set_sd
-			 * Patch for bug #2242 from Tom Lackemann <cessnatomny@yahoo.com>.
-			 */
-
-			uint32_t sec_info_sent;
-			uint32_t saved_access_mask = fsp->access_mask;
-
-			sec_info_sent = get_sec_info(sd);
-
-			fsp->access_mask = FILE_GENERIC_ALL;
-
-			if (sec_info_sent & (SECINFO_OWNER|
-						SECINFO_GROUP|
-						SECINFO_DACL|
-						SECINFO_SACL)) {
-				status = set_sd(fsp, sd, sec_info_sent);
-			}
-
-			fsp->access_mask = saved_access_mask;
-
-			if (!NT_STATUS_IS_OK(status)) {
-				goto fail;
-			}
-		} else if (lp_inherit_acls(SNUM(conn))) {
-			/* Inherit from parent. Errors here are not fatal. */
-			status = inherit_new_acl(fsp);
-			if (!NT_STATUS_IS_OK(status)) {
-				DEBUG(10,("inherit_new_acl: failed for %s with %s\n",
-					fsp_str_dbg(fsp),
-					nt_errstr(status) ));
-			}
-		}
 	}
 
 	DEBUG(10, ("create_file_unixpath: info=%d\n", info));
@@ -4106,7 +3589,7 @@
 		 * Copy in the base directory name.
 		 */
 
-		parent_fname = talloc_array(talloc_tos(), char,
+		parent_fname = TALLOC_ARRAY(talloc_tos(), char,
 		    dir_name_len+2);
 		if (parent_fname == NULL) {
 			status = NT_STATUS_NO_MEMORY;
@@ -4245,7 +3728,7 @@
 		}
 	}
 
-	if (is_ntfs_default_stream_smb_fname(smb_fname)) {
+	if (stream_name && is_ntfs_default_stream_smb_fname(smb_fname)) {
 		int ret;
 		smb_fname->stream_name = NULL;
 		/* We have to handle this error here. */
Only in ../../samba-3.6.24/source3/smbd: open.o
diff -ur smbd/oplock.c ../../samba-3.6.24/source3/smbd/oplock.c
--- smbd/oplock.c	2014-12-08 15:46:38.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/oplock.c	2015-01-28 10:52:25.149068676 +0800
@@ -4,17 +4,17 @@
    Copyright (C) Andrew Tridgell 1992-1998
    Copyright (C) Jeremy Allison 1998 - 2001
    Copyright (C) Volker Lendecke 2005
-
+   
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -24,7 +24,15 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "messages.h"
-#include "../librpc/gen_ndr/open_files.h"
+
+/****************************************************************************
+ Get the number of current exclusive oplocks.
+****************************************************************************/
+
+int32 get_number_of_exclusive_open_oplocks(void)
+{
+  return exclusive_oplocks_open;
+}
 
 /*
  * helper function used by the kernel oplock backends to post the break message
@@ -51,35 +59,30 @@
  if oplock set.
 ****************************************************************************/
 
-NTSTATUS set_file_oplock(files_struct *fsp, int oplock_type)
+bool set_file_oplock(files_struct *fsp, int oplock_type)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-	bool use_kernel = lp_kernel_oplocks(SNUM(fsp->conn)) && koplocks;
-
 	if (fsp->oplock_type == LEVEL_II_OPLOCK) {
-		if (use_kernel &&
+		if (koplocks &&
 		    !(koplocks->flags & KOPLOCKS_LEVEL2_SUPPORTED)) {
 			DEBUG(10, ("Refusing level2 oplock, kernel oplocks "
 				   "don't support them\n"));
-			return NT_STATUS_NOT_SUPPORTED;
+			return false;
 		}
 	}
 
 	if ((fsp->oplock_type != NO_OPLOCK) &&
 	    (fsp->oplock_type != FAKE_LEVEL_II_OPLOCK) &&
-	    use_kernel &&
-	    !koplocks->ops->set_oplock(koplocks, fsp, oplock_type))
-	{
-		return map_nt_error_from_unix(errno);
+	    koplocks &&
+	    !koplocks->ops->set_oplock(koplocks, fsp, oplock_type)) {
+		return False;
 	}
 
 	fsp->oplock_type = oplock_type;
 	fsp->sent_oplock_break = NO_BREAK_SENT;
 	if (oplock_type == LEVEL_II_OPLOCK) {
-		sconn->oplocks.level_II_open++;
+		level_II_oplocks_open++;
 	} else if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
-		sconn->oplocks.exclusive_open++;
+		exclusive_oplocks_open++;
 	}
 
 	DEBUG(5,("set_file_oplock: granted oplock on file %s, %s/%lu, "
@@ -88,7 +91,7 @@
 		 fsp->fh->gen_id, (int)fsp->open_time.tv_sec,
 		 (int)fsp->open_time.tv_usec ));
 
-	return NT_STATUS_OK;
+	return True;
 }
 
 /****************************************************************************
@@ -97,9 +100,6 @@
 
 void release_file_oplock(files_struct *fsp)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-
 	if ((fsp->oplock_type != NO_OPLOCK) &&
 	    (fsp->oplock_type != FAKE_LEVEL_II_OPLOCK) &&
 	    koplocks) {
@@ -107,13 +107,13 @@
 	}
 
 	if (fsp->oplock_type == LEVEL_II_OPLOCK) {
-		sconn->oplocks.level_II_open--;
+		level_II_oplocks_open--;
 	} else if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
-		sconn->oplocks.exclusive_open--;
+		exclusive_oplocks_open--;
 	}
 
-	SMB_ASSERT(sconn->oplocks.exclusive_open>=0);
-	SMB_ASSERT(sconn->oplocks.level_II_open>=0);
+	SMB_ASSERT(exclusive_oplocks_open>=0);
+	SMB_ASSERT(level_II_oplocks_open>=0);
 
 	if (EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
 		/* This doesn't matter for close. */
@@ -135,9 +135,6 @@
 
 static void downgrade_file_oplock(files_struct *fsp)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-
 	if (!EXCLUSIVE_OPLOCK_TYPE(fsp->oplock_type)) {
 		DEBUG(0, ("trying to downgrade an already-downgraded oplock!\n"));
 		return;
@@ -147,14 +144,9 @@
 		koplocks->ops->release_oplock(koplocks, fsp, LEVEL_II_OPLOCK);
 	}
 	fsp->oplock_type = LEVEL_II_OPLOCK;
-	sconn->oplocks.exclusive_open--;
-	sconn->oplocks.level_II_open++;
+	exclusive_oplocks_open--;
+	level_II_oplocks_open++;
 	fsp->sent_oplock_break = NO_BREAK_SENT;
-
-	flush_write_cache(fsp, OPLOCK_RELEASE_FLUSH);
-	delete_write_cache(fsp);
-
-	TALLOC_FREE(fsp->oplock_timeout);
 }
 
 /****************************************************************************
@@ -169,7 +161,8 @@
 	struct share_mode_lock *lck;
 
 	/* Remove the oplock flag from the sharemode. */
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
 	if (lck == NULL) {
 		DEBUG(0,("remove_oplock: failed to lock share entry for "
 			 "file %s\n", fsp_str_dbg(fsp)));
@@ -178,8 +171,8 @@
 	ret = remove_share_oplock(lck, fsp);
 	if (!ret) {
 		DEBUG(0,("remove_oplock: failed to remove share oplock for "
-			 "file %s, %s, %s\n",
-			 fsp_str_dbg(fsp), fsp_fnum_dbg(fsp),
+			 "file %s fnum %d, %s\n",
+			 fsp_str_dbg(fsp), fsp->fnum,
 			 file_id_string_tos(&fsp->file_id)));
 	}
 	release_file_oplock(fsp);
@@ -195,7 +188,8 @@
 	bool ret;
 	struct share_mode_lock *lck;
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
 	if (lck == NULL) {
 		DEBUG(0,("downgrade_oplock: failed to lock share entry for "
 			 "file %s\n", fsp_str_dbg(fsp)));
@@ -204,8 +198,8 @@
 	ret = downgrade_share_oplock(lck, fsp);
 	if (!ret) {
 		DEBUG(0,("downgrade_oplock: failed to downgrade share oplock "
-			 "for file %s, %s, file_id %s\n",
-			 fsp_str_dbg(fsp), fsp_fnum_dbg(fsp),
+			 "for file %s fnum %d, file_id %s\n",
+			 fsp_str_dbg(fsp), fsp->fnum,
 			 file_id_string_tos(&fsp->file_id)));
 	}
 
@@ -217,9 +211,8 @@
 /*
  * Some kernel oplock implementations handle the notification themselves.
  */
-bool should_notify_deferred_opens(struct smbd_server_connection *sconn)
+bool should_notify_deferred_opens()
 {
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
 	return !(koplocks &&
 		(koplocks->flags & KOPLOCKS_DEFERRED_OPEN_NOTIFICATION));
 }
@@ -231,7 +224,7 @@
 static char *new_break_message_smb1(TALLOC_CTX *mem_ctx,
 				   files_struct *fsp, int cmd)
 {
-	char *result = talloc_array(mem_ctx, char, smb_size + 8*2 + 0);
+	char *result = TALLOC_ARRAY(mem_ctx, char, smb_size + 8*2 + 0);
 
 	if (result == NULL) {
 		DEBUG(0, ("talloc failed\n"));
@@ -279,8 +272,7 @@
 		dbgtext( "initial_break_processing: called for %s/%u\n",
 			 file_id_string_tos(&id), (int)file_id);
 		dbgtext( "Current oplocks_open (exclusive = %d, levelII = %d)\n",
-			sconn->oplocks.exclusive_open,
-			sconn->oplocks.level_II_open);
+			exclusive_oplocks_open, level_II_oplocks_open );
 	}
 
 	/*
@@ -346,9 +338,6 @@
 
 static void add_oplock_timeout_handler(files_struct *fsp)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-
 	/*
 	 * If kernel oplocks already notifies smbds when an oplock break times
 	 * out, just return.
@@ -364,9 +353,9 @@
 	}
 
 	fsp->oplock_timeout =
-		tevent_add_timer(fsp->conn->sconn->ev_ctx, fsp,
-				 timeval_current_ofs(OPLOCK_BREAK_TIMEOUT, 0),
-				 oplock_timeout_handler, fsp);
+		event_add_timed(smbd_event_context(), fsp,
+				timeval_current_ofs(OPLOCK_BREAK_TIMEOUT, 0),
+				oplock_timeout_handler, fsp);
 
 	if (fsp->oplock_timeout == NULL) {
 		DEBUG(0, ("Could not add oplock timeout handler\n"));
@@ -418,7 +407,7 @@
 	SMB_ASSERT(fsp->oplock_type == LEVEL_II_OPLOCK);
 
 	DEBUG(10,("process_oplock_async_level2_break_message: sending break "
-		  "to none message for %s, file %s\n", fsp_fnum_dbg(fsp),
+		  "to none message for fid %d, file %s\n", fsp->fnum,
 		  fsp_str_dbg(fsp)));
 
 	/* Now send a break to none message to our client. */
@@ -440,23 +429,27 @@
  the client for LEVEL2.
 *******************************************************************/
 
-static void process_oplock_async_level2_break_message(struct messaging_context *msg_ctx,
+void process_oplock_async_level2_break_message(struct messaging_context *msg_ctx,
 						      void *private_data,
 						      uint32_t msg_type,
 						      struct server_id src,
 						      DATA_BLOB *data)
 {
+	struct smbd_server_connection *sconn;
 	struct share_mode_entry msg;
 	files_struct *fsp;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
 
 	if (data->data == NULL) {
 		DEBUG(0, ("Got NULL buffer\n"));
 		return;
 	}
 
+	sconn = msg_ctx_to_sconn(msg_ctx);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
+
 	if (data->length != MSG_SMB_SHARE_MODE_ENTRY_SIZE) {
 		DEBUG(0, ("Got invalid msg len %d\n", (int)data->length));
 		return;
@@ -466,9 +459,8 @@
 	message_to_share_mode_entry(&msg, (char *)data->data);
 
 	DEBUG(10, ("Got oplock async level 2 break message from pid %s: "
-		   "%s/%llu\n", server_id_str(talloc_tos(), &src),
-		   file_id_string_tos(&msg.id),
-		   (unsigned long long)msg.share_file_id));
+		   "%s/%lu\n", procid_str(talloc_tos(), &src),
+		   file_id_string_tos(&msg.id), msg.share_file_id));
 
 	fsp = initial_break_processing(sconn, msg.id, msg.share_file_id);
 
@@ -493,21 +485,22 @@
 					 struct server_id src,
 					 DATA_BLOB *data)
 {
+	struct smbd_server_connection *sconn;
 	struct share_mode_entry msg;
 	files_struct *fsp;
 	bool break_to_level2 = False;
-	bool use_kernel;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
-	struct server_id self = messaging_server_id(sconn->msg_ctx);
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
 
 	if (data->data == NULL) {
 		DEBUG(0, ("Got NULL buffer\n"));
 		return;
 	}
 
+	sconn = msg_ctx_to_sconn(msg_ctx);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
+
 	if (data->length != MSG_SMB_SHARE_MODE_ENTRY_SIZE) {
 		DEBUG(0, ("Got invalid msg len %d\n", (int)data->length));
 		return;
@@ -516,10 +509,9 @@
 	/* De-linearize incoming message. */
 	message_to_share_mode_entry(&msg, (char *)data->data);
 
-	DEBUG(10, ("Got oplock break message from pid %s: %s/%llu\n",
-		   server_id_str(talloc_tos(), &src),
-		   file_id_string_tos(&msg.id),
-		   (unsigned long long)msg.share_file_id));
+	DEBUG(10, ("Got oplock break message from pid %s: %s/%lu\n",
+		   procid_str(talloc_tos(), &src), file_id_string_tos(&msg.id),
+		   msg.share_file_id));
 
 	fsp = initial_break_processing(sconn, msg.id, msg.share_file_id);
 
@@ -558,18 +550,16 @@
 		return;
 	}
 
-	use_kernel = lp_kernel_oplocks(SNUM(fsp->conn)) && koplocks;
-
-	if ((global_client_caps & CAP_LEVEL_II_OPLOCKS) &&
+	if ((global_client_caps & CAP_LEVEL_II_OPLOCKS) && 
 	    !(msg.op_type & FORCE_OPLOCK_BREAK_TO_NONE) &&
-	    !(use_kernel && !(koplocks->flags & KOPLOCKS_LEVEL2_SUPPORTED)) &&
+	    !(koplocks && !(koplocks->flags & KOPLOCKS_LEVEL2_SUPPORTED)) &&
 	    lp_level2_oplocks(SNUM(fsp->conn))) {
 		break_to_level2 = True;
 	}
 
 	/* Need to wait before sending a break
 	   message if we sent ourselves this message. */
-	if (serverid_equal(&self, &src)) {
+	if (procid_is_me(&src)) {
 		wait_before_sending_break();
 	}
 
@@ -601,12 +591,10 @@
 					struct server_id src,
 					DATA_BLOB *data)
 {
+	struct smbd_server_connection *sconn;
 	struct file_id id;
 	unsigned long file_id;
 	files_struct *fsp;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
 
 	if (data->data == NULL) {
 		DEBUG(0, ("Got NULL buffer\n"));
@@ -618,12 +606,18 @@
 		return;
 	}
 
+	sconn = msg_ctx_to_sconn(msg_ctx);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
+
 	/* Pull the data from the message. */
 	pull_file_id_24((char *)data->data, &id);
 	file_id = (unsigned long)IVAL(data->data, 24);
 
 	DEBUG(10, ("Got kernel oplock break message from pid %s: %s/%u\n",
-		   server_id_str(talloc_tos(), &src), file_id_string_tos(&id),
+		   procid_str(talloc_tos(), &src), file_id_string_tos(&id),
 		   (unsigned int)file_id));
 
 	fsp = initial_break_processing(sconn, id, file_id);
@@ -654,8 +648,6 @@
 
 void reply_to_oplock_break_requests(files_struct *fsp)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
 	int i;
 
 	/*
@@ -681,7 +673,11 @@
 
 	SAFE_FREE(fsp->pending_break_messages);
 	fsp->num_pending_break_messages = 0;
-	TALLOC_FREE(fsp->oplock_timeout);
+	if (fsp->oplock_timeout != NULL) {
+		/* Remove the timed event handler. */
+		TALLOC_FREE(fsp->oplock_timeout);
+		fsp->oplock_timeout = NULL;
+	}
 	return;
 }
 
@@ -692,9 +688,6 @@
 					  DATA_BLOB *data)
 {
 	struct share_mode_entry msg;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
 
 	if (data->data == NULL) {
 		DEBUG(0, ("Got NULL buffer\n"));
@@ -710,13 +703,11 @@
 	/* De-linearize incoming message. */
 	message_to_share_mode_entry(&msg, (char *)data->data);
 
-	DEBUG(10, ("Got oplock break response from pid %s: %s/%llu mid %llu\n",
-		   server_id_str(talloc_tos(), &src),
-		   file_id_string_tos(&msg.id),
-		   (unsigned long long)msg.share_file_id,
-		   (unsigned long long)msg.op_mid));
+	DEBUG(10, ("Got oplock break response from pid %s: %s/%lu mid %llu\n",
+		   procid_str(talloc_tos(), &src), file_id_string_tos(&msg.id),
+		   msg.share_file_id, (unsigned long long)msg.op_mid));
 
-	schedule_deferred_open_message_smb(sconn, msg.op_mid);
+	schedule_deferred_open_message_smb(msg.op_mid);
 }
 
 static void process_open_retry_message(struct messaging_context *msg_ctx,
@@ -726,10 +717,7 @@
 				       DATA_BLOB *data)
 {
 	struct share_mode_entry msg;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
-
+	
 	if (data->data == NULL) {
 		DEBUG(0, ("Got NULL buffer\n"));
 		return;
@@ -744,18 +732,12 @@
 	message_to_share_mode_entry(&msg, (char *)data->data);
 
 	DEBUG(10, ("Got open retry msg from pid %s: %s mid %llu\n",
-		   server_id_str(talloc_tos(), &src), file_id_string_tos(&msg.id),
+		   procid_str(talloc_tos(), &src), file_id_string_tos(&msg.id),
 		   (unsigned long long)msg.op_mid));
 
-	schedule_deferred_open_message_smb(sconn, msg.op_mid);
+	schedule_deferred_open_message_smb(msg.op_mid);
 }
 
-struct break_to_none_state {
-	struct smbd_server_connection *sconn;
-	struct file_id id;
-};
-static void do_break_to_none(struct tevent_req *req);
-
 /****************************************************************************
  This function is called on any file modification or lock request. If a file
  is level 2 oplocked then it must tell all other level 2 holders to break to
@@ -765,9 +747,8 @@
 static void contend_level2_oplocks_begin_default(files_struct *fsp,
 					      enum level2_contention_type type)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct tevent_req *req;
-	struct break_to_none_state *state;
+	int i;
+	struct share_mode_lock *lck;
 
 	/*
 	 * If this file is level II oplocked then we need
@@ -780,59 +761,19 @@
 	if (!LEVEL_II_OPLOCK_TYPE(fsp->oplock_type))
 		return;
 
-	/*
-	 * When we get here we might have a brlock entry locked. Also
-	 * locking the share mode entry would violate the locking
-	 * order. Breaking level2 oplocks to none is asynchronous
-	 * anyway, so we postpone this into an immediate timed event.
-	 */
-
-	state = talloc(sconn, struct break_to_none_state);
-	if (state == NULL) {
-		DEBUG(1, ("talloc failed\n"));
-		return;
-	}
-	state->sconn = sconn;
-	state->id = fsp->file_id;
-
-	req = tevent_wakeup_send(state, sconn->ev_ctx, timeval_set(0, 0));
-	if (req == NULL) {
-		DEBUG(1, ("tevent_wakeup_send failed\n"));
-		TALLOC_FREE(state);
-		return;
-	}
-	tevent_req_set_callback(req, do_break_to_none, state);
-	return;
-}
-
-static void do_break_to_none(struct tevent_req *req)
-{
-	struct break_to_none_state *state = tevent_req_callback_data(
-		req, struct break_to_none_state);
-	struct server_id self = messaging_server_id(state->sconn->msg_ctx);
-	bool ret;
-	int i;
-	struct share_mode_lock *lck;
-
-	ret = tevent_wakeup_recv(req);
-	TALLOC_FREE(req);
-	if (!ret) {
-		DEBUG(1, ("tevent_wakeup_recv failed\n"));
-		goto done;
-	}
-	lck = get_existing_share_mode_lock(talloc_tos(), state->id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
 	if (lck == NULL) {
-		DEBUG(1, ("release_level_2_oplocks_on_change: failed to lock "
-			  "share mode entry for file %s.\n",
-			  file_id_string_tos(&state->id)));
-		goto done;
+		DEBUG(0,("release_level_2_oplocks_on_change: failed to lock "
+			 "share mode entry for file %s.\n", fsp_str_dbg(fsp)));
+		return;
 	}
 
 	DEBUG(10,("release_level_2_oplocks_on_change: num_share_modes = %d\n", 
-		  lck->data->num_share_modes ));
+		  lck->num_share_modes ));
 
-	for(i = 0; i < lck->data->num_share_modes; i++) {
-		struct share_mode_entry *share_entry = &lck->data->share_modes[i];
+	for(i = 0; i < lck->num_share_modes; i++) {
+		struct share_mode_entry *share_entry = &lck->share_modes[i];
 		char msg[MSG_SMB_SHARE_MODE_ENTRY_SIZE];
 
 		if (!is_valid_share_mode_entry(share_entry)) {
@@ -881,9 +822,9 @@
  		 * Bugid #5980.
  		 */
 
-		if (serverid_equal(&self, &share_entry->pid)) {
+		if (procid_is_me(&share_entry->pid)) {
 			struct files_struct *cur_fsp =
-				initial_break_processing(state->sconn,
+				initial_break_processing(fsp->conn->sconn,
 					share_entry->id,
 					share_entry->share_file_id);
 			wait_before_sending_break();
@@ -894,7 +835,7 @@
 				"Did not find fsp, ignoring\n"));
 			}
 		} else {
-			messaging_send_buf(state->sconn->msg_ctx,
+			messaging_send_buf(fsp->conn->sconn->msg_ctx,
 					share_entry->pid,
 					MSG_SMB_ASYNC_LEVEL2_BREAK,
 					(uint8 *)msg,
@@ -906,17 +847,11 @@
 	   in the share mode lock db. */
 
 	TALLOC_FREE(lck);
-done:
-	TALLOC_FREE(state);
-	return;
 }
 
-void smbd_contend_level2_oplocks_begin(files_struct *fsp,
+void contend_level2_oplocks_begin(files_struct *fsp,
 				  enum level2_contention_type type)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-
 	if (koplocks && koplocks->ops->contend_level2_oplocks_begin) {
 		koplocks->ops->contend_level2_oplocks_begin(fsp, type);
 		return;
@@ -925,12 +860,9 @@
 	contend_level2_oplocks_begin_default(fsp, type);
 }
 
-void smbd_contend_level2_oplocks_end(files_struct *fsp,
+void contend_level2_oplocks_end(files_struct *fsp,
 				enum level2_contention_type type)
 {
-	struct smbd_server_connection *sconn = fsp->conn->sconn;
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-
 	/* Only kernel oplocks implement this so far */
 	if (koplocks && koplocks->ops->contend_level2_oplocks_end) {
 		koplocks->ops->contend_level2_oplocks_end(fsp, type);
@@ -985,35 +917,31 @@
  Setup oplocks for this process.
 ****************************************************************************/
 
-bool init_oplocks(struct smbd_server_connection *sconn)
+bool init_oplocks(struct messaging_context *msg_ctx)
 {
 	DEBUG(3,("init_oplocks: initializing messages.\n"));
 
-	messaging_register(sconn->msg_ctx, sconn, MSG_SMB_BREAK_REQUEST,
+	messaging_register(msg_ctx, NULL, MSG_SMB_BREAK_REQUEST,
 			   process_oplock_break_message);
-	messaging_register(sconn->msg_ctx, sconn, MSG_SMB_ASYNC_LEVEL2_BREAK,
+	messaging_register(msg_ctx, NULL, MSG_SMB_ASYNC_LEVEL2_BREAK,
 			   process_oplock_async_level2_break_message);
-	messaging_register(sconn->msg_ctx, sconn, MSG_SMB_BREAK_RESPONSE,
+	messaging_register(msg_ctx, NULL, MSG_SMB_BREAK_RESPONSE,
 			   process_oplock_break_response);
-	messaging_register(sconn->msg_ctx, sconn, MSG_SMB_KERNEL_BREAK,
+	messaging_register(msg_ctx, NULL, MSG_SMB_KERNEL_BREAK,
 			   process_kernel_oplock_break);
-	messaging_register(sconn->msg_ctx, sconn, MSG_SMB_OPEN_RETRY,
+	messaging_register(msg_ctx, NULL, MSG_SMB_OPEN_RETRY,
 			   process_open_retry_message);
 
-	return true;
-}
-
-void init_kernel_oplocks(struct smbd_server_connection *sconn)
-{
-	struct kernel_oplocks *koplocks = sconn->oplocks.kernel_ops;
-
-	/* only initialize once */
-	if (koplocks == NULL) {
+	if (lp_kernel_oplocks()) {
 #if HAVE_KERNEL_OPLOCKS_IRIX
-		koplocks = irix_init_kernel_oplocks(sconn);
+		koplocks = irix_init_kernel_oplocks(NULL);
 #elif HAVE_KERNEL_OPLOCKS_LINUX
-		koplocks = linux_init_kernel_oplocks(sconn);
+		koplocks = linux_init_kernel_oplocks(NULL);
+#elif HAVE_ONEFS
+#error Isilon, please check if the NULL context is okay here. Thanks!
+		koplocks = onefs_init_kernel_oplocks(NULL);
 #endif
-		sconn->oplocks.kernel_ops = koplocks;
 	}
+
+	return True;
 }
diff -ur smbd/oplock_irix.c ../../samba-3.6.24/source3/smbd/oplock_irix.c
--- smbd/oplock_irix.c	2012-10-02 16:24:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/oplock_irix.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,7 +27,6 @@
 
 struct irix_oplocks_context {
 	struct kernel_oplocks *ctx;
-	struct smbd_server_connection *sconn;
 	int write_fd;
 	int read_fd;
 	struct fd_event *read_fde;
@@ -50,7 +49,7 @@
 	tmpname = talloc_asprintf(ctx,
 				"%s/koplock.%d",
 				lp_lockdir(),
-				(int)getpid());
+				(int)sys_getpid());
 	if (!tmpname) {
 		TALLOC_FREE(ctx);
 		return False;
@@ -64,7 +63,7 @@
 		return False;
 	}
 
-	if((fd = open(tmpname, O_RDWR|O_CREAT|O_EXCL|O_TRUNC, 0600)) < 0) {
+	if((fd = sys_open(tmpname, O_RDWR|O_CREAT|O_EXCL|O_TRUNC, 0600)) < 0) {
 		DEBUG(0,("check_kernel_oplocks: Unable to open temp test file "
 			 "%s. Error was %s\n",
 			 tmpname, strerror(errno) ));
@@ -185,7 +184,7 @@
 
 	fileid = file_id_create_dev((SMB_DEV_T)os.os_dev,
 				    (SMB_INO_T)os.os_ino);
-	if ((fsp = file_find_di_first(ctx->sconn, fileid)) == NULL) {
+	if ((fsp = file_find_di_first(smbd_server_conn, fileid)) == NULL) {
 		DEBUG(0,("irix_oplock_receive_message: unable to find open "
 			 "file with dev = %x, inode = %.0f\n",
 			 (unsigned int)os.os_dev, (double)os.os_ino ));
@@ -286,7 +285,7 @@
 	files_struct *fsp;
 
 	fsp = irix_oplock_receive_message(ctx->ctx);
-	break_kernel_oplock(ctx->sconn->msg_ctx, fsp);
+	break_kernel_oplock(fsp->conn->sconn->msg_ctx, fsp);
 }
 
 /****************************************************************************
@@ -300,7 +299,7 @@
 	.contend_level2_oplocks_end	= NULL,
 };
 
-struct kernel_oplocks *irix_init_kernel_oplocks(struct smbd_server_connection *sconn)
+struct kernel_oplocks *irix_init_kernel_oplocks(TALLOC_CTX *mem_ctx)
 {
 	struct kernel_oplocks *_ctx;
 	struct irix_oplocks_context *ctx;
@@ -309,7 +308,7 @@
 	if (!irix_oplocks_available())
 		return NULL;
 
-	_ctx = talloc_zero(sconn, struct kernel_oplocks);
+	_ctx = talloc_zero(mem_ctx, struct kernel_oplocks);
 	if (!_ctx) {
 		return NULL;
 	}
@@ -322,7 +321,6 @@
 	_ctx->ops = &irix_koplocks;
 	_ctx->private_data = ctx;
 	ctx->ctx = _ctx;
-	ctx->sconn = sconn;
 
 	if(pipe(pfd) != 0) {
 		talloc_free(_ctx);
@@ -334,7 +332,7 @@
 	ctx->read_fd = pfd[0];
 	ctx->write_fd = pfd[1];
 
-	ctx->read_fde = event_add_fd(sconn->ev_ctx,
+	ctx->read_fde = event_add_fd(smbd_event_context(),
 				     ctx,
 				     ctx->read_fd,
 				     EVENT_FD_READ,
Only in ../../samba-3.6.24/source3/smbd: oplock_irix.o
diff -ur smbd/oplock_linux.c ../../samba-3.6.24/source3/smbd/oplock_linux.c
--- smbd/oplock_linux.c	2013-08-15 17:57:15.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/oplock_linux.c	2015-01-28 10:52:25.149068676 +0800
@@ -2,17 +2,17 @@
    Unix SMB/CIFS implementation.
    kernel oplock processing for Linux
    Copyright (C) Andrew Tridgell 2000
-
+   
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -115,22 +115,16 @@
 					int signum, int count,
 					void *_info, void *private_data)
 {
-	struct kernel_oplocks *ctx =
-		talloc_get_type_abort(private_data,
-		struct kernel_oplocks);
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(ctx->private_data,
-		struct smbd_server_connection);
 	siginfo_t *info = (siginfo_t *)_info;
 	int fd = info->si_fd;
 	files_struct *fsp;
 
-	fsp = file_find_fd(sconn, fd);
+	fsp = file_find_fd(smbd_server_conn, fd);
 	if (fsp == NULL) {
 		DEBUG(0,("linux_oplock_signal_handler: failed to find fsp for file fd=%d (file was closed ?)\n", fd ));
 		return;
 	}
-	break_kernel_oplock(sconn->msg_ctx, fsp);
+	break_kernel_oplock(fsp->conn->sconn->msg_ctx, fsp);
 }
 
 /****************************************************************************
@@ -218,7 +212,7 @@
 	.contend_level2_oplocks_end	= NULL,
 };
 
-struct kernel_oplocks *linux_init_kernel_oplocks(struct smbd_server_connection *sconn)
+struct kernel_oplocks *linux_init_kernel_oplocks(TALLOC_CTX *mem_ctx)
 {
 	struct kernel_oplocks *ctx;
 	struct tevent_signal *se;
@@ -228,16 +222,15 @@
 		return NULL;
 	}
 
-	ctx = talloc_zero(sconn, struct kernel_oplocks);
+	ctx = talloc_zero(mem_ctx, struct kernel_oplocks);
 	if (!ctx) {
 		DEBUG(0,("Linux Kernel oplocks talloc_Zero failed\n"));
 		return NULL;
 	}
 
 	ctx->ops = &linux_koplocks;
-	ctx->private_data = sconn;
 
-	se = tevent_add_signal(sconn->ev_ctx,
+	se = tevent_add_signal(smbd_event_context(),
 			       ctx,
 			       RT_SIGNAL_LEASE, SA_SIGINFO,
 			       linux_oplock_signal_handler,
@@ -248,6 +241,8 @@
 		return NULL;
 	}
 
+	ctx->private_data = se;
+
 	DEBUG(3,("Linux kernel oplocks enabled\n"));
 
 	return ctx;
Only in ../../samba-3.6.24/source3/smbd: oplock_linux.o
Only in ../../samba-3.6.24/source3/smbd: oplock.o
Only in ../../samba-3.6.24/source3/smbd: oplock_onefs.c
Only in ../../samba-3.6.24/source3/smbd: oplock_onefs.o
diff -ur smbd/password.c ../../samba-3.6.24/source3/smbd/password.c
--- smbd/password.c	2012-10-30 17:01:47.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/password.c	2015-01-28 10:52:25.149068676 +0800
@@ -24,7 +24,6 @@
 #include "smbd/globals.h"
 #include "../librpc/gen_ndr/netlogon.h"
 #include "auth.h"
-#include "../libcli/security/security.h"
 
 /* Fix up prototypes for OSX 10.4, where they're missing */
 #ifndef HAVE_SETNETGRENT_PROTOTYPE
@@ -41,18 +40,18 @@
 				SERVER_ALLOCATED_REQUIRED_NO,
 				SERVER_ALLOCATED_REQUIRED_ANY};
 
-static struct user_struct *get_valid_user_struct_internal(
+static user_struct *get_valid_user_struct_internal(
 			struct smbd_server_connection *sconn,
-			uint64_t vuid,
+			uint16 vuid,
 			enum server_allocated_state server_allocated)
 {
-	struct user_struct *usp;
+	user_struct *usp;
 	int count=0;
 
 	if (vuid == UID_FIELD_INVALID)
 		return NULL;
 
-	usp=sconn->users;
+	usp=sconn->smb1.sessions.validated_users;
 	for (;usp;usp=usp->next,count++) {
 		if (vuid == usp->vuid) {
 			switch (server_allocated) {
@@ -69,7 +68,8 @@
 					break;
 			}
 			if (count > 10) {
-				DLIST_PROMOTE(sconn->users, usp);
+				DLIST_PROMOTE(sconn->smb1.sessions.validated_users,
+					      usp);
 			}
 			return usp;
 		}
@@ -84,20 +84,36 @@
  tell random client vuid's (normally zero) from valid vuids.
 ****************************************************************************/
 
-struct user_struct *get_valid_user_struct(struct smbd_server_connection *sconn,
-					  uint64_t vuid)
+user_struct *get_valid_user_struct(struct smbd_server_connection *sconn,
+				   uint16 vuid)
 {
 	return get_valid_user_struct_internal(sconn, vuid,
 			SERVER_ALLOCATED_REQUIRED_YES);
 }
 
+bool is_partial_auth_vuid(struct smbd_server_connection *sconn, uint16 vuid)
+{
+	return (get_partial_auth_user_struct(sconn, vuid) != NULL);
+}
+
+/****************************************************************************
+ Get the user struct of a partial NTLMSSP login
+****************************************************************************/
+
+user_struct *get_partial_auth_user_struct(struct smbd_server_connection *sconn,
+					  uint16 vuid)
+{
+	return get_valid_user_struct_internal(sconn, vuid,
+			SERVER_ALLOCATED_REQUIRED_NO);
+}
+
 /****************************************************************************
  Invalidate a uid.
 ****************************************************************************/
 
-void invalidate_vuid(struct smbd_server_connection *sconn, uint64_t vuid)
+void invalidate_vuid(struct smbd_server_connection *sconn, uint16 vuid)
 {
-	struct user_struct *vuser = NULL;
+	user_struct *vuser = NULL;
 
 	vuser = get_valid_user_struct_internal(sconn, vuid,
 			SERVER_ALLOCATED_REQUIRED_ANY);
@@ -105,17 +121,95 @@
 		return;
 	}
 
-	session_yield(vuser->session);
+	session_yield(vuser);
+
+	if (vuser->auth_ntlmssp_state) {
+		TALLOC_FREE(vuser->auth_ntlmssp_state);
+	}
 
-	DLIST_REMOVE(sconn->users, vuser);
-	SMB_ASSERT(sconn->num_users > 0);
-	sconn->num_users--;
+	DLIST_REMOVE(sconn->smb1.sessions.validated_users, vuser);
 
 	/* clear the vuid from the 'cache' on each connection, and
 	   from the vuid 'owner' of connections */
 	conn_clear_vuid_caches(sconn, vuid);
 
 	TALLOC_FREE(vuser);
+	sconn->smb1.sessions.num_validated_vuids--;
+}
+
+/****************************************************************************
+ Invalidate all vuid entries for this process.
+****************************************************************************/
+
+void invalidate_all_vuids(struct smbd_server_connection *sconn)
+{
+	if (sconn->using_smb2) {
+		return;
+	}
+
+	while (sconn->smb1.sessions.validated_users != NULL) {
+		invalidate_vuid(sconn,
+				sconn->smb1.sessions.validated_users->vuid);
+	}
+}
+
+static void increment_next_vuid(uint16_t *vuid)
+{
+	*vuid += 1;
+
+	/* Check for vuid wrap. */
+	if (*vuid == UID_FIELD_INVALID) {
+		*vuid = VUID_OFFSET;
+	}
+}
+
+/****************************************************
+ Create a new partial auth user struct.
+*****************************************************/
+
+int register_initial_vuid(struct smbd_server_connection *sconn)
+{
+	user_struct *vuser;
+
+	/* Paranoia check. */
+	if(lp_security() == SEC_SHARE) {
+		smb_panic("register_initial_vuid: "
+			"Tried to register uid in security=share");
+	}
+
+	/* Limit allowed vuids to 16bits - VUID_OFFSET. */
+	if (sconn->smb1.sessions.num_validated_vuids >= 0xFFFF-VUID_OFFSET) {
+		return UID_FIELD_INVALID;
+	}
+
+	if((vuser = talloc_zero(NULL, user_struct)) == NULL) {
+		DEBUG(0,("register_initial_vuid: "
+				"Failed to talloc users struct!\n"));
+		return UID_FIELD_INVALID;
+	}
+
+	/* Allocate a free vuid. Yes this is a linear search... */
+	while( get_valid_user_struct_internal(sconn,
+			sconn->smb1.sessions.next_vuid,
+			SERVER_ALLOCATED_REQUIRED_ANY) != NULL ) {
+		increment_next_vuid(&sconn->smb1.sessions.next_vuid);
+	}
+
+	DEBUG(10,("register_initial_vuid: allocated vuid = %u\n",
+		(unsigned int)sconn->smb1.sessions.next_vuid ));
+
+	vuser->vuid = sconn->smb1.sessions.next_vuid;
+
+	/*
+	 * This happens in an unfinished NTLMSSP session setup. We
+	 * need to allocate a vuid between the first and second calls
+	 * to NTLMSSP.
+	 */
+	increment_next_vuid(&sconn->smb1.sessions.next_vuid);
+	sconn->smb1.sessions.num_validated_vuids++;
+
+	DLIST_ADD(sconn->smb1.sessions.validated_users, vuser);
+	return vuser->vuid;
 }
 
 int register_homes_share(const char *username)
@@ -127,7 +221,7 @@
 	if (result != -1) {
 		DEBUG(3, ("Using static (or previously created) service for "
 			  "user '%s'; path = '%s'\n", username,
-			  lp_pathname(talloc_tos(), result)));
+			  lp_pathname(result)));
 		return result;
 	}
 
@@ -148,3 +242,495 @@
 	TALLOC_FREE(pwd);
 	return result;
 }
+
+/**
+ *  register that a valid login has been performed, establish 'session'.
+ *  @param session_info The token returned from the authentication process.
+ *   (now 'owned' by register_existing_vuid)
+ *
+ *  @param session_key The User session key for the login session (now also
+ *  'owned' by register_existing_vuid)
+ *
+ *  @param respose_blob The NT challenge-response, if available.  (May be
+ *  freed after this call)
+ *
+ *  @param smb_name The untranslated name of the user
+ *
+ *  @return Newly allocated vuid, biased by an offset. (This allows us to
+ *   tell random client vuid's (normally zero) from valid vuids.)
+ *
+ */
+
+int register_existing_vuid(struct smbd_server_connection *sconn,
+			uint16 vuid,
+			struct auth_serversupplied_info *session_info,
+			DATA_BLOB response_blob,
+			const char *smb_name)
+{
+	fstring tmp;
+	user_struct *vuser;
+
+	vuser = get_partial_auth_user_struct(sconn, vuid);
+	if (!vuser) {
+		goto fail;
+	}
+
+	/* Use this to keep tabs on all our info from the authentication */
+	vuser->session_info = talloc_move(vuser, &session_info);
+
+	/* This is a potentially untrusted username */
+	alpha_strcpy(tmp, smb_name, ". _-$", sizeof(tmp));
+
+	vuser->session_info->sanitized_username = talloc_strdup(
+		vuser->session_info, tmp);
+
+	DEBUG(10,("register_existing_vuid: (%u,%u) %s %s %s guest=%d\n",
+		  (unsigned int)vuser->session_info->utok.uid,
+		  (unsigned int)vuser->session_info->utok.gid,
+		  vuser->session_info->unix_name,
+		  vuser->session_info->sanitized_username,
+		  vuser->session_info->info3->base.domain.string,
+		  vuser->session_info->guest ));
+
+	DEBUG(3, ("register_existing_vuid: User name: %s\t"
+		  "Real name: %s\n", vuser->session_info->unix_name,
+		  vuser->session_info->info3->base.full_name.string ?
+		  vuser->session_info->info3->base.full_name.string : ""));
+
+	if (!vuser->session_info->security_token) {
+		DEBUG(1, ("register_existing_vuid: session_info does not "
+			"contain a user_token - cannot continue\n"));
+		goto fail;
+	}
+
+	DEBUG(3,("register_existing_vuid: UNIX uid %d is UNIX user %s, "
+		"and will be vuid %u\n", (int)vuser->session_info->utok.uid,
+		 vuser->session_info->unix_name, vuser->vuid));
+
+	if (!session_claim(sconn, vuser)) {
+		DEBUG(1, ("register_existing_vuid: Failed to claim session "
+			"for vuid=%d\n",
+			vuser->vuid));
+		goto fail;
+	}
+
+	/* Register a home dir service for this user if
+	(a) This is not a guest connection,
+	(b) we have a home directory defined
+	(c) there s not an existing static share by that name
+	If a share exists by this name (autoloaded or not) reuse it . */
+
+	vuser->homes_snum = -1;
+
+	if (!vuser->session_info->guest) {
+		vuser->homes_snum = register_homes_share(
+			vuser->session_info->unix_name);
+	}
+
+	if (srv_is_signing_negotiated(sconn) &&
+	    !vuser->session_info->guest) {
+		/* Try and turn on server signing on the first non-guest
+		 * sessionsetup. */
+		srv_set_signing(sconn,
+				vuser->session_info->user_session_key,
+				response_blob);
+	}
+
+	/* fill in the current_user_info struct */
+	set_current_user_info(
+		vuser->session_info->sanitized_username,
+		vuser->session_info->unix_name,
+		vuser->session_info->info3->base.domain.string);
+
+	return vuser->vuid;
+
+  fail:
+
+	if (vuser) {
+		invalidate_vuid(sconn, vuid);
+	}
+	return UID_FIELD_INVALID;
+}
+
+/****************************************************************************
+ Add a name to the session users list.
+****************************************************************************/
+
+void add_session_user(struct smbd_server_connection *sconn,
+		      const char *user)
+{
+	struct passwd *pw;
+	char *tmp;
+
+	pw = Get_Pwnam_alloc(talloc_tos(), user);
+
+	if (pw == NULL) {
+		return;
+	}
+
+	if (sconn->smb1.sessions.session_userlist == NULL) {
+		sconn->smb1.sessions.session_userlist = SMB_STRDUP(pw->pw_name);
+		goto done;
+	}
+
+	if (in_list(pw->pw_name,sconn->smb1.sessions.session_userlist,false)) {
+		goto done;
+	}
+
+	if (strlen(sconn->smb1.sessions.session_userlist) > 128 * 1024) {
+		DEBUG(3,("add_session_user: session userlist already "
+			 "too large.\n"));
+		goto done;
+	}
+
+	if (asprintf(&tmp, "%s %s",
+		     sconn->smb1.sessions.session_userlist, pw->pw_name) == -1) {
+		DEBUG(3, ("asprintf failed\n"));
+		goto done;
+	}
+
+	SAFE_FREE(sconn->smb1.sessions.session_userlist);
+	sconn->smb1.sessions.session_userlist = tmp;
+ done:
+	TALLOC_FREE(pw);
+}
+
+/****************************************************************************
+ In security=share mode we need to store the client workgroup, as that's
+  what Vista uses for the NTLMv2 calculation.
+****************************************************************************/
+
+void add_session_workgroup(struct smbd_server_connection *sconn,
+			   const char *workgroup)
+{
+	if (sconn->smb1.sessions.session_workgroup) {
+		SAFE_FREE(sconn->smb1.sessions.session_workgroup);
+	}
+	sconn->smb1.sessions.session_workgroup = smb_xstrdup(workgroup);
+}
+
+/****************************************************************************
+ In security=share mode we need to return the client workgroup, as that's
+  what Vista uses for the NTLMv2 calculation.
+****************************************************************************/
+
+const char *get_session_workgroup(struct smbd_server_connection *sconn)
+{
+	return sconn->smb1.sessions.session_workgroup;
+}
+
+/****************************************************************************
+ Check if a username is valid.
+****************************************************************************/
+
+static bool user_ok(const char *user, int snum)
+{
+	bool ret;
+
+	ret = True;
+
+	if (lp_invalid_users(snum)) {
+		char **invalid = str_list_copy(talloc_tos(),
+			lp_invalid_users(snum));
+		if (invalid &&
+		    str_list_substitute(invalid, "%S", lp_servicename(snum))) {
+
+			/* This is used in sec=share only, so no current user
+			 * around to pass to str_list_sub_basic() */
+
+			if ( invalid && str_list_sub_basic(invalid, "", "") ) {
+				ret = !user_in_list(talloc_tos(), user,
+						    (const char **)invalid);
+			}
+		}
+		TALLOC_FREE(invalid);
+	}
+
+	if (ret && lp_valid_users(snum)) {
+		char **valid = str_list_copy(talloc_tos(),
+			lp_valid_users(snum));
+		if ( valid &&
+		     str_list_substitute(valid, "%S", lp_servicename(snum)) ) {
+
+			/* This is used in sec=share only, so no current user
+			 * around to pass to str_list_sub_basic() */
+
+			if ( valid && str_list_sub_basic(valid, "", "") ) {
+				ret = user_in_list(talloc_tos(), user,
+						   (const char **)valid);
+			}
+		}
+		TALLOC_FREE(valid);
+	}
+
+	if (ret && lp_onlyuser(snum)) {
+		char **user_list = str_list_make_v3(
+			talloc_tos(), lp_username(snum), NULL);
+		if (user_list &&
+		    str_list_substitute(user_list, "%S",
+					lp_servicename(snum))) {
+			ret = user_in_list(talloc_tos(), user,
+					   (const char **)user_list);
+		}
+		TALLOC_FREE(user_list);
+	}
+
+	return(ret);
+}
+
+/****************************************************************************
+ Validate a group username entry. Return the username or NULL.
+****************************************************************************/
+
+static char *validate_group(struct smbd_server_connection *sconn,
+			    char *group, DATA_BLOB password,int snum)
+{
+#ifdef HAVE_NETGROUP
+	{
+		char *host, *user, *domain;
+		struct auth_context *actx = sconn->smb1.negprot.auth_context;
+		bool enc = sconn->smb1.negprot.encrypted_passwords;
+		setnetgrent(group);
+		while (getnetgrent(&host, &user, &domain)) {
+			if (user) {
+				if (user_ok(user, snum) &&
+				    password_ok(actx, enc,
+						get_session_workgroup(sconn),
+						user,password)) {
+					endnetgrent();
+					return(user);
+				}
+			}
+		}
+		endnetgrent();
+	}
+#endif
+
+#ifdef HAVE_GETGRENT
+	{
+		struct group *gptr;
+		struct auth_context *actx = sconn->smb1.negprot.auth_context;
+		bool enc = sconn->smb1.negprot.encrypted_passwords;
+
+		setgrent();
+		while ((gptr = (struct group *)getgrent())) {
+			if (strequal(gptr->gr_name,group))
+				break;
+		}
+
+		/*
+		 * As user_ok can recurse doing a getgrent(), we must
+		 * copy the member list onto the heap before
+		 * use. Bug pointed out by leon@eatworms.swmed.edu.
+		 */
+
+		if (gptr) {
+			char *member_list = NULL;
+			size_t list_len = 0;
+			char *member;
+			int i;
+
+			for(i = 0; gptr->gr_mem && gptr->gr_mem[i]; i++) {
+				list_len += strlen(gptr->gr_mem[i])+1;
+			}
+			list_len++;
+
+			member_list = (char *)SMB_MALLOC(list_len);
+			if (!member_list) {
+				endgrent();
+				return NULL;
+			}
+
+			*member_list = '\0';
+			member = member_list;
+
+			for(i = 0; gptr->gr_mem && gptr->gr_mem[i]; i++) {
+				size_t member_len = strlen(gptr->gr_mem[i])+1;
+
+				DEBUG(10,("validate_group: = gr_mem = "
+					  "%s\n", gptr->gr_mem[i]));
+
+				strlcpy(member, gptr->gr_mem[i],
+					list_len - (member-member_list));
+				member += member_len;
+			}
+
+			endgrent();
+
+			member = member_list;
+			while (*member) {
+				if (user_ok(member,snum) &&
+				    password_ok(actx, enc,
+						get_session_workgroup(sconn),
+						member,password)) {
+					char *name = talloc_strdup(talloc_tos(),
+								member);
+					SAFE_FREE(member_list);
+					return name;
+				}
+
+				DEBUG(10,("validate_group = member = %s\n",
+					  member));
+
+				member += strlen(member) + 1;
+			}
+
+			SAFE_FREE(member_list);
+		} else {
+			endgrent();
+			return NULL;
+		}
+	}
+#endif
+	return(NULL);
+}
+
+/****************************************************************************
+ Check for authority to login to a service with a given username/password.
+ Note this is *NOT* used when logging on using sessionsetup_and_X.
+****************************************************************************/
+
+bool authorise_login(struct smbd_server_connection *sconn,
+		     int snum, fstring user, DATA_BLOB password,
+		     bool *guest)
+{
+	bool ok = False;
+	struct auth_context *actx = sconn->smb1.negprot.auth_context;
+	bool enc = sconn->smb1.negprot.encrypted_passwords;
+
+#ifdef DEBUG_PASSWORD
+	DEBUG(100,("authorise_login: checking authorisation on "
+		   "user=%s pass=%s\n", user,password.data));
+#endif
+
+	*guest = False;
+
+	/* there are several possibilities:
+		1) login as the given user with given password
+		2) login as a previously registered username with the given
+		   password
+		3) login as a session list username with the given password
+		4) login as a previously validated user/password pair
+		5) login as the "user =" user with given password
+		6) login as the "user =" user with no password
+		   (guest connection)
+		7) login as guest user with no password
+
+		if the service is guest_only then steps 1 to 5 are skipped
+	*/
+
+	/* now check the list of session users */
+	if (!ok) {
+		char *auser;
+		char *user_list = NULL;
+		char *saveptr;
+
+		if (sconn->smb1.sessions.session_userlist)
+			user_list = SMB_STRDUP(sconn->smb1.sessions.session_userlist);
+		else
+			user_list = SMB_STRDUP("");
+
+		if (!user_list)
+			return(False);
+
+		for (auser = strtok_r(user_list, LIST_SEP, &saveptr);
+		     !ok && auser;
+		     auser = strtok_r(NULL, LIST_SEP, &saveptr)) {
+			fstring user2;
+			fstrcpy(user2,auser);
+			if (!user_ok(user2,snum))
+				continue;
+
+			if (password_ok(actx, enc,
+					get_session_workgroup(sconn),
+					user2,password)) {
+				ok = True;
+				fstrcpy(user,user2);
+				DEBUG(3,("authorise_login: ACCEPTED: session "
+					 "list username (%s) and given "
+					 "password ok\n", user));
+			}
+		}
+
+		SAFE_FREE(user_list);
+	}
+
+	/* check the user= fields and the given password */
+	if (!ok && lp_username(snum)) {
+		TALLOC_CTX *ctx = talloc_tos();
+		char *auser;
+		char *user_list = talloc_strdup(ctx, lp_username(snum));
+		char *saveptr;
+
+		if (!user_list) {
+			goto check_guest;
+		}
+
+		user_list = talloc_string_sub(ctx,
+				user_list,
+				"%S",
+				lp_servicename(snum));
+
+		if (!user_list) {
+			goto check_guest;
+		}
+
+		for (auser = strtok_r(user_list, LIST_SEP, &saveptr);
+		     auser && !ok;
+		     auser = strtok_r(NULL, LIST_SEP, &saveptr)) {
+			if (*auser == '@') {
+				auser = validate_group(sconn,auser+1,
+						       password,snum);
+				if (auser) {
+					ok = True;
+					fstrcpy(user,auser);
+					DEBUG(3,("authorise_login: ACCEPTED: "
+						 "group username and given "
+						 "password ok (%s)\n", user));
+				}
+			} else {
+				fstring user2;
+				fstrcpy(user2,auser);
+				if (user_ok(user2,snum) &&
+				    password_ok(actx, enc,
+						get_session_workgroup(sconn),
+						user2,password)) {
+					ok = True;
+					fstrcpy(user,user2);
+					DEBUG(3,("authorise_login: ACCEPTED: "
+						 "user list username and "
+						 "given password ok (%s)\n",
+						 user));
+				}
+			}
+		}
+	}
+
+  check_guest:
+
+	/* check for a normal guest connection */
+	if (!ok && GUEST_OK(snum)) {
+		struct passwd *guest_pw;
+		fstring guestname;
+		fstrcpy(guestname,lp_guestaccount());
+		guest_pw = Get_Pwnam_alloc(talloc_tos(), guestname);
+		if (guest_pw != NULL) {
+			fstrcpy(user,guestname);
+			ok = True;
+			DEBUG(3,("authorise_login: ACCEPTED: guest account "
+				 "and guest ok (%s)\n",	user));
+		} else {
+			DEBUG(0,("authorise_login: Invalid guest account "
+				 "%s??\n",guestname));
+		}
+		TALLOC_FREE(guest_pw);
+		*guest = True;
+	}
+
+	if (ok && !user_ok(user, snum)) {
+		DEBUG(0,("authorise_login: rejected invalid user %s\n",user));
+		ok = False;
+	}
+
+	return(ok);
+}
Only in ../../samba-3.6.24/source3/smbd: password.o
diff -ur smbd/perfcount.c ../../samba-3.6.24/source3/smbd/perfcount.c
--- smbd/perfcount.c	2012-10-02 16:24:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/perfcount.c	2015-01-28 10:52:25.149068676 +0800
@@ -85,7 +85,7 @@
 
 	entry = SMB_XMALLOC_P(struct smb_perfcount_module);
 	entry->name = smb_xstrdup(name);
-	entry->handlers = discard_const_p(struct smb_perfcount_handlers, handlers);
+	entry->handlers = (struct smb_perfcount_handlers*) handlers;
 
 	DLIST_ADD(modules, entry);
 	DEBUG(3, ("Successfully added perfcounter module '%s'\n", name));
@@ -176,7 +176,7 @@
 {
 	char *perfcount_object;
 
-	perfcount_object = lp_perfcount_module(talloc_tos());
+	perfcount_object = lp_perfcount_module();
 
 	/* don't init */
 	if (!perfcount_object || !perfcount_object[0])
Only in ../../samba-3.6.24/source3/smbd: perfcount.o
diff -ur smbd/pipes.c ../../samba-3.6.24/source3/smbd/pipes.c
--- smbd/pipes.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/pipes.c	2015-01-28 10:52:25.149068676 +0800
@@ -1,21 +1,21 @@
-/*
+/* 
    Unix SMB/CIFS implementation.
    Pipe SMB reply routines
    Copyright (C) Andrew Tridgell 1992-1998
    Copyright (C) Luke Kenneth Casson Leighton 1996-1998
    Copyright (C) Paul Ashton  1997-1998.
    Copyright (C) Jeremy Allison 2005.
-
+   
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -31,6 +31,11 @@
 #include "libcli/security/security.h"
 #include "rpc_server/srv_pipe_hnd.h"
 
+#define	PIPE		"\\PIPE\\"
+#define	PIPELEN		strlen(PIPE)
+
+#define MAX_PIPE_NAME_LEN	24
+
 NTSTATUS open_np_file(struct smb_request *smb_req, const char *name,
 		      struct files_struct **pfsp)
 {
@@ -67,6 +72,7 @@
 	status = np_open(fsp, name,
 			 conn->sconn->local_address,
 			 conn->sconn->remote_address,
+			 &conn->sconn->client_id,
 			 conn->session_info,
 			 conn->sconn->msg_ctx,
 			 &fsp->fake_file_handle);
@@ -107,24 +113,15 @@
 	/* If the name doesn't start \PIPE\ then this is directed */
 	/* at a mailslot or something we really, really don't understand, */
 	/* not just something we really don't understand. */
-
-#define	PIPE		"PIPE\\"
-#define	PIPELEN		strlen(PIPE)
-
-	fname = pipe_name;
-	while (fname[0] == '\\') {
-		fname++;
-	}
-	if (!strnequal(fname, PIPE, PIPELEN)) {
-		reply_nterror(req, NT_STATUS_OBJECT_PATH_SYNTAX_BAD);
+	if ( strncmp(pipe_name,PIPE,PIPELEN) != 0 ) {
+		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 		return;
 	}
-	fname += PIPELEN;
-	while (fname[0] == '\\') {
-		fname++;
-	}
 
-	DEBUG(4,("Opening pipe %s => %s.\n", pipe_name, fname));
+	DEBUG(4,("Opening pipe %s.\n", pipe_name));
+
+	/* Strip \PIPE\ off the name. */
+	fname = pipe_name + PIPELEN;
 
 #if 0
 	/*
@@ -150,9 +147,6 @@
 	/* Prepare the reply */
 	reply_outbuf(req, 15, 0);
 
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	/* Mark the opened file as an existing named pipe in message mode. */
 	SSVAL(req->outbuf,smb_vwv9,2);
 	SSVAL(req->outbuf,smb_vwv10,0xc700);
@@ -163,6 +157,9 @@
 	SIVAL(req->outbuf, smb_vwv6, 0);	/* size */
 	SSVAL(req->outbuf, smb_vwv8, 0);	/* rmode */
 	SSVAL(req->outbuf, smb_vwv11, 0x0001);
+
+	chain_reply(req);
+	return;
 }
 
 /****************************************************************************
@@ -203,10 +200,10 @@
 
 	data = req->buf + 3;
 
-	DEBUG(6, ("reply_pipe_write: %s, name: %s len: %d\n", fsp_fnum_dbg(fsp),
+	DEBUG(6, ("reply_pipe_write: %x name: %s len: %d\n", (int)fsp->fnum,
 		  fsp_str_dbg(fsp), (int)state->numtowrite));
 
-	subreq = np_write_send(state, req->sconn->ev_ctx,
+	subreq = np_write_send(state, smbd_event_context(),
 			       fsp->fake_file_handle, data, state->numtowrite);
 	if (subreq == NULL) {
 		TALLOC_FREE(state);
@@ -273,7 +270,7 @@
 {
 	files_struct *fsp = file_fsp(req, SVAL(req->vwv+2, 0));
 	int smb_doff = SVAL(req->vwv+11, 0);
-	const uint8_t *data;
+	uint8_t *data;
 	struct pipe_write_andx_state *state;
 	struct tevent_req *subreq;
 
@@ -299,10 +296,10 @@
 		((SVAL(req->vwv+7, 0) & (PIPE_START_MESSAGE|PIPE_RAW_MODE))
 		 == (PIPE_START_MESSAGE|PIPE_RAW_MODE));
 
-	DEBUG(6, ("reply_pipe_write_and_X: %s, name: %s len: %d\n",
-		  fsp_fnum_dbg(fsp), fsp_str_dbg(fsp), (int)state->numtowrite));
+	DEBUG(6, ("reply_pipe_write_and_X: %x name: %s len: %d\n",
+		  (int)fsp->fnum, fsp_str_dbg(fsp), (int)state->numtowrite));
 
-	data = (const uint8_t *)smb_base(req->inbuf) + smb_doff;
+	data = (uint8_t *)smb_base(req->inbuf) + smb_doff;
 
 	if (state->pipe_start_message_raw) {
 		/*
@@ -322,7 +319,7 @@
 		state->numtowrite -= 2;
 	}
 
-	subreq = np_write_send(state, req->sconn->ev_ctx,
+	subreq = np_write_send(state, smbd_event_context(),
 			       fsp->fake_file_handle, data, state->numtowrite);
 	if (subreq == NULL) {
 		TALLOC_FREE(state);
@@ -358,20 +355,18 @@
 
 	reply_outbuf(req, 6, 0);
 
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	nwritten = (state->pipe_start_message_raw ? nwritten + 2 : nwritten);
 	SSVAL(req->outbuf,smb_vwv2,nwritten);
 
 	DEBUG(3,("writeX-IPC nwritten=%d\n", (int)nwritten));
 
  done:
+	chain_reply(req);
 	/*
 	 * We must free here as the ownership of req was
 	 * moved to the connection struct in reply_pipe_write_and_X().
 	 */
-	smb_request_done(req);
+	TALLOC_FREE(req);
 }
 
 /****************************************************************************
@@ -423,9 +418,6 @@
 	state->smb_mincnt = SVAL(req->vwv+6, 0);
 
 	reply_outbuf(req, 12, state->smb_maxcnt);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	data = (uint8_t *)smb_buf(req->outbuf);
 
 	/*
@@ -434,7 +426,7 @@
 	state->outbuf = req->outbuf;
 	req->outbuf = NULL;
 
-	subreq = np_read_send(state, req->sconn->ev_ctx,
+	subreq = np_read_send(state, smbd_event_context(),
 			      fsp->fake_file_handle, data,
 			      state->smb_maxcnt);
 	if (subreq == NULL) {
@@ -458,8 +450,6 @@
 	status = np_read_recv(subreq, &nread, &is_data_outstanding);
 	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
-		NTSTATUS old = status;
-		status = nt_status_np_pipe(old);
 		reply_nterror(req, status);
 		goto done;
 	}
@@ -485,19 +475,20 @@
 
 	SSVAL(req->outbuf,smb_vwv5,nread);
 	SSVAL(req->outbuf,smb_vwv6,
-	      (smb_wct - 4)	/* offset from smb header to wct */
+	      req_wct_ofs(req)
 	      + 1 		/* the wct field */
 	      + 12 * sizeof(uint16_t) /* vwv */
 	      + 2);		/* the buflen field */
 	SSVAL(req->outbuf,smb_vwv11,state->smb_maxcnt);
-
+  
 	DEBUG(3,("readX-IPC min=%d max=%d nread=%d\n",
 		 state->smb_mincnt, state->smb_maxcnt, (int)nread));
 
  done:
+	chain_reply(req);
 	/*
 	 * We must free here as the ownership of req was
 	 * moved to the connection struct in reply_pipe_read_and_X().
 	 */
-	smb_request_done(req);
+	TALLOC_FREE(req);
 }
Only in ../../samba-3.6.24/source3/smbd: pipes.o
diff -ur smbd/posix_acls.c ../../samba-3.6.24/source3/smbd/posix_acls.c
--- smbd/posix_acls.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/posix_acls.c	2015-01-28 10:52:25.149068676 +0800
@@ -26,8 +26,6 @@
 #include "trans2.h"
 #include "passdb/lookup_sid.h"
 #include "auth.h"
-#include "../librpc/gen_ndr/idmap.h"
-#include "lib/param/loadparm.h"
 
 extern const struct generic_mapping file_generic_mapping;
 
@@ -41,6 +39,12 @@
 enum ace_owner {UID_ACE, GID_ACE, WORLD_ACE};
 enum ace_attribute {ALLOW_ACE, DENY_ACE}; /* Used for incoming NT ACLS. */
 
+typedef union posix_id {
+		uid_t uid;
+		gid_t gid;
+		int world;
+} posix_id;
+
 typedef struct canon_ace {
 	struct canon_ace *next, *prev;
 	SMB_ACL_TAG_T type;
@@ -48,7 +52,7 @@
 	struct dom_sid trustee;
 	enum ace_owner owner_type;
 	enum ace_attribute attr;
-	struct unixid unix_ug;
+	posix_id unix_ug;
 	uint8_t ace_flags; /* From windows ACE entry. */
 } canon_ace;
 
@@ -117,7 +121,7 @@
 	struct pai_entry *next, *prev;
 	uint8_t ace_flags;
 	enum ace_owner owner_type;
-	struct unixid unix_ug;
+	posix_id unix_ug;
 };
 
 struct pai_val {
@@ -136,11 +140,11 @@
 {
 	switch (paie->owner_type) {
 		case UID_ACE:
-			DEBUG(10,("get_pai_entry_val: uid = %u\n", (unsigned int)paie->unix_ug.id ));
-			return (uint32_t)paie->unix_ug.id;
+			DEBUG(10,("get_pai_entry_val: uid = %u\n", (unsigned int)paie->unix_ug.uid ));
+			return (uint32_t)paie->unix_ug.uid;
 		case GID_ACE:
-			DEBUG(10,("get_pai_entry_val: gid = %u\n", (unsigned int)paie->unix_ug.id ));
-			return (uint32_t)paie->unix_ug.id;
+			DEBUG(10,("get_pai_entry_val: gid = %u\n", (unsigned int)paie->unix_ug.gid ));
+			return (uint32_t)paie->unix_ug.gid;
 		case WORLD_ACE:
 		default:
 			DEBUG(10,("get_pai_entry_val: world ace\n"));
@@ -156,11 +160,11 @@
 {
 	switch (ace_entry->owner_type) {
 		case UID_ACE:
-			DEBUG(10,("get_entry_val: uid = %u\n", (unsigned int)ace_entry->unix_ug.id ));
-			return (uint32_t)ace_entry->unix_ug.id;
+			DEBUG(10,("get_entry_val: uid = %u\n", (unsigned int)ace_entry->unix_ug.uid ));
+			return (uint32_t)ace_entry->unix_ug.uid;
 		case GID_ACE:
-			DEBUG(10,("get_entry_val: gid = %u\n", (unsigned int)ace_entry->unix_ug.id ));
-			return (uint32_t)ace_entry->unix_ug.id;
+			DEBUG(10,("get_entry_val: gid = %u\n", (unsigned int)ace_entry->unix_ug.gid ));
+			return (uint32_t)ace_entry->unix_ug.gid;
 		case WORLD_ACE:
 		default:
 			DEBUG(10,("get_entry_val: world ace\n"));
@@ -197,7 +201,7 @@
 	*store_size = PAI_V2_ENTRIES_BASE +
 		((num_entries + num_def_entries)*PAI_V2_ENTRY_LENGTH);
 
-	pai_buf = talloc_array(talloc_tos(), char, *store_size);
+	pai_buf = (char *)SMB_MALLOC(*store_size);
 	if (!pai_buf) {
 		return NULL;
 	}
@@ -279,7 +283,7 @@
 				       pai_buf, store_size, 0);
 	}
 
-	TALLOC_FREE(pai_buf);
+	SAFE_FREE(pai_buf);
 
 	DEBUG(10,("store_inheritance_attribute: type 0x%x for file %s\n",
 		(unsigned int)sd_type,
@@ -300,13 +304,13 @@
 		struct pai_entry *paie, *paie_next;
 		for (paie = pal->entry_list; paie; paie = paie_next) {
 			paie_next = paie->next;
-			TALLOC_FREE(paie);
+			SAFE_FREE(paie);
 		}
 		for (paie = pal->def_entry_list; paie; paie = paie_next) {
 			paie_next = paie->next;
-			TALLOC_FREE(paie);
+			SAFE_FREE(paie);
 		}
-		TALLOC_FREE(pal);
+		SAFE_FREE(pal);
 	}
 }
 
@@ -404,20 +408,17 @@
 	paie->owner_type = (enum ace_owner)CVAL(entry_offset,0);
 	switch( paie->owner_type) {
 		case UID_ACE:
-			paie->unix_ug.type = ID_TYPE_UID;
-			paie->unix_ug.id = (uid_t)IVAL(entry_offset,1);
+			paie->unix_ug.uid = (uid_t)IVAL(entry_offset,1);
 			DEBUG(10,("get_pai_owner_type: uid = %u\n",
-				(unsigned int)paie->unix_ug.id ));
+				(unsigned int)paie->unix_ug.uid ));
 			break;
 		case GID_ACE:
-			paie->unix_ug.type = ID_TYPE_GID;
-			paie->unix_ug.id = (gid_t)IVAL(entry_offset,1);
+			paie->unix_ug.gid = (gid_t)IVAL(entry_offset,1);
 			DEBUG(10,("get_pai_owner_type: gid = %u\n",
-				(unsigned int)paie->unix_ug.id ));
+				(unsigned int)paie->unix_ug.gid ));
 			break;
 		case WORLD_ACE:
-			paie->unix_ug.type = ID_TYPE_NOT_SPECIFIED;
-			paie->unix_ug.id = -1;
+			paie->unix_ug.world = -1;
 			DEBUG(10,("get_pai_owner_type: world ace\n"));
 			break;
 		default:
@@ -439,14 +440,14 @@
 	int i;
 
 	for (i = 0; i < paiv->num_entries; i++) {
-		struct pai_entry *paie = talloc(talloc_tos(), struct pai_entry);
+		struct pai_entry *paie = SMB_MALLOC_P(struct pai_entry);
 		if (!paie) {
 			return NULL;
 		}
 
 		paie->ace_flags = SEC_ACE_FLAG_INHERITED_ACE;
 		if (!get_pai_owner_type(paie, entry_offset)) {
-			TALLOC_FREE(paie);
+			SAFE_FREE(paie);
 			return NULL;
 		}
 
@@ -473,7 +474,7 @@
 		return NULL;
 	}
 
-	paiv = talloc(talloc_tos(), struct pai_val);
+	paiv = SMB_MALLOC_P(struct pai_val);
 	if (!paiv) {
 		return NULL;
 	}
@@ -517,7 +518,7 @@
 	unsigned int i;
 
 	for (i = 0; i < num_entries; i++) {
-		struct pai_entry *paie = talloc(talloc_tos(), struct pai_entry);
+		struct pai_entry *paie = SMB_MALLOC_P(struct pai_entry);
 		if (!paie) {
 			return NULL;
 		}
@@ -525,7 +526,7 @@
 		paie->ace_flags = CVAL(entry_offset,0);
 
 		if (!get_pai_owner_type(paie, entry_offset+1)) {
-			TALLOC_FREE(paie);
+			SAFE_FREE(paie);
 			return NULL;
 		}
 		if (!def_entry) {
@@ -551,7 +552,7 @@
 		return NULL;
 	}
 
-	paiv = talloc(talloc_tos(), struct pai_val);
+	paiv = SMB_MALLOC_P(struct pai_val);
 	if (!paiv) {
 		return NULL;
 	}
@@ -618,7 +619,7 @@
 		return NULL;
 	}
 
-	if ((pai_buf = talloc_array(talloc_tos(), char, pai_buf_size)) == NULL) {
+	if ((pai_buf = (char *)SMB_MALLOC(pai_buf_size)) == NULL) {
 		return NULL;
 	}
 
@@ -639,11 +640,11 @@
 			}
 			/* Buffer too small - enlarge it. */
 			pai_buf_size *= 2;
-			TALLOC_FREE(pai_buf);
+			SAFE_FREE(pai_buf);
 			if (pai_buf_size > 1024*1024) {
 				return NULL; /* Limit malloc to 1mb. */
 			}
-			if ((pai_buf = talloc_array(talloc_tos(), char, pai_buf_size)) == NULL)
+			if ((pai_buf = (char *)SMB_MALLOC(pai_buf_size)) == NULL)
 				return NULL;
 		}
 	} while (ret == -1);
@@ -660,7 +661,7 @@
 		if (errno != ENOSYS)
 			DEBUG(10,("load_inherited_info: Error %s\n", strerror(errno) ));
 #endif
-		TALLOC_FREE(pai_buf);
+		SAFE_FREE(pai_buf);
 		return NULL;
 	}
 
@@ -671,7 +672,7 @@
 			  (unsigned int)paiv->sd_type, fsp_str_dbg(fsp)));
 	}
 
-	TALLOC_FREE(pai_buf);
+	SAFE_FREE(pai_buf);
 	return paiv;
 }
 
@@ -691,7 +692,7 @@
 		return NULL;
 	}
 
-	if ((pai_buf = talloc_array(talloc_tos(), char, pai_buf_size)) == NULL) {
+	if ((pai_buf = (char *)SMB_MALLOC(pai_buf_size)) == NULL) {
 		return NULL;
 	}
 
@@ -706,11 +707,11 @@
 			}
 			/* Buffer too small - enlarge it. */
 			pai_buf_size *= 2;
-			TALLOC_FREE(pai_buf);
+			SAFE_FREE(pai_buf);
 			if (pai_buf_size > 1024*1024) {
 				return NULL; /* Limit malloc to 1mb. */
 			}
-			if ((pai_buf = talloc_array(talloc_tos(), char, pai_buf_size)) == NULL)
+			if ((pai_buf = (char *)SMB_MALLOC(pai_buf_size)) == NULL)
 				return NULL;
 		}
 	} while (ret == -1);
@@ -726,7 +727,7 @@
 		if (errno != ENOSYS)
 			DEBUG(10,("load_inherited_info: Error %s\n", strerror(errno) ));
 #endif
-		TALLOC_FREE(pai_buf);
+		SAFE_FREE(pai_buf);
 		return NULL;
 	}
 
@@ -738,7 +739,7 @@
 			fname));
 	}
 
-	TALLOC_FREE(pai_buf);
+	SAFE_FREE(pai_buf);
 	return paiv;
 }
 
@@ -772,7 +773,7 @@
 	for (list = l_head; list; list = next) {
 		next = list->next;
 		DLIST_REMOVE(l_head, list);
-		TALLOC_FREE(list);
+		SAFE_FREE(list);
 	}
 }
 
@@ -782,7 +783,7 @@
 
 static canon_ace *dup_canon_ace( canon_ace *src_ace)
 {
-	canon_ace *dst_ace = talloc(talloc_tos(), canon_ace);
+	canon_ace *dst_ace = SMB_MALLOC_P(canon_ace);
 
 	if (dst_ace == NULL)
 		return NULL;
@@ -801,11 +802,11 @@
 	dbgtext( "canon_ace index %d. Type = %s ", num, pace->attr == ALLOW_ACE ? "allow" : "deny" );
 	dbgtext( "SID = %s ", sid_string_dbg(&pace->trustee));
 	if (pace->owner_type == UID_ACE) {
-		const char *u_name = uidtoname(pace->unix_ug.id);
-		dbgtext( "uid %u (%s) ", (unsigned int)pace->unix_ug.id, u_name );
+		const char *u_name = uidtoname(pace->unix_ug.uid);
+		dbgtext( "uid %u (%s) ", (unsigned int)pace->unix_ug.uid, u_name );
 	} else if (pace->owner_type == GID_ACE) {
-		char *g_name = gidtoname(pace->unix_ug.id);
-		dbgtext( "gid %u (%s) ", (unsigned int)pace->unix_ug.id, g_name );
+		char *g_name = gidtoname(pace->unix_ug.gid);
+		dbgtext( "gid %u (%s) ", (unsigned int)pace->unix_ug.gid, g_name );
 	} else
 		dbgtext( "other ");
 	switch (pace->type) {
@@ -855,13 +856,13 @@
  Map POSIX ACL perms to canon_ace permissions (a mode_t containing only S_(R|W|X)USR bits).
 ****************************************************************************/
 
-static mode_t convert_permset_to_mode_t(SMB_ACL_PERMSET_T permset)
+static mode_t convert_permset_to_mode_t(connection_struct *conn, SMB_ACL_PERMSET_T permset)
 {
 	mode_t ret = 0;
 
-	ret |= (sys_acl_get_perm(permset, SMB_ACL_READ) ? S_IRUSR : 0);
-	ret |= (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? S_IWUSR : 0);
-	ret |= (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? S_IXUSR : 0);
+	ret |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_READ) ? S_IRUSR : 0);
+	ret |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_WRITE) ? S_IWUSR : 0);
+	ret |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_EXECUTE) ? S_IXUSR : 0);
 
 	return ret;
 }
@@ -891,18 +892,18 @@
 
 static int map_acl_perms_to_permset(connection_struct *conn, mode_t mode, SMB_ACL_PERMSET_T *p_permset)
 {
-	if (sys_acl_clear_perms(*p_permset) ==  -1)
+	if (SMB_VFS_SYS_ACL_CLEAR_PERMS(conn, *p_permset) ==  -1)
 		return -1;
 	if (mode & S_IRUSR) {
-		if (sys_acl_add_perm(*p_permset, SMB_ACL_READ) == -1)
+		if (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_READ) == -1)
 			return -1;
 	}
 	if (mode & S_IWUSR) {
-		if (sys_acl_add_perm(*p_permset, SMB_ACL_WRITE) == -1)
+		if (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_WRITE) == -1)
 			return -1;
 	}
 	if (mode & S_IXUSR) {
-		if (sys_acl_add_perm(*p_permset, SMB_ACL_EXECUTE) == -1)
+		if (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_EXECUTE) == -1)
 			return -1;
 	}
 	return 0;
@@ -919,7 +920,7 @@
 }
 
 /****************************************************************************
- Merge aces with a common UID or GID - if both are allow or deny, OR the permissions together and
+ Merge aces with a common sid - if both are allow or deny, OR the permissions together and
  delete the second one. If the first is deny, mask the permissions off and delete the allow
  if the permissions become zero, delete the deny if the permissions are non zero.
 ****************************************************************************/
@@ -948,21 +949,15 @@
 
 			/* For file ACLs we can merge if the SIDs and ALLOW/DENY
 			 * types are the same. For directory acls we must also
-			 * ensure the POSIX ACL types are the same.
-			 *
-			 * For the IDMAP_BOTH case, we must not merge
-			 * the UID and GID ACE values for same SID
-			 */
+			 * ensure the POSIX ACL types are the same. */
 
 			if (!dir_acl) {
-				can_merge = (curr_ace->unix_ug.id == curr_ace_outer->unix_ug.id &&
-					     curr_ace->owner_type == curr_ace_outer->owner_type &&
-					     (curr_ace->attr == curr_ace_outer->attr));
+				can_merge = (dom_sid_equal(&curr_ace->trustee, &curr_ace_outer->trustee) &&
+						(curr_ace->attr == curr_ace_outer->attr));
 			} else {
-				can_merge = (curr_ace->unix_ug.id == curr_ace_outer->unix_ug.id &&
-					     curr_ace->owner_type == curr_ace_outer->owner_type &&
-					     (curr_ace->type == curr_ace_outer->type) &&
-					     (curr_ace->attr == curr_ace_outer->attr));
+				can_merge = (dom_sid_equal(&curr_ace->trustee, &curr_ace_outer->trustee) &&
+						(curr_ace->type == curr_ace_outer->type) &&
+						(curr_ace->attr == curr_ace_outer->attr));
 			}
 
 			if (can_merge) {
@@ -982,7 +977,7 @@
 				curr_ace_outer->perms |= curr_ace->perms;
 				curr_ace_outer->ace_flags |= curr_ace->ace_flags;
 				DLIST_REMOVE(l_head, curr_ace);
-				TALLOC_FREE(curr_ace);
+				SAFE_FREE(curr_ace);
 				curr_ace_outer_next = curr_ace_outer->next; /* We may have deleted the link. */
 			}
 		}
@@ -1009,9 +1004,8 @@
 			 * we've put on the ACL, we know the deny must be the first one.
 			 */
 
-			if (curr_ace->unix_ug.id == curr_ace_outer->unix_ug.id &&
-			    (curr_ace->owner_type == curr_ace_outer->owner_type) &&
-			    (curr_ace_outer->attr == DENY_ACE) && (curr_ace->attr == ALLOW_ACE)) {
+			if (dom_sid_equal(&curr_ace->trustee, &curr_ace_outer->trustee) &&
+				(curr_ace_outer->attr == DENY_ACE) && (curr_ace->attr == ALLOW_ACE)) {
 
 				if( DEBUGLVL( 10 )) {
 					dbgtext("merge_aces: Masking ACE's\n");
@@ -1028,7 +1022,7 @@
 					 */
 
 					DLIST_REMOVE(l_head, curr_ace);
-					TALLOC_FREE(curr_ace);
+					SAFE_FREE(curr_ace);
 					curr_ace_outer_next = curr_ace_outer->next; /* We may have deleted the link. */
 
 				} else {
@@ -1044,7 +1038,7 @@
 					 */
 
 					DLIST_REMOVE(l_head, curr_ace_outer);
-					TALLOC_FREE(curr_ace_outer);
+					SAFE_FREE(curr_ace_outer);
 					break;
 				}
 			}
@@ -1058,6 +1052,24 @@
 }
 
 /****************************************************************************
+ Check if we need to return NT4.x compatible ACL entries.
+****************************************************************************/
+
+bool nt4_compatible_acls(void)
+{
+	int compat = lp_acl_compatibility();
+
+	if (compat == ACL_COMPAT_AUTO) {
+		enum remote_arch_types ra_type = get_remote_arch();
+
+		/* Automatically adapt to client */
+		return (ra_type <= RA_WINNT);
+	} else
+		return (compat == ACL_COMPAT_WINNT);
+}
+
+
+/****************************************************************************
  Map canon_ace perms to permission bits NT.
  The attr element is not used here - we only process deny entries on set,
  not get. Deny entries are implicit on get with ace->perms = 0.
@@ -1088,7 +1100,10 @@
 		 * to be changed in the future.
 		 */
 
-		nt_mask = 0;
+		if (nt4_compatible_acls())
+			nt_mask = UNIX_ACCESS_NONE;
+		else
+			nt_mask = 0;
 	} else {
 		if (directory_ace) {
 			nt_mask |= ((perms & S_IRUSR) ? UNIX_DIRECTORY_ACCESS_R : 0 );
@@ -1235,19 +1250,48 @@
 	return NT_STATUS_OK;
 }
 
+/****************************************************************************
+ Ensure the enforced permissions for this share apply.
+****************************************************************************/
 
-static void trim_ace_perms(canon_ace *pace)
+static void apply_default_perms(const struct share_params *params,
+				const bool is_directory, canon_ace *pace,
+				mode_t type)
 {
-	pace->perms = pace->perms & (S_IXUSR|S_IWUSR|S_IRUSR);
-}
+	mode_t and_bits = (mode_t)0;
+	mode_t or_bits = (mode_t)0;
+
+	/* Get the initial bits to apply. */
 
-static void ensure_minimal_owner_ace_perms(const bool is_directory,
-					   canon_ace *pace)
-{
-	pace->perms |= S_IRUSR;
 	if (is_directory) {
-		pace->perms |= (S_IWUSR|S_IXUSR);
+		and_bits = lp_dir_security_mask(params->service);
+		or_bits = lp_force_dir_security_mode(params->service);
+	} else {
+		and_bits = lp_security_mask(params->service);
+		or_bits = lp_force_security_mode(params->service);
 	}
+
+	/* Now bounce them into the S_USR space. */	
+	switch(type) {
+	case S_IRUSR:
+		/* Ensure owner has read access. */
+		pace->perms |= S_IRUSR;
+		if (is_directory)
+			pace->perms |= (S_IWUSR|S_IXUSR);
+		and_bits = unix_perms_to_acl_perms(and_bits, S_IRUSR, S_IWUSR, S_IXUSR);
+		or_bits = unix_perms_to_acl_perms(or_bits, S_IRUSR, S_IWUSR, S_IXUSR);
+		break;
+	case S_IRGRP:
+		and_bits = unix_perms_to_acl_perms(and_bits, S_IRGRP, S_IWGRP, S_IXGRP);
+		or_bits = unix_perms_to_acl_perms(or_bits, S_IRGRP, S_IWGRP, S_IXGRP);
+		break;
+	case S_IROTH:
+		and_bits = unix_perms_to_acl_perms(and_bits, S_IROTH, S_IWOTH, S_IXOTH);
+		or_bits = unix_perms_to_acl_perms(or_bits, S_IROTH, S_IWOTH, S_IXOTH);
+		break;
+	}
+
+	pace->perms = ((pace->perms & and_bits)|or_bits);
 }
 
 /****************************************************************************
@@ -1257,6 +1301,8 @@
 
 static bool uid_entry_in_group(connection_struct *conn, canon_ace *uid_ace, canon_ace *group_ace )
 {
+	const char *u_name = NULL;
+
 	/* "Everyone" always matches every uid. */
 
 	if (dom_sid_equal(&group_ace->trustee, &global_sid_World))
@@ -1266,352 +1312,214 @@
 	 * if it's the current user, we already have the unix token
 	 * and don't need to do the complex user_in_group_sid() call
 	 */
-	if (uid_ace->unix_ug.id == get_current_uid(conn)) {
+	if (uid_ace->unix_ug.uid == get_current_uid(conn)) {
 		const struct security_unix_token *curr_utok = NULL;
 		size_t i;
 
-		if (group_ace->unix_ug.id == get_current_gid(conn)) {
+		if (group_ace->unix_ug.gid == get_current_gid(conn)) {
 			return True;
 		}
 
 		curr_utok = get_current_utok(conn);
 		for (i=0; i < curr_utok->ngroups; i++) {
-			if (group_ace->unix_ug.id == curr_utok->groups[i]) {
+			if (group_ace->unix_ug.gid == curr_utok->groups[i]) {
 				return True;
 			}
 		}
 	}
 
+	/* u_name talloc'ed off tos. */
+	u_name = uidtoname(uid_ace->unix_ug.uid);
+	if (!u_name) {
+		return False;
+	}
+
 	/*
-	 * user_in_group_sid() uses create_token_from_sid()
+	 * user_in_group_sid() uses create_token_from_username()
 	 * which creates an artificial NT token given just a username,
 	 * so this is not reliable for users from foreign domains
 	 * exported by winbindd!
 	 */
-	return user_sid_in_group_sid(&uid_ace->trustee, &group_ace->trustee);
+	return user_in_group_sid(u_name, &group_ace->trustee);
 }
 
 /****************************************************************************
- A well formed POSIX file or default ACL has at least 3 entries, a
+ A well formed POSIX file or default ACL has at least 3 entries, a 
  SMB_ACL_USER_OBJ, SMB_ACL_GROUP_OBJ, SMB_ACL_OTHER_OBJ.
  In addition, the owner must always have at least read access.
  When using this call on get_acl, the pst struct is valid and contains
- the mode of the file.
+ the mode of the file. When using this call on set_acl, the pst struct has
+ been modified to have a mode containing the default for this file or directory
+ type.
 ****************************************************************************/
 
-static bool ensure_canon_entry_valid_on_get(connection_struct *conn,
+static bool ensure_canon_entry_valid(connection_struct *conn,
 					canon_ace **pp_ace,
+					bool is_default_acl,
+					const struct share_params *params,
+					const bool is_directory,
 					const struct dom_sid *pfile_owner_sid,
 					const struct dom_sid *pfile_grp_sid,
-					const SMB_STRUCT_STAT *pst)
+					const SMB_STRUCT_STAT *pst,
+					bool setting_acl)
 {
 	canon_ace *pace;
-	bool got_user = false;
-	bool got_group = false;
-	bool got_other = false;
+	bool got_user = False;
+	bool got_grp = False;
+	bool got_other = False;
+	canon_ace *pace_other = NULL;
 
 	for (pace = *pp_ace; pace; pace = pace->next) {
 		if (pace->type == SMB_ACL_USER_OBJ) {
-			got_user = true;
-		} else if (pace->type == SMB_ACL_GROUP_OBJ) {
-			got_group = true;
-		} else if (pace->type == SMB_ACL_OTHER) {
-			got_other = true;
-		}
-	}
 
-	if (!got_user) {
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("malloc fail.\n"));
-			return false;
-		}
+			if (setting_acl) {
+				/*
+				 * Ensure we have default parameters for the
+				 * user (owner) even on default ACLs.
+				 */
+				apply_default_perms(params, is_directory, pace, S_IRUSR);
+			}
+			got_user = True;
 
-		ZERO_STRUCTP(pace);
-		pace->type = SMB_ACL_USER_OBJ;
-		pace->owner_type = UID_ACE;
-		pace->unix_ug.type = ID_TYPE_UID;
-		pace->unix_ug.id = pst->st_ex_uid;
-		pace->trustee = *pfile_owner_sid;
-		pace->attr = ALLOW_ACE;
-		pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IRUSR, S_IWUSR, S_IXUSR);
-		DLIST_ADD(*pp_ace, pace);
-	}
+		} else if (pace->type == SMB_ACL_GROUP_OBJ) {
 
-	if (!got_group) {
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("malloc fail.\n"));
-			return false;
-		}
+			/*
+			 * Ensure create mask/force create mode is respected on set.
+			 */
 
-		ZERO_STRUCTP(pace);
-		pace->type = SMB_ACL_GROUP_OBJ;
-		pace->owner_type = GID_ACE;
-		pace->unix_ug.type = ID_TYPE_GID;
-		pace->unix_ug.id = pst->st_ex_gid;
-		pace->trustee = *pfile_grp_sid;
-		pace->attr = ALLOW_ACE;
-		pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IRGRP, S_IWGRP, S_IXGRP);
-		DLIST_ADD(*pp_ace, pace);
-	}
+			if (setting_acl && !is_default_acl) {
+				apply_default_perms(params, is_directory, pace, S_IRGRP);
+			}
+			got_grp = True;
 
-	if (!got_other) {
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("malloc fail.\n"));
-			return false;
-		}
+		} else if (pace->type == SMB_ACL_OTHER) {
 
-		ZERO_STRUCTP(pace);
-		pace->type = SMB_ACL_OTHER;
-		pace->owner_type = WORLD_ACE;
-		pace->unix_ug.type = ID_TYPE_NOT_SPECIFIED;
-		pace->unix_ug.id = -1;
-		pace->trustee = global_sid_World;
-		pace->attr = ALLOW_ACE;
-		pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IROTH, S_IWOTH, S_IXOTH);
-		DLIST_ADD(*pp_ace, pace);
-	}
+			/*
+			 * Ensure create mask/force create mode is respected on set.
+			 */
 
-	return true;
-}
+			if (setting_acl && !is_default_acl) {
+				apply_default_perms(params, is_directory, pace, S_IROTH);
+			}
+			got_other = True;
+			pace_other = pace;
 
-/****************************************************************************
- A well formed POSIX file or default ACL has at least 3 entries, a
- SMB_ACL_USER_OBJ, SMB_ACL_GROUP_OBJ, SMB_ACL_OTHER_OBJ.
- In addition, the owner must always have at least read access.
- When using this call on set_acl, the pst struct has
- been modified to have a mode containing the default for this file or directory
- type.
-****************************************************************************/
+		} else if (pace->type == SMB_ACL_USER || pace->type == SMB_ACL_GROUP) {
 
-static bool ensure_canon_entry_valid_on_set(connection_struct *conn,
-					canon_ace **pp_ace,
-					bool is_default_acl,
-					const struct share_params *params,
-					const bool is_directory,
-					const struct dom_sid *pfile_owner_sid,
-					const struct dom_sid *pfile_grp_sid,
-					const SMB_STRUCT_STAT *pst)
-{
-	canon_ace *pace;
-	canon_ace *pace_user = NULL;
-	canon_ace *pace_group = NULL;
-	canon_ace *pace_other = NULL;
-	bool got_duplicate_user = false;
-	bool got_duplicate_group = false;
+			/*
+			 * Ensure create mask/force create mode is respected on set.
+			 */
 
-	for (pace = *pp_ace; pace; pace = pace->next) {
-		trim_ace_perms(pace);
-		if (pace->type == SMB_ACL_USER_OBJ) {
-			ensure_minimal_owner_ace_perms(is_directory, pace);
-			pace_user = pace;
-		} else if (pace->type == SMB_ACL_GROUP_OBJ) {
-			pace_group = pace;
-		} else if (pace->type == SMB_ACL_OTHER) {
-			pace_other = pace;
+			if (setting_acl && !is_default_acl) {
+				apply_default_perms(params, is_directory, pace, S_IRGRP);
+			}
 		}
 	}
 
-	if (!pace_user) {
-		canon_ace *pace_iter;
-
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("talloc fail.\n"));
-			return false;
+	if (!got_user) {
+		if ((pace = SMB_MALLOC_P(canon_ace)) == NULL) {
+			DEBUG(0,("ensure_canon_entry_valid: malloc fail.\n"));
+			return False;
 		}
 
 		ZERO_STRUCTP(pace);
 		pace->type = SMB_ACL_USER_OBJ;
 		pace->owner_type = UID_ACE;
-		pace->unix_ug.type = ID_TYPE_UID;
-		pace->unix_ug.id = pst->st_ex_uid;
+		pace->unix_ug.uid = pst->st_ex_uid;
 		pace->trustee = *pfile_owner_sid;
 		pace->attr = ALLOW_ACE;
-		/* Start with existing user permissions, principle of least
+		/* Start with existing permissions, principle of least
 		   surprises for the user. */
-		pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IRUSR, S_IWUSR, S_IXUSR);
-
-		/* See if the owning user is in any of the other groups in
-		   the ACE, or if there's a matching user entry (by uid
-		   or in the case of ID_TYPE_BOTH by SID).
-		   If so, OR in the permissions from that entry. */
+		pace->perms = pst->st_ex_mode;
 
-
-		for (pace_iter = *pp_ace; pace_iter; pace_iter = pace_iter->next) {
-			if (pace_iter->type == SMB_ACL_USER &&
-					pace_iter->unix_ug.id == pace->unix_ug.id) {
-				pace->perms |= pace_iter->perms;
-			} else if (pace_iter->type == SMB_ACL_GROUP_OBJ || pace_iter->type == SMB_ACL_GROUP) {
-				if (dom_sid_equal(&pace->trustee, &pace_iter->trustee)) {
-					pace->perms |= pace_iter->perms;
-				} else if (uid_entry_in_group(conn, pace, pace_iter)) {
+		if (setting_acl) {
+			/* See if the owning user is in any of the other groups in
+			   the ACE, or if there's a matching user entry.
+			   If so, OR in the permissions from that entry. */
+
+			canon_ace *pace_iter;
+
+			for (pace_iter = *pp_ace; pace_iter; pace_iter = pace_iter->next) {
+				if (pace_iter->type == SMB_ACL_USER &&
+						pace_iter->unix_ug.uid == pace->unix_ug.uid) {
 					pace->perms |= pace_iter->perms;
+				} else if (pace_iter->type == SMB_ACL_GROUP_OBJ || pace_iter->type == SMB_ACL_GROUP) {
+					if (uid_entry_in_group(conn, pace, pace_iter)) {
+						pace->perms |= pace_iter->perms;
+					}
 				}
 			}
-		}
 
-		if (pace->perms == 0) {
-			/* If we only got an "everyone" perm, just use that. */
-			if (pace_other)
-				pace->perms = pace_other->perms;
-		}
+			if (pace->perms == 0) {
+				/* If we only got an "everyone" perm, just use that. */
+				if (got_other)
+					pace->perms = pace_other->perms;
+			}
 
-		/*
-		 * Ensure we have default parameters for the
-		 * user (owner) even on default ACLs.
-		 */
-		ensure_minimal_owner_ace_perms(is_directory, pace);
+			/*
+			 * Ensure we have default parameters for the
+			 * user (owner) even on default ACLs.
+			 */
+			apply_default_perms(params, is_directory, pace, S_IRUSR);
+		} else {
+			pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IRUSR, S_IWUSR, S_IXUSR);
+		}
 
 		DLIST_ADD(*pp_ace, pace);
-		pace_user = pace;
 	}
 
-	if (!pace_group) {
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("talloc fail.\n"));
-			return false;
+	if (!got_grp) {
+		if ((pace = SMB_MALLOC_P(canon_ace)) == NULL) {
+			DEBUG(0,("ensure_canon_entry_valid: malloc fail.\n"));
+			return False;
 		}
 
 		ZERO_STRUCTP(pace);
 		pace->type = SMB_ACL_GROUP_OBJ;
 		pace->owner_type = GID_ACE;
-		pace->unix_ug.type = ID_TYPE_GID;
-		pace->unix_ug.id = pst->st_ex_gid;
+		pace->unix_ug.uid = pst->st_ex_gid;
 		pace->trustee = *pfile_grp_sid;
 		pace->attr = ALLOW_ACE;
-
-		/* If we only got an "everyone" perm, just use that. */
-		if (pace_other) {
-			pace->perms = pace_other->perms;
+		if (setting_acl) {
+			/* If we only got an "everyone" perm, just use that. */
+			if (got_other)
+				pace->perms = pace_other->perms;
+			else
+				pace->perms = 0;
+			if (!is_default_acl) {
+				apply_default_perms(params, is_directory, pace, S_IRGRP);
+			}
 		} else {
-			pace->perms = 0;
+			pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IRGRP, S_IWGRP, S_IXGRP);
 		}
 
 		DLIST_ADD(*pp_ace, pace);
-		pace_group = pace;
 	}
 
-	if (!pace_other) {
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("talloc fail.\n"));
-			return false;
+	if (!got_other) {
+		if ((pace = SMB_MALLOC_P(canon_ace)) == NULL) {
+			DEBUG(0,("ensure_canon_entry_valid: malloc fail.\n"));
+			return False;
 		}
 
 		ZERO_STRUCTP(pace);
 		pace->type = SMB_ACL_OTHER;
 		pace->owner_type = WORLD_ACE;
-		pace->unix_ug.type = ID_TYPE_NOT_SPECIFIED;
-		pace->unix_ug.id = -1;
+		pace->unix_ug.world = -1;
 		pace->trustee = global_sid_World;
 		pace->attr = ALLOW_ACE;
-		pace->perms = 0;
-
-		DLIST_ADD(*pp_ace, pace);
-		pace_other = pace;
-	}
-
-	/* Ensure when setting a POSIX ACL, that the uid for a
-	   SMB_ACL_USER_OBJ ACE (the owner ACE entry) has a duplicate
-	   permission entry as an SMB_ACL_USER, and a gid for a
-	   SMB_ACL_GROUP_OBJ ACE (the primary group ACE entry) also has
-	   a duplicate permission entry as an SMB_ACL_GROUP. If not,
-	   then if the ownership or group ownership of this file or
-	   directory gets changed, the user or group can lose their
-	   access. */
-
-	for (pace = *pp_ace; pace; pace = pace->next) {
-		if (pace->type == SMB_ACL_USER &&
-				pace->unix_ug.id == pace_user->unix_ug.id) {
-			/* Already got one. */
-			got_duplicate_user = true;
-		} else if (pace->type == SMB_ACL_GROUP &&
-				pace->unix_ug.id == pace_group->unix_ug.id) {
-			/* Already got one. */
-			got_duplicate_group = true;
-		} else if ((pace->type == SMB_ACL_GROUP)
-			   && (dom_sid_equal(&pace->trustee, &pace_user->trustee))) {
-			/* If the SID owning the file appears
-			 * in a group entry, then we have
-			 * enough duplication, they will still
-			 * have access */
-			got_duplicate_user = true;
-		}
-	}
-
-	/* If the SID is equal for the user and group that we need
-	   to add the duplicate for, add only the group */
-	if (!got_duplicate_user && !got_duplicate_group
-			&& dom_sid_equal(&pace_group->trustee,
-					&pace_user->trustee)) {
-		/* Add a duplicate SMB_ACL_GROUP entry, this
-		 * will cover the owning SID as well, as it
-		 * will always be mapped to both a uid and
-		 * gid. */
-
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("talloc fail.\n"));
-			return false;
-		}
-
-		ZERO_STRUCTP(pace);
-		pace->type = SMB_ACL_GROUP;;
-		pace->owner_type = GID_ACE;
-		pace->unix_ug.type = ID_TYPE_GID;
-		pace->unix_ug.id = pace_group->unix_ug.id;
-		pace->trustee = pace_group->trustee;
-		pace->attr = pace_group->attr;
-		pace->perms = pace_group->perms;
-
-		DLIST_ADD(*pp_ace, pace);
-
-		/* We're done here, make sure the
-		   statements below are not executed. */
-		got_duplicate_user = true;
-		got_duplicate_group = true;
-	}
-
-	if (!got_duplicate_user) {
-		/* Add a duplicate SMB_ACL_USER entry. */
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("talloc fail.\n"));
-			return false;
-		}
-
-		ZERO_STRUCTP(pace);
-		pace->type = SMB_ACL_USER;;
-		pace->owner_type = UID_ACE;
-		pace->unix_ug.type = ID_TYPE_UID;
-		pace->unix_ug.id = pace_user->unix_ug.id;
-		pace->trustee = pace_user->trustee;
-		pace->attr = pace_user->attr;
-		pace->perms = pace_user->perms;
-
-		DLIST_ADD(*pp_ace, pace);
-
-		got_duplicate_user = true;
-	}
-
-	if (!got_duplicate_group) {
-		/* Add a duplicate SMB_ACL_GROUP entry. */
-		if ((pace = talloc(talloc_tos(), canon_ace)) == NULL) {
-			DEBUG(0,("talloc fail.\n"));
-			return false;
-		}
-
-		ZERO_STRUCTP(pace);
-		pace->type = SMB_ACL_GROUP;;
-		pace->owner_type = GID_ACE;
-		pace->unix_ug.type = ID_TYPE_GID;
-		pace->unix_ug.id = pace_group->unix_ug.id;
-		pace->trustee = pace_group->trustee;
-		pace->attr = pace_group->attr;
-		pace->perms = pace_group->perms;
+		if (setting_acl) {
+			pace->perms = 0;
+			if (!is_default_acl) {
+				apply_default_perms(params, is_directory, pace, S_IROTH);
+			}
+		} else
+			pace->perms = unix_perms_to_acl_perms(pst->st_ex_mode, S_IROTH, S_IWOTH, S_IXOTH);
 
 		DLIST_ADD(*pp_ace, pace);
-
-		got_duplicate_group = true;
 	}
 
-	return true;
+	return True;
 }
 
 /****************************************************************************
@@ -1660,181 +1568,6 @@
 		DEBUG(10,("check_owning_objs: ACL is missing an owning group entry.\n"));
 }
 
-static bool add_current_ace_to_acl(files_struct *fsp, struct security_ace *psa,
-				   canon_ace **file_ace, canon_ace **dir_ace,
-				   bool *got_file_allow, bool *got_dir_allow,
-				   bool *all_aces_are_inherit_only,
-				   canon_ace *current_ace)
-{
-
-	/*
-	 * Map the given NT permissions into a UNIX mode_t containing only
-	 * S_I(R|W|X)USR bits.
-	 */
-
-	current_ace->perms |= map_nt_perms( &psa->access_mask, S_IRUSR);
-	current_ace->attr = (psa->type == SEC_ACE_TYPE_ACCESS_ALLOWED) ? ALLOW_ACE : DENY_ACE;
-
-	/* Store the ace_flag. */
-	current_ace->ace_flags = psa->flags;
-
-	/*
-	 * Now add the created ace to either the file list, the directory
-	 * list, or both. We *MUST* preserve the order here (hence we use
-	 * DLIST_ADD_END) as NT ACLs are order dependent.
-	 */
-
-	if (fsp->is_directory) {
-
-		/*
-		 * We can only add to the default POSIX ACE list if the ACE is
-		 * designed to be inherited by both files and directories.
-		 */
-
-		if ((psa->flags & (SEC_ACE_FLAG_OBJECT_INHERIT|SEC_ACE_FLAG_CONTAINER_INHERIT)) ==
-		    (SEC_ACE_FLAG_OBJECT_INHERIT|SEC_ACE_FLAG_CONTAINER_INHERIT)) {
-
-			canon_ace *current_dir_ace = current_ace;
-			DLIST_ADD_END(*dir_ace, current_ace, canon_ace *);
-
-			/*
-			 * Note if this was an allow ace. We can't process
-			 * any further deny ace's after this.
-			 */
-
-			if (current_ace->attr == ALLOW_ACE)
-				*got_dir_allow = True;
-
-			if ((current_ace->attr == DENY_ACE) && *got_dir_allow) {
-				DEBUG(0,("add_current_ace_to_acl: "
-					 "malformed ACL in "
-					 "inheritable ACL! Deny entry "
-					 "after Allow entry. Failing "
-					 "to set on file %s.\n",
-					 fsp_str_dbg(fsp)));
-				return False;
-			}
-
-			if( DEBUGLVL( 10 )) {
-				dbgtext("add_current_ace_to_acl: adding dir ACL:\n");
-				print_canon_ace( current_ace, 0);
-			}
-
-			/*
-			 * If this is not an inherit only ACE we need to add a duplicate
-			 * to the file acl.
-			 */
-
-			if (!(psa->flags & SEC_ACE_FLAG_INHERIT_ONLY)) {
-				canon_ace *dup_ace = dup_canon_ace(current_ace);
-
-				if (!dup_ace) {
-					DEBUG(0,("add_current_ace_to_acl: malloc fail !\n"));
-					return False;
-				}
-
-				/*
-				 * We must not free current_ace here as its
-				 * pointer is now owned by the dir_ace list.
-				 */
-				current_ace = dup_ace;
-				/* We've essentially split this ace into two,
-				 * and added the ace with inheritance request
-				 * bits to the directory ACL. Drop those bits for
-				 * the ACE we're adding to the file list. */
-				current_ace->ace_flags &= ~(SEC_ACE_FLAG_OBJECT_INHERIT|
-							    SEC_ACE_FLAG_CONTAINER_INHERIT|
-							    SEC_ACE_FLAG_INHERIT_ONLY);
-			} else {
-				/*
-				 * We must not free current_ace here as its
-				 * pointer is now owned by the dir_ace list.
-				 */
-				current_ace = NULL;
-			}
-
-			/*
-			 * current_ace is now either owned by file_ace
-			 * or is NULL. We can safely operate on current_dir_ace
-			 * to treat mapping for default acl entries differently
-			 * than access acl entries.
-			 */
-
-			if (current_dir_ace->owner_type == UID_ACE) {
-				/*
-				 * We already decided above this is a uid,
-				 * for default acls ace's only CREATOR_OWNER
-				 * maps to ACL_USER_OBJ. All other uid
-				 * ace's are ACL_USER.
-				 */
-				if (dom_sid_equal(&current_dir_ace->trustee,
-						  &global_sid_Creator_Owner)) {
-					current_dir_ace->type = SMB_ACL_USER_OBJ;
-				} else {
-					current_dir_ace->type = SMB_ACL_USER;
-				}
-			}
-
-			if (current_dir_ace->owner_type == GID_ACE) {
-				/*
-				 * We already decided above this is a gid,
-				 * for default acls ace's only CREATOR_GROUP
-				 * maps to ACL_GROUP_OBJ. All other uid
-				 * ace's are ACL_GROUP.
-				 */
-				if (dom_sid_equal(&current_dir_ace->trustee,
-						  &global_sid_Creator_Group)) {
-					current_dir_ace->type = SMB_ACL_GROUP_OBJ;
-				} else {
-					current_dir_ace->type = SMB_ACL_GROUP;
-				}
-			}
-		}
-	}
-
-	/*
-	 * Only add to the file ACL if not inherit only.
-	 */
-
-	if (current_ace && !(psa->flags & SEC_ACE_FLAG_INHERIT_ONLY)) {
-		DLIST_ADD_END(*file_ace, current_ace, canon_ace *);
-
-		/*
-		 * Note if this was an allow ace. We can't process
-		 * any further deny ace's after this.
-		 */
-
-		if (current_ace->attr == ALLOW_ACE)
-			*got_file_allow = True;
-
-		if ((current_ace->attr == DENY_ACE) && *got_file_allow) {
-			DEBUG(0,("add_current_ace_to_acl: malformed "
-				 "ACL in file ACL ! Deny entry after "
-				 "Allow entry. Failing to set on file "
-				 "%s.\n", fsp_str_dbg(fsp)));
-			return False;
-		}
-
-		if( DEBUGLVL( 10 )) {
-			dbgtext("add_current_ace_to_acl: adding file ACL:\n");
-			print_canon_ace( current_ace, 0);
-		}
-		*all_aces_are_inherit_only = False;
-		/*
-		 * We must not free current_ace here as its
-		 * pointer is now owned by the file_ace list.
-		 */
-		current_ace = NULL;
-	}
-
-	/*
-	 * Free if ACE was not added.
-	 */
-
-	TALLOC_FREE(current_ace);
-	return true;
-}
-
 /****************************************************************************
  Unpack a struct security_descriptor into two canonical ace lists.
 ****************************************************************************/
@@ -1869,6 +1602,26 @@
 			DEBUG(3,("create_canon_ace_lists: unable to set anything but an ALLOW or DENY ACE.\n"));
 			return False;
 		}
+
+		if (nt4_compatible_acls()) {
+			/*
+			 * The security mask may be UNIX_ACCESS_NONE which should map into
+			 * no permissions (we overload the WRITE_OWNER bit for this) or it
+			 * should be one of the ALL/EXECUTE/READ/WRITE bits. Arrange for this
+			 * to be so. Any other bits override the UNIX_ACCESS_NONE bit.
+			 */
+
+			/*
+			 * Convert GENERIC bits to specific bits.
+			 */
+ 
+			se_map_generic(&psa->access_mask, &file_generic_mapping);
+
+			psa->access_mask &= (UNIX_ACCESS_NONE|FILE_ALL_ACCESS);
+
+			if(psa->access_mask != UNIX_ACCESS_NONE)
+				psa->access_mask &= ~UNIX_ACCESS_NONE;
+		}
 	}
 
 	/*
@@ -1917,7 +1670,7 @@
 		 * Create a canon_ace entry representing this NT DACL ACE.
 		 */
 
-		if ((current_ace = talloc(talloc_tos(), canon_ace)) == NULL) {
+		if ((current_ace = SMB_MALLOC_P(canon_ace)) == NULL) {
 			free_canon_ace_list(file_ace);
 			free_canon_ace_list(dir_ace);
 			DEBUG(0,("create_canon_ace_lists: malloc fail.\n"));
@@ -1936,13 +1689,11 @@
 
 		if( dom_sid_equal(&current_ace->trustee, &global_sid_World)) {
 			current_ace->owner_type = WORLD_ACE;
-			current_ace->unix_ug.type = ID_TYPE_NOT_SPECIFIED;
-			current_ace->unix_ug.id = -1;
+			current_ace->unix_ug.world = -1;
 			current_ace->type = SMB_ACL_OTHER;
 		} else if (dom_sid_equal(&current_ace->trustee, &global_sid_Creator_Owner)) {
 			current_ace->owner_type = UID_ACE;
-			current_ace->unix_ug.type = ID_TYPE_UID;
-			current_ace->unix_ug.id = pst->st_ex_uid;
+			current_ace->unix_ug.uid = pst->st_ex_uid;
 			current_ace->type = SMB_ACL_USER_OBJ;
 
 			/*
@@ -1955,8 +1706,7 @@
 
 		} else if (dom_sid_equal(&current_ace->trustee, &global_sid_Creator_Group)) {
 			current_ace->owner_type = GID_ACE;
-			current_ace->unix_ug.type = ID_TYPE_GID;
-			current_ace->unix_ug.id = pst->st_ex_gid;
+			current_ace->unix_ug.gid = pst->st_ex_gid;
 			current_ace->type = SMB_ACL_GROUP_OBJ;
 
 			/*
@@ -1966,138 +1716,225 @@
 			 */
 			psa->flags |= SEC_ACE_FLAG_INHERIT_ONLY;
 
+		} else if (sid_to_uid( &current_ace->trustee, &current_ace->unix_ug.uid)) {
+			current_ace->owner_type = UID_ACE;
+			/* If it's the owning user, this is a user_obj, not
+			 * a user. */
+			if (current_ace->unix_ug.uid == pst->st_ex_uid) {
+				current_ace->type = SMB_ACL_USER_OBJ;
+			} else {
+				current_ace->type = SMB_ACL_USER;
+			}
+		} else if (sid_to_gid( &current_ace->trustee, &current_ace->unix_ug.gid)) {
+			current_ace->owner_type = GID_ACE;
+			/* If it's the primary group, this is a group_obj, not
+			 * a group. */
+			if (current_ace->unix_ug.gid == pst->st_ex_gid) {
+				current_ace->type = SMB_ACL_GROUP_OBJ;
+			} else {
+				current_ace->type = SMB_ACL_GROUP;
+			}
 		} else {
-			struct unixid unixid;
+			/*
+			 * Silently ignore map failures in non-mappable SIDs (NT Authority, BUILTIN etc).
+			 */
 
-			if (!sids_to_unixids(&current_ace->trustee, 1, &unixid)) {
-				free_canon_ace_list(file_ace);
-				free_canon_ace_list(dir_ace);
-				TALLOC_FREE(current_ace);
-				DEBUG(0, ("create_canon_ace_lists: sids_to_unixids "
-					"failed for %s (allocation failure)\n",
-					sid_string_dbg(&current_ace->trustee)));
-				return false;
+			if (non_mappable_sid(&psa->trustee)) {
+				DEBUG(10, ("create_canon_ace_lists: ignoring "
+					   "non-mappable SID %s\n",
+					   sid_string_dbg(&psa->trustee)));
+				SAFE_FREE(current_ace);
+				continue;
 			}
 
-			if (unixid.type == ID_TYPE_BOTH) {
+			if (lp_force_unknown_acl_user(SNUM(fsp->conn))) {
+				DEBUG(10, ("create_canon_ace_lists: ignoring "
+					"unknown or foreign SID %s\n",
+					sid_string_dbg(&psa->trustee)));
+				SAFE_FREE(current_ace);
+				continue;
+			}
+
+			free_canon_ace_list(file_ace);
+			free_canon_ace_list(dir_ace);
+			DEBUG(0, ("create_canon_ace_lists: unable to map SID "
+				  "%s to uid or gid.\n",
+				  sid_string_dbg(&current_ace->trustee)));
+			SAFE_FREE(current_ace);
+			return False;
+		}
+
+		/*
+		 * Map the given NT permissions into a UNIX mode_t containing only
+		 * S_I(R|W|X)USR bits.
+		 */
+
+		current_ace->perms |= map_nt_perms( &psa->access_mask, S_IRUSR);
+		current_ace->attr = (psa->type == SEC_ACE_TYPE_ACCESS_ALLOWED) ? ALLOW_ACE : DENY_ACE;
+
+		/* Store the ace_flag. */
+		current_ace->ace_flags = psa->flags;
+
+		/*
+		 * Now add the created ace to either the file list, the directory
+		 * list, or both. We *MUST* preserve the order here (hence we use
+		 * DLIST_ADD_END) as NT ACLs are order dependent.
+		 */
+
+		if (fsp->is_directory) {
+
+			/*
+			 * We can only add to the default POSIX ACE list if the ACE is
+			 * designed to be inherited by both files and directories.
+			 */
+
+			if ((psa->flags & (SEC_ACE_FLAG_OBJECT_INHERIT|SEC_ACE_FLAG_CONTAINER_INHERIT)) ==
+				(SEC_ACE_FLAG_OBJECT_INHERIT|SEC_ACE_FLAG_CONTAINER_INHERIT)) {
+
+				canon_ace *current_dir_ace = current_ace;
+				DLIST_ADD_END(dir_ace, current_ace, canon_ace *);
+
 				/*
-				 * We must add both a user and group
-				 * entry POSIX_ACL.
-				 * This is due to the fact that in POSIX
-				 * user entries are more specific than
-				 * groups.
+				 * Note if this was an allow ace. We can't process
+				 * any further deny ace's after this.
 				 */
-				current_ace->owner_type = UID_ACE;
-				current_ace->unix_ug.type = ID_TYPE_UID;
-				current_ace->unix_ug.id = unixid.id;
-				current_ace->type =
-					(unixid.id == pst->st_ex_uid) ?
-						SMB_ACL_USER_OBJ :
-						SMB_ACL_USER;
-
-				/* Add the user object to the posix ACL,
-				   and proceed to the group mapping
-				   below. This handles the talloc_free
-				   of current_ace if not added for some
-				   reason */
-				if (!add_current_ace_to_acl(fsp,
-						psa,
-						&file_ace,
-						&dir_ace,
-						&got_file_allow,
-						&got_dir_allow,
-						&all_aces_are_inherit_only,
-						current_ace)) {
-					free_canon_ace_list(file_ace);
-					free_canon_ace_list(dir_ace);
-					return false;
-				}
 
-				if ((current_ace = talloc(talloc_tos(),
-						canon_ace)) == NULL) {
+				if (current_ace->attr == ALLOW_ACE)
+					got_dir_allow = True;
+
+				if ((current_ace->attr == DENY_ACE) && got_dir_allow) {
+					DEBUG(0,("create_canon_ace_lists: "
+						 "malformed ACL in "
+						 "inheritable ACL! Deny entry "
+						 "after Allow entry. Failing "
+						 "to set on file %s.\n",
+						 fsp_str_dbg(fsp)));
 					free_canon_ace_list(file_ace);
 					free_canon_ace_list(dir_ace);
-					DEBUG(0,("create_canon_ace_lists: "
-						"malloc fail.\n"));
 					return False;
+				}	
+
+				if( DEBUGLVL( 10 )) {
+					dbgtext("create_canon_ace_lists: adding dir ACL:\n");
+					print_canon_ace( current_ace, 0);
 				}
 
-				ZERO_STRUCTP(current_ace);
+				/*
+				 * If this is not an inherit only ACE we need to add a duplicate
+				 * to the file acl.
+				 */
 
-				sid_copy(&current_ace->trustee, &psa->trustee);
+				if (!(psa->flags & SEC_ACE_FLAG_INHERIT_ONLY)) {
+					canon_ace *dup_ace = dup_canon_ace(current_ace);
 
-				current_ace->unix_ug.type = ID_TYPE_GID;
-				current_ace->unix_ug.id = unixid.id;
-				current_ace->owner_type = GID_ACE;
-				/* If it's the primary group, this is a
-				   group_obj, not a group. */
-				if (current_ace->unix_ug.id == pst->st_ex_gid) {
-					current_ace->type = SMB_ACL_GROUP_OBJ;
-				} else {
-					current_ace->type = SMB_ACL_GROUP;
-				}
+					if (!dup_ace) {
+						DEBUG(0,("create_canon_ace_lists: malloc fail !\n"));
+						free_canon_ace_list(file_ace);
+						free_canon_ace_list(dir_ace);
+						return False;
+					}
 
-			} else if (unixid.type == ID_TYPE_UID) {
-				current_ace->owner_type = UID_ACE;
-				current_ace->unix_ug.type = ID_TYPE_UID;
-				current_ace->unix_ug.id = unixid.id;
-				/* If it's the owning user, this is a user_obj,
-				   not a user. */
-				if (current_ace->unix_ug.id == pst->st_ex_uid) {
-					current_ace->type = SMB_ACL_USER_OBJ;
-				} else {
-					current_ace->type = SMB_ACL_USER;
-				}
-			} else if (unixid.type == ID_TYPE_GID) {
-				current_ace->unix_ug.type = ID_TYPE_GID;
-				current_ace->unix_ug.id = unixid.id;
-				current_ace->owner_type = GID_ACE;
-				/* If it's the primary group, this is a
-				   group_obj, not a group. */
-				if (current_ace->unix_ug.id == pst->st_ex_gid) {
-					current_ace->type = SMB_ACL_GROUP_OBJ;
+					/*
+					 * We must not free current_ace here as its
+					 * pointer is now owned by the dir_ace list.
+					 */
+					current_ace = dup_ace;
+					/* We've essentially split this ace into two,
+					 * and added the ace with inheritance request
+					 * bits to the directory ACL. Drop those bits for
+					 * the ACE we're adding to the file list. */
+					current_ace->ace_flags &= ~(SEC_ACE_FLAG_OBJECT_INHERIT|
+								SEC_ACE_FLAG_CONTAINER_INHERIT|
+								SEC_ACE_FLAG_INHERIT_ONLY);
 				} else {
-					current_ace->type = SMB_ACL_GROUP;
+					/*
+					 * We must not free current_ace here as its
+					 * pointer is now owned by the dir_ace list.
+					 */
+					current_ace = NULL;
 				}
-			} else {
+
 				/*
-				 * Silently ignore map failures in non-mappable SIDs (NT Authority, BUILTIN etc).
+				 * current_ace is now either owned by file_ace
+				 * or is NULL. We can safely operate on current_dir_ace
+				 * to treat mapping for default acl entries differently
+				 * than access acl entries.
 				 */
 
-				if (non_mappable_sid(&psa->trustee)) {
-					DEBUG(10, ("create_canon_ace_lists: ignoring "
-						   "non-mappable SID %s\n",
-						   sid_string_dbg(&psa->trustee)));
-					TALLOC_FREE(current_ace);
-					continue;
+				if (current_dir_ace->owner_type == UID_ACE) {
+					/*
+					 * We already decided above this is a uid,
+					 * for default acls ace's only CREATOR_OWNER
+					 * maps to ACL_USER_OBJ. All other uid
+					 * ace's are ACL_USER.
+					 */
+					if (dom_sid_equal(&current_dir_ace->trustee,
+							&global_sid_Creator_Owner)) {
+						current_dir_ace->type = SMB_ACL_USER_OBJ;
+					} else {
+						current_dir_ace->type = SMB_ACL_USER;
+					}
 				}
 
-				if (lp_force_unknown_acl_user(SNUM(fsp->conn))) {
-					DEBUG(10, ("create_canon_ace_lists: ignoring "
-						"unknown or foreign SID %s\n",
-						sid_string_dbg(&psa->trustee)));
-					TALLOC_FREE(current_ace);
-					continue;
+				if (current_dir_ace->owner_type == GID_ACE) {
+					/*
+					 * We already decided above this is a gid,
+					 * for default acls ace's only CREATOR_GROUP
+					 * maps to ACL_GROUP_OBJ. All other uid
+					 * ace's are ACL_GROUP.
+					 */
+					if (dom_sid_equal(&current_dir_ace->trustee,
+							&global_sid_Creator_Group)) {
+						current_dir_ace->type = SMB_ACL_GROUP_OBJ;
+					} else {
+						current_dir_ace->type = SMB_ACL_GROUP;
+					}
 				}
+			}
+		}
+
+		/*
+		 * Only add to the file ACL if not inherit only.
+		 */
+
+		if (current_ace && !(psa->flags & SEC_ACE_FLAG_INHERIT_ONLY)) {
+			DLIST_ADD_END(file_ace, current_ace, canon_ace *);
 
+			/*
+			 * Note if this was an allow ace. We can't process
+			 * any further deny ace's after this.
+			 */
+
+			if (current_ace->attr == ALLOW_ACE)
+				got_file_allow = True;
+
+			if ((current_ace->attr == DENY_ACE) && got_file_allow) {
+				DEBUG(0,("create_canon_ace_lists: malformed "
+					 "ACL in file ACL ! Deny entry after "
+					 "Allow entry. Failing to set on file "
+					 "%s.\n", fsp_str_dbg(fsp)));
 				free_canon_ace_list(file_ace);
 				free_canon_ace_list(dir_ace);
-				DEBUG(0, ("create_canon_ace_lists: unable to map SID "
-					  "%s to uid or gid.\n",
-					  sid_string_dbg(&current_ace->trustee)));
-				TALLOC_FREE(current_ace);
-				return false;
+				return False;
+			}	
+
+			if( DEBUGLVL( 10 )) {
+				dbgtext("create_canon_ace_lists: adding file ACL:\n");
+				print_canon_ace( current_ace, 0);
 			}
+			all_aces_are_inherit_only = False;
+			/*
+			 * We must not free current_ace here as its
+			 * pointer is now owned by the file_ace list.
+			 */
+			current_ace = NULL;
 		}
 
-		/* handles the talloc_free of current_ace if not added for some reason */
-		if (!add_current_ace_to_acl(fsp, psa, &file_ace, &dir_ace,
-					    &got_file_allow, &got_dir_allow,
-					    &all_aces_are_inherit_only, current_ace)) {
-			free_canon_ace_list(file_ace);
-			free_canon_ace_list(dir_ace);
-			return false;
-		}
+		/*
+		 * Free if ACE was not added.
+		 */
+
+		SAFE_FREE(current_ace);
 	}
 
 	if (fsp->is_directory && all_aces_are_inherit_only) {
@@ -2118,7 +1955,7 @@
 		 * the file ACL. If we don't have them, check if any SMB_ACL_USER/SMB_ACL_GROUP
 		 * entries can be converted to *_OBJ. Don't do this for the default
 		 * ACL, we will create them separately for this if needed inside
-		 * ensure_canon_entry_valid_on_set().
+		 * ensure_canon_entry_valid().
 		 */
 		if (file_ace) {
 			check_owning_objs(file_ace, pfile_owner_sid, pfile_grp_sid);
@@ -2520,8 +2357,8 @@
 
 	print_canon_ace_list( "file ace - before valid", file_ace);
 
-	if (!ensure_canon_entry_valid_on_set(fsp->conn, &file_ace, false, fsp->conn->params,
-			fsp->is_directory, pfile_owner_sid, pfile_grp_sid, pst)) {
+	if (!ensure_canon_entry_valid(fsp->conn, &file_ace, false, fsp->conn->params,
+			fsp->is_directory, pfile_owner_sid, pfile_grp_sid, pst, True)) {
 		free_canon_ace_list(file_ace);
 		free_canon_ace_list(dir_ace);
 		return False;
@@ -2529,8 +2366,8 @@
 
 	print_canon_ace_list( "dir ace - before valid", dir_ace);
 
-	if (dir_ace && !ensure_canon_entry_valid_on_set(fsp->conn, &dir_ace, true, fsp->conn->params,
-			fsp->is_directory, pfile_owner_sid, pfile_grp_sid, pst)) {
+	if (dir_ace && !ensure_canon_entry_valid(fsp->conn, &dir_ace, true, fsp->conn->params,
+			fsp->is_directory, pfile_owner_sid, pfile_grp_sid, pst, True)) {
 		free_canon_ace_list(file_ace);
 		free_canon_ace_list(dir_ace);
 		return False;
@@ -2622,20 +2459,20 @@
 	SMB_ACL_ENTRY_T entry;
 	size_t ace_count;
 
-	while ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {
+	while ( posix_acl && (SMB_VFS_SYS_ACL_GET_ENTRY(conn, posix_acl, entry_id, &entry) == 1)) {
 		SMB_ACL_TAG_T tagtype;
 		SMB_ACL_PERMSET_T permset;
 		struct dom_sid sid;
-		struct unixid unix_ug;
+		posix_id unix_ug;
 		enum ace_owner owner_type;
 
 		entry_id = SMB_ACL_NEXT_ENTRY;
 
 		/* Is this a MASK entry ? */
-		if (sys_acl_get_tag_type(entry, &tagtype) == -1)
+		if (SMB_VFS_SYS_ACL_GET_TAG_TYPE(conn, entry, &tagtype) == -1)
 			continue;
 
-		if (sys_acl_get_permset(entry, &permset) == -1)
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, entry, &permset) == -1)
 			continue;
 
 		/* Decide which SID to use based on the ACL type. */
@@ -2643,51 +2480,48 @@
 			case SMB_ACL_USER_OBJ:
 				/* Get the SID from the owner. */
 				sid_copy(&sid, powner);
-				unix_ug.type = ID_TYPE_UID;
-				unix_ug.id = psbuf->st_ex_uid;
+				unix_ug.uid = psbuf->st_ex_uid;
 				owner_type = UID_ACE;
 				break;
 			case SMB_ACL_USER:
 				{
-					uid_t *puid = (uid_t *)sys_acl_get_qualifier(entry);
+					uid_t *puid = (uid_t *)SMB_VFS_SYS_ACL_GET_QUALIFIER(conn, entry);
 					if (puid == NULL) {
 						DEBUG(0,("canonicalise_acl: Failed to get uid.\n"));
 						continue;
 					}
 					uid_to_sid( &sid, *puid);
-					unix_ug.type = ID_TYPE_UID;
-					unix_ug.id = *puid;
+					unix_ug.uid = *puid;
 					owner_type = UID_ACE;
+					SMB_VFS_SYS_ACL_FREE_QUALIFIER(conn, (void *)puid,tagtype);
 					break;
 				}
 			case SMB_ACL_GROUP_OBJ:
 				/* Get the SID from the owning group. */
 				sid_copy(&sid, pgroup);
-				unix_ug.type = ID_TYPE_GID;
-				unix_ug.id = psbuf->st_ex_gid;
+				unix_ug.gid = psbuf->st_ex_gid;
 				owner_type = GID_ACE;
 				break;
 			case SMB_ACL_GROUP:
 				{
-					gid_t *pgid = (gid_t *)sys_acl_get_qualifier(entry);
+					gid_t *pgid = (gid_t *)SMB_VFS_SYS_ACL_GET_QUALIFIER(conn, entry);
 					if (pgid == NULL) {
 						DEBUG(0,("canonicalise_acl: Failed to get gid.\n"));
 						continue;
 					}
 					gid_to_sid( &sid, *pgid);
-					unix_ug.type = ID_TYPE_GID;
-					unix_ug.id = *pgid;
+					unix_ug.gid = *pgid;
 					owner_type = GID_ACE;
+					SMB_VFS_SYS_ACL_FREE_QUALIFIER(conn, (void *)pgid,tagtype);
 					break;
 				}
 			case SMB_ACL_MASK:
-				acl_mask = convert_permset_to_mode_t(permset);
+				acl_mask = convert_permset_to_mode_t(conn, permset);
 				continue; /* Don't count the mask as an entry. */
 			case SMB_ACL_OTHER:
 				/* Use the Everyone SID */
 				sid = global_sid_World;
-				unix_ug.type = ID_TYPE_NOT_SPECIFIED;
-				unix_ug.id = -1;
+				unix_ug.world = -1;
 				owner_type = WORLD_ACE;
 				break;
 			default:
@@ -2699,12 +2533,12 @@
 		 * Add this entry to the list.
 		 */
 
-		if ((ace = talloc(talloc_tos(), canon_ace)) == NULL)
+		if ((ace = SMB_MALLOC_P(canon_ace)) == NULL)
 			goto fail;
 
 		ZERO_STRUCTP(ace);
 		ace->type = tagtype;
-		ace->perms = convert_permset_to_mode_t(permset);
+		ace->perms = convert_permset_to_mode_t(conn, permset);
 		ace->attr = ALLOW_ACE;
 		ace->trustee = sid;
 		ace->unix_ug = unix_ug;
@@ -2718,9 +2552,9 @@
 	 * This next call will ensure we have at least a user/group/world set.
 	 */
 
-	if (!ensure_canon_entry_valid_on_get(conn, &l_head,
-				      powner, pgroup,
-				      psbuf))
+	if (!ensure_canon_entry_valid(conn, &l_head, is_default_acl, conn->params,
+				      S_ISDIR(psbuf->st_ex_mode), powner, pgroup,
+				      psbuf, False))
 		goto fail;
 
 	/*
@@ -2814,7 +2648,7 @@
 {
 	connection_struct *conn = fsp->conn;
 	bool ret = False;
-	SMB_ACL_T the_acl = sys_acl_init(talloc_tos());
+	SMB_ACL_T the_acl = SMB_VFS_SYS_ACL_INIT(conn, (int)count_canon_ace_list(the_ace) + 1);
 	canon_ace *p_ace;
 	int i;
 	SMB_ACL_ENTRY_T mask_entry;
@@ -2835,8 +2669,17 @@
 #endif
 
 	if (the_acl == NULL) {
-		DEBUG(0, ("sys_acl_init failed to allocate an ACL\n"));
-		return false;
+
+		if (!no_acl_syscall_error(errno)) {
+			/*
+			 * Only print this error message if we have some kind of ACL
+			 * support that's not working. Otherwise we would always get this.
+			 */
+			DEBUG(0,("set_canon_ace_list: Unable to init %s ACL. (%s)\n",
+				default_ace ? "default" : "file", strerror(errno) ));
+		}
+		*pacl_set_support = False;
+		goto fail;
 	}
 
 	if( DEBUGLVL( 10 )) {
@@ -2868,7 +2711,7 @@
 		 * Get the entry for this ACE.
 		 */
 
-		if (sys_acl_create_entry(&the_acl, &the_entry) == -1) {
+		if (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &the_entry) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to create entry %d. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
@@ -2894,7 +2737,7 @@
 		 * First tell the entry what type of ACE this is.
 		 */
 
-		if (sys_acl_set_tag_type(the_entry, p_ace->type) == -1) {
+		if (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, the_entry, p_ace->type) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to set tag type on entry %d. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
@@ -2906,7 +2749,7 @@
 		 */
 
 		if ((p_ace->type == SMB_ACL_USER) || (p_ace->type == SMB_ACL_GROUP)) {
-			if (sys_acl_set_qualifier(the_entry,(void *)&p_ace->unix_ug.id) == -1) {
+			if (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&p_ace->unix_ug.uid) == -1) {
 				DEBUG(0,("set_canon_ace_list: Failed to set qualifier on entry %d. (%s)\n",
 					i, strerror(errno) ));
 				goto fail;
@@ -2917,7 +2760,7 @@
 		 * Convert the mode_t perms in the canon_ace to a POSIX permset.
 		 */
 
-		if (sys_acl_get_permset(the_entry, &the_permset) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, the_entry, &the_permset) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to get permset on entry %d. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
@@ -2933,7 +2776,7 @@
 		 * ..and apply them to the entry.
 		 */
 
-		if (sys_acl_set_permset(the_entry, the_permset) == -1) {
+		if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, the_entry, the_permset) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to add permset on entry %d. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
@@ -2945,17 +2788,17 @@
 	}
 
 	if (needs_mask && !got_mask_entry) {
-		if (sys_acl_create_entry(&the_acl, &mask_entry) == -1) {
+		if (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &mask_entry) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to create mask entry. (%s)\n", strerror(errno) ));
 			goto fail;
 		}
 
-		if (sys_acl_set_tag_type(mask_entry, SMB_ACL_MASK) == -1) {
+		if (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, mask_entry, SMB_ACL_MASK) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to set tag type on mask entry. (%s)\n",strerror(errno) ));
 			goto fail;
 		}
 
-		if (sys_acl_get_permset(mask_entry, &mask_permset) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, mask_entry, &mask_permset) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to get mask permset. (%s)\n", strerror(errno) ));
 			goto fail;
 		}
@@ -2965,7 +2808,7 @@
 			goto fail;
 		}
 
-		if (sys_acl_set_permset(mask_entry, mask_permset) == -1) {
+		if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, mask_entry, mask_permset) == -1) {
 			DEBUG(0,("set_canon_ace_list: Failed to add mask permset. (%s)\n", strerror(errno) ));
 			goto fail;
 		}
@@ -3055,13 +2898,29 @@
   fail:
 
 	if (the_acl != NULL) {
-		TALLOC_FREE(the_acl);
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);
 	}
 
 	return ret;
 }
 
 /****************************************************************************
+ Find a particular canon_ace entry.
+****************************************************************************/
+
+static struct canon_ace *canon_ace_entry_for(struct canon_ace *list, SMB_ACL_TAG_T type, posix_id *id)
+{
+	while (list) {
+		if (list->type == type && ((type != SMB_ACL_USER && type != SMB_ACL_GROUP) ||
+				(type == SMB_ACL_USER  && id && id->uid == list->unix_ug.uid) ||
+				(type == SMB_ACL_GROUP && id && id->gid == list->unix_ug.gid)))
+			break;
+		list = list->next;
+	}
+	return list;
+}
+
+/****************************************************************************
  
 ****************************************************************************/
 
@@ -3071,8 +2930,8 @@
 
 	if (!the_acl)
 		return NULL;
-	if (sys_acl_get_entry(the_acl, SMB_ACL_FIRST_ENTRY, &entry) != 1) {
-		TALLOC_FREE(the_acl);
+	if (SMB_VFS_SYS_ACL_GET_ENTRY(conn, the_acl, SMB_ACL_FIRST_ENTRY, &entry) != 1) {
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);
 		return NULL;
 	}
 	return the_acl;
@@ -3086,11 +2945,14 @@
 
 static bool convert_canon_ace_to_posix_perms( files_struct *fsp, canon_ace *file_ace_list, mode_t *posix_perms)
 {
+	int snum = SNUM(fsp->conn);
 	size_t ace_count = count_canon_ace_list(file_ace_list);
 	canon_ace *ace_p;
 	canon_ace *owner_ace = NULL;
 	canon_ace *group_ace = NULL;
 	canon_ace *other_ace = NULL;
+	mode_t and_bits;
+	mode_t or_bits;
 
 	if (ace_count != 3) {
 		DEBUG(3,("convert_canon_ace_to_posix_perms: Too many ACE "
@@ -3130,6 +2992,20 @@
 	if (fsp->is_directory)
 		*posix_perms |= (S_IWUSR|S_IXUSR);
 
+	/* If requested apply the masks. */
+
+	/* Get the initial bits to apply. */
+
+	if (fsp->is_directory) {
+		and_bits = lp_dir_security_mask(snum);
+		or_bits = lp_force_dir_security_mode(snum);
+	} else {
+		and_bits = lp_security_mask(snum);
+		or_bits = lp_force_security_mode(snum);
+	}
+
+	*posix_perms = (((*posix_perms) & and_bits)|or_bits);
+
 	DEBUG(10,("convert_canon_ace_to_posix_perms: converted u=%o,g=%o,w=%o "
 		  "to perm=0%o for file %s.\n", (int)owner_ace->perms,
 		  (int)group_ace->perms, (int)other_ace->perms,
@@ -3255,7 +3131,6 @@
 				      SMB_ACL_T posix_acl,
 				      SMB_ACL_T def_acl,
 				      uint32_t security_info,
-				      TALLOC_CTX *mem_ctx,
 				      struct security_descriptor **ppdesc)
 {
 	struct dom_sid owner_sid;
@@ -3287,7 +3162,7 @@
 		num_profile_acls = 3;
 	}
 
-	if (security_info & SECINFO_DACL) {
+	if ((security_info & SECINFO_DACL) && !(security_info & SECINFO_PROTECTED_DACL)) {
 
 		/*
 		 * In the optimum case Creator Owner and Creator Group would be used for
@@ -3326,11 +3201,60 @@
 			canon_ace *ace;
 			enum security_ace_type nt_acl_type;
 
+			if (nt4_compatible_acls() && dir_ace) {
+				/*
+				 * NT 4 chokes if an ACL contains an INHERIT_ONLY entry
+				 * but no non-INHERIT_ONLY entry for one SID. So we only
+				 * remove entries from the Access ACL if the
+				 * corresponding Default ACL entries have also been
+				 * removed. ACEs for CREATOR-OWNER and CREATOR-GROUP
+				 * are exceptions. We can do nothing
+				 * intelligent if the Default ACL contains entries that
+				 * are not also contained in the Access ACL, so this
+				 * case will still fail under NT 4.
+				 */
+
+				ace = canon_ace_entry_for(dir_ace, SMB_ACL_OTHER, NULL);
+				if (ace && !ace->perms) {
+					DLIST_REMOVE(dir_ace, ace);
+					SAFE_FREE(ace);
+
+					ace = canon_ace_entry_for(file_ace, SMB_ACL_OTHER, NULL);
+					if (ace && !ace->perms) {
+						DLIST_REMOVE(file_ace, ace);
+						SAFE_FREE(ace);
+					}
+				}
+
+				/*
+				 * WinNT doesn't usually have Creator Group
+				 * in browse lists, so we send this entry to
+				 * WinNT even if it contains no relevant
+				 * permissions. Once we can add
+				 * Creator Group to browse lists we can
+				 * re-enable this.
+				 */
+
+#if 0
+				ace = canon_ace_entry_for(dir_ace, SMB_ACL_GROUP_OBJ, NULL);
+				if (ace && !ace->perms) {
+					DLIST_REMOVE(dir_ace, ace);
+					SAFE_FREE(ace);
+				}
+#endif
+
+				ace = canon_ace_entry_for(file_ace, SMB_ACL_GROUP_OBJ, NULL);
+				if (ace && !ace->perms) {
+					DLIST_REMOVE(file_ace, ace);
+					SAFE_FREE(ace);
+				}
+			}
+
 			num_acls = count_canon_ace_list(file_ace);
 			num_def_acls = count_canon_ace_list(dir_ace);
 
 			/* Allocate the ace list. */
-			if ((nt_ace_list = talloc_array(talloc_tos(), struct security_ace,num_acls + num_profile_acls + num_def_acls)) == NULL) {
+			if ((nt_ace_list = SMB_MALLOC_ARRAY(struct security_ace,num_acls + num_profile_acls + num_def_acls)) == NULL) {
 				DEBUG(0,("get_nt_acl: Unable to malloc space for nt_ace_list.\n"));
 				goto done;
 			}
@@ -3419,7 +3343,7 @@
 		}
 	} /* security_info & SECINFO_DACL */
 
-	psd = make_standard_sec_desc(mem_ctx,
+	psd = make_standard_sec_desc( talloc_tos(),
 			(security_info & SECINFO_OWNER) ? &owner_sid : NULL,
 			(security_info & SECINFO_GROUP) ? &group_sid : NULL,
 			psa,
@@ -3456,28 +3380,25 @@
  done:
 
 	if (posix_acl) {
-		TALLOC_FREE(posix_acl);
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, posix_acl);
 	}
 	if (def_acl) {
-		TALLOC_FREE(def_acl);
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 	}
 	free_canon_ace_list(file_ace);
 	free_canon_ace_list(dir_ace);
 	free_inherited_info(pal);
-	TALLOC_FREE(nt_ace_list);
+	SAFE_FREE(nt_ace_list);
 
 	return NT_STATUS_OK;
 }
 
 NTSTATUS posix_fget_nt_acl(struct files_struct *fsp, uint32_t security_info,
-			   TALLOC_CTX *mem_ctx,
 			   struct security_descriptor **ppdesc)
 {
 	SMB_STRUCT_STAT sbuf;
 	SMB_ACL_T posix_acl = NULL;
 	struct pai_val *pal;
-	TALLOC_CTX *frame = talloc_stackframe();
-	NTSTATUS status;
 
 	*ppdesc = NULL;
 
@@ -3486,42 +3407,33 @@
 
 	/* can it happen that fsp_name == NULL ? */
 	if (fsp->is_directory ||  fsp->fh->fd == -1) {
-		status = posix_get_nt_acl(fsp->conn, fsp->fsp_name->base_name,
-					  security_info, mem_ctx, ppdesc);
-		TALLOC_FREE(frame);
-		return status;
+		return posix_get_nt_acl(fsp->conn, fsp->fsp_name->base_name,
+					security_info, ppdesc);
 	}
 
 	/* Get the stat struct for the owner info. */
 	if(SMB_VFS_FSTAT(fsp, &sbuf) != 0) {
-		TALLOC_FREE(frame);
 		return map_nt_error_from_unix(errno);
 	}
 
 	/* Get the ACL from the fd. */
-	posix_acl = SMB_VFS_SYS_ACL_GET_FD(fsp, frame);
+	posix_acl = SMB_VFS_SYS_ACL_GET_FD(fsp);
 
 	pal = fload_inherited_info(fsp);
 
-	status = posix_get_nt_acl_common(fsp->conn, fsp->fsp_name->base_name,
-					 &sbuf, pal, posix_acl, NULL,
-					 security_info, mem_ctx, ppdesc);
-	TALLOC_FREE(frame);
-	return status;
+	return posix_get_nt_acl_common(fsp->conn, fsp->fsp_name->base_name,
+				       &sbuf, pal, posix_acl, NULL,
+				       security_info, ppdesc);
 }
 
 NTSTATUS posix_get_nt_acl(struct connection_struct *conn, const char *name,
-			  uint32_t security_info,
-			  TALLOC_CTX *mem_ctx,
-			  struct security_descriptor **ppdesc)
+			  uint32_t security_info, struct security_descriptor **ppdesc)
 {
 	SMB_ACL_T posix_acl = NULL;
 	SMB_ACL_T def_acl = NULL;
 	struct pai_val *pal;
 	struct smb_filename smb_fname;
 	int ret;
-	TALLOC_CTX *frame = talloc_stackframe();
-	NTSTATUS status;
 
 	*ppdesc = NULL;
 
@@ -3538,29 +3450,23 @@
 	}
 
 	if (ret == -1) {
-		TALLOC_FREE(frame);
 		return map_nt_error_from_unix(errno);
 	}
 
 	/* Get the ACL from the path. */
-	posix_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, name,
-					     SMB_ACL_TYPE_ACCESS, frame);
+	posix_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, name, SMB_ACL_TYPE_ACCESS);
 
 	/* If it's a directory get the default POSIX ACL. */
 	if(S_ISDIR(smb_fname.st.st_ex_mode)) {
-		def_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, name,
-						   SMB_ACL_TYPE_DEFAULT, frame);
+		def_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, name, SMB_ACL_TYPE_DEFAULT);
 		def_acl = free_empty_sys_acl(conn, def_acl);
 	}
 
 	pal = load_inherited_info(conn, name);
 
-	status = posix_get_nt_acl_common(conn, name, &smb_fname.st, pal,
-					 posix_acl, def_acl, security_info,
-					 mem_ctx,
-					 ppdesc);
-	TALLOC_FREE(frame);
-	return status;
+	return posix_get_nt_acl_common(conn, name, &smb_fname.st, pal,
+				       posix_acl, def_acl, security_info,
+				       ppdesc);
 }
 
 /****************************************************************************
@@ -3721,7 +3627,7 @@
 
 	num_aces += parent_sd->dacl->num_aces;
 
-	if((new_ace = talloc_zero_array(mem_ctx, struct security_ace,
+	if((new_ace = TALLOC_ZERO_ARRAY(mem_ctx, struct security_ace,
 					num_aces)) == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -4189,34 +4095,33 @@
 	SMB_ACL_T posix_acl;
 	int result = -1;
 
-	posix_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, fname,
-					     SMB_ACL_TYPE_ACCESS, talloc_tos());
+	posix_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, fname, SMB_ACL_TYPE_ACCESS);
 	if (posix_acl == (SMB_ACL_T)NULL)
 		return -1;
 
-	while (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1) {
+	while (SMB_VFS_SYS_ACL_GET_ENTRY(conn, posix_acl, entry_id, &entry) == 1) {
 		SMB_ACL_TAG_T tagtype;
 		SMB_ACL_PERMSET_T permset;
 
 		entry_id = SMB_ACL_NEXT_ENTRY;
 
-		if (sys_acl_get_tag_type(entry, &tagtype) ==-1)
+		if (SMB_VFS_SYS_ACL_GET_TAG_TYPE(conn, entry, &tagtype) ==-1)
 			break;
 
 		if (tagtype == SMB_ACL_GROUP_OBJ) {
-			if (sys_acl_get_permset(entry, &permset) == -1) {
+			if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, entry, &permset) == -1) {
 				break;
 			} else {
 				*mode &= ~(S_IRGRP|S_IWGRP|S_IXGRP);
-				*mode |= (sys_acl_get_perm(permset, SMB_ACL_READ) ? S_IRGRP : 0);
-				*mode |= (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? S_IWGRP : 0);
-				*mode |= (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? S_IXGRP : 0);
+				*mode |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_READ) ? S_IRGRP : 0);
+				*mode |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_WRITE) ? S_IWGRP : 0);
+				*mode |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_EXECUTE) ? S_IXGRP : 0);
 				result = 0;
 				break;
 			}
 		}
 	}
-	TALLOC_FREE(posix_acl);
+	SMB_VFS_SYS_ACL_FREE_ACL(conn, posix_acl);
 	return result;
 }
 
@@ -4231,17 +4136,17 @@
 	SMB_ACL_ENTRY_T entry;
 	int num_entries = 0;
 
-	while ( sys_acl_get_entry(posix_acl, entry_id, &entry) == 1) {
+	while ( SMB_VFS_SYS_ACL_GET_ENTRY(conn, posix_acl, entry_id, &entry) == 1) {
 		SMB_ACL_TAG_T tagtype;
 		SMB_ACL_PERMSET_T permset;
 		mode_t perms;
 
 		entry_id = SMB_ACL_NEXT_ENTRY;
 
-		if (sys_acl_get_tag_type(entry, &tagtype) == -1)
+		if (SMB_VFS_SYS_ACL_GET_TAG_TYPE(conn, entry, &tagtype) == -1)
 			return -1;
 
-		if (sys_acl_get_permset(entry, &permset) == -1)
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, entry, &permset) == -1)
 			return -1;
 
 		num_entries++;
@@ -4272,7 +4177,7 @@
 		if (map_acl_perms_to_permset(conn, perms, &permset) == -1)
 			return -1;
 
-		if (sys_acl_set_permset(entry, permset) == -1)
+		if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, entry, permset) == -1)
 			return -1;
 	}
 
@@ -4298,9 +4203,7 @@
 	SMB_ACL_T posix_acl = NULL;
 	int ret = -1;
 
-	if ((posix_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, from,
-						  SMB_ACL_TYPE_ACCESS,
-						  talloc_tos())) == NULL)
+	if ((posix_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, from, SMB_ACL_TYPE_ACCESS)) == NULL)
 		return -1;
 
 	if ((ret = chmod_acl_internals(conn, posix_acl, mode)) == -1)
@@ -4310,7 +4213,7 @@
 
  done:
 
-	TALLOC_FREE(posix_acl);
+	SMB_VFS_SYS_ACL_FREE_ACL(conn, posix_acl);
 	return ret;
 }
 
@@ -4331,18 +4234,16 @@
 
 static bool directory_has_default_posix_acl(connection_struct *conn, const char *fname)
 {
-	SMB_ACL_T def_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, fname,
-						     SMB_ACL_TYPE_DEFAULT,
-						     talloc_tos());
+	SMB_ACL_T def_acl = SMB_VFS_SYS_ACL_GET_FILE( conn, fname, SMB_ACL_TYPE_DEFAULT);
 	bool has_acl = False;
 	SMB_ACL_ENTRY_T entry;
 
-	if (def_acl != NULL && (sys_acl_get_entry(def_acl, SMB_ACL_FIRST_ENTRY, &entry) == 1)) {
+	if (def_acl != NULL && (SMB_VFS_SYS_ACL_GET_ENTRY(conn, def_acl, SMB_ACL_FIRST_ENTRY, &entry) == 1)) {
 		has_acl = True;
 	}
 
 	if (def_acl) {
-	        TALLOC_FREE(def_acl);
+	        SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 	}
         return has_acl;
 }
@@ -4372,7 +4273,7 @@
 	SMB_ACL_T posix_acl = NULL;
 	int ret = -1;
 
-	if ((posix_acl = SMB_VFS_SYS_ACL_GET_FD(fsp, talloc_tos())) == NULL)
+	if ((posix_acl = SMB_VFS_SYS_ACL_GET_FD(fsp)) == NULL)
 		return -1;
 
 	if ((ret = chmod_acl_internals(conn, posix_acl, mode)) == -1)
@@ -4382,7 +4283,7 @@
 
   done:
 
-	TALLOC_FREE(posix_acl);
+	SMB_VFS_SYS_ACL_FREE_ACL(conn, posix_acl);
 	return ret;
 }
 
@@ -4396,22 +4297,22 @@
 		return False;
 	}
 
-	if (sys_acl_clear_perms(*p_permset) ==  -1) {
+	if (SMB_VFS_SYS_ACL_CLEAR_PERMS(conn, *p_permset) ==  -1) {
 		return False;
 	}
 
 	if (wire_perm & SMB_POSIX_ACL_READ) {
-		if (sys_acl_add_perm(*p_permset, SMB_ACL_READ) == -1) {
+		if (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_READ) == -1) {
 			return False;
 		}
 	}
 	if (wire_perm & SMB_POSIX_ACL_WRITE) {
-		if (sys_acl_add_perm(*p_permset, SMB_ACL_WRITE) == -1) {
+		if (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_WRITE) == -1) {
 			return False;
 		}
 	}
 	if (wire_perm & SMB_POSIX_ACL_EXECUTE) {
-		if (sys_acl_add_perm(*p_permset, SMB_ACL_EXECUTE) == -1) {
+		if (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_EXECUTE) == -1) {
 			return False;
 		}
 	}
@@ -4454,13 +4355,10 @@
  FIXME ! How does the share mask/mode fit into this.... ?
 ****************************************************************************/
 
-static SMB_ACL_T create_posix_acl_from_wire(connection_struct *conn,
-					    uint16 num_acls,
-					    const char *pdata,
-					    TALLOC_CTX *mem_ctx)
+static SMB_ACL_T create_posix_acl_from_wire(connection_struct *conn, uint16 num_acls, const char *pdata)
 {
 	unsigned int i;
-	SMB_ACL_T the_acl = sys_acl_init(mem_ctx);
+	SMB_ACL_T the_acl = SMB_VFS_SYS_ACL_INIT(conn, num_acls);
 
 	if (the_acl == NULL) {
 		return NULL;
@@ -4471,7 +4369,7 @@
 		SMB_ACL_PERMSET_T the_permset;
 		SMB_ACL_TAG_T tag_type;
 
-		if (sys_acl_create_entry(&the_acl, &the_entry) == -1) {
+		if (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &the_entry) == -1) {
 			DEBUG(0,("create_posix_acl_from_wire: Failed to create entry %u. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
@@ -4483,14 +4381,14 @@
 			goto fail;
 		}
 
-		if (sys_acl_set_tag_type(the_entry, tag_type) == -1) {
+		if (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, the_entry, tag_type) == -1) {
 			DEBUG(0,("create_posix_acl_from_wire: Failed to set tagtype on entry %u. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
 		}
 
 		/* Get the permset pointer from the new ACL entry. */
-		if (sys_acl_get_permset(the_entry, &the_permset) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, the_entry, &the_permset) == -1) {
 			DEBUG(0,("create_posix_acl_from_wire: Failed to get permset on entry %u. (%s)\n",
                                 i, strerror(errno) ));
                         goto fail;
@@ -4504,7 +4402,7 @@
 		}
 
 		/* Now apply to the new ACL entry. */
-		if (sys_acl_set_permset(the_entry, the_permset) == -1) {
+		if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, the_entry, the_permset) == -1) {
 			DEBUG(0,("create_posix_acl_from_wire: Failed to add permset on entry %u. (%s)\n",
 				i, strerror(errno) ));
 			goto fail;
@@ -4513,7 +4411,7 @@
 		if (tag_type == SMB_ACL_USER) {
 			uint32 uidval = IVAL(pdata,(i*SMB_POSIX_ACL_ENTRY_SIZE)+2);
 			uid_t uid = (uid_t)uidval;
-			if (sys_acl_set_qualifier(the_entry,(void *)&uid) == -1) {
+			if (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&uid) == -1) {
 				DEBUG(0,("create_posix_acl_from_wire: Failed to set uid %u on entry %u. (%s)\n",
 					(unsigned int)uid, i, strerror(errno) ));
 				goto fail;
@@ -4523,7 +4421,7 @@
 		if (tag_type == SMB_ACL_GROUP) {
 			uint32 gidval = IVAL(pdata,(i*SMB_POSIX_ACL_ENTRY_SIZE)+2);
 			gid_t gid = (uid_t)gidval;
-			if (sys_acl_set_qualifier(the_entry,(void *)&gid) == -1) {
+			if (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&gid) == -1) {
 				DEBUG(0,("create_posix_acl_from_wire: Failed to set gid %u on entry %u. (%s)\n",
 					(unsigned int)gid, i, strerror(errno) ));
 				goto fail;
@@ -4536,7 +4434,7 @@
  fail:
 
 	if (the_acl != NULL) {
-		TALLOC_FREE(the_acl);
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);
 	}
 	return NULL;
 }
@@ -4573,21 +4471,19 @@
 		return True;
 	}
 
-	if ((def_acl = create_posix_acl_from_wire(conn, num_def_acls,
-						  pdata,
-						  talloc_tos())) == NULL) {
+	if ((def_acl = create_posix_acl_from_wire(conn, num_def_acls, pdata)) == NULL) {
 		return False;
 	}
 
 	if (SMB_VFS_SYS_ACL_SET_FILE(conn, fname, SMB_ACL_TYPE_DEFAULT, def_acl) == -1) {
 		DEBUG(5,("set_unix_posix_default_acl: acl_set_file failed on directory %s (%s)\n",
 			fname, strerror(errno) ));
-	        TALLOC_FREE(def_acl);
+	        SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 		return False;
 	}
 
 	DEBUG(10,("set_unix_posix_default_acl: set default acl for file %s\n", fname ));
-	TALLOC_FREE(def_acl);
+	SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 	return True;
 }
 
@@ -4606,7 +4502,7 @@
 	SMB_ACL_ENTRY_T entry;
 	bool ret = False;
 	/* Create a new ACL with only 3 entries, u/g/w. */
-	SMB_ACL_T new_file_acl = sys_acl_init(talloc_tos());
+	SMB_ACL_T new_file_acl = SMB_VFS_SYS_ACL_INIT(conn, 3);
 	SMB_ACL_ENTRY_T user_ent = NULL;
 	SMB_ACL_ENTRY_T group_ent = NULL;
 	SMB_ACL_ENTRY_T other_ent = NULL;
@@ -4617,34 +4513,34 @@
 	}
 
 	/* Now create the u/g/w entries. */
-	if (sys_acl_create_entry(&new_file_acl, &user_ent) == -1) {
+	if (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &new_file_acl, &user_ent) == -1) {
 		DEBUG(5,("remove_posix_acl: Failed to create user entry for file %s. (%s)\n",
 			fname, strerror(errno) ));
 		goto done;
 	}
-	if (sys_acl_set_tag_type(user_ent, SMB_ACL_USER_OBJ) == -1) {
+	if (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, user_ent, SMB_ACL_USER_OBJ) == -1) {
 		DEBUG(5,("remove_posix_acl: Failed to set user entry for file %s. (%s)\n",
 			fname, strerror(errno) ));
 		goto done;
 	}
 
-	if (sys_acl_create_entry(&new_file_acl, &group_ent) == -1) {
+	if (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &new_file_acl, &group_ent) == -1) {
 		DEBUG(5,("remove_posix_acl: Failed to create group entry for file %s. (%s)\n",
 			fname, strerror(errno) ));
 		goto done;
 	}
-	if (sys_acl_set_tag_type(group_ent, SMB_ACL_GROUP_OBJ) == -1) {
+	if (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, group_ent, SMB_ACL_GROUP_OBJ) == -1) {
 		DEBUG(5,("remove_posix_acl: Failed to set group entry for file %s. (%s)\n",
 			fname, strerror(errno) ));
 		goto done;
 	}
 
-	if (sys_acl_create_entry(&new_file_acl, &other_ent) == -1) {
+	if (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &new_file_acl, &other_ent) == -1) {
 		DEBUG(5,("remove_posix_acl: Failed to create other entry for file %s. (%s)\n",
 			fname, strerror(errno) ));
 		goto done;
 	}
-	if (sys_acl_set_tag_type(other_ent, SMB_ACL_OTHER) == -1) {
+	if (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, other_ent, SMB_ACL_OTHER) == -1) {
 		DEBUG(5,("remove_posix_acl: Failed to set other entry for file %s. (%s)\n",
 			fname, strerror(errno) ));
 		goto done;
@@ -4652,11 +4548,9 @@
 
 	/* Get the current file ACL. */
 	if (fsp && fsp->fh->fd != -1) {
-		file_acl = SMB_VFS_SYS_ACL_GET_FD(fsp, talloc_tos());
+		file_acl = SMB_VFS_SYS_ACL_GET_FD(fsp);
 	} else {
-		file_acl = SMB_VFS_SYS_ACL_GET_FILE(conn, fname,
-						    SMB_ACL_TYPE_ACCESS,
-						    talloc_tos());
+		file_acl = SMB_VFS_SYS_ACL_GET_FILE( conn, fname, SMB_ACL_TYPE_ACCESS);
 	}
 
 	if (file_acl == NULL) {
@@ -4667,36 +4561,36 @@
 		goto done;
 	}
 
-	while ( sys_acl_get_entry(file_acl, entry_id, &entry) == 1) {
+	while ( SMB_VFS_SYS_ACL_GET_ENTRY(conn, file_acl, entry_id, &entry) == 1) {
 		SMB_ACL_TAG_T tagtype;
 		SMB_ACL_PERMSET_T permset;
 
 		entry_id = SMB_ACL_NEXT_ENTRY;
 
-		if (sys_acl_get_tag_type(entry, &tagtype) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_TAG_TYPE(conn, entry, &tagtype) == -1) {
 			DEBUG(5,("remove_posix_acl: failed to get tagtype from ACL on file %s (%s).\n",
 				fname, strerror(errno) ));
 			goto done;
 		}
 
-		if (sys_acl_get_permset(entry, &permset) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, entry, &permset) == -1) {
 			DEBUG(5,("remove_posix_acl: failed to get permset from ACL on file %s (%s).\n",
 				fname, strerror(errno) ));
 			goto done;
 		}
 
 		if (tagtype == SMB_ACL_USER_OBJ) {
-			if (sys_acl_set_permset(user_ent, permset) == -1) {
+			if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, user_ent, permset) == -1) {
 				DEBUG(5,("remove_posix_acl: failed to set permset from ACL on file %s (%s).\n",
 					fname, strerror(errno) ));
 			}
 		} else if (tagtype == SMB_ACL_GROUP_OBJ) {
-			if (sys_acl_set_permset(group_ent, permset) == -1) {
+			if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, group_ent, permset) == -1) {
 				DEBUG(5,("remove_posix_acl: failed to set permset from ACL on file %s (%s).\n",
 					fname, strerror(errno) ));
 			}
 		} else if (tagtype == SMB_ACL_OTHER) {
-			if (sys_acl_set_permset(other_ent, permset) == -1) {
+			if (SMB_VFS_SYS_ACL_SET_PERMSET(conn, other_ent, permset) == -1) {
 				DEBUG(5,("remove_posix_acl: failed to set permset from ACL on file %s (%s).\n",
 					fname, strerror(errno) ));
 			}
@@ -4723,10 +4617,10 @@
  done:
 
 	if (file_acl) {
-		TALLOC_FREE(file_acl);
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 	}
 	if (new_file_acl) {
-		TALLOC_FREE(new_file_acl);
+		SMB_VFS_SYS_ACL_FREE_ACL(conn, new_file_acl);
 	}
 	return ret;
 }
@@ -4746,9 +4640,7 @@
 		return remove_posix_acl(conn, fsp, fname);
 	}
 
-	if ((file_acl = create_posix_acl_from_wire(conn, num_acls,
-						   pdata,
-						   talloc_tos())) == NULL) {
+	if ((file_acl = create_posix_acl_from_wire(conn, num_acls, pdata)) == NULL) {
 		return False;
 	}
 
@@ -4757,20 +4649,20 @@
 		if (SMB_VFS_SYS_ACL_SET_FD(fsp, file_acl) == -1) {
 			DEBUG(5,("set_unix_posix_acl: acl_set_file failed on %s (%s)\n",
 				fname, strerror(errno) ));
-		        TALLOC_FREE(file_acl);
+		        SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 			return False;
 		}
 	} else {
 		if (SMB_VFS_SYS_ACL_SET_FILE(conn, fname, SMB_ACL_TYPE_ACCESS, file_acl) == -1) {
 			DEBUG(5,("set_unix_posix_acl: acl_set_file failed on %s (%s)\n",
 				fname, strerror(errno) ));
-		        TALLOC_FREE(file_acl);
+		        SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 			return False;
 		}
 	}
 
 	DEBUG(10,("set_unix_posix_acl: set acl for file %s\n", fname ));
-	TALLOC_FREE(file_acl);
+	SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 	return True;
 }
 
@@ -4784,24 +4676,23 @@
  Assume we are dealing with files (for now)
 ********************************************************************/
 
-struct security_descriptor *get_nt_acl_no_snum( TALLOC_CTX *ctx, const char *fname, uint32 security_info_wanted)
+struct security_descriptor *get_nt_acl_no_snum( TALLOC_CTX *ctx, const char *fname)
 {
-	struct security_descriptor *ret_sd;
+	struct security_descriptor *psd, *ret_sd;
 	connection_struct *conn;
 	files_struct finfo;
 	struct fd_handle fh;
 	NTSTATUS status;
-	TALLOC_CTX *frame = talloc_stackframe();
 
-	conn = talloc_zero(frame, connection_struct);
+	conn = TALLOC_ZERO_P(ctx, connection_struct);
 	if (conn == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		return NULL;
 	}
 
-	if (!(conn->params = talloc(conn, struct share_params))) {
+	if (!(conn->params = TALLOC_P(conn, struct share_params))) {
 		DEBUG(0,("get_nt_acl_no_snum: talloc() failed!\n"));
-		TALLOC_FREE(frame);
+		TALLOC_FREE(conn);
 		return NULL;
 	}
 
@@ -4812,39 +4703,35 @@
 	if (!smbd_vfs_init(conn)) {
 		DEBUG(0,("get_nt_acl_no_snum: Unable to create a fake connection struct!\n"));
 		conn_free(conn);
-		TALLOC_FREE(frame);
 		return NULL;
         }
 
 	ZERO_STRUCT( finfo );
 	ZERO_STRUCT( fh );
 
-	finfo.fnum = FNUM_FIELD_INVALID;
+	finfo.fnum = -1;
 	finfo.conn = conn;
 	finfo.fh = &fh;
 	finfo.fh->fd = -1;
 
-	status = create_synthetic_smb_fname(frame, fname, NULL, NULL,
+	status = create_synthetic_smb_fname(talloc_tos(), fname, NULL, NULL,
 					    &finfo.fsp_name);
 	if (!NT_STATUS_IS_OK(status)) {
 		conn_free(conn);
-		TALLOC_FREE(frame);
 		return NULL;
 	}
 
-	if (!NT_STATUS_IS_OK(SMB_VFS_FGET_NT_ACL( &finfo,
-						  security_info_wanted,
-						  ctx, &ret_sd))) {
+	if (!NT_STATUS_IS_OK(SMB_VFS_FGET_NT_ACL( &finfo, SECINFO_DACL, &psd))) {
 		DEBUG(0,("get_nt_acl_no_snum: get_nt_acl returned zero.\n"));
 		TALLOC_FREE(finfo.fsp_name);
 		conn_free(conn);
-		TALLOC_FREE(frame);
 		return NULL;
 	}
 
+	ret_sd = dup_sec_desc( ctx, psd );
+
 	TALLOC_FREE(finfo.fsp_name);
 	conn_free(conn);
-	TALLOC_FREE(frame);
 
 	return ret_sd;
 }
Only in ../../samba-3.6.24/source3/smbd: posix_acls.o
diff -ur smbd/process.c ../../samba-3.6.24/source3/smbd/process.c
--- smbd/process.c	2014-12-08 15:46:38.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/process.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,7 +27,7 @@
 #include "../lib/async_req/async_sock.h"
 #include "ctdbd_conn.h"
 #include "../lib/util/select.h"
-#include "printing/queue_process.h"
+#include "printing/pcap.h"
 #include "system/select.h"
 #include "passdb.h"
 #include "auth.h"
@@ -35,31 +35,12 @@
 #include "smbprofile.h"
 #include "rpc_server/spoolss/srv_spoolss_nt.h"
 #include "libsmb/libsmb.h"
-#include "../lib/util/tevent_ntstatus.h"
-#include "../libcli/security/dom_sid.h"
-#include "../libcli/security/security_token.h"
-#include "lib/id_cache.h"
-#include "serverid.h"
-
-/* Internal message queue for deferred opens. */
-struct pending_message_list {
-	struct pending_message_list *next, *prev;
-	struct timeval request_time; /* When was this first issued? */
-	struct smbd_server_connection *sconn;
-	struct timed_event *te;
-	struct smb_perfcount_data pcd;
-	uint32_t seqnum;
-	bool encrypted;
-	bool processed;
-	DATA_BLOB buf;
-	DATA_BLOB private_data;
-};
+
+extern bool global_machine_password_needs_changing;
 
 static void construct_reply_common(struct smb_request *req, const char *inbuf,
 				   char *outbuf);
-static struct pending_message_list *get_deferred_open_message_smb(
-	struct smbd_server_connection *sconn, uint64_t mid);
-static bool smb_splice_chain(uint8_t **poutbuf, const uint8_t *andx_buf);
+static struct pending_message_list *get_deferred_open_message_smb(uint64_t mid);
 
 static bool smbd_lock_socket_internal(struct smbd_server_connection *sconn)
 {
@@ -75,12 +56,12 @@
 		return true;
 	}
 
-	DEBUG(10,("pid[%d] wait for socket lock\n", (int)getpid()));
+	DEBUG(10,("pid[%d] wait for socket lock\n", (int)sys_getpid()));
 
 	do {
 		ok = fcntl_lock(
 			sconn->smb1.echo_handler.socket_lock_fd,
-			F_SETLKW, 0, 0, F_WRLCK);
+			SMB_F_SETLKW, 0, 0, F_WRLCK);
 	} while (!ok && (errno == EINTR));
 
 	if (!ok) {
@@ -88,7 +69,7 @@
 		return false;
 	}
 
-	DEBUG(10,("pid[%d] got for socket lock\n", (int)getpid()));
+	DEBUG(10,("pid[%d] got for socket lock\n", (int)sys_getpid()));
 
 	return true;
 }
@@ -117,7 +98,7 @@
 	do {
 		ok = fcntl_lock(
 			sconn->smb1.echo_handler.socket_lock_fd,
-			F_SETLKW, 0, 0, F_UNLCK);
+			SMB_F_SETLKW, 0, 0, F_UNLCK);
 	} while (!ok && (errno == EINTR));
 
 	if (!ok) {
@@ -125,7 +106,7 @@
 		return false;
 	}
 
-	DEBUG(10,("pid[%d] unlocked socket\n", (int)getpid()));
+	DEBUG(10,("pid[%d] unlocked socket\n", (int)sys_getpid()));
 
 	return true;
 }
@@ -153,13 +134,6 @@
 	ssize_t ret;
 	char *buf_out = buffer;
 
-	if (!NT_STATUS_IS_OK(sconn->status)) {
-		/*
-		 * we're not supposed to do any io
-		 */
-		return true;
-	}
-
 	smbd_lock_socket(sconn);
 
 	if (do_signing) {
@@ -168,7 +142,7 @@
 	}
 
 	if (do_encrypt) {
-		NTSTATUS status = srv_encrypt_buffer(sconn, buffer, &buf_out);
+		NTSTATUS status = srv_encrypt_buffer(buffer, &buf_out);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(0, ("send_smb: SMB encryption failed "
 				"on outgoing packet! Error %s\n",
@@ -188,21 +162,21 @@
 		 * client failed.
 		 */
 		DEBUG(1,("pid[%d] Error writing %d bytes to client %s. %d. (%s)\n",
-			 (int)getpid(), (int)len,
+			 (int)sys_getpid(), (int)len,
 			 get_peer_addr(sconn->sock, addr, sizeof(addr)),
 			 (int)ret, strerror(errno) ));
 
-		srv_free_enc_buffer(sconn, buf_out);
+		srv_free_enc_buffer(buf_out);
 		goto out;
 	}
 
 	SMB_PERFCOUNT_SET_MSGLEN_OUT(pcd, len);
-	srv_free_enc_buffer(sconn, buf_out);
+	srv_free_enc_buffer(buf_out);
 out:
 	SMB_PERFCOUNT_END(pcd);
 
 	smbd_unlock_socket(sconn);
-	return (ret > 0);
+	return true;
 }
 
 /*******************************************************************
@@ -223,10 +197,9 @@
 	return (smb_size + num_words*2 + num_bytes);
 }
 
-static bool valid_smb_header(struct smbd_server_connection *sconn,
-			     const uint8_t *inbuf)
+static bool valid_smb_header(const uint8_t *inbuf)
 {
-	if (is_encrypted_packet(sconn, inbuf)) {
+	if (is_encrypted_packet(inbuf)) {
 		return true;
 	}
 	/*
@@ -245,7 +218,7 @@
 	 * of header. Don't print the error if this fits.... JRA.
 	 */
 
-	if (len > (LARGE_WRITEX_BUFFER_SIZE + LARGE_WRITEX_HDR_SIZE)) {
+	if (len > (BUFFER_SIZE + LARGE_WRITEX_HDR_SIZE)) {
 		DEBUG(0,("Invalid packet length! (%lu bytes).\n",
 					(unsigned long)len));
 		return false;
@@ -314,9 +287,7 @@
 
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0, ("read_fd_with_timeout failed for client %s read "
-			  "error = %s.\n",
-			  tsocket_address_string(sconn->remote_address,
-						 talloc_tos()),
+			  "error = %s.\n", sconn->client_id.addr,
 			  nt_errstr(status)));
 		return status;
 	}
@@ -350,7 +321,7 @@
 
 		/* Copy the header we've written. */
 
-		*buffer = (char *)talloc_memdup(mem_ctx,
+		*buffer = (char *)TALLOC_MEMDUP(mem_ctx,
 				writeX_header,
 				sizeof(writeX_header));
 
@@ -375,7 +346,7 @@
 	 * talloc and return.
 	 */
 
-	*buffer = talloc_array(mem_ctx, char, len+4);
+	*buffer = TALLOC_ARRAY(mem_ctx, char, len+4);
 
 	if (*buffer == NULL) {
 		DEBUG(0, ("Could not allocate inbuf of length %d\n",
@@ -444,7 +415,7 @@
 	 * The +4 here can't wrap, we've checked the length above already.
 	 */
 
-	*buffer = talloc_array(mem_ctx, char, len+4);
+	*buffer = TALLOC_ARRAY(mem_ctx, char, len+4);
 
 	if (*buffer == NULL) {
 		DEBUG(0, ("Could not allocate inbuf of length %d\n",
@@ -483,14 +454,12 @@
 		DEBUG(NT_STATUS_EQUAL(status, NT_STATUS_END_OF_FILE)?5:1,
 		      ("receive_smb_raw_talloc failed for client %s "
 		       "read error = %s.\n",
-		       tsocket_address_string(sconn->remote_address,
-					      talloc_tos()),
-		       nt_errstr(status)) );
+		       sconn->client_id.addr, nt_errstr(status)));
 		return status;
 	}
 
-	if (is_encrypted_packet(sconn, (uint8_t *)*buffer)) {
-		status = srv_decrypt_buffer(sconn, *buffer);
+	if (is_encrypted_packet((uint8_t *)*buffer)) {
+		status = srv_decrypt_buffer(*buffer);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(0, ("receive_smb_talloc: SMB decryption failed on "
 				"incoming packet! Error %s\n",
@@ -521,21 +490,13 @@
 			     size_t unread_bytes, bool encrypted,
 			     uint32_t seqnum)
 {
-	struct smbXsrv_tcon *tcon;
-	NTSTATUS status;
-	NTTIME now;
 	size_t req_size = smb_len(inbuf) + 4;
-
 	/* Ensure we have at least smb_size bytes. */
 	if (req_size < smb_size) {
 		DEBUG(0,("init_smb_request: invalid request size %u\n",
 			(unsigned int)req_size ));
 		return false;
 	}
-
-	req->request_time = timeval_current();
-	now = timeval_to_nttime(&req->request_time);
-
 	req->cmd    = CVAL(inbuf, smb_com);
 	req->flags2 = SVAL(inbuf, smb_flg2);
 	req->smbpid = SVAL(inbuf, smb_pid);
@@ -544,22 +505,17 @@
 	req->vuid   = SVAL(inbuf, smb_uid);
 	req->tid    = SVAL(inbuf, smb_tid);
 	req->wct    = CVAL(inbuf, smb_wct);
-	req->vwv    = (const uint16_t *)(inbuf+smb_vwv);
+	req->vwv    = (uint16_t *)(inbuf+smb_vwv);
 	req->buflen = smb_buflen(inbuf);
-	req->buf    = (const uint8_t *)smb_buf_const(inbuf);
+	req->buf    = (const uint8_t *)smb_buf(inbuf);
 	req->unread_bytes = unread_bytes;
 	req->encrypted = encrypted;
 	req->sconn = sconn;
-	status = smb1srv_tcon_lookup(sconn->conn, req->tid, now, &tcon);
-	if (NT_STATUS_IS_OK(status)) {
-		req->conn = tcon->compat;
-	} else {
-		req->conn = NULL;
-	}
+	req->conn = conn_find(sconn,req->tid);
 	req->chain_fsp = NULL;
+	req->chain_outbuf = NULL;
+	req->done = false;
 	req->smb2req = NULL;
-	req->priv_paths = NULL;
-	req->chain = NULL;
 	smb_init_perfcount_data(&req->pcd);
 
 	/* Ensure we have at least wct words and 2 bytes of bcc. */
@@ -570,7 +526,7 @@
 		return false;
 	}
 	/* Ensure bcc is correct. */
-	if (((const uint8_t *)smb_buf_const(inbuf)) + req->buflen > inbuf + req_size) {
+	if (((uint8 *)smb_buf(inbuf)) + req->buflen > inbuf + req_size) {
 		DEBUG(0,("init_smb_request: invalid bcc number %u "
 			"(wct = %u, size %u)\n",
 			(unsigned int)req->buflen,
@@ -595,7 +551,6 @@
 {
 	struct pending_message_list *msg = talloc_get_type(private_data,
 					   struct pending_message_list);
-	struct smbd_server_connection *sconn = msg->sconn;
 	TALLOC_CTX *mem_ctx = talloc_tos();
 	uint64_t mid = (uint64_t)SVAL(msg->buf.data,smb_mid);
 	uint8_t *inbuf;
@@ -616,14 +571,14 @@
 	 * re-processed in error. */
 	msg->processed = true;
 
-	process_smb(sconn, inbuf,
+	process_smb(smbd_server_conn, inbuf,
 		    msg->buf.length, 0,
 		    msg->seqnum, msg->encrypted, &msg->pcd);
 
 	/* If it's still there and was processed, remove it. */
-	msg = get_deferred_open_message_smb(sconn, mid);
+	msg = get_deferred_open_message_smb(mid);
 	if (msg && msg->processed) {
-		remove_deferred_open_message_smb(sconn, mid);
+		remove_deferred_open_message_smb(mid);
 	}
 }
 
@@ -640,13 +595,12 @@
 	int msg_len = smb_len(req->inbuf) + 4;
 	struct pending_message_list *msg;
 
-	msg = talloc_zero(NULL, struct pending_message_list);
+	msg = TALLOC_ZERO_P(NULL, struct pending_message_list);
 
 	if(msg == NULL) {
 		DEBUG(0,("push_message: malloc fail (1)\n"));
 		return False;
 	}
-	msg->sconn = req->sconn;
 
 	msg->buf = data_blob_talloc(msg, req->inbuf, msg_len);
 	if(msg->buf.data == NULL) {
@@ -671,19 +625,18 @@
 		}
 	}
 
-	msg->te = tevent_add_timer(msg->sconn->ev_ctx,
-				   msg,
-				   end_time,
-				   smbd_deferred_open_timer,
-				   msg);
+	msg->te = event_add_timed(smbd_event_context(),
+				  msg,
+				  end_time,
+				  smbd_deferred_open_timer,
+				  msg);
 	if (!msg->te) {
 		DEBUG(0,("push_message: event_add_timed failed\n"));
 		TALLOC_FREE(msg);
 		return false;
 	}
 
-	DLIST_ADD_END(req->sconn->deferred_open_queue, msg,
-		      struct pending_message_list *);
+	DLIST_ADD_END(deferred_open_queue, msg, struct pending_message_list *);
 
 	DEBUG(10,("push_message: pushed message length %u on "
 		  "deferred_open_queue\n", (unsigned int)msg_len));
@@ -695,23 +648,22 @@
  Function to delete a sharing violation open message by mid.
 ****************************************************************************/
 
-void remove_deferred_open_message_smb(struct smbd_server_connection *sconn,
-				      uint64_t mid)
+void remove_deferred_open_message_smb(uint64_t mid)
 {
 	struct pending_message_list *pml;
 
-	if (sconn->using_smb2) {
-		remove_deferred_open_message_smb2(sconn, mid);
+	if (smbd_server_conn->using_smb2) {
+		remove_deferred_open_message_smb2(smbd_server_conn, mid);
 		return;
 	}
 
-	for (pml = sconn->deferred_open_queue; pml; pml = pml->next) {
+	for (pml = deferred_open_queue; pml; pml = pml->next) {
 		if (mid == (uint64_t)SVAL(pml->buf.data,smb_mid)) {
 			DEBUG(10,("remove_deferred_open_message_smb: "
 				  "deleting mid %llu len %u\n",
 				  (unsigned long long)mid,
 				  (unsigned int)pml->buf.length ));
-			DLIST_REMOVE(sconn->deferred_open_queue, pml);
+			DLIST_REMOVE(deferred_open_queue, pml);
 			TALLOC_FREE(pml);
 			return;
 		}
@@ -723,17 +675,17 @@
  schedule it for immediate processing.
 ****************************************************************************/
 
-bool schedule_deferred_open_message_smb(struct smbd_server_connection *sconn,
-					uint64_t mid)
+void schedule_deferred_open_message_smb(uint64_t mid)
 {
 	struct pending_message_list *pml;
 	int i = 0;
 
-	if (sconn->using_smb2) {
-		return schedule_deferred_open_message_smb2(sconn, mid);
+	if (smbd_server_conn->using_smb2) {
+		schedule_deferred_open_message_smb2(smbd_server_conn, mid);
+		return;
 	}
 
-	for (pml = sconn->deferred_open_queue; pml; pml = pml->next) {
+	for (pml = deferred_open_queue; pml; pml = pml->next) {
 		uint64_t msg_mid = (uint64_t)SVAL(pml->buf.data,smb_mid);
 
 		DEBUG(10,("schedule_deferred_open_message_smb: [%d] "
@@ -757,11 +709,11 @@
 				"scheduling mid %llu\n",
 				(unsigned long long)mid ));
 
-			te = tevent_add_timer(pml->sconn->ev_ctx,
-					      pml,
-					      timeval_zero(),
-					      smbd_deferred_open_timer,
-					      pml);
+			te = event_add_timed(smbd_event_context(),
+					     pml,
+					     timeval_zero(),
+					     smbd_deferred_open_timer,
+					     pml);
 			if (!te) {
 				DEBUG(10,("schedule_deferred_open_message_smb: "
 					"event_add_timed() failed, "
@@ -771,31 +723,29 @@
 
 			TALLOC_FREE(pml->te);
 			pml->te = te;
-			DLIST_PROMOTE(sconn->deferred_open_queue, pml);
-			return true;
+			DLIST_PROMOTE(deferred_open_queue, pml);
+			return;
 		}
 	}
 
 	DEBUG(10,("schedule_deferred_open_message_smb: failed to "
 		"find message mid %llu\n",
 		(unsigned long long)mid ));
-
-	return false;
 }
 
 /****************************************************************************
  Return true if this mid is on the deferred queue and was not yet processed.
 ****************************************************************************/
 
-bool open_was_deferred(struct smbd_server_connection *sconn, uint64_t mid)
+bool open_was_deferred(uint64_t mid)
 {
 	struct pending_message_list *pml;
 
-	if (sconn->using_smb2) {
-		return open_was_deferred_smb2(sconn, mid);
+	if (smbd_server_conn->using_smb2) {
+		return open_was_deferred_smb2(smbd_server_conn, mid);
 	}
 
-	for (pml = sconn->deferred_open_queue; pml; pml = pml->next) {
+	for (pml = deferred_open_queue; pml; pml = pml->next) {
 		if (((uint64_t)SVAL(pml->buf.data,smb_mid)) == mid && !pml->processed) {
 			return True;
 		}
@@ -807,12 +757,11 @@
  Return the message queued by this mid.
 ****************************************************************************/
 
-static struct pending_message_list *get_deferred_open_message_smb(
-	struct smbd_server_connection *sconn, uint64_t mid)
+static struct pending_message_list *get_deferred_open_message_smb(uint64_t mid)
 {
 	struct pending_message_list *pml;
 
-	for (pml = sconn->deferred_open_queue; pml; pml = pml->next) {
+	for (pml = deferred_open_queue; pml; pml = pml->next) {
 		if (((uint64_t)SVAL(pml->buf.data,smb_mid)) == mid) {
 			return pml;
 		}
@@ -830,13 +779,13 @@
 {
 	struct pending_message_list *pml;
 
-	if (smbreq->sconn->using_smb2) {
+	if (smbd_server_conn->using_smb2) {
 		return get_deferred_open_message_state_smb2(smbreq->smb2req,
 					p_request_time,
 					pp_state);
 	}
 
-	pml = get_deferred_open_message_smb(smbreq->sconn, smbreq->mid);
+	pml = get_deferred_open_message_smb(smbreq->mid);
 	if (!pml) {
 		return false;
 	}
@@ -892,74 +841,139 @@
 				   private_data, priv_len);
 }
 
-static void smbd_sig_term_handler(struct tevent_context *ev,
-				  struct tevent_signal *se,
-				  int signum,
-				  int count,
-				  void *siginfo,
-				  void *private_data)
-{
-	exit_server_cleanly("termination signal");
-}
+struct idle_event {
+	struct timed_event *te;
+	struct timeval interval;
+	char *name;
+	bool (*handler)(const struct timeval *now, void *private_data);
+	void *private_data;
+};
 
-void smbd_setup_sig_term_handler(struct smbd_server_connection *sconn)
+static void smbd_idle_event_handler(struct event_context *ctx,
+				    struct timed_event *te,
+				    struct timeval now,
+				    void *private_data)
 {
-	struct tevent_signal *se;
+	struct idle_event *event =
+		talloc_get_type_abort(private_data, struct idle_event);
+
+	TALLOC_FREE(event->te);
+
+	DEBUG(10,("smbd_idle_event_handler: %s %p called\n",
+		  event->name, event->te));
 
-	se = tevent_add_signal(sconn->ev_ctx,
-			       sconn,
-			       SIGTERM, 0,
-			       smbd_sig_term_handler,
-			       sconn);
-	if (!se) {
-		exit_server("failed to setup SIGTERM handler");
+	if (!event->handler(&now, event->private_data)) {
+		DEBUG(10,("smbd_idle_event_handler: %s %p stopped\n",
+			  event->name, event->te));
+		/* Don't repeat, delete ourselves */
+		TALLOC_FREE(event);
+		return;
 	}
+
+	DEBUG(10,("smbd_idle_event_handler: %s %p rescheduled\n",
+		  event->name, event->te));
+
+	event->te = event_add_timed(ctx, event,
+				    timeval_sum(&now, &event->interval),
+				    smbd_idle_event_handler, event);
+
+	/* We can't do much but fail here. */
+	SMB_ASSERT(event->te != NULL);
 }
 
-static void smbd_sig_hup_handler(struct tevent_context *ev,
-				  struct tevent_signal *se,
-				  int signum,
-				  int count,
-				  void *siginfo,
+struct idle_event *event_add_idle(struct event_context *event_ctx,
+				  TALLOC_CTX *mem_ctx,
+				  struct timeval interval,
+				  const char *name,
+				  bool (*handler)(const struct timeval *now,
+						  void *private_data),
 				  void *private_data)
 {
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
+	struct idle_event *result;
+	struct timeval now = timeval_current();
 
-	change_to_root_user();
-	DEBUG(1,("Reloading services after SIGHUP\n"));
-	reload_services(sconn, conn_snum_used, false);
-}
+	result = TALLOC_P(mem_ctx, struct idle_event);
+	if (result == NULL) {
+		DEBUG(0, ("talloc failed\n"));
+		return NULL;
+	}
 
-void smbd_setup_sig_hup_handler(struct smbd_server_connection *sconn)
-{
-	struct tevent_signal *se;
+	result->interval = interval;
+	result->handler = handler;
+	result->private_data = private_data;
+
+	if (!(result->name = talloc_asprintf(result, "idle_evt(%s)", name))) {
+		DEBUG(0, ("talloc failed\n"));
+		TALLOC_FREE(result);
+		return NULL;
+	}
 
-	se = tevent_add_signal(sconn->ev_ctx,
-			       sconn,
-			       SIGHUP, 0,
-			       smbd_sig_hup_handler,
-			       sconn);
-	if (!se) {
-		exit_server("failed to setup SIGHUP handler");
+	result->te = event_add_timed(event_ctx, result,
+				     timeval_sum(&now, &interval),
+				     smbd_idle_event_handler, result);
+	if (result->te == NULL) {
+		DEBUG(0, ("event_add_timed failed\n"));
+		TALLOC_FREE(result);
+		return NULL;
 	}
+
+	DEBUG(10,("event_add_idle: %s %p\n", result->name, result->te));
+	return result;
 }
 
-static void smbd_conf_updated(struct messaging_context *msg,
-			      void *private_data,
-			      uint32_t msg_type,
-			      struct server_id server_id,
-			      DATA_BLOB *data)
+static NTSTATUS smbd_server_connection_loop_once(struct smbd_server_connection *conn)
 {
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
+	int timeout;
+	int num_pfds = 0;
+	int ret;
+	bool retry;
 
-	DEBUG(10,("smbd_conf_updated: Got message saying smb.conf was "
-		  "updated. Reloading.\n"));
-	change_to_root_user();
-	reload_services(sconn, conn_snum_used, false);
+	timeout = SMBD_SELECT_TIMEOUT * 1000;
+
+	/*
+	 * Are there any timed events waiting ? If so, ensure we don't
+	 * select for longer than it would take to wait for them.
+	 */
+
+	event_add_to_poll_args(smbd_event_context(), conn,
+			       &conn->pfds, &num_pfds, &timeout);
+
+	/* Process a signal and timed events now... */
+	if (run_events_poll(smbd_event_context(), 0, NULL, 0)) {
+		return NT_STATUS_RETRY;
+	}
+
+	{
+		int sav;
+		START_PROFILE(smbd_idle);
+
+		ret = sys_poll(conn->pfds, num_pfds, timeout);
+		sav = errno;
+
+		END_PROFILE(smbd_idle);
+		errno = sav;
+	}
+
+	if (ret == -1) {
+		if (errno == EINTR) {
+			return NT_STATUS_RETRY;
+		}
+		return map_nt_error_from_unix(errno);
+	}
+
+	retry = run_events_poll(smbd_event_context(), ret, conn->pfds,
+				num_pfds);
+	if (retry) {
+		return NT_STATUS_RETRY;
+	}
+
+	/* Did we timeout ? */
+	if (ret == 0) {
+		return NT_STATUS_RETRY;
+	}
+
+	/* should not be reached */
+	return NT_STATUS_INTERNAL_ERROR;
 }
 
 /*
@@ -1277,26 +1291,21 @@
 			  const char *inbuf, char **outbuf, uint8_t num_words,
 			  uint32_t num_bytes)
 {
-	size_t smb_len = MIN_SMB_SIZE + VWV(num_words) + num_bytes;
-
 	/*
-	 * Protect against integer wrap.
-	 * The SMB layer reply can be up to 0xFFFFFF bytes.
-	 */
-	if ((num_bytes > 0xffffff) || (smb_len > 0xffffff)) {
+         * Protect against integer wrap
+         */
+	if ((num_bytes > 0xffffff)
+	    || ((num_bytes + smb_size + num_words*2) > 0xffffff)) {
 		char *msg;
 		if (asprintf(&msg, "num_bytes too large: %u",
 			     (unsigned)num_bytes) == -1) {
-			msg = discard_const_p(char, "num_bytes too large");
+			msg = CONST_DISCARD(char *, "num_bytes too large");
 		}
 		smb_panic(msg);
 	}
 
-	/*
-	 * Here we include the NBT header for now.
-	 */
-	*outbuf = talloc_array(mem_ctx, char,
-			       NBT_HDR_SIZE + smb_len);
+	*outbuf = TALLOC_ARRAY(mem_ctx, char,
+			       smb_size + num_words*2 + num_bytes);
 	if (*outbuf == NULL) {
 		return false;
 	}
@@ -1308,7 +1317,7 @@
 	 * himself
 	 */
 	if (num_words != 0) {
-		memset(*outbuf + (NBT_HDR_SIZE + HDR_VWV), 0, VWV(num_words));
+		memset(*outbuf + smb_vwv0, 0, num_words*2);
 	}
 
 	return true;
@@ -1317,7 +1326,7 @@
 void reply_outbuf(struct smb_request *req, uint8 num_words, uint32 num_bytes)
 {
 	char *outbuf;
-	if (!create_outbuf(req, req, (const char *)req->inbuf, &outbuf, num_words,
+	if (!create_outbuf(req, req, (char *)req->inbuf, &outbuf, num_words,
 			   num_bytes)) {
 		smb_panic("could not allocate output buffer\n");
 	}
@@ -1329,28 +1338,22 @@
  Dump a packet to a file.
 ********************************************************************/
 
-static void smb_dump(const char *name, int type, const char *data)
+static void smb_dump(const char *name, int type, const char *data, ssize_t len)
 {
-	size_t len;
 	int fd, i;
 	char *fname = NULL;
 	if (DEBUGLEVEL < 50) {
 		return;
 	}
 
-	len = smb_len_tcp(data)+4;
+	if (len < 4) len = smb_len(data)+4;
 	for (i=1;i<100;i++) {
-		fname = talloc_asprintf(talloc_tos(),
-				"/tmp/%s.%d.%s",
-				name,
-				i,
-				type ? "req" : "resp");
-		if (fname == NULL) {
+		if (asprintf(&fname, "/tmp/%s.%d.%s", name, i,
+			     type ? "req" : "resp") == -1) {
 			return;
 		}
 		fd = open(fname, O_WRONLY|O_CREAT|O_EXCL, 0644);
 		if (fd != -1 || errno != EEXIST) break;
-		TALLOC_FREE(fname);
 	}
 	if (fd != -1) {
 		ssize_t ret = write(fd, data, len);
@@ -1359,7 +1362,7 @@
 		close(fd);
 		DEBUG(0,("created %s len %lu\n", fname, (unsigned long)len));
 	}
-	TALLOC_FREE(fname);
+	SAFE_FREE(fname);
 }
 
 /****************************************************************************
@@ -1375,21 +1378,27 @@
  find.
 ****************************************************************************/
 
-static connection_struct *switch_message(uint8 type, struct smb_request *req)
+static connection_struct *switch_message(uint8 type, struct smb_request *req, int size)
 {
 	int flags;
-	uint64_t session_tag;
+	uint16 session_tag;
 	connection_struct *conn = NULL;
 	struct smbd_server_connection *sconn = req->sconn;
-	NTTIME now = timeval_to_nttime(&req->request_time);
-	struct smbXsrv_session *session = NULL;
-	NTSTATUS status;
 
 	errno = 0;
 
+	/* Make sure this is an SMB packet. smb_size contains NetBIOS header
+	 * so subtract 4 from it. */
+	if ((size < (smb_size - 4)) ||
+	    !valid_smb_header(req->inbuf)) {
+		DEBUG(2,("Non-SMB packet of length %d. Terminating server\n",
+			 smb_len(req->inbuf)));
+		exit_server_cleanly("Non-SMB packet");
+	}
+
 	if (smb_messages[type].fn == NULL) {
 		DEBUG(0,("Unknown message type %d!\n",type));
-		smb_dump("Unknown", 1, (const char *)req->inbuf);
+		smb_dump("Unknown", 1, (char *)req->inbuf, size);
 		reply_unknown_new(req, type);
 		return NULL;
 	}
@@ -1397,16 +1406,17 @@
 	flags = smb_messages[type].flags;
 
 	/* In share mode security we must ignore the vuid. */
-	session_tag = req->vuid;
+	session_tag = (lp_security() == SEC_SHARE)
+		? UID_FIELD_INVALID : req->vuid;
 	conn = req->conn;
 
 	DEBUG(3,("switch message %s (pid %d) conn 0x%lx\n", smb_fn_name(type),
-		 (int)getpid(), (unsigned long)conn));
+		 (int)sys_getpid(), (unsigned long)conn));
 
-	smb_dump(smb_fn_name(type), 1, (const char *)req->inbuf);
+	smb_dump(smb_fn_name(type), 1, (char *)req->inbuf, size);
 
 	/* Ensure this value is replaced in the incoming packet. */
-	SSVAL(discard_const_p(uint8_t, req->inbuf),smb_uid,session_tag);
+	SSVAL(req->inbuf,smb_uid,session_tag);
 
 	/*
 	 * Ensure the correct username is in current_user_info.  This is a
@@ -1417,42 +1427,18 @@
 	 * JRA.
 	 */
 
-	/*
-	 * lookup an existing session
-	 *
-	 * Note: for now we only check for NT_STATUS_NETWORK_SESSION_EXPIRED
-	 * here, the main check is still in change_to_user()
-	 */
-	status = smb1srv_session_lookup(sconn->conn,
-					session_tag,
-					now,
-					&session);
-	if (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {
-		switch (type) {
-		case SMBsesssetupX:
-			status = NT_STATUS_OK;
-			break;
-		default:
-			DEBUG(1,("Error: session %llu is expired, mid=%llu.\n",
-				 (unsigned long long)session_tag,
-				 (unsigned long long)req->mid));
-			reply_nterror(req, NT_STATUS_NETWORK_SESSION_EXPIRED);
-			return conn;
-		}
-	}
-
-	if (session_tag != sconn->conn->last_session_id) {
-		struct user_struct *vuser = NULL;
+	if (session_tag != sconn->smb1.sessions.last_session_tag) {
+		user_struct *vuser = NULL;
 
-		sconn->conn->last_session_id = session_tag;
-		if (session) {
-			vuser = session->compat;
-		}
-		if (vuser) {
-			set_current_user_info(
-				vuser->session_info->unix_info->sanitized_username,
-				vuser->session_info->unix_info->unix_name,
-				vuser->session_info->info->domain_name);
+		sconn->smb1.sessions.last_session_tag = session_tag;
+		if(session_tag != UID_FIELD_INVALID) {
+			vuser = get_valid_user_struct(sconn, session_tag);
+			if (vuser) {
+				set_current_user_info(
+					vuser->session_info->sanitized_username,
+					vuser->session_info->unix_name,
+					vuser->session_info->info3->base.domain.string);
+			}
 		}
 	}
 
@@ -1504,15 +1490,11 @@
 		if (req->encrypted) {
 			conn->encrypted_tid = true;
 			/* encrypted required from now on. */
-			conn->encrypt_level = SMB_SIGNING_REQUIRED;
+			conn->encrypt_level = Required;
 		} else if (ENCRYPTION_REQUIRED(conn)) {
 			if (req->cmd != SMBtrans2 && req->cmd != SMBtranss2) {
-				DEBUG(1,("service[%s] requires encryption"
-					"%s ACCESS_DENIED. mid=%llu\n",
-					lp_servicename(talloc_tos(), SNUM(conn)),
-					smb_fn_name(type),
-					(unsigned long long)req->mid));
-				reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+				exit_server_cleanly("encryption required "
+					"on connection");
 				return conn;
 			}
 		}
@@ -1526,38 +1508,14 @@
 		conn->num_smb_operations++;
 	}
 
-	/*
-	 * Does this protocol need to be run as guest? (Only archane
-	 * messenger service requests have this...)
-	 */
-	if (flags & AS_GUEST) {
-		char *raddr;
-		bool ok;
-
-		if (!change_to_guest()) {
-			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
-			return conn;
-		}
-
-		raddr = tsocket_address_inet_addr_string(sconn->remote_address,
-							 talloc_tos());
-		if (raddr == NULL) {
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return conn;
-		}
-
-		/*
-		 * Haven't we checked this in smbd_process already???
-		 */
-
-		ok = allow_access(lp_hostsdeny(-1), lp_hostsallow(-1),
-				  sconn->remote_hostname, raddr);
-		TALLOC_FREE(raddr);
-
-		if (!ok) {
-			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
-			return conn;
-		}
+	/* does this protocol need to be run as guest? */
+	if ((flags & AS_GUEST)
+	    && (!change_to_guest() ||
+		!allow_access(lp_hostsdeny(-1), lp_hostsallow(-1),
+			      sconn->client_id.name,
+			      sconn->client_id.addr))) {
+		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+		return conn;
 	}
 
 	smb_messages[type].fn(req);
@@ -1596,7 +1554,21 @@
 		SMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, size);
 	}
 
-	conn = switch_message(req->cmd, req);
+	conn = switch_message(req->cmd, req, size);
+
+	if (req->unread_bytes) {
+		/* writeX failed. drain socket. */
+		if (drain_socket(req->sconn->sock, req->unread_bytes) !=
+				req->unread_bytes) {
+			smb_panic("failed to drain pending bytes");
+		}
+		req->unread_bytes = 0;
+	}
+
+	if (req->done) {
+		TALLOC_FREE(req);
+		return;
+	}
 
 	if (req->outbuf == NULL) {
 		return;
@@ -1619,170 +1591,6 @@
 	return;
 }
 
-static void construct_reply_chain(struct smbd_server_connection *sconn,
-				  char *inbuf, int size, uint32_t seqnum,
-				  bool encrypted,
-				  struct smb_perfcount_data *deferred_pcd)
-{
-	struct smb_request **reqs = NULL;
-	struct smb_request *req;
-	unsigned num_reqs;
-	bool ok;
-
-	ok = smb1_parse_chain(talloc_tos(), (uint8_t *)inbuf, sconn, encrypted,
-			      seqnum, &reqs, &num_reqs);
-	if (!ok) {
-		char errbuf[smb_size];
-		error_packet(errbuf, 0, 0, NT_STATUS_INVALID_PARAMETER,
-			     __LINE__, __FILE__);
-		if (!srv_send_smb(sconn, errbuf, true, seqnum, encrypted,
-				  NULL)) {
-			exit_server_cleanly("construct_reply_chain: "
-					    "srv_send_smb failed.");
-		}
-		return;
-	}
-
-	req = reqs[0];
-	req->inbuf = (uint8_t *)talloc_move(reqs, &inbuf);
-
-	req->conn = switch_message(req->cmd, req);
-
-	if (req->outbuf == NULL) {
-		/*
-		 * Request has suspended itself, will come
-		 * back here.
-		 */
-		return;
-	}
-	smb_request_done(req);
-}
-
-/*
- * To be called from an async SMB handler that is potentially chained
- * when it is finished for shipping.
- */
-
-void smb_request_done(struct smb_request *req)
-{
-	struct smb_request **reqs = NULL;
-	struct smb_request *first_req;
-	size_t i, num_reqs, next_index;
-	NTSTATUS status;
-
-	if (req->chain == NULL) {
-		first_req = req;
-		goto shipit;
-	}
-
-	reqs = req->chain;
-	num_reqs = talloc_array_length(reqs);
-
-	for (i=0; i<num_reqs; i++) {
-		if (reqs[i] == req) {
-			break;
-		}
-	}
-	if (i == num_reqs) {
-		/*
-		 * Invalid chain, should not happen
-		 */
-		status = NT_STATUS_INTERNAL_ERROR;
-		goto error;
-	}
-	next_index = i+1;
-
-	while ((next_index < num_reqs) && (IVAL(req->outbuf, smb_rcls) == 0)) {
-		struct smb_request *next = reqs[next_index];
-		struct smbXsrv_tcon *tcon;
-		NTTIME now = timeval_to_nttime(&req->request_time);
-
-		next->vuid = SVAL(req->outbuf, smb_uid);
-		next->tid  = SVAL(req->outbuf, smb_tid);
-		status = smb1srv_tcon_lookup(req->sconn->conn, req->tid,
-					     now, &tcon);
-		if (NT_STATUS_IS_OK(status)) {
-			req->conn = tcon->compat;
-		} else {
-			req->conn = NULL;
-		}
-		next->chain_fsp = req->chain_fsp;
-		next->inbuf = (uint8_t *)req->inbuf;
-
-		req = next;
-		req->conn = switch_message(req->cmd, req);
-
-		if (req->outbuf == NULL) {
-			/*
-			 * Request has suspended itself, will come
-			 * back here.
-			 */
-			return;
-		}
-		next_index += 1;
-	}
-
-	first_req = reqs[0];
-
-	for (i=1; i<next_index; i++) {
-		bool ok;
-
-		ok = smb_splice_chain(&first_req->outbuf, reqs[i]->outbuf);
-		if (!ok) {
-			status = NT_STATUS_INTERNAL_ERROR;
-			goto error;
-		}
-	}
-
-	SSVAL(first_req->outbuf, smb_uid, SVAL(req->outbuf, smb_uid));
-	SSVAL(first_req->outbuf, smb_tid, SVAL(req->outbuf, smb_tid));
-
-	/*
-	 * This scary statement intends to set the
-	 * FLAGS2_32_BIT_ERROR_CODES flg2 field in first_req->outbuf
-	 * to the value last_req->outbuf carries
-	 */
-	SSVAL(first_req->outbuf, smb_flg2,
-	      (SVAL(first_req->outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)
-	      |(SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));
-
-	/*
-	 * Transfer the error codes from the subrequest to the main one
-	 */
-	SSVAL(first_req->outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));
-	SSVAL(first_req->outbuf, smb_err,  SVAL(req->outbuf, smb_err));
-
-	_smb_setlen_large(
-		first_req->outbuf, talloc_get_size(first_req->outbuf) - 4);
-
-shipit:
-	if (!srv_send_smb(first_req->sconn,
-			  (char *)first_req->outbuf,
-			  true, first_req->seqnum+1,
-			  IS_CONN_ENCRYPTED(req->conn)||first_req->encrypted,
-			  &first_req->pcd)) {
-		exit_server_cleanly("construct_reply_chain: srv_send_smb "
-				    "failed.");
-	}
-	TALLOC_FREE(req);	/* non-chained case */
-	TALLOC_FREE(reqs);	/* chained case */
-	return;
-
-error:
-	{
-		char errbuf[smb_size];
-		error_packet(errbuf, 0, 0, status, __LINE__, __FILE__);
-		if (!srv_send_smb(req->sconn, errbuf, true,
-				  req->seqnum+1, req->encrypted,
-				  NULL)) {
-			exit_server_cleanly("construct_reply_chain: "
-					    "srv_send_smb failed.");
-		}
-	}
-	TALLOC_FREE(req);	/* non-chained case */
-	TALLOC_FREE(reqs);	/* chained case */
-}
-
 /****************************************************************************
  Process an smb from the client
 ****************************************************************************/
@@ -1800,7 +1608,7 @@
 	DEBUG(3, ("Transaction %d of length %d (%u toread)\n",
 		  sconn->trans_num, (int)nread, (unsigned int)unread_bytes));
 
-	if (msg_type != NBSSmessage) {
+	if (msg_type != 0) {
 		/*
 		 * NetBIOS session request, keepalive, etc.
 		 */
@@ -1814,7 +1622,7 @@
 		if (smbd_is_smb2_header(inbuf, nread)) {
 			smbd_smb2_first_negprot(sconn, inbuf, nread);
 			return;
-		} else if (nread >= smb_size && valid_smb_header(sconn, inbuf)
+		} else if (nread >= smb_size && valid_smb_header(inbuf)
 				&& CVAL(inbuf, smb_com) != 0x72) {
 			/* This is a non-negprot SMB1 packet.
 			   Disable SMB2 from now on. */
@@ -1822,35 +1630,10 @@
 		}
 	}
 
-	/* Make sure this is an SMB packet. smb_size contains NetBIOS header
-	 * so subtract 4 from it. */
-	if ((nread < (smb_size - 4)) || !valid_smb_header(sconn, inbuf)) {
-		DEBUG(2,("Non-SMB packet of length %d. Terminating server\n",
-			 smb_len(inbuf)));
-
-		/* special magic for immediate exit */
-		if ((nread == 9) &&
-		    (IVAL(inbuf, 4) == 0x74697865) &&
-		    lp_parm_bool(-1, "smbd", "suicide mode", false)) {
-			uint8_t exitcode = CVAL(inbuf, 8);
-			DEBUG(1, ("Exiting immediately with code %d\n",
-				  (int)exitcode));
-			exit(exitcode);
-		}
-
-		exit_server_cleanly("Non-SMB packet");
-	}
-
 	show_msg((char *)inbuf);
 
-	if ((unread_bytes == 0) && smb1_is_chain(inbuf)) {
-		construct_reply_chain(sconn, (char *)inbuf, nread,
-				      seqnum, encrypted, deferred_pcd);
-	} else {
-		construct_reply(sconn, (char *)inbuf, nread, unread_bytes,
-				seqnum,	encrypted, deferred_pcd);
-	}
-
+	construct_reply(sconn, (char *)inbuf, nread, unread_bytes, seqnum,
+			encrypted, deferred_pcd);
 	sconn->trans_num++;
 
 done:
@@ -1901,21 +1684,15 @@
 static void construct_reply_common(struct smb_request *req, const char *inbuf,
 				   char *outbuf)
 {
-	uint16_t in_flags2 = SVAL(inbuf,smb_flg2);
-	uint16_t out_flags2 = common_flags2;
-
-	out_flags2 |= in_flags2 & FLAGS2_UNICODE_STRINGS;
-	out_flags2 |= in_flags2 & FLAGS2_SMB_SECURITY_SIGNATURES;
-	out_flags2 |= in_flags2 & FLAGS2_SMB_SECURITY_SIGNATURES_REQUIRED;
-
 	srv_set_message(outbuf,0,0,false);
 
 	SCVAL(outbuf, smb_com, req->cmd);
 	SIVAL(outbuf,smb_rcls,0);
 	SCVAL(outbuf,smb_flg, FLAG_REPLY | (CVAL(inbuf,smb_flg) & FLAG_CASELESS_PATHNAMES)); 
-	SSVAL(outbuf,smb_flg2, out_flags2);
+	SSVAL(outbuf,smb_flg2,
+		(SVAL(inbuf,smb_flg2) & FLAGS2_UNICODE_STRINGS) |
+		common_flags2);
 	memset(outbuf+smb_pidhigh,'\0',(smb_tid-smb_pidhigh));
-	memcpy(outbuf+smb_ss_field, inbuf+smb_ss_field, 8);
 
 	SSVAL(outbuf,smb_tid,SVAL(inbuf,smb_tid));
 	SSVAL(outbuf,smb_pid,SVAL(inbuf,smb_pid));
@@ -1925,7 +1702,41 @@
 
 void construct_reply_common_req(struct smb_request *req, char *outbuf)
 {
-	construct_reply_common(req, (const char *)req->inbuf, outbuf);
+	construct_reply_common(req, (char *)req->inbuf, outbuf);
+}
+
+/*
+ * How many bytes have we already accumulated up to the current wct field
+ * offset?
+ */
+
+size_t req_wct_ofs(struct smb_request *req)
+{
+	size_t buf_size;
+
+	if (req->chain_outbuf == NULL) {
+		return smb_wct - 4;
+	}
+	buf_size = talloc_get_size(req->chain_outbuf);
+	if ((buf_size % 4) != 0) {
+		buf_size += (4 - (buf_size % 4));
+	}
+	return buf_size - 4;
+}
+
+/*
+ * Hack around reply_nterror & friends not being aware of chained requests,
+ * generating illegal (i.e. wct==0) chain replies.
+ */
+
+static void fixup_chain_error_packet(struct smb_request *req)
+{
+	uint8_t *outbuf = req->outbuf;
+	req->outbuf = NULL;
+	reply_outbuf(req, 2, 0);
+	memcpy(req->outbuf, outbuf, smb_wct);
+	TALLOC_FREE(outbuf);
+	SCVAL(req->outbuf, smb_vwv0, 0xff);
 }
 
 /**
@@ -1945,9 +1756,7 @@
 
 	cmd = CVAL(buf, smb_com);
 
-	if (!is_andx_req(cmd)) {
-		return false;
-	}
+	SMB_ASSERT(is_andx_req(cmd));
 
 	ofs = smb_vwv0;
 
@@ -1963,9 +1772,7 @@
 		 */
 		ofs = SVAL(buf, ofs+2) + 4 + 1;
 
-		if (ofs+4 >= talloc_get_size(buf)) {
-			return false;
-		}
+		SMB_ASSERT(ofs+4 < talloc_get_size(buf));
 	}
 
 	*pofs = ofs;
@@ -1975,27 +1782,39 @@
 /**
  * @brief Do the smb chaining at a buffer level
  * @param[in] poutbuf		Pointer to the talloc'ed buffer to be modified
- * @param[in] andx_buf		Buffer to be appended
+ * @param[in] smb_command	The command that we want to issue
+ * @param[in] wct		How many words?
+ * @param[in] vwv		The words, already in network order
+ * @param[in] bytes_alignment	How shall we align "bytes"?
+ * @param[in] num_bytes		How many bytes?
+ * @param[in] bytes		The data the request ships
+ *
+ * smb_splice_chain() adds the vwv and bytes to the request already present in
+ * *poutbuf.
  */
 
-static bool smb_splice_chain(uint8_t **poutbuf, const uint8_t *andx_buf)
+static bool smb_splice_chain(uint8_t **poutbuf, uint8_t smb_command,
+			     uint8_t wct, const uint16_t *vwv,
+			     size_t bytes_alignment,
+			     uint32_t num_bytes, const uint8_t *bytes)
 {
-	uint8_t smb_command	= CVAL(andx_buf, smb_com);
-	uint8_t wct		= CVAL(andx_buf, smb_wct);
-	const uint16_t *vwv	= (const uint16_t *)(andx_buf + smb_vwv);
-	uint32_t num_bytes	= smb_buflen(andx_buf);
-	const uint8_t *bytes	= (const uint8_t *)smb_buf_const(andx_buf);
-
 	uint8_t *outbuf;
 	size_t old_size, new_size;
 	size_t ofs;
 	size_t chain_padding = 0;
-	size_t andx_cmd_ofs;
-
+	size_t bytes_padding = 0;
+	bool first_request;
 
 	old_size = talloc_get_size(*poutbuf);
 
-	if ((old_size % 4) != 0) {
+	/*
+	 * old_size == smb_wct means we're pushing the first request in for
+	 * libsmb/
+	 */
+
+	first_request = (old_size == smb_wct);
+
+	if (!first_request && ((old_size % 4) != 0)) {
 		/*
 		 * Align the wct field of subsequent requests to a 4-byte
 		 * boundary
@@ -2005,38 +1824,51 @@
 
 	/*
 	 * After the old request comes the new wct field (1 byte), the vwv's
-	 * and the num_bytes field.
+	 * and the num_bytes field. After at we might need to align the bytes
+	 * given to us to "bytes_alignment", increasing the num_bytes value.
 	 */
 
 	new_size = old_size + chain_padding + 1 + wct * sizeof(uint16_t) + 2;
-	new_size += num_bytes;
+
+	if ((bytes_alignment != 0) && ((new_size % bytes_alignment) != 0)) {
+		bytes_padding = bytes_alignment - (new_size % bytes_alignment);
+	}
+
+	new_size += bytes_padding + num_bytes;
 
 	if ((smb_command != SMBwriteX) && (new_size > 0xffff)) {
-		DEBUG(1, ("smb_splice_chain: %u bytes won't fit\n",
+		DEBUG(1, ("splice_chain: %u bytes won't fit\n",
 			  (unsigned)new_size));
 		return false;
 	}
 
-	outbuf = talloc_realloc(NULL, *poutbuf, uint8_t, new_size);
+	outbuf = TALLOC_REALLOC_ARRAY(NULL, *poutbuf, uint8_t, new_size);
 	if (outbuf == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		return false;
 	}
 	*poutbuf = outbuf;
 
-	if (!find_andx_cmd_ofs(outbuf, &andx_cmd_ofs)) {
-		DEBUG(1, ("invalid command chain\n"));
-		*poutbuf = talloc_realloc(NULL, *poutbuf, uint8_t, old_size);
-		return false;
-	}
+	if (first_request) {
+		SCVAL(outbuf, smb_com, smb_command);
+	} else {
+		size_t andx_cmd_ofs;
 
-	if (chain_padding != 0) {
-		memset(outbuf + old_size, 0, chain_padding);
-		old_size += chain_padding;
-	}
+		if (!find_andx_cmd_ofs(outbuf, &andx_cmd_ofs)) {
+			DEBUG(1, ("invalid command chain\n"));
+			*poutbuf = TALLOC_REALLOC_ARRAY(
+				NULL, *poutbuf, uint8_t, old_size);
+			return false;
+		}
 
-	SCVAL(outbuf, andx_cmd_ofs, smb_command);
-	SSVAL(outbuf, andx_cmd_ofs + 2, old_size - 4);
+		if (chain_padding != 0) {
+			memset(outbuf + old_size, 0, chain_padding);
+			old_size += chain_padding;
+		}
+
+		SCVAL(outbuf, andx_cmd_ofs, smb_command);
+		SSVAL(outbuf, andx_cmd_ofs + 2, old_size - 4);
+	}
 
 	ofs = old_size;
 
@@ -2054,47 +1886,24 @@
 	 */
 
 	memcpy(outbuf + ofs, vwv, sizeof(uint16_t) * wct);
+	ofs += sizeof(uint16_t) * wct;
 
 	/*
-	 * HACK ALERT
-	 *
-	 * Read&X has an offset into its data buffer at
-	 * vwv[6]. reply_read_andx has no idea anymore that it's
-	 * running from within a chain, so we have to fix up the
-	 * offset here.
-	 *
-	 * Although it looks disgusting at this place, I want to keep
-	 * it here. The alternative would be to push knowledge about
-	 * the andx chain down into read&x again.
+	 * bcc (byte count)
 	 */
 
-	if (smb_command == SMBreadX) {
-		uint8_t *bytes_addr;
-
-		if (wct < 7) {
-			/*
-			 * Invalid read&x response
-			 */
-			return false;
-		}
+	SSVAL(outbuf, ofs, num_bytes + bytes_padding);
+	ofs += sizeof(uint16_t);
 
-		bytes_addr = outbuf + ofs	 /* vwv start */
-			+ sizeof(uint16_t) * wct /* vwv array */
-			+ sizeof(uint16_t);	 /* bcc */
+	/*
+	 * padding
+	 */
 
-		SSVAL(outbuf + ofs, 6 * sizeof(uint16_t),
-		      bytes_addr - outbuf - 4);
+	if (bytes_padding != 0) {
+		memset(outbuf + ofs, 0, bytes_padding);
+		ofs += bytes_padding;
 	}
 
-	ofs += sizeof(uint16_t) * wct;
-
-	/*
-	 * bcc (byte count)
-	 */
-
-	SSVAL(outbuf, ofs, num_bytes);
-	ofs += sizeof(uint16_t);
-
 	/*
 	 * The bytes field
 	 */
@@ -2104,244 +1913,268 @@
 	return true;
 }
 
-bool smb1_is_chain(const uint8_t *buf)
-{
-	uint8_t cmd, wct, andx_cmd;
-
-	cmd = CVAL(buf, smb_com);
-	if (!is_andx_req(cmd)) {
-		return false;
-	}
-	wct = CVAL(buf, smb_wct);
-	if (wct < 2) {
-		return false;
-	}
-	andx_cmd = CVAL(buf, smb_vwv);
-	return (andx_cmd != 0xFF);
-}
+/****************************************************************************
+ Construct a chained reply and add it to the already made reply
+****************************************************************************/
 
-bool smb1_walk_chain(const uint8_t *buf,
-		     bool (*fn)(uint8_t cmd,
-				uint8_t wct, const uint16_t *vwv,
-				uint16_t num_bytes, const uint8_t *bytes,
-				void *private_data),
-		     void *private_data)
+void chain_reply(struct smb_request *req)
 {
-	size_t smblen = smb_len(buf);
-	const char *smb_buf = smb_base(buf);
-	uint8_t cmd, chain_cmd;
-	uint8_t wct;
-	const uint16_t *vwv;
-	uint16_t num_bytes;
-	const uint8_t *bytes;
+	size_t smblen = smb_len(req->inbuf);
+	size_t already_used, length_needed;
+	uint8_t chain_cmd;
+	uint32_t chain_offset;	/* uint32_t to avoid overflow */
 
-	cmd = CVAL(buf, smb_com);
-	wct = CVAL(buf, smb_wct);
-	vwv = (const uint16_t *)(buf + smb_vwv);
-	num_bytes = smb_buflen(buf);
-	bytes = (uint8_t *)smb_buf_const(buf);
+	uint8_t wct;
+	uint16_t *vwv;
+	uint16_t buflen;
+	uint8_t *buf;
 
-	if (!fn(cmd, wct, vwv, num_bytes, bytes, private_data)) {
-		return false;
+	if (IVAL(req->outbuf, smb_rcls) != 0) {
+		fixup_chain_error_packet(req);
 	}
 
-	if (!is_andx_req(cmd)) {
-		return true;
-	}
-	if (wct < 2) {
-		return false;
-	}
+	/*
+	 * Any of the AndX requests and replies have at least a wct of
+	 * 2. vwv[0] is the next command, vwv[1] is the offset from the
+	 * beginning of the SMB header to the next wct field.
+	 *
+	 * None of the AndX requests put anything valuable in vwv[0] and [1],
+	 * so we can overwrite it here to form the chain.
+	 */
 
-	chain_cmd = CVAL(vwv, 0);
+	if ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {
+		if (req->chain_outbuf == NULL) {
+			req->chain_outbuf = TALLOC_REALLOC_ARRAY(
+				req, req->outbuf, uint8_t,
+				smb_len(req->outbuf) + 4);
+			if (req->chain_outbuf == NULL) {
+				smb_panic("talloc failed");
+			}
+		}
+		req->outbuf = NULL;
+		goto error;
+	}
 
-	while (chain_cmd != 0xff) {
-		uint32_t chain_offset;	/* uint32_t to avoid overflow */
-		size_t length_needed;
-		ptrdiff_t vwv_offset;
+	/*
+	 * Here we assume that this is the end of the chain. For that we need
+	 * to set "next command" to 0xff and the offset to 0. If we later find
+	 * more commands in the chain, this will be overwritten again.
+	 */
 
-		chain_offset = SVAL(vwv+1, 0);
+	SCVAL(req->outbuf, smb_vwv0, 0xff);
+	SCVAL(req->outbuf, smb_vwv0+1, 0);
+	SSVAL(req->outbuf, smb_vwv1, 0);
 
+	if (req->chain_outbuf == NULL) {
 		/*
-		 * Check if the client tries to fool us. The chain
-		 * offset needs to point beyond the current request in
-		 * the chain, it needs to strictly grow. Otherwise we
-		 * might be tricked into an endless loop always
-		 * processing the same request over and over again. We
-		 * used to assume that vwv and the byte buffer array
-		 * in a chain are always attached, but OS/2 the
-		 * Write&X/Read&X chain puts the Read&X vwv array
-		 * right behind the Write&X vwv chain. The Write&X bcc
-		 * array is put behind the Read&X vwv array. So now we
-		 * check whether the chain offset points strictly
-		 * behind the previous vwv array. req->buf points
-		 * right after the vwv array of the previous
-		 * request. See
-		 * https://bugzilla.samba.org/show_bug.cgi?id=8360 for
-		 * more information.
-		 */
-
-		vwv_offset = ((const char *)vwv - smb_buf);
-		if (chain_offset <= vwv_offset) {
-			return false;
+		 * In req->chain_outbuf we collect all the replies. Start the
+		 * chain by copying in the first reply.
+		 *
+		 * We do the realloc because later on we depend on
+		 * talloc_get_size to determine the length of
+		 * chain_outbuf. The reply_xxx routines might have
+		 * over-allocated (reply_pipe_read_and_X used to be such an
+		 * example).
+		 */
+		req->chain_outbuf = TALLOC_REALLOC_ARRAY(
+			req, req->outbuf, uint8_t,
+			smb_len_large(req->outbuf) + 4);
+		if (req->chain_outbuf == NULL) {
+			smb_panic("talloc failed");
 		}
-
+		req->outbuf = NULL;
+	} else {
 		/*
-		 * Next check: Make sure the chain offset does not
-		 * point beyond the overall smb request length.
+		 * Update smb headers where subsequent chained commands
+		 * may have updated them.
 		 */
+		SSVAL(req->chain_outbuf, smb_tid, SVAL(req->outbuf, smb_tid));
+		SSVAL(req->chain_outbuf, smb_uid, SVAL(req->outbuf, smb_uid));
 
-		length_needed = chain_offset+1;	/* wct */
-		if (length_needed > smblen) {
-			return false;
+		if (!smb_splice_chain(&req->chain_outbuf,
+				      CVAL(req->outbuf, smb_com),
+				      CVAL(req->outbuf, smb_wct),
+				      (uint16_t *)(req->outbuf + smb_vwv),
+				      0, smb_buflen(req->outbuf),
+				      (uint8_t *)smb_buf(req->outbuf))) {
+			goto error;
 		}
+		TALLOC_FREE(req->outbuf);
+	}
 
-		/*
-		 * Now comes the pointer magic. Goal here is to set up
-		 * vwv and buf correctly again. The chain offset (the
-		 * former vwv[1]) points at the new wct field.
-		 */
-
-		wct = CVAL(smb_buf, chain_offset);
+	/*
+	 * We use the old request's vwv field to grab the next chained command
+	 * and offset into the chained fields.
+	 */
 
-		if (is_andx_req(chain_cmd) && (wct < 2)) {
-			return false;
-		}
+	chain_cmd = CVAL(req->vwv+0, 0);
+	chain_offset = SVAL(req->vwv+1, 0);
 
+	if (chain_cmd == 0xff) {
 		/*
-		 * Next consistency check: Make the new vwv array fits
-		 * in the overall smb request.
+		 * End of chain, no more requests from the client. So ship the
+		 * replies.
 		 */
+		smb_setlen((char *)(req->chain_outbuf),
+			   talloc_get_size(req->chain_outbuf) - 4);
 
-		length_needed += (wct+1)*sizeof(uint16_t); /* vwv+buflen */
-		if (length_needed > smblen) {
-			return false;
+		if (!srv_send_smb(req->sconn, (char *)req->chain_outbuf,
+				  true, req->seqnum+1,
+				  IS_CONN_ENCRYPTED(req->conn)
+				  ||req->encrypted,
+				  &req->pcd)) {
+			exit_server_cleanly("chain_reply: srv_send_smb "
+					    "failed.");
 		}
-		vwv = (const uint16_t *)(smb_buf + chain_offset + 1);
-
-		/*
-		 * Now grab the new byte buffer....
-		 */
+		TALLOC_FREE(req->chain_outbuf);
+		req->done = true;
+		return;
+	}
 
-		num_bytes = SVAL(vwv+wct, 0);
+	/* add a new perfcounter for this element of chain */
+	SMB_PERFCOUNT_ADD(&req->pcd);
+	SMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);
+	SMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);
 
-		/*
-		 * .. and check that it fits.
-		 */
+	/*
+	 * Check if the client tries to fool us. The chain offset
+	 * needs to point beyond the current request in the chain, it
+	 * needs to strictly grow. Otherwise we might be tricked into
+	 * an endless loop always processing the same request over and
+	 * over again. We used to assume that vwv and the byte buffer
+	 * array in a chain are always attached, but OS/2 the
+	 * Write&X/Read&X chain puts the Read&X vwv array right behind
+	 * the Write&X vwv chain. The Write&X bcc array is put behind
+	 * the Read&X vwv array. So now we check whether the chain
+	 * offset points strictly behind the previous vwv
+	 * array. req->buf points right after the vwv array of the
+	 * previous request. See
+	 * https://bugzilla.samba.org/show_bug.cgi?id=8360 for more
+	 * information.
+	 */
 
-		length_needed += num_bytes;
-		if (length_needed > smblen) {
-			return false;
-		}
-		bytes = (const uint8_t *)(vwv+wct+1);
+	already_used = PTR_DIFF(req->buf, smb_base(req->inbuf));
+	if (chain_offset <= already_used) {
+		goto error;
+	}
 
-		if (!fn(chain_cmd, wct, vwv, num_bytes, bytes, private_data)) {
-			return false;
-		}
+	/*
+	 * Next check: Make sure the chain offset does not point beyond the
+	 * overall smb request length.
+	 */
 
-		if (!is_andx_req(chain_cmd)) {
-			return true;
-		}
-		chain_cmd = CVAL(vwv, 0);
+	length_needed = chain_offset+1;	/* wct */
+	if (length_needed > smblen) {
+		goto error;
 	}
-	return true;
-}
 
-static bool smb1_chain_length_cb(uint8_t cmd,
-				 uint8_t wct, const uint16_t *vwv,
-				 uint16_t num_bytes, const uint8_t *bytes,
-				 void *private_data)
-{
-	unsigned *count = (unsigned *)private_data;
-	*count += 1;
-	return true;
-}
+	/*
+	 * Now comes the pointer magic. Goal here is to set up req->vwv and
+	 * req->buf correctly again to be able to call the subsequent
+	 * switch_message(). The chain offset (the former vwv[1]) points at
+	 * the new wct field.
+	 */
 
-unsigned smb1_chain_length(const uint8_t *buf)
-{
-	unsigned count = 0;
+	wct = CVAL(smb_base(req->inbuf), chain_offset);
 
-	if (!smb1_walk_chain(buf, smb1_chain_length_cb, &count)) {
-		return 0;
-	}
-	return count;
-}
+	/*
+	 * Next consistency check: Make the new vwv array fits in the overall
+	 * smb request.
+	 */
 
-struct smb1_parse_chain_state {
-	TALLOC_CTX *mem_ctx;
-	const uint8_t *buf;
-	struct smbd_server_connection *sconn;
-	bool encrypted;
-	uint32_t seqnum;
+	length_needed += (wct+1)*sizeof(uint16_t); /* vwv+buflen */
+	if (length_needed > smblen) {
+		goto error;
+	}
+	vwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);
 
-	struct smb_request **reqs;
-	unsigned num_reqs;
-};
+	/*
+	 * Now grab the new byte buffer....
+	 */
 
-static bool smb1_parse_chain_cb(uint8_t cmd,
-				uint8_t wct, const uint16_t *vwv,
-				uint16_t num_bytes, const uint8_t *bytes,
-				void *private_data)
-{
-	struct smb1_parse_chain_state *state =
-		(struct smb1_parse_chain_state *)private_data;
-	struct smb_request **reqs;
-	struct smb_request *req;
-	bool ok;
+	buflen = SVAL(vwv+wct, 0);
 
-	reqs = talloc_realloc(state->mem_ctx, state->reqs,
-			      struct smb_request *, state->num_reqs+1);
-	if (reqs == NULL) {
-		return false;
-	}
-	state->reqs = reqs;
+	/*
+	 * .. and check that it fits.
+	 */
 
-	req = talloc(reqs, struct smb_request);
-	if (req == NULL) {
-		return false;
+	length_needed += buflen;
+	if (length_needed > smblen) {
+		goto error;
 	}
+	buf = (uint8_t *)(vwv+wct+1);
 
-	ok = init_smb_request(req, state->sconn, state->buf, 0,
-			      state->encrypted, state->seqnum);
-	if (!ok) {
-		return false;
-	}
-	req->cmd = cmd;
+	req->cmd = chain_cmd;
 	req->wct = wct;
 	req->vwv = vwv;
-	req->buflen = num_bytes;
-	req->buf = bytes;
+	req->buflen = buflen;
+	req->buf = buf;
 
-	reqs[state->num_reqs] = req;
-	state->num_reqs += 1;
-	return true;
-}
+	switch_message(chain_cmd, req, smblen);
 
-bool smb1_parse_chain(TALLOC_CTX *mem_ctx, const uint8_t *buf,
-		      struct smbd_server_connection *sconn,
-		      bool encrypted, uint32_t seqnum,
-		      struct smb_request ***reqs, unsigned *num_reqs)
-{
-	struct smb1_parse_chain_state state;
-	unsigned i;
-
-	state.mem_ctx = mem_ctx;
-	state.buf = buf;
-	state.sconn = sconn;
-	state.encrypted = encrypted;
-	state.seqnum = seqnum;
-	state.reqs = NULL;
-	state.num_reqs = 0;
-
-	if (!smb1_walk_chain(buf, smb1_parse_chain_cb, &state)) {
-		TALLOC_FREE(state.reqs);
-		return false;
+	if (req->outbuf == NULL) {
+		/*
+		 * This happens if the chained command has suspended itself or
+		 * if it has called srv_send_smb() itself.
+		 */
+		return;
 	}
-	for (i=0; i<state.num_reqs; i++) {
-		state.reqs[i]->chain = state.reqs;
+
+	/*
+	 * We end up here if the chained command was not itself chained or
+	 * suspended, but for example a close() command. We now need to splice
+	 * the chained commands' outbuf into the already built up chain_outbuf
+	 * and ship the result.
+	 */
+	goto done;
+
+ error:
+	/*
+	 * We end up here if there's any error in the chain syntax. Report a
+	 * DOS error, just like Windows does.
+	 */
+	reply_force_doserror(req, ERRSRV, ERRerror);
+	fixup_chain_error_packet(req);
+
+ done:
+	/*
+	 * This scary statement intends to set the
+	 * FLAGS2_32_BIT_ERROR_CODES flg2 field in req->chain_outbuf
+	 * to the value req->outbuf carries
+	 */
+	SSVAL(req->chain_outbuf, smb_flg2,
+	      (SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)
+	      | (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));
+
+	/*
+	 * Transfer the error codes from the subrequest to the main one
+	 */
+	SSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));
+	SSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));
+
+	if (!smb_splice_chain(&req->chain_outbuf,
+			      CVAL(req->outbuf, smb_com),
+			      CVAL(req->outbuf, smb_wct),
+			      (uint16_t *)(req->outbuf + smb_vwv),
+			      0, smb_buflen(req->outbuf),
+			      (uint8_t *)smb_buf(req->outbuf))) {
+		exit_server_cleanly("chain_reply: smb_splice_chain failed\n");
+	}
+	TALLOC_FREE(req->outbuf);
+
+	smb_setlen((char *)(req->chain_outbuf),
+		   talloc_get_size(req->chain_outbuf) - 4);
+
+	show_msg((char *)(req->chain_outbuf));
+
+	if (!srv_send_smb(req->sconn, (char *)req->chain_outbuf,
+			  true, req->seqnum+1,
+			  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,
+			  &req->pcd)) {
+		exit_server_cleanly("chain_reply: srv_send_smb failed.");
 	}
-	*reqs = state.reqs;
-	*num_reqs = state.num_reqs;
-	return true;
+	TALLOC_FREE(req->chain_outbuf);
+	req->done = true;
 }
 
 /****************************************************************************
@@ -2356,7 +2189,7 @@
 	}
 
 	if (t >= last_smb_conf_reload_time+SMBD_RELOAD_CHECK) {
-		reload_services(sconn, conn_snum_used, true);
+		reload_services(sconn->msg_ctx, sconn->sock, True);
 		last_smb_conf_reload_time = t;
 	}
 }
@@ -2371,14 +2204,13 @@
 
 }
 
-static void smbd_server_connection_write_handler(
-	struct smbd_server_connection *sconn)
+static void smbd_server_connection_write_handler(struct smbd_server_connection *conn)
 {
 	/* TODO: make write nonblocking */
 }
 
 static void smbd_server_connection_read_handler(
-	struct smbd_server_connection *sconn, int fd)
+	struct smbd_server_connection *conn, int fd)
 {
 	uint8_t *inbuf = NULL;
 	size_t inbuf_len = 0;
@@ -2388,41 +2220,35 @@
 	NTSTATUS status;
 	uint32_t seqnum;
 
-	bool from_client;
-
-	if (lp_async_smb_echo_handler()
-	    && fd_is_readable(sconn->smb1.echo_handler.trusted_fd)) {
-		/*
-		 * This is the super-ugly hack to prefer the packets
-		 * forwarded by the echo handler over the ones by the
-		 * client directly
-		 */
-		fd = sconn->smb1.echo_handler.trusted_fd;
-	}
-
-	from_client = (sconn->sock == fd);
+	bool from_client = (conn->sock == fd);
 
 	if (from_client) {
-		smbd_lock_socket(sconn);
+		smbd_lock_socket(conn);
 
-		if (!fd_is_readable(fd)) {
+		if (lp_async_smb_echo_handler() && !fd_is_readable(fd)) {
 			DEBUG(10,("the echo listener was faster\n"));
-			smbd_unlock_socket(sconn);
+			smbd_unlock_socket(conn);
 			return;
 		}
-	}
-
-	/* TODO: make this completely nonblocking */
-	status = receive_smb_talloc(mem_ctx, sconn, fd,
-				    (char **)(void *)&inbuf,
-				    0, /* timeout */
-				    &unread_bytes,
-				    &encrypted,
-				    &inbuf_len, &seqnum,
-				    !from_client /* trusted channel */);
 
-	if (from_client) {
-		smbd_unlock_socket(sconn);
+		/* TODO: make this completely nonblocking */
+		status = receive_smb_talloc(mem_ctx, conn, fd,
+					    (char **)(void *)&inbuf,
+					    0, /* timeout */
+					    &unread_bytes,
+					    &encrypted,
+					    &inbuf_len, &seqnum,
+					    false /* trusted channel */);
+		smbd_unlock_socket(conn);
+	} else {
+		/* TODO: make this completely nonblocking */
+		status = receive_smb_talloc(mem_ctx, conn, fd,
+					    (char **)(void *)&inbuf,
+					    0, /* timeout */
+					    &unread_bytes,
+					    &encrypted,
+					    &inbuf_len, &seqnum,
+					    true /* trusted channel */);
 	}
 
 	if (NT_STATUS_EQUAL(status, NT_STATUS_RETRY)) {
@@ -2436,7 +2262,7 @@
 	}
 
 process:
-	process_smb(sconn, inbuf, inbuf_len, unread_bytes,
+	process_smb(conn, inbuf, inbuf_len, unread_bytes,
 		    seqnum, encrypted, NULL);
 }
 
@@ -2448,20 +2274,11 @@
 	struct smbd_server_connection *conn = talloc_get_type(private_data,
 					      struct smbd_server_connection);
 
-	if (!NT_STATUS_IS_OK(conn->status)) {
-		/*
-		 * we're not supposed to do any io
-		 */
-		TEVENT_FD_NOT_READABLE(conn->smb1.fde);
-		TEVENT_FD_NOT_WRITEABLE(conn->smb1.fde);
-		return;
-	}
-
-	if (flags & TEVENT_FD_WRITE) {
+	if (flags & EVENT_FD_WRITE) {
 		smbd_server_connection_write_handler(conn);
 		return;
 	}
-	if (flags & TEVENT_FD_READ) {
+	if (flags & EVENT_FD_READ) {
 		smbd_server_connection_read_handler(conn, conn->sock);
 		return;
 	}
@@ -2475,68 +2292,25 @@
 	struct smbd_server_connection *conn = talloc_get_type(private_data,
 					      struct smbd_server_connection);
 
-	if (!NT_STATUS_IS_OK(conn->status)) {
-		/*
-		 * we're not supposed to do any io
-		 */
-		TEVENT_FD_NOT_READABLE(conn->smb1.echo_handler.trusted_fde);
-		TEVENT_FD_NOT_WRITEABLE(conn->smb1.echo_handler.trusted_fde);
-		return;
-	}
-
-	if (flags & TEVENT_FD_WRITE) {
+	if (flags & EVENT_FD_WRITE) {
 		smbd_server_connection_write_handler(conn);
 		return;
 	}
-	if (flags & TEVENT_FD_READ) {
+	if (flags & EVENT_FD_READ) {
 		smbd_server_connection_read_handler(
 			conn, conn->smb1.echo_handler.trusted_fd);
 		return;
 	}
 }
 
-#ifdef CLUSTER_SUPPORT
-
-struct smbd_release_ip_state {
-	struct smbd_server_connection *sconn;
-	struct tevent_immediate *im;
-	char addr[INET6_ADDRSTRLEN];
-};
-
-static void smbd_release_ip_immediate(struct tevent_context *ctx,
-				      struct tevent_immediate *im,
-				      void *private_data)
-{
-	struct smbd_release_ip_state *state =
-		talloc_get_type_abort(private_data,
-		struct smbd_release_ip_state);
-
-	if (!NT_STATUS_EQUAL(state->sconn->status, NT_STATUS_ADDRESS_CLOSED)) {
-		/*
-		 * smbd_server_connection_terminate() already triggered ?
-		 */
-		return;
-	}
-
-	smbd_server_connection_terminate(state->sconn, "CTDB_SRVID_RELEASE_IP");
-}
-
 /****************************************************************************
 received when we should release a specific IP
 ****************************************************************************/
-static bool release_ip(const char *ip, void *priv)
+static void release_ip(const char *ip, void *priv)
 {
-	struct smbd_release_ip_state *state =
-		talloc_get_type_abort(priv,
-		struct smbd_release_ip_state);
-	const char *addr = state->addr;
+	const char *addr = (const char *)priv;
 	const char *p = addr;
 
-	if (!NT_STATUS_IS_OK(state->sconn->status)) {
-		/* avoid recursion */
-		return false;
-	}
-
 	if (strncmp("::ffff:", addr, 7) == 0) {
 		p = addr + 7;
 	}
@@ -2545,70 +2319,29 @@
 		   "our address is %s\n", ip, p));
 
 	if ((strcmp(p, ip) == 0) || ((p != addr) && strcmp(addr, ip) == 0)) {
+		/* we can't afford to do a clean exit - that involves
+		   database writes, which would potentially mean we
+		   are still running after the failover has finished -
+		   we have to get rid of this process ID straight
+		   away */
 		DEBUG(0,("Got release IP message for our IP %s - exiting immediately\n",
 			ip));
-		/*
-		 * With SMB2 we should do a clean disconnect,
-		 * the previous_session_id in the session setup
-		 * will cleanup the old session, tcons and opens.
-		 *
-		 * A clean disconnect is needed in order to support
-		 * durable handles.
-		 *
-		 * Note: typically this is never triggered
-		 *       as we got a TCP RST (triggered by ctdb event scripts)
-		 *       before we get CTDB_SRVID_RELEASE_IP.
-		 *
-		 * We used to call _exit(1) here, but as this was mostly never
-		 * triggered and has implication on our process model,
-		 * we can just use smbd_server_connection_terminate()
-		 * (also for SMB1).
-		 *
-		 * We don't call smbd_server_connection_terminate() directly
-		 * as we might be called from within ctdbd_migrate(),
-		 * we need to defer our action to the next event loop
-		 */
-		tevent_schedule_immediate(state->im, state->sconn->ev_ctx,
-					  smbd_release_ip_immediate, state);
-
-		/*
-		 * Make sure we don't get any io on the connection.
-		 */
-		state->sconn->status = NT_STATUS_ADDRESS_CLOSED;
-		return true;
+		/* note we must exit with non-zero status so the unclean handler gets
+		   called in the parent, so that the brl database is tickled */
+		_exit(1);
 	}
-
-	return false;
 }
 
-static NTSTATUS smbd_register_ips(struct smbd_server_connection *sconn,
-				  struct sockaddr_storage *srv,
-				  struct sockaddr_storage *clnt)
+static void msg_release_ip(struct messaging_context *msg_ctx, void *private_data,
+			   uint32_t msg_type, struct server_id server_id, DATA_BLOB *data)
 {
-	struct smbd_release_ip_state *state;
-	struct ctdbd_connection *cconn;
-
-	cconn = messaging_ctdbd_connection();
-	if (cconn == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	state = talloc_zero(sconn, struct smbd_release_ip_state);
-	if (state == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	state->sconn = sconn;
-	state->im = tevent_create_immediate(state);
-	if (state->im == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	if (print_sockaddr(state->addr, sizeof(state->addr), srv) == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
+	struct smbd_server_connection *sconn = talloc_get_type_abort(
+		private_data, struct smbd_server_connection);
 
-	return ctdbd_register_ips(cconn, srv, clnt, release_ip, state);
+	release_ip((char *)data->data, sconn->client_id.addr);
 }
 
+#ifdef CLUSTER_SUPPORT
 static int client_get_tcp_info(int sock, struct sockaddr_storage *server,
 			       struct sockaddr_storage *client)
 {
@@ -2630,8 +2363,7 @@
  */
 static bool keepalive_fn(const struct timeval *now, void *private_data)
 {
-	struct smbd_server_connection *sconn = talloc_get_type_abort(
-		private_data, struct smbd_server_connection);
+	struct smbd_server_connection *sconn = smbd_server_conn;
 	bool ret;
 
 	if (sconn->using_smb2) {
@@ -2639,9 +2371,9 @@
 		return false;
 	}
 
-	smbd_lock_socket(sconn);
+	smbd_lock_socket(smbd_server_conn);
 	ret = send_keepalive(sconn->sock);
-	smbd_unlock_socket(sconn);
+	smbd_unlock_socket(smbd_server_conn);
 
 	if (!ret) {
 		char addr[INET6_ADDRSTRLEN];
@@ -2697,6 +2429,9 @@
 	/* check if we need to reload services */
 	check_reload(sconn, time_mono(NULL));
 
+	/* Change machine password if neccessary. */
+	attempt_machine_password_change();
+
         /*
 	 * Force a log file check.
 	 */
@@ -2705,158 +2440,30 @@
 	return true;
 }
 
-/*
- * Read an smb packet in the echo handler child, giving the parent
- * smbd one second to react once the socket becomes readable.
- */
-
-struct smbd_echo_read_state {
-	struct tevent_context *ev;
-	struct smbd_server_connection *sconn;
-
-	char *buf;
-	size_t buflen;
-	uint32_t seqnum;
-};
-
-static void smbd_echo_read_readable(struct tevent_req *subreq);
-static void smbd_echo_read_waited(struct tevent_req *subreq);
-
-static struct tevent_req *smbd_echo_read_send(
-	TALLOC_CTX *mem_ctx, struct tevent_context *ev,
-	struct smbd_server_connection *sconn)
-{
-	struct tevent_req *req, *subreq;
-	struct smbd_echo_read_state *state;
-
-	req = tevent_req_create(mem_ctx, &state,
-				struct smbd_echo_read_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->ev = ev;
-	state->sconn = sconn;
-
-	subreq = wait_for_read_send(state, ev, sconn->sock);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
-	}
-	tevent_req_set_callback(subreq, smbd_echo_read_readable, req);
-	return req;
-}
-
-static void smbd_echo_read_readable(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smbd_echo_read_state *state = tevent_req_data(
-		req, struct smbd_echo_read_state);
-	bool ok;
-	int err;
-
-	ok = wait_for_read_recv(subreq, &err);
-	TALLOC_FREE(subreq);
-	if (!ok) {
-		tevent_req_nterror(req, map_nt_error_from_unix(err));
-		return;
-	}
-
-	/*
-	 * Give the parent smbd one second to step in
-	 */
-
-	subreq = tevent_wakeup_send(
-		state, state->ev, timeval_current_ofs(1, 0));
-	if (tevent_req_nomem(subreq, req)) {
-		return;
-	}
-	tevent_req_set_callback(subreq, smbd_echo_read_waited, req);
-}
-
-static void smbd_echo_read_waited(struct tevent_req *subreq)
+static int create_unlink_tmp(const char *dir)
 {
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smbd_echo_read_state *state = tevent_req_data(
-		req, struct smbd_echo_read_state);
-	struct smbd_server_connection *sconn = state->sconn;
-	bool ok;
-	NTSTATUS status;
-	size_t unread = 0;
-	bool encrypted;
-
-	ok = tevent_wakeup_recv(subreq);
-	TALLOC_FREE(subreq);
-	if (!ok) {
-		tevent_req_nterror(req, NT_STATUS_INTERNAL_ERROR);
-		return;
-	}
+	char *fname;
+	int fd;
 
-	ok = smbd_lock_socket_internal(sconn);
-	if (!ok) {
-		tevent_req_nterror(req, map_nt_error_from_unix(errno));
-		DEBUG(0, ("%s: failed to lock socket\n", __location__));
-		return;
-	}
-
-	if (!fd_is_readable(sconn->sock)) {
-		DEBUG(10,("echo_handler[%d] the parent smbd was faster\n",
-			  (int)getpid()));
-
-		ok = smbd_unlock_socket_internal(sconn);
-		if (!ok) {
-			tevent_req_nterror(req, map_nt_error_from_unix(errno));
-			DEBUG(1, ("%s: failed to unlock socket\n",
-				__location__));
-			return;
-		}
-
-		subreq = wait_for_read_send(state, state->ev, sconn->sock);
-		if (tevent_req_nomem(subreq, req)) {
-			return;
-		}
-		tevent_req_set_callback(subreq, smbd_echo_read_readable, req);
-		return;
-	}
-
-	status = receive_smb_talloc(state, sconn, sconn->sock, &state->buf,
-				    0 /* timeout */,
-				    &unread,
-				    &encrypted,
-				    &state->buflen,
-				    &state->seqnum,
-				    false /* trusted_channel*/);
-
-	if (tevent_req_nterror(req, status)) {
-		tevent_req_nterror(req, status);
-		DEBUG(1, ("echo_handler[%d]: receive_smb_raw_talloc failed: %s\n",
-			  (int)getpid(), nt_errstr(status)));
-		return;
+	fname = talloc_asprintf(talloc_tos(), "%s/listenerlock_XXXXXX", dir);
+	if (fname == NULL) {
+		errno = ENOMEM;
+		return -1;
 	}
-
-	ok = smbd_unlock_socket_internal(sconn);
-	if (!ok) {
-		tevent_req_nterror(req, map_nt_error_from_unix(errno));
-		DEBUG(1, ("%s: failed to unlock socket\n", __location__));
-		return;
+	fd = mkstemp(fname);
+	if (fd == -1) {
+		TALLOC_FREE(fname);
+		return -1;
 	}
-	tevent_req_done(req);
-}
-
-static NTSTATUS smbd_echo_read_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx,
-				    char **pbuf, size_t *pbuflen, uint32_t *pseqnum)
-{
-	struct smbd_echo_read_state *state = tevent_req_data(
-		req, struct smbd_echo_read_state);
-	NTSTATUS status;
-
-	if (tevent_req_is_nterror(req, &status)) {
-		return status;
+	if (unlink(fname) == -1) {
+		int sys_errno = errno;
+		close(fd);
+		TALLOC_FREE(fname);
+		errno = sys_errno;
+		return -1;
 	}
-	*pbuf = talloc_move(mem_ctx, &state->buf);
-	*pbuflen = state->buflen;
-	*pseqnum = state->seqnum;
-	return NT_STATUS_OK;
+	TALLOC_FREE(fname);
+	return fd;
 }
 
 struct smbd_echo_state {
@@ -2867,6 +2474,7 @@
 
 	struct tevent_fd *parent_fde;
 
+	struct tevent_fd *read_fde;
 	struct tevent_req *write_req;
 };
 
@@ -2914,20 +2522,20 @@
 		DEBUG(1, ("writev to parent failed: %s\n", strerror(err)));
 		exit(1);
 	}
-	DEBUG(10,("echo_handler[%d]: forwarded pdu to main\n", (int)getpid()));
+	DEBUG(10,("echo_handler[%d]: forwarded pdu to main\n", (int)sys_getpid()));
 	smbd_echo_activate_writer(state);
 }
 
-static bool smbd_echo_reply(struct smbd_echo_state *state,
-			    uint8_t *inbuf, size_t inbuf_len,
+static bool smbd_echo_reply(uint8_t *inbuf, size_t inbuf_len,
 			    uint32_t seqnum)
 {
 	struct smb_request req;
 	uint16_t num_replies;
+	size_t out_len;
 	char *outbuf;
 	bool ok;
 
-	if ((inbuf_len == 4) && (CVAL(inbuf, 0) == NBSSkeepalive)) {
+	if ((inbuf_len == 4) && (CVAL(inbuf, 0) == SMBkeepalive)) {
 		DEBUG(10, ("Got netbios keepalive\n"));
 		/*
 		 * Just swallow it
@@ -2939,12 +2547,12 @@
 		DEBUG(10, ("Got short packet: %d bytes\n", (int)inbuf_len));
 		return false;
 	}
-	if (!valid_smb_header(state->sconn, inbuf)) {
+	if (!valid_smb_header(inbuf)) {
 		DEBUG(10, ("Got invalid SMB header\n"));
 		return false;
 	}
 
-	if (!init_smb_request(&req, state->sconn, inbuf, 0, false,
+	if (!init_smb_request(&req, smbd_server_conn, inbuf, 0, false,
 			      seqnum)) {
 		return false;
 	}
@@ -2967,7 +2575,7 @@
 		return false;
 	}
 
-	if (!create_outbuf(talloc_tos(), &req, (const char *)req.inbuf, &outbuf,
+	if (!create_outbuf(talloc_tos(), &req, (char *)req.inbuf, &outbuf,
 			   1, req.buflen)) {
 		DEBUG(10, ("create_outbuf failed\n"));
 		return false;
@@ -2980,6 +2588,8 @@
 		memcpy(smb_buf(req.outbuf), req.buf, req.buflen);
 	}
 
+	out_len = smb_len(req.outbuf) + 4;
+
 	ok = srv_send_smb(req.sconn,
 			  (char *)outbuf,
 			  true, seqnum+1,
@@ -3000,13 +2610,107 @@
 	exit(0);
 }
 
-static void smbd_echo_got_packet(struct tevent_req *req);
+static void smbd_echo_reader(struct tevent_context *ev,
+			     struct tevent_fd *fde, uint16_t flags,
+			     void *private_data)
+{
+	struct smbd_echo_state *state = talloc_get_type_abort(
+		private_data, struct smbd_echo_state);
+	struct smbd_server_connection *sconn = state->sconn;
+	size_t unread, num_pending;
+	NTSTATUS status;
+	struct iovec *tmp;
+	size_t iov_len;
+	uint32_t seqnum = 0;
+	bool reply;
+	bool ok;
+	bool encrypted = false;
+
+	smb_msleep(1000);
+
+	ok = smbd_lock_socket_internal(sconn);
+	if (!ok) {
+		DEBUG(0, ("%s: failed to lock socket\n",
+			__location__));
+		exit(1);
+	}
+
+	if (!fd_is_readable(sconn->sock)) {
+		DEBUG(10,("echo_handler[%d] the parent smbd was faster\n",
+			  (int)sys_getpid()));
+		ok = smbd_unlock_socket_internal(sconn);
+		if (!ok) {
+			DEBUG(1, ("%s: failed to unlock socket in\n",
+				__location__));
+			exit(1);
+		}
+		return;
+	}
+
+	num_pending = talloc_array_length(state->pending);
+	tmp = talloc_realloc(state, state->pending, struct iovec,
+			     num_pending+1);
+	if (tmp == NULL) {
+		DEBUG(1, ("talloc_realloc failed\n"));
+		exit(1);
+	}
+	state->pending = tmp;
+
+	DEBUG(10,("echo_handler[%d]: reading pdu\n", (int)sys_getpid()));
+
+	status = receive_smb_talloc(state->pending, sconn, sconn->sock,
+				    (char **)(void *)&state->pending[num_pending].iov_base,
+				    0 /* timeout */,
+				    &unread,
+				    &encrypted,
+				    &iov_len,
+				    &seqnum,
+				    false /* trusted_channel*/);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(1, ("echo_handler[%d]: receive_smb_raw_talloc failed: %s\n",
+			  (int)sys_getpid(), nt_errstr(status)));
+		exit(1);
+	}
+	state->pending[num_pending].iov_len = iov_len;
+
+	ok = smbd_unlock_socket_internal(sconn);
+	if (!ok) {
+		DEBUG(1, ("%s: failed to unlock socket in\n",
+			__location__));
+		exit(1);
+	}
+
+	reply = smbd_echo_reply((uint8_t *)state->pending[num_pending].iov_base,
+				state->pending[num_pending].iov_len,
+				seqnum);
+	if (reply) {
+		DEBUG(10,("echo_handler[%d]: replied to client\n", (int)sys_getpid()));
+		/* no check, shrinking by some bytes does not fail */
+		state->pending = talloc_realloc(state, state->pending,
+						struct iovec,
+						num_pending);
+		return;
+	}
+
+	if (state->pending[num_pending].iov_len >= smb_size) {
+		/*
+		 * place the seqnum in the packet so that the main process
+		 * can reply with signing
+		 */
+		SIVAL((uint8_t *)state->pending[num_pending].iov_base,
+		      smb_ss_field, seqnum);
+		SIVAL((uint8_t *)state->pending[num_pending].iov_base,
+		      smb_ss_field+4, NT_STATUS_V(NT_STATUS_OK));
+	}
+
+	DEBUG(10,("echo_handler[%d]: forward to main\n", (int)sys_getpid()));
+	smbd_echo_activate_writer(state);
+}
 
 static void smbd_echo_loop(struct smbd_server_connection *sconn,
 			   int parent_pipe)
 {
 	struct smbd_echo_state *state;
-	struct tevent_req *read_req;
 
 	state = talloc_zero(sconn, struct smbd_echo_state);
 	if (state == NULL) {
@@ -3029,14 +2733,14 @@
 		TALLOC_FREE(state);
 		return;
 	}
-
-	read_req = smbd_echo_read_send(state, state->ev, sconn);
-	if (read_req == NULL) {
-		DEBUG(1, ("smbd_echo_read_send failed\n"));
+	state->read_fde = tevent_add_fd(state->ev, state, sconn->sock,
+					TEVENT_FD_READ, smbd_echo_reader,
+					state);
+	if (state->read_fde == NULL) {
+		DEBUG(1, ("tevent_add_fd failed\n"));
 		TALLOC_FREE(state);
 		return;
 	}
-	tevent_req_set_callback(read_req, smbd_echo_got_packet, state);
 
 	while (true) {
 		if (tevent_loop_once(state->ev) == -1) {
@@ -3048,66 +2752,6 @@
 	TALLOC_FREE(state);
 }
 
-static void smbd_echo_got_packet(struct tevent_req *req)
-{
-	struct smbd_echo_state *state = tevent_req_callback_data(
-		req, struct smbd_echo_state);
-	NTSTATUS status;
-	char *buf = NULL;
-	size_t buflen = 0;
-	uint32_t seqnum = 0;
-	bool reply;
-
-	status = smbd_echo_read_recv(req, state, &buf, &buflen, &seqnum);
-	TALLOC_FREE(req);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(1, ("smbd_echo_read_recv returned %s\n",
-			  nt_errstr(status)));
-		exit(1);
-	}
-
-	reply = smbd_echo_reply(state, (uint8_t *)buf, buflen, seqnum);
-	if (!reply) {
-		size_t num_pending;
-		struct iovec *tmp;
-		struct iovec *iov;
-
-		num_pending = talloc_array_length(state->pending);
-		tmp = talloc_realloc(state, state->pending, struct iovec,
-				     num_pending+1);
-		if (tmp == NULL) {
-			DEBUG(1, ("talloc_realloc failed\n"));
-			exit(1);
-		}
-		state->pending = tmp;
-
-		if (buflen >= smb_size) {
-			/*
-			 * place the seqnum in the packet so that the main process
-			 * can reply with signing
-			 */
-			SIVAL(buf, smb_ss_field, seqnum);
-			SIVAL(buf, smb_ss_field+4, NT_STATUS_V(NT_STATUS_OK));
-		}
-
-		iov = &state->pending[num_pending];
-		iov->iov_base = talloc_move(state->pending, &buf);
-		iov->iov_len = buflen;
-
-		DEBUG(10,("echo_handler[%d]: forward to main\n",
-			  (int)getpid()));
-		smbd_echo_activate_writer(state);
-	}
-
-	req = smbd_echo_read_send(state, state->ev, state->sconn);
-	if (req == NULL) {
-		DEBUG(1, ("smbd_echo_read_send failed\n"));
-		exit(1);
-	}
-	tevent_req_set_callback(req, smbd_echo_got_packet, state);
-}
-
-
 /*
  * Handle SMBecho requests in a forked child process
  */
@@ -3128,7 +2772,7 @@
 		goto fail;
 	}
 
-	child = fork();
+	child = sys_fork();
 	if (child == 0) {
 		NTSTATUS status;
 
@@ -3136,8 +2780,8 @@
 		set_blocking(listener_pipe[1], false);
 
 		status = reinit_after_fork(sconn->msg_ctx,
-					   sconn->ev_ctx,
-					   false);
+					   smbd_event_context(),
+					   procid_self(), false);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(1, ("reinit_after_fork failed: %s\n",
 				  nt_errstr(status)));
@@ -3150,16 +2794,16 @@
 	listener_pipe[1] = -1;
 	sconn->smb1.echo_handler.trusted_fd = listener_pipe[0];
 
-	DEBUG(10,("fork_echo_handler: main[%d] echo_child[%d]\n", (int)getpid(), child));
+	DEBUG(10,("fork_echo_handler: main[%d] echo_child[%d]\n", (int)sys_getpid(), child));
 
 	/*
 	 * Without smb signing this is the same as the normal smbd
 	 * listener. This needs to change once signing comes in.
 	 */
-	sconn->smb1.echo_handler.trusted_fde = tevent_add_fd(sconn->ev_ctx,
+	sconn->smb1.echo_handler.trusted_fde = event_add_fd(smbd_event_context(),
 					sconn,
 					sconn->smb1.echo_handler.trusted_fd,
-					TEVENT_FD_READ,
+					EVENT_FD_READ,
 					smbd_server_echo_handler,
 					sconn);
 	if (sconn->smb1.echo_handler.trusted_fde == NULL) {
@@ -3185,231 +2829,47 @@
 	return false;
 }
 
-static bool uid_in_use(const struct user_struct *user, uid_t uid)
-{
-	while (user) {
-		if (user->session_info &&
-		    (user->session_info->unix_token->uid == uid)) {
-			return true;
-		}
-		user = user->next;
-	}
-	return false;
-}
-
-static bool gid_in_use(const struct user_struct *user, gid_t gid)
-{
-	while (user) {
-		if (user->session_info != NULL) {
-			int i;
-			struct security_unix_token *utok;
-
-			utok = user->session_info->unix_token;
-			if (utok->gid == gid) {
-				return true;
-			}
-			for(i=0; i<utok->ngroups; i++) {
-				if (utok->groups[i] == gid) {
-					return true;
-				}
-			}
-		}
-		user = user->next;
-	}
-	return false;
-}
-
-static bool sid_in_use(const struct user_struct *user,
-		       const struct dom_sid *psid)
-{
-	while (user) {
-		struct security_token *tok;
+#if CLUSTER_SUPPORT
 
-		if (user->session_info == NULL) {
-			continue;
-		}
-		tok = user->session_info->security_token;
-		if (tok == NULL) {
-			/*
-			 * Not sure session_info->security_token can
-			 * ever be NULL. This check might be not
-			 * necessary.
-			 */
-			continue;
-		}
-		if (security_token_has_sid(tok, psid)) {
-			return true;
-		}
-		user = user->next;
-	}
-	return false;
-}
-
-static bool id_in_use(const struct user_struct *user,
-		      const struct id_cache_ref *id)
+static NTSTATUS smbd_register_ips(struct smbd_server_connection *sconn,
+				  struct sockaddr_storage *srv,
+				  struct sockaddr_storage *clnt)
 {
-	switch(id->type) {
-	case UID:
-		return uid_in_use(user, id->id.uid);
-	case GID:
-		return gid_in_use(user, id->id.gid);
-	case SID:
-		return sid_in_use(user, &id->id.sid);
-	default:
-		break;
-	}
-	return false;
-}
-
-static void smbd_id_cache_kill(struct messaging_context *msg_ctx,
-			       void *private_data,
-			       uint32_t msg_type,
-			       struct server_id server_id,
-			       DATA_BLOB* data)
-{
-	const char *msg = (data && data->data)
-		? (const char *)data->data : "<NULL>";
-	struct id_cache_ref id;
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
-
-	if (!id_cache_ref_parse(msg, &id)) {
-		DEBUG(0, ("Invalid ?ID: %s\n", msg));
-		return;
-	}
+	struct ctdbd_connection *cconn;
+	char tmp_addr[INET6_ADDRSTRLEN];
+	char *addr;
 
-	if (id_in_use(sconn->users, &id)) {
-		exit_server_cleanly(msg);
+	cconn = messaging_ctdbd_connection();
+	if (cconn == NULL) {
+		return NT_STATUS_NO_MEMORY;
 	}
-	id_cache_delete_from_cache(&id);
-}
-
-NTSTATUS smbXsrv_connection_init_tables(struct smbXsrv_connection *conn,
-					enum protocol_types protocol)
-{
-	NTSTATUS status;
-
-	set_Protocol(protocol);
-	conn->protocol = protocol;
-
-	if (protocol >= PROTOCOL_SMB2_02) {
-		status = smb2srv_session_table_init(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
 
-		status = smb2srv_open_table_init(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	} else {
-		status = smb1srv_session_table_init(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-
-		status = smb1srv_tcon_table_init(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-
-		status = smb1srv_open_table_init(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
+	client_socket_addr(sconn->sock, tmp_addr, sizeof(tmp_addr));
+	addr = talloc_strdup(cconn, tmp_addr);
+	if (addr == NULL) {
+		return NT_STATUS_NO_MEMORY;
 	}
-
-	return NT_STATUS_OK;
+	return ctdbd_register_ips(cconn, srv, clnt, release_ip, addr);
 }
 
-static void smbd_tevent_trace_callback(enum tevent_trace_point point,
-				       void *private_data)
-{
-	struct smbXsrv_connection *conn =
-		talloc_get_type_abort(private_data,
-		struct smbXsrv_connection);
-
-	switch (point) {
-	case TEVENT_TRACE_BEFORE_WAIT:
-		/*
-		 * This just removes compiler warning
-		 * without profile support
-		 */
-		conn->smbd_idle_profstamp = 0;
-		START_PROFILE_STAMP(smbd_idle, conn->smbd_idle_profstamp);
-		break;
-	case TEVENT_TRACE_AFTER_WAIT:
-		END_PROFILE_STAMP(smbd_idle, conn->smbd_idle_profstamp);
-		break;
-	}
-}
+#endif
 
 /****************************************************************************
  Process commands from the client
 ****************************************************************************/
 
-void smbd_process(struct tevent_context *ev_ctx,
-		  struct messaging_context *msg_ctx,
-		  int sock_fd,
-		  bool interactive)
+void smbd_process(struct smbd_server_connection *sconn)
 {
 	TALLOC_CTX *frame = talloc_stackframe();
-	struct smbXsrv_connection *conn;
-	struct smbd_server_connection *sconn;
 	struct sockaddr_storage ss;
 	struct sockaddr *sa = NULL;
 	socklen_t sa_socklen;
 	struct tsocket_address *local_address = NULL;
 	struct tsocket_address *remote_address = NULL;
-	const char *locaddr = NULL;
 	const char *remaddr = NULL;
-	char *rhost;
 	int ret;
-	int tmp;
-
-	conn = talloc_zero(ev_ctx, struct smbXsrv_connection);
-	if (conn == NULL) {
-		DEBUG(0,("talloc_zero(struct smbXsrv_connection)\n"));
-		exit_server_cleanly("talloc_zero(struct smbXsrv_connection).\n");
-	}
 
-	conn->ev_ctx = ev_ctx;
-	conn->msg_ctx = msg_ctx;
-
-	sconn = talloc_zero(conn, struct smbd_server_connection);
-	if (!sconn) {
-		exit_server("failed to create smbd_server_connection");
-	}
-
-	conn->sconn = sconn;
-	sconn->conn = conn;
-
-	/*
-	 * TODO: remove this...:-)
-	 */
-	global_smbXsrv_connection = conn;
-
-	sconn->ev_ctx = ev_ctx;
-	sconn->msg_ctx = msg_ctx;
-	sconn->sock = sock_fd;
-	sconn->smb1.echo_handler.trusted_fd = -1;
-	sconn->smb1.echo_handler.socket_lock_fd = -1;
-
-	if (!interactive) {
-		smbd_setup_sig_term_handler(sconn);
-		smbd_setup_sig_hup_handler(sconn);
-
-		if (!serverid_register(messaging_server_id(msg_ctx),
-				       FLAG_MSG_GENERAL|FLAG_MSG_SMBD
-				       |FLAG_MSG_DBWRAP
-				       |FLAG_MSG_PRINT_GENERAL)) {
-			exit_server_cleanly("Could not register myself in "
-					    "serverid.tdb");
-		}
-	}
-
-	if (lp_srv_maxprotocol() >= PROTOCOL_SMB2_02) {
+	if (lp_maxprotocol() == PROTOCOL_SMB2) {
 		/*
 		 * We're not making the decision here,
 		 * we're just allowing the client
@@ -3463,27 +2923,12 @@
 	sconn->local_address = local_address;
 	sconn->remote_address = remote_address;
 
-	if (tsocket_address_is_inet(local_address, "ip")) {
-		locaddr = tsocket_address_inet_addr_string(
-				sconn->local_address,
-				talloc_tos());
-		if (locaddr == NULL) {
-			DEBUG(0,("%s: tsocket_address_inet_addr_string local failed - %s\n",
-				 __location__, strerror(errno)));
-			exit_server_cleanly("tsocket_address_inet_addr_string local failed.\n");
-		}
-	} else {
-		locaddr = "0.0.0.0";
-	}
-
 	if (tsocket_address_is_inet(remote_address, "ip")) {
 		remaddr = tsocket_address_inet_addr_string(
 				sconn->remote_address,
 				talloc_tos());
 		if (remaddr == NULL) {
-			DEBUG(0,("%s: tsocket_address_inet_addr_string remote failed - %s\n",
-				 __location__, strerror(errno)));
-			exit_server_cleanly("tsocket_address_inet_addr_string remote failed.\n");
+
 		}
 	} else {
 		remaddr = "0.0.0.0";
@@ -3492,7 +2937,7 @@
 	/* this is needed so that we get decent entries
 	   in smbstatus for port 445 connects */
 	set_remote_machine_name(remaddr, false);
-	reload_services(sconn, conn_snum_used, true);
+	reload_services(sconn->msg_ctx, sconn->sock, true);
 
 	/*
 	 * Before the first packet, check the global hosts allow/ hosts deny
@@ -3501,26 +2946,9 @@
 	 * the hosts allow list.
 	 */
 
-	ret = get_remote_hostname(remote_address,
-				  &rhost,
-				  talloc_tos());
-	if (ret < 0) {
-		DEBUG(0,("%s: get_remote_hostname failed - %s\n",
-			__location__, strerror(errno)));
-		exit_server_cleanly("get_remote_hostname failed.\n");
-	}
-	if (strequal(rhost, "UNKNOWN")) {
-		rhost = talloc_strdup(talloc_tos(), remaddr);
-	}
-	sconn->remote_hostname = talloc_move(sconn, &rhost);
-
-	sub_set_socket_ids(remaddr,
-			   sconn->remote_hostname,
-			   locaddr);
-
 	if (!allow_access(lp_hostsdeny(-1), lp_hostsallow(-1),
-			  sconn->remote_hostname,
-			  remaddr)) {
+			  sconn->client_id.name,
+			  sconn->client_id.addr)) {
 		/*
 		 * send a negative session response "not listening on calling
 		 * name"
@@ -3538,9 +2966,7 @@
 		   tsocket_address_string(remote_address, talloc_tos()),
 		   tsocket_address_string(local_address, talloc_tos())));
 
-	if (lp_preload_modules()) {
-		smb_load_modules(lp_preload_modules());
-	}
+	init_modules();
 
 	smb_perfcount_init();
 
@@ -3548,48 +2974,33 @@
 		exit_server("Could not open account policy tdb.\n");
 	}
 
-	if (*lp_rootdir(talloc_tos())) {
-		if (chroot(lp_rootdir(talloc_tos())) != 0) {
-			DEBUG(0,("Failed to change root to %s\n",
-				 lp_rootdir(talloc_tos())));
+	if (*lp_rootdir()) {
+		if (chroot(lp_rootdir()) != 0) {
+			DEBUG(0,("Failed to change root to %s\n", lp_rootdir()));
 			exit_server("Failed to chroot()");
 		}
 		if (chdir("/") == -1) {
-			DEBUG(0,("Failed to chdir to / on chroot to %s\n", lp_rootdir(talloc_tos())));
+			DEBUG(0,("Failed to chdir to / on chroot to %s\n", lp_rootdir()));
 			exit_server("Failed to chroot()");
 		}
-		DEBUG(0,("Changed root to %s\n", lp_rootdir(talloc_tos())));
+		DEBUG(0,("Changed root to %s\n", lp_rootdir()));
 	}
 
 	if (!srv_init_signing(sconn)) {
 		exit_server("Failed to init smb_signing");
 	}
 
-	if (!file_init(sconn)) {
-		exit_server("file_init() failed");
-	}
-
 	/* Setup oplocks */
-	if (!init_oplocks(sconn))
+	if (!init_oplocks(sconn->msg_ctx))
 		exit_server("Failed to init oplocks");
 
 	/* register our message handlers */
-	messaging_register(sconn->msg_ctx, sconn,
+	messaging_register(sconn->msg_ctx, NULL,
 			   MSG_SMB_FORCE_TDIS, msg_force_tdis);
 	messaging_register(sconn->msg_ctx, sconn,
+			   MSG_SMB_RELEASE_IP, msg_release_ip);
+	messaging_register(sconn->msg_ctx, NULL,
 			   MSG_SMB_CLOSE_FILE, msg_close_file);
-	messaging_register(sconn->msg_ctx, sconn,
-			   MSG_SMB_FILE_RENAME, msg_file_was_renamed);
-
-	id_cache_register_msgs(sconn->msg_ctx);
-	messaging_deregister(sconn->msg_ctx, ID_CACHE_KILL, NULL);
-	messaging_register(sconn->msg_ctx, sconn,
-			   ID_CACHE_KILL, smbd_id_cache_kill);
-
-	messaging_deregister(sconn->msg_ctx,
-			     MSG_SMB_CONF_UPDATED, sconn->ev_ctx);
-	messaging_register(sconn->msg_ctx, sconn,
-			   MSG_SMB_CONF_UPDATED, smbd_conf_updated);
 
 	/*
 	 * Use the default MSG_DEBUG handler to avoid rebroadcasting
@@ -3601,22 +3012,22 @@
 			   MSG_DEBUG, debug_message);
 
 	if ((lp_keepalive() != 0)
-	    && !(event_add_idle(ev_ctx, NULL,
+	    && !(event_add_idle(smbd_event_context(), NULL,
 				timeval_set(lp_keepalive(), 0),
 				"keepalive", keepalive_fn,
-				sconn))) {
+				NULL))) {
 		DEBUG(0, ("Could not add keepalive event\n"));
 		exit(1);
 	}
 
-	if (!(event_add_idle(ev_ctx, NULL,
+	if (!(event_add_idle(smbd_event_context(), NULL,
 			     timeval_set(IDLE_CLOSED_TIMEOUT, 0),
 			     "deadtime", deadtime_fn, sconn))) {
 		DEBUG(0, ("Could not add deadtime event\n"));
 		exit(1);
 	}
 
-	if (!(event_add_idle(ev_ctx, NULL,
+	if (!(event_add_idle(smbd_event_context(), NULL,
 			     timeval_set(SMBD_HOUSEKEEPING_INTERVAL, 0),
 			     "housekeeping", housekeeping_fn, sconn))) {
 		DEBUG(0, ("Could not add housekeeping event\n"));
@@ -3654,20 +3065,26 @@
 
 	sconn->nbt.got_session = false;
 
-	tmp = lp_max_xmit();
-	tmp = MAX(tmp, SMB_BUFFER_SIZE_MIN);
-	tmp = MIN(tmp, SMB_BUFFER_SIZE_MAX);
-
-	sconn->smb1.negprot.max_recv = tmp;
+	sconn->smb1.negprot.max_recv = MIN(lp_maxxmit(),BUFFER_SIZE);
 
 	sconn->smb1.sessions.done_sesssetup = false;
-	sconn->smb1.sessions.max_send = SMB_BUFFER_SIZE_MAX;
+	sconn->smb1.sessions.max_send = BUFFER_SIZE;
+	sconn->smb1.sessions.last_session_tag = UID_FIELD_INVALID;
+	/* users from session setup */
+	sconn->smb1.sessions.session_userlist = NULL;
+	/* workgroup from session setup. */
+	sconn->smb1.sessions.session_workgroup = NULL;
+	/* this holds info on user ids that are already validated for this VC */
+	sconn->smb1.sessions.validated_users = NULL;
+	sconn->smb1.sessions.next_vuid = VUID_OFFSET;
+	sconn->smb1.sessions.num_validated_vuids = 0;
 
+	conn_init(sconn);
 	if (!init_dptrs(sconn)) {
 		exit_server("init_dptrs() failed");
 	}
 
-	sconn->smb1.fde = event_add_fd(ev_ctx,
+	sconn->smb1.fde = event_add_fd(smbd_event_context(),
 						  sconn,
 						  sconn->sock,
 						  EVENT_FD_READ,
@@ -3677,25 +3094,21 @@
 		exit_server("failed to create smbd_server_connection fde");
 	}
 
-	sconn->conn->local_address = sconn->local_address;
-	sconn->conn->remote_address = sconn->remote_address;
-	sconn->conn->remote_hostname = sconn->remote_hostname;
-	sconn->conn->protocol = PROTOCOL_NONE;
-
 	TALLOC_FREE(frame);
 
-	tevent_set_trace_callback(ev_ctx, smbd_tevent_trace_callback, conn);
-
 	while (True) {
+		NTSTATUS status;
+
 		frame = talloc_stackframe_pool(8192);
 
 		errno = 0;
-		if (tevent_loop_once(ev_ctx) == -1) {
-			if (errno != EINTR) {
-				DEBUG(3, ("tevent_loop_once failed: %s,"
-					  " exiting\n", strerror(errno) ));
-				break;
-			}
+
+		status = smbd_server_connection_loop_once(sconn);
+		if (!NT_STATUS_EQUAL(status, NT_STATUS_RETRY) &&
+		    !NT_STATUS_IS_OK(status)) {
+			DEBUG(3, ("smbd_server_connection_loop_once failed: %s,"
+				  " exiting\n", nt_errstr(status)));
+			break;
 		}
 
 		TALLOC_FREE(frame);
@@ -3704,9 +3117,9 @@
 	exit_server_cleanly(NULL);
 }
 
-bool req_is_in_chain(const struct smb_request *req)
+bool req_is_in_chain(struct smb_request *req)
 {
-	if (req->vwv != (const uint16_t *)(req->inbuf+smb_vwv)) {
+	if (req->vwv != (uint16_t *)(req->inbuf+smb_vwv)) {
 		/*
 		 * We're right now handling a subsequent request, so we must
 		 * be in a chain
Only in ../../samba-3.6.24/source3/smbd: process.o
diff -ur smbd/proto.h ../../samba-3.6.24/source3/smbd/proto.h
--- smbd/proto.h	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/proto.h	2015-01-28 10:52:25.149068676 +0800
@@ -48,14 +48,14 @@
 
 /* The following definitions come from smbd/signing.c  */
 
+struct smbd_server_connection;
 bool srv_check_sign_mac(struct smbd_server_connection *conn,
 			const char *inbuf, uint32_t *seqnum, bool trusted_channel);
 void srv_calculate_sign_mac(struct smbd_server_connection *conn,
 			    char *outbuf, uint32_t seqnum);
 void srv_cancel_sign_response(struct smbd_server_connection *conn);
 bool srv_init_signing(struct smbd_server_connection *conn);
-void srv_set_signing_negotiated(struct smbd_server_connection *conn,
-			        bool allowed, bool mandatory);
+void srv_set_signing_negotiated(struct smbd_server_connection *conn);
 bool srv_is_signing_active(struct smbd_server_connection *conn);
 bool srv_is_signing_negotiated(struct smbd_server_connection *conn);
 void srv_set_signing(struct smbd_server_connection *conn,
@@ -64,23 +64,21 @@
 
 /* The following definitions come from smbd/aio.c  */
 
-struct aio_extra;
-bool aio_write_through_requested(struct aio_extra *aio_ex);
 NTSTATUS schedule_aio_read_and_X(connection_struct *conn,
 			     struct smb_request *req,
-			     files_struct *fsp, off_t startpos,
+			     files_struct *fsp, SMB_OFF_T startpos,
 			     size_t smb_maxcnt);
 NTSTATUS schedule_aio_write_and_X(connection_struct *conn,
 			      struct smb_request *req,
-			      files_struct *fsp, const char *data,
-			      off_t startpos,
+			      files_struct *fsp, char *data,
+			      SMB_OFF_T startpos,
 			      size_t numtowrite);
 NTSTATUS schedule_smb2_aio_read(connection_struct *conn,
 				struct smb_request *smbreq,
 				files_struct *fsp,
 				TALLOC_CTX *ctx,
 				DATA_BLOB *preadbuf,
-				off_t startpos,
+				SMB_OFF_T startpos,
 				size_t smb_maxcnt);
 NTSTATUS schedule_aio_smb2_write(connection_struct *conn,
 				struct smb_request *smbreq,
@@ -88,7 +86,9 @@
 				uint64_t in_offset,
 				DATA_BLOB in_data,
 				bool write_through);
-bool cancel_smb2_aio(struct smb_request *smbreq);
+int wait_for_aio_completion(files_struct *fsp);
+void cancel_aio_by_fsp(files_struct *fsp);
+void smbd_aio_complete_aio_ex(struct aio_extra *aio_ex);
 
 /* The following definitions come from smbd/blocking.c  */
 
@@ -110,9 +110,6 @@
 		uint64_t offset,
 		uint64_t count,
 		uint64_t blocking_smblctx);
-void smbd_cancel_pending_lock_requests_by_fid(files_struct *fsp,
-			struct byte_range_lock *br_lck,
-			enum file_close_type close_type);
 void cancel_pending_lock_requests_by_fid(files_struct *fsp,
 			struct byte_range_lock *br_lck,
 			enum file_close_type close_type);
@@ -139,24 +136,19 @@
 		    struct server_id server_id,
 		    DATA_BLOB *data);
 NTSTATUS delete_all_streams(connection_struct *conn, const char *fname);
-bool recursive_rmdir(TALLOC_CTX *ctx,
-		     connection_struct *conn,
-		     struct smb_filename *smb_dname);
 
 /* The following definitions come from smbd/conn.c  */
 
-uint32_t get_connection_share_access_list_entry(connection_struct *conn,
-						unsigned int i);
-void set_connection_share_access_list_entry(connection_struct *conn,
-						unsigned int i,
-						uint32_t val);
+void conn_init(struct smbd_server_connection *sconn);
 int conn_num_open(struct smbd_server_connection *sconn);
-bool conn_snum_used(struct smbd_server_connection *sconn, int snum);
+bool conn_snum_used(int snum);
+connection_struct *conn_find(struct smbd_server_connection *sconn,
+			     unsigned cnum);
 connection_struct *conn_new(struct smbd_server_connection *sconn);
+bool conn_close_all(struct smbd_server_connection *sconn);
 bool conn_idle_all(struct smbd_server_connection *sconn, time_t t);
-void conn_clear_vuid_caches(struct smbd_server_connection *sconn, uint64_t vuid);
+void conn_clear_vuid_caches(struct smbd_server_connection *sconn, uint16 vuid);
 void conn_free(connection_struct *conn);
-void conn_force_tdis(struct smbd_server_connection *sconn, const char *sharename);
 void msg_force_tdis(struct messaging_context *msg,
 		    void *private_data,
 		    uint32_t msg_type,
@@ -165,12 +157,12 @@
 
 /* The following definitions come from smbd/connection.c  */
 
-int count_current_connections(const char *sharename, bool verify);
-bool connections_snum_used(struct smbd_server_connection *unused, int snum);
+bool yield_connection(connection_struct *conn, const char *name);
+int count_current_connections( const char *sharename, bool clear  );
+bool claim_connection(connection_struct *conn, const char *name);
 
 /* The following definitions come from smbd/dfree.c  */
 
-void disk_norm(bool small_query, uint64_t *bsize,uint64_t *dfree,uint64_t *dsize);
 uint64_t sys_disk_free(connection_struct *conn, const char *path, bool small_query,
                               uint64_t *bsize,uint64_t *dfree,uint64_t *dsize);
 uint64_t get_dfree_info(connection_struct *conn,
@@ -186,22 +178,20 @@
 			char *buf,
 			const char *mask,
 			const char *fname,
-			off_t size,
+			SMB_OFF_T size,
 			uint32 mode,
 			time_t date,
 			bool uc);
 bool init_dptrs(struct smbd_server_connection *sconn);
-const char *dptr_path(struct smbd_server_connection *sconn, int key);
-const char *dptr_wcard(struct smbd_server_connection *sconn, int key);
+char *dptr_path(struct smbd_server_connection *sconn, int key);
+char *dptr_wcard(struct smbd_server_connection *sconn, int key);
 uint16 dptr_attr(struct smbd_server_connection *sconn, int key);
 void dptr_close(struct smbd_server_connection *sconn, int *key);
 void dptr_closecnum(connection_struct *conn);
 void dptr_idlecnum(connection_struct *conn);
 void dptr_closepath(struct smbd_server_connection *sconn,
 		    char *path,uint16 spid);
-NTSTATUS dptr_create(connection_struct *conn,
-		struct smb_request *req,
-		files_struct *fsp,
+NTSTATUS dptr_create(connection_struct *conn, files_struct *fsp,
 		const char *path, bool old_handle, bool expect_close,uint16 spid,
 		const char *wcard, bool wcard_has_wild, uint32 attr, struct dptr_struct **dptr_ret);
 void dptr_CloseDir(files_struct *fsp);
@@ -209,8 +199,6 @@
 long dptr_TellDir(struct dptr_struct *dptr);
 bool dptr_has_wild(struct dptr_struct *dptr);
 int dptr_dnum(struct dptr_struct *dptr);
-bool dptr_get_priv(struct dptr_struct *dptr);
-void dptr_set_priv(struct dptr_struct *dptr);
 char *dptr_ReadDirName(TALLOC_CTX *ctx,
 			struct dptr_struct *dptr,
 			long *poffset,
@@ -230,7 +218,7 @@
 		const char *mask,
 		uint32 dirtype,
 		char **pp_fname_out,
-		off_t *size,
+		SMB_OFF_T *size,
 		uint32 *mode,
 		struct timespec *date,
 		bool check_descend,
@@ -309,30 +297,34 @@
 
 /* The following definitions come from smbd/file_access.c  */
 
+bool can_access_file_acl(struct connection_struct *conn,
+			 const struct smb_filename *smb_fname,
+			 uint32_t access_mask);
 bool can_delete_file_in_directory(connection_struct *conn,
 				  const struct smb_filename *smb_fname);
+bool can_access_file_data(connection_struct *conn,
+			  const struct smb_filename *smb_fname,
+			  uint32 access_mask);
 bool can_write_to_file(connection_struct *conn,
 		       const struct smb_filename *smb_fname);
 bool directory_has_default_acl(connection_struct *conn, const char *fname);
-NTSTATUS can_set_delete_on_close(files_struct *fsp, uint32 dosmode);
 
 /* The following definitions come from smbd/fileio.c  */
 
-ssize_t read_file(files_struct *fsp,char *data,off_t pos,size_t n);
+ssize_t read_file(files_struct *fsp,char *data,SMB_OFF_T pos,size_t n);
 void update_write_time_handler(struct event_context *ctx,
                                       struct timed_event *te,
                                       struct timeval now,
                                       void *private_data);
 void trigger_write_time_update(struct files_struct *fsp);
 void trigger_write_time_update_immediate(struct files_struct *fsp);
-void mark_file_modified(files_struct *fsp);
 ssize_t write_file(struct smb_request *req,
 			files_struct *fsp,
 			const char *data,
-			off_t pos,
+			SMB_OFF_T pos,
 			size_t n);
 void delete_write_cache(files_struct *fsp);
-void set_filelen_write_cache(files_struct *fsp, off_t file_size);
+void set_filelen_write_cache(files_struct *fsp, SMB_OFF_T file_size);
 ssize_t flush_write_cache(files_struct *fsp, enum flush_reason_enum reason);
 NTSTATUS sync_file(connection_struct *conn, files_struct *fsp, bool write_through);
 int fsp_stat(files_struct *fsp);
@@ -356,26 +348,16 @@
 			uint32_t ucf_flags,
 			bool *ppath_contains_wcard,
 			struct smb_filename **pp_smb_fname);
-NTSTATUS filename_convert_with_privilege(TALLOC_CTX *mem_ctx,
-			connection_struct *conn,
-			struct smb_request *smbreq,
-			const char *name_in,
-			uint32_t ucf_flags,
-			bool *ppath_contains_wcard,
-			struct smb_filename **pp_smb_fname);
 
 /* The following definitions come from smbd/files.c  */
 
-NTSTATUS fsp_new(struct connection_struct *conn, TALLOC_CTX *mem_ctx,
-		 files_struct **result);
 NTSTATUS file_new(struct smb_request *req, connection_struct *conn,
 		  files_struct **result);
 void file_close_conn(connection_struct *conn);
 void file_close_pid(struct smbd_server_connection *sconn, uint16 smbpid,
-		    uint64_t vuid);
-bool file_init_global(void);
+		    int vuid);
 bool file_init(struct smbd_server_connection *sconn);
-void file_close_user(struct smbd_server_connection *sconn, uint64_t vuid);
+void file_close_user(struct smbd_server_connection *sconn, int vuid);
 struct files_struct *files_forall(
 	struct smbd_server_connection *sconn,
 	struct files_struct *(*fn)(struct files_struct *fsp,
@@ -389,9 +371,9 @@
 files_struct *file_find_di_next(files_struct *start_fsp);
 bool file_find_subpath(files_struct *dir_fsp);
 void file_sync_all(connection_struct *conn);
-void fsp_free(files_struct *fsp);
 void file_free(struct smb_request *req, files_struct *fsp);
 files_struct *file_fsp(struct smb_request *req, uint16 fid);
+uint64_t fsp_persistent_id(const struct files_struct *fsp);
 struct files_struct *file_fsp_smb2(struct smbd_smb2_request *smb2req,
 				   uint64_t persistent_id,
 				   uint64_t volatile_id);
@@ -405,7 +387,6 @@
 
 /* The following definitions come from smbd/ipc.c  */
 
-NTSTATUS nt_status_np_pipe(NTSTATUS status);
 void send_trans_reply(connection_struct *conn,
 		      struct smb_request *req,
 		      char *rparam, int rparam_len,
@@ -416,7 +397,7 @@
 
 /* The following definitions come from smbd/lanman.c  */
 
-void api_reply(connection_struct *conn, uint64_t vuid,
+void api_reply(connection_struct *conn, uint16 vuid,
 	       struct smb_request *req,
 	       char *data, char *params,
 	       int tdscnt, int tpscnt,
@@ -466,7 +447,6 @@
 struct junction_map;
 NTSTATUS get_referred_path(TALLOC_CTX *ctx,
 			const char *dfs_path,
-			bool allow_broken_path,
 			struct junction_map *jucn,
 			int *consumedcntp,
 			bool *self_referralp);
@@ -476,33 +456,27 @@
 			char **ppdata, NTSTATUS *pstatus);
 bool create_junction(TALLOC_CTX *ctx,
 		const char *dfs_path,
-		bool allow_broken_path,
 		struct junction_map *jucn);
 bool create_msdfs_link(const struct junction_map *jucn);
 bool remove_msdfs_link(const struct junction_map *jucn);
 struct junction_map *enum_msdfs_links(TALLOC_CTX *ctx, size_t *p_num_jn);
+NTSTATUS resolve_dfspath(TALLOC_CTX *ctx,
+			connection_struct *conn,
+			bool dfs_pathnames,
+			const char *name_in,
+			char **pp_name_out);
 NTSTATUS resolve_dfspath_wcard(TALLOC_CTX *ctx,
 				connection_struct *conn,
 				bool dfs_pathnames,
 				const char *name_in,
 				bool allow_wcards,
-				bool allow_broken_path,
 				char **pp_name_out,
 				bool *ppath_contains_wcard);
 NTSTATUS create_conn_struct(TALLOC_CTX *ctx,
-			    struct tevent_context *ev,
-			    struct messaging_context *msg,
-			    connection_struct **pconn,
-			    int snum,
-			    const char *path,
-			    const struct auth_session_info *session_info);
-NTSTATUS create_conn_struct_cwd(TALLOC_CTX *ctx,
-				struct tevent_context *ev,
-				struct messaging_context *msg,
 				connection_struct **pconn,
 				int snum,
 				const char *path,
-				const struct auth_session_info *session_info,
+				const struct auth_serversupplied_info *session_info,
 				char **poldcwd);
 
 /* The following definitions come from smbd/negprot.c  */
@@ -511,7 +485,6 @@
 
 /* The following definitions come from smbd/notify.c  */
 
-bool change_notify_fsp_has_changes(struct files_struct *fsp);
 void change_notify_reply(struct smb_request *req,
 			 NTSTATUS error_code,
 			 uint32_t max_param,
@@ -535,15 +508,20 @@
 void notify_fname(connection_struct *conn, uint32 action, uint32 filter,
 		  const char *path);
 char *notify_filter_string(TALLOC_CTX *mem_ctx, uint32 filter);
-struct sys_notify_context *sys_notify_context_create(TALLOC_CTX *mem_ctx,
+struct sys_notify_context *sys_notify_context_create(connection_struct *conn,
+						     TALLOC_CTX *mem_ctx,
 						     struct event_context *ev);
+NTSTATUS sys_notify_watch(struct sys_notify_context *ctx,
+			  struct notify_entry *e,
+			  void (*callback)(struct sys_notify_context *ctx,
+					   void *private_data,
+					   struct notify_event *ev),
+			  void *private_data, void *handle);
 
 /* The following definitions come from smbd/notify_inotify.c  */
 
 NTSTATUS inotify_watch(struct sys_notify_context *ctx,
-		       const char *path,
-		       uint32_t *filter,
-		       uint32_t *subdir_filter,
+		       struct notify_entry *e,
 		       void (*callback)(struct sys_notify_context *ctx,
 					void *private_data,
 					struct notify_event *ev),
@@ -552,33 +530,22 @@
 
 /* The following definitions come from smbd/notify_internal.c  */
 
-struct notify_context *notify_init(TALLOC_CTX *mem_ctx,
+struct notify_context *notify_init(TALLOC_CTX *mem_ctx, struct server_id server,
 				   struct messaging_context *messaging_ctx,
-				   struct event_context *ev);
-NTSTATUS notify_add(struct notify_context *notify,
-		    const char *path, uint32_t filter, uint32_t subdir_filter,
+				   struct event_context *ev,
+				   connection_struct *conn);
+bool notify_internal_parent_init(TALLOC_CTX *mem_ctx);
+NTSTATUS notify_add(struct notify_context *notify, struct notify_entry *e0,
 		    void (*callback)(void *, const struct notify_event *),
 		    void *private_data);
 NTSTATUS notify_remove(struct notify_context *notify, void *private_data);
+NTSTATUS notify_remove_onelevel(struct notify_context *notify,
+				const struct file_id *fid,
+				void *private_data);
+void notify_onelevel(struct notify_context *notify, uint32_t action,
+		     uint32_t filter, struct file_id fid, const char *name);
 void notify_trigger(struct notify_context *notify,
 		    uint32_t action, uint32_t filter, const char *path);
-void notify_walk_idx(struct notify_context *notify,
-		     void (*fn)(const char *path,
-				uint32_t *vnns, size_t num_vnns,
-				void *private_data),
-		     void *private_data);
-void notify_walk(struct notify_context *notify,
-		 void (*fn)(const char *path,
-			    struct notify_db_entry *entries,
-			    size_t num_entries,
-			    time_t deleted_time, void *private_data),
-		 void *private_data);
-void notify_cleanup(struct notify_context *notify);
-
-struct tevent_req *notify_cluster_proxy_send(
-	TALLOC_CTX *mem_ctx, struct tevent_context *ev,
-	struct notify_context *notify);
-int notify_cluster_proxy_recv(struct tevent_req *req);
 
 /* The following definitions come from smbd/ntquotas.c  */
 
@@ -589,11 +556,24 @@
 
 /* The following definitions come from smbd/nttrans.c  */
 
+void send_nt_replies(connection_struct *conn,
+			struct smb_request *req, NTSTATUS nt_error,
+		     char *params, int paramsize,
+		     char *pdata, int datasize);
 void reply_ntcreate_and_X(struct smb_request *req);
 NTSTATUS set_sd(files_struct *fsp, struct security_descriptor *psd,
                        uint32_t security_info_sent);
 NTSTATUS set_sd_blob(files_struct *fsp, uint8_t *data, uint32_t sd_len,
                        uint32_t security_info_sent);
+NTSTATUS smb_fsctl(struct files_struct *fsp,
+		       TALLOC_CTX *ctx,
+		       uint32_t function,
+		       uint16_t req_flags,  /* Needed for UNICODE ... */
+		       const uint8_t *_in_data,
+		       uint32_t in_len,
+		       uint8_t **_out_data,
+		       uint32_t max_out_len,
+		       uint32_t *out_len);
 struct ea_list *read_nttrans_ea_list(TALLOC_CTX *ctx, const char *pdata, size_t data_size);
 void reply_ntcancel(struct smb_request *req);
 void reply_ntrename(struct smb_request *req);
@@ -609,11 +589,11 @@
 
 /* The following definitions come from smbd/open.c  */
 
-NTSTATUS smbd_check_access_rights(struct connection_struct *conn,
-				const struct smb_filename *smb_fname,
-				uint32_t access_mask);
-NTSTATUS fd_open(struct connection_struct *conn, files_struct *fsp,
-		 int flags, mode_t mode);
+NTSTATUS smb1_file_se_access_check(connection_struct *conn,
+				const struct security_descriptor *sd,
+				const struct security_token *token,
+				uint32_t access_desired,
+				uint32_t *access_granted);
 NTSTATUS fd_close(files_struct *fsp);
 void change_file_owner_to_parent(connection_struct *conn,
 				 const char *inherit_from_dir,
@@ -623,9 +603,31 @@
 				    const char *fname,
 				    SMB_STRUCT_STAT *psbuf);
 bool is_stat_open(uint32 access_mask);
+bool request_timed_out(struct timeval request_time,
+		       struct timeval timeout);
+bool open_match_attributes(connection_struct *conn,
+			   uint32 old_dos_attr,
+			   uint32 new_dos_attr,
+			   mode_t existing_unx_mode,
+			   mode_t new_unx_mode,
+			   mode_t *returned_unx_mode);
+NTSTATUS fcb_or_dos_open(struct smb_request *req,
+			 connection_struct *conn,
+			 files_struct *fsp_to_dup_into,
+			 const struct smb_filename *smb_fname,
+			 struct file_id id,
+			 uint16 file_pid,
+			 uint16 vuid,
+			 uint32 access_mask,
+			 uint32 share_access,
+			 uint32 create_options);
 void remove_deferred_open_entry(struct file_id id, uint64_t mid,
 				struct server_id pid);
-bool is_deferred_open_async(const void *ptr);
+NTSTATUS open_file_fchmod(connection_struct *conn,
+			  struct smb_filename *smb_fname,
+			  files_struct **result);
+bool check_same_stat(const SMB_STRUCT_STAT *sbuf1,
+			const SMB_STRUCT_STAT *sbuf2);
 NTSTATUS create_directory(connection_struct *conn, struct smb_request *req,
 			  struct smb_filename *smb_dname);
 void msg_file_was_renamed(struct messaging_context *msg,
@@ -660,44 +662,66 @@
 
 /* The following definitions come from smbd/oplock.c  */
 
+int32 get_number_of_exclusive_open_oplocks(void);
 void break_kernel_oplock(struct messaging_context *msg_ctx, files_struct *fsp);
-NTSTATUS set_file_oplock(files_struct *fsp, int oplock_type);
+bool set_file_oplock(files_struct *fsp, int oplock_type);
 void release_file_oplock(files_struct *fsp);
 bool remove_oplock(files_struct *fsp);
 bool downgrade_oplock(files_struct *fsp);
-bool should_notify_deferred_opens(struct smbd_server_connection *sconn);
+bool should_notify_deferred_opens(void);
 void break_level2_to_none_async(files_struct *fsp);
 void reply_to_oplock_break_requests(files_struct *fsp);
+void process_oplock_async_level2_break_message(struct messaging_context *msg_ctx,
+						      void *private_data,
+						      uint32_t msg_type,
+						      struct server_id src,
+						      DATA_BLOB *data);
 void contend_level2_oplocks_begin(files_struct *fsp,
 				  enum level2_contention_type type);
 void contend_level2_oplocks_end(files_struct *fsp,
 				enum level2_contention_type type);
-void smbd_contend_level2_oplocks_begin(files_struct *fsp,
-				  enum level2_contention_type type);
-void smbd_contend_level2_oplocks_end(files_struct *fsp,
-				enum level2_contention_type type);
 void share_mode_entry_to_message(char *msg, const struct share_mode_entry *e);
 void message_to_share_mode_entry(struct share_mode_entry *e, char *msg);
-bool init_oplocks(struct smbd_server_connection *sconn);
-void init_kernel_oplocks(struct smbd_server_connection *sconn);
+bool init_oplocks(struct messaging_context *msg_ctx);
 
 /* The following definitions come from smbd/oplock_irix.c  */
 
-struct kernel_oplocks *irix_init_kernel_oplocks(struct smbd_server_connection *sconn);
+struct kernel_oplocks *irix_init_kernel_oplocks(TALLOC_CTX *mem_ctx) ;
 
 /* The following definitions come from smbd/oplock_linux.c  */
 
 void linux_set_lease_capability(void);
 int linux_set_lease_sighandler(int fd);
 int linux_setlease(int fd, int leasetype);
-struct kernel_oplocks *linux_init_kernel_oplocks(struct smbd_server_connection *sconn);
+struct kernel_oplocks *linux_init_kernel_oplocks(TALLOC_CTX *mem_ctx) ;
+
+/* The following definitions come from smbd/oplock_onefs.c  */
+
+struct kernel_oplocks *onefs_init_kernel_oplocks(TALLOC_CTX *mem_ctx);
 
 /* The following definitions come from smbd/password.c  */
 
-struct user_struct *get_valid_user_struct(struct smbd_server_connection *sconn,
-					  uint64_t vuid);
-void invalidate_vuid(struct smbd_server_connection *sconn, uint64_t vuid);
+user_struct *get_valid_user_struct(struct smbd_server_connection *sconn,
+				   uint16 vuid);
+bool is_partial_auth_vuid(struct smbd_server_connection *sconn, uint16 vuid);
+user_struct *get_partial_auth_user_struct(struct smbd_server_connection *sconn,
+					  uint16 vuid);
+void invalidate_vuid(struct smbd_server_connection *sconn, uint16 vuid);
+void invalidate_all_vuids(struct smbd_server_connection *sconn);
+int register_initial_vuid(struct smbd_server_connection *sconn);
 int register_homes_share(const char *username);
+int register_existing_vuid(struct smbd_server_connection *sconn,
+			uint16 vuid,
+			struct auth_serversupplied_info *session_info,
+			DATA_BLOB response_blob,
+			const char *smb_name);
+void add_session_user(struct smbd_server_connection *sconn, const char *user);
+void add_session_workgroup(struct smbd_server_connection *sconn,
+			   const char *workgroup);
+const char *get_session_workgroup(struct smbd_server_connection *sconn);
+bool authorise_login(struct smbd_server_connection *sconn,
+		     int snum, fstring user, DATA_BLOB password,
+		     bool *guest);
 
 /* The following definitions come from smbd/pipes.c  */
 
@@ -711,6 +735,7 @@
 /* The following definitions come from smbd/posix_acls.c  */
 
 void create_file_sids(const SMB_STRUCT_STAT *psbuf, struct dom_sid *powner_sid, struct dom_sid *pgroup_sid);
+bool nt4_compatible_acls(void);
 uint32_t map_canon_ace_perms(int snum,
                                 enum security_ace_type *pacl_type,
                                 mode_t perms,
@@ -719,12 +744,9 @@
 bool current_user_in_group(connection_struct *conn, gid_t gid);
 SMB_ACL_T free_empty_sys_acl(connection_struct *conn, SMB_ACL_T the_acl);
 NTSTATUS posix_fget_nt_acl(struct files_struct *fsp, uint32_t security_info,
-			   TALLOC_CTX *mem_ctx,
 			   struct security_descriptor **ppdesc);
 NTSTATUS posix_get_nt_acl(struct connection_struct *conn, const char *name,
-			  uint32_t security_info,
-			  TALLOC_CTX *mem_ctx,
-			  struct security_descriptor **ppdesc);
+			  uint32_t security_info, struct security_descriptor **ppdesc);
 NTSTATUS try_chown(files_struct *fsp, uid_t uid, gid_t gid);
 NTSTATUS append_parent_acl(files_struct *fsp,
 				const struct security_descriptor *pcsd,
@@ -739,7 +761,7 @@
 				const SMB_STRUCT_STAT *psbuf,
 				uint16 num_def_acls, const char *pdata);
 bool set_unix_posix_acl(connection_struct *conn, files_struct *fsp, const char *fname, uint16 num_acls, const char *pdata);
-struct security_descriptor *get_nt_acl_no_snum( TALLOC_CTX *ctx, const char *fname, uint32 security_info_wanted);
+struct security_descriptor *get_nt_acl_no_snum( TALLOC_CTX *ctx, const char *fname);
 NTSTATUS make_default_filesystem_acl(TALLOC_CTX *ctx,
 					const char *name,
 					SMB_STRUCT_STAT *psbuf,
@@ -747,8 +769,6 @@
 
 /* The following definitions come from smbd/process.c  */
 
-void smbd_setup_sig_term_handler(struct smbd_server_connection *sconn);
-void smbd_setup_sig_hup_handler(struct smbd_server_connection *sconn);
 bool srv_send_smb(struct smbd_server_connection *sconn, char *buffer,
 		  bool no_signing, uint32_t seqnum,
 		  bool do_encrypt,
@@ -757,11 +777,9 @@
                         int num_words,
                         int num_bytes,
                         bool zero);
-void remove_deferred_open_message_smb(struct smbd_server_connection *sconn,
-				      uint64_t mid);
-bool schedule_deferred_open_message_smb(struct smbd_server_connection *sconn,
-					uint64_t mid);
-bool open_was_deferred(struct smbd_server_connection *sconn, uint64_t mid);
+void remove_deferred_open_message_smb(uint64_t mid);
+void schedule_deferred_open_message_smb(uint64_t mid);
+bool open_was_deferred(uint64_t mid);
 bool get_deferred_open_message_state(struct smb_request *smbreq,
 				struct timeval *p_request_time,
 				void **pp_state);
@@ -771,36 +789,39 @@
 				struct file_id id,
 				char *private_data,
 				size_t priv_len);
+struct idle_event *event_add_idle(struct event_context *event_ctx,
+				  TALLOC_CTX *mem_ctx,
+				  struct timeval interval,
+				  const char *name,
+				  bool (*handler)(const struct timeval *now,
+						  void *private_data),
+				  void *private_data);
 NTSTATUS allow_new_trans(struct trans_state *list, uint64_t mid);
 void reply_outbuf(struct smb_request *req, uint8 num_words, uint32 num_bytes);
-void smb_request_done(struct smb_request *req);
 const char *smb_fn_name(int type);
 void add_to_common_flags2(uint32 v);
 void remove_from_common_flags2(uint32 v);
 void construct_reply_common_req(struct smb_request *req, char *outbuf);
-bool smb1_is_chain(const uint8_t *buf);
-bool smb1_walk_chain(const uint8_t *buf,
-		     bool (*fn)(uint8_t cmd,
-				uint8_t wct, const uint16_t *vwv,
-				uint16_t num_bytes, const uint8_t *bytes,
-				void *private_data),
-		     void *private_data);
-unsigned smb1_chain_length(const uint8_t *buf);
-bool smb1_parse_chain(TALLOC_CTX *mem_ctx, const uint8_t *buf,
-		      struct smbd_server_connection *sconn,
-		      bool encrypted, uint32_t seqnum,
-		      struct smb_request ***reqs, unsigned *num_reqs);
-bool req_is_in_chain(const struct smb_request *req);
-void smbd_process(struct tevent_context *ev_ctx,
-		  struct messaging_context *msg_ctx,
-		  int sock_fd,
-		  bool interactive);
+size_t req_wct_ofs(struct smb_request *req);
+void chain_reply(struct smb_request *req);
+bool req_is_in_chain(struct smb_request *req);
+void smbd_process(struct smbd_server_connection *sconn);
 bool fork_echo_handler(struct smbd_server_connection *sconn);
 
 /* The following definitions come from smbd/quotas.c  */
 
 bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
+bool disk_quotas(const char *path,
+		uint64_t *bsize,
+		uint64_t *dfree,
+		uint64_t *dsize);
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
 bool disk_quotas_vxfs(const char *name, char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
+bool disk_quotas(const char *path,uint64_t *bsize,uint64_t *dfree,uint64_t *dsize);
+bool disk_quotas(const char *path,uint64_t *bsize,uint64_t *dfree,uint64_t *dsize);
 
 /* The following definitions come from smbd/reply.c  */
 
@@ -830,8 +851,6 @@
 size_t srvstr_get_path_req(TALLOC_CTX *mem_ctx, struct smb_request *req,
 			   char **pp_dest, const char *src, int flags,
 			   NTSTATUS *err);
-size_t srvstr_pull_req_talloc(TALLOC_CTX *ctx, struct smb_request *req,
-			      char **dest, const char *src, int flags);
 bool check_fsp_open(connection_struct *conn, struct smb_request *req,
 		    files_struct *fsp);
 bool check_fsp(connection_struct *conn, struct smb_request *req,
@@ -858,7 +877,7 @@
 			  uint32 dirtype, struct smb_filename *smb_fname,
 			  bool has_wild);
 void reply_unlink(struct smb_request *req);
-ssize_t fake_sendfile(files_struct *fsp, off_t startpos, size_t nread);
+ssize_t fake_sendfile(files_struct *fsp, SMB_OFF_T startpos, size_t nread);
 void sendfile_short_send(files_struct *fsp,
 				ssize_t nread,
 				size_t headersize,
@@ -929,19 +948,18 @@
 
 /* The following definitions come from smbd/seal.c  */
 
-bool is_encrypted_packet(struct smbd_server_connection *sconn,
-			 const uint8_t *inbuf);
-void srv_free_enc_buffer(struct smbd_server_connection *sconn, char *buf);
-NTSTATUS srv_decrypt_buffer(struct smbd_server_connection *sconn, char *buf);
-NTSTATUS srv_encrypt_buffer(struct smbd_server_connection *sconn, char *buf,
-			    char **buf_out);
+uint16_t srv_enc_ctx(void);
+bool is_encrypted_packet(const uint8_t *inbuf);
+void srv_free_enc_buffer(char *buf);
+NTSTATUS srv_decrypt_buffer(char *buf);
+NTSTATUS srv_encrypt_buffer(char *buf, char **buf_out);
 NTSTATUS srv_request_encryption_setup(connection_struct *conn,
 					unsigned char **ppdata,
 					size_t *p_data_size,
 					unsigned char **pparam,
 					size_t *p_param_size);
 NTSTATUS srv_encryption_start(connection_struct *conn);
-void server_encryption_shutdown(struct smbd_server_connection *sconn);
+void server_encryption_shutdown(void);
 
 /* The following definitions come from smbd/sec_ctx.c  */
 
@@ -951,24 +969,21 @@
 void set_root_sec_ctx(void);
 bool pop_sec_ctx(void);
 void init_sec_ctx(void);
-const struct security_token *sec_ctx_active_token(void);
 
 /* The following definitions come from smbd/server.c  */
 
+struct event_context *smbd_event_context(void);
+struct messaging_context *smbd_messaging_context(void);
 struct memcache *smbd_memcache(void);
-bool snum_is_shared_printer(int snum);
-void delete_and_reload_printers(struct tevent_context *ev,
-				struct messaging_context *msg_ctx);
-bool reload_services(struct smbd_server_connection *sconn,
-		     bool (*snumused) (struct smbd_server_connection *, int),
+void reload_printers(struct tevent_context *ev,
+		     struct messaging_context *msg_ctx);
+void reload_printers_full(struct tevent_context *ev,
+			  struct messaging_context *msg_ctx);
+bool reload_services(struct messaging_context *msg_ctx, int smb_sock,
 		     bool test);
-NTSTATUS messaging_send_to_children(struct messaging_context *msg_ctx,
-				    uint32_t msg_type, DATA_BLOB* data);
-
-/* The following definitions come from smbd/server_exit.c  */
-
-void smbd_exit_server(const char *reason) _NORETURN_;
-void smbd_exit_server_cleanly(const char *const reason) _NORETURN_;
+void exit_server(const char *const explanation);
+void exit_server_cleanly(const char *const explanation);
+void exit_server_fault(void);
 
 /* The following definitions come from smbd/service.c  */
 
@@ -978,29 +993,36 @@
 void load_registry_shares(void);
 int add_home_service(const char *service, const char *username, const char *homedir);
 int find_service(TALLOC_CTX *ctx, const char *service, char **p_service_out);
+struct smbd_smb2_tcon;
 connection_struct *make_connection_smb2(struct smbd_server_connection *sconn,
-					struct smbXsrv_tcon *tcon,
-					int snum,
-					struct user_struct *vuser,
+					struct smbd_smb2_tcon *tcon,
+					user_struct *vuser,
+					DATA_BLOB password,
 					const char *pdev,
 					NTSTATUS *pstatus);
 connection_struct *make_connection(struct smbd_server_connection *sconn,
-				   NTTIME now,
-				   const char *service_in,
-				   const char *pdev, uint64_t vuid,
+				   const char *service_in, DATA_BLOB password,
+				   const char *pdev, uint16 vuid,
 				   NTSTATUS *status);
-void close_cnum(connection_struct *conn, uint64_t vuid);
+void close_cnum(connection_struct *conn, uint16 vuid);
 
 /* The following definitions come from smbd/session.c  */
 struct sessionid;
-struct smbXsrv_session;
 bool session_init(void);
-bool session_claim(struct smbXsrv_session *session);
-void session_yield(struct smbXsrv_session *session);
+bool session_claim(struct smbd_server_connection *sconn, user_struct *vuser);
+void session_yield(user_struct *vuser);
 int list_sessions(TALLOC_CTX *mem_ctx, struct sessionid **session_list);
 
 /* The following definitions come from smbd/sesssetup.c  */
 
+NTSTATUS do_map_to_guest(NTSTATUS status,
+		struct auth_serversupplied_info **session_info,
+		const char *user, const char *domain);
+
+NTSTATUS parse_spnego_mechanisms(TALLOC_CTX *ctx,
+		DATA_BLOB blob_in,
+		DATA_BLOB *pblob_out,
+		char **kerb_mechOID);
 void reply_sesssetup_and_X(struct smb_request *req);
 
 /* The following definitions come from smbd/share_access.c  */
@@ -1019,7 +1041,8 @@
 
 /* The following definitions come from smbd/srvstr.c  */
 
-size_t srvstr_push_fn(const char *base_ptr, uint16 smb_flags2, void *dest,
+size_t srvstr_push_fn(const char *function, unsigned int line,
+		      const char *base_ptr, uint16 smb_flags2, void *dest,
 		      const char *src, int dest_len, int flags);
 ssize_t message_push_string(uint8 **outbuf, const char *str, int flags);
 
@@ -1034,8 +1057,6 @@
 			char **pp_dirpath,
 			char **pp_start,
 			SMB_STRUCT_STAT *pst);
-void smbd_send_stat_cache_delete_message(struct messaging_context *msg_ctx,
-				    const char *name);
 void send_stat_cache_delete_message(struct messaging_context *msg_ctx,
 				    const char *name);
 void stat_cache_delete(const char *name);
@@ -1049,10 +1070,6 @@
 
 /* The following definitions come from smbd/trans2.c  */
 
-NTSTATUS check_access(connection_struct *conn,
-				files_struct *fsp,
-				const struct smb_filename *smb_fname,
-				uint32_t access_mask);
 uint64_t smb_roundup(connection_struct *conn, uint64_t val);
 uint64_t get_FileIndex(connection_struct *conn, const SMB_STRUCT_STAT *psbuf);
 NTSTATUS get_ea_value(TALLOC_CTX *mem_ctx, connection_struct *conn,
@@ -1066,7 +1083,6 @@
 struct ea_list *read_ea_list_entry(TALLOC_CTX *ctx, const char *pdata, size_t data_size, size_t *pbytes_used);
 void send_trans2_replies(connection_struct *conn,
 			struct smb_request *req,
-			NTSTATUS status,
 			 const char *params,
 			 int paramsize,
 			 const char *pdata,
@@ -1092,44 +1108,56 @@
 /* The following definitions come from smbd/uid.c  */
 
 bool change_to_guest(void);
-NTSTATUS check_user_share_access(connection_struct *conn,
-				const struct auth_session_info *session_info,
-				uint32_t *p_share_access,
-				bool *p_readonly_share);
-bool change_to_user(connection_struct *conn, uint64_t vuid);
+void conn_clear_vuid_cache(connection_struct *conn, uint16_t vuid);
+bool change_to_user(connection_struct *conn, uint16 vuid);
+bool change_to_user_by_session(connection_struct *conn,
+			       const struct auth_serversupplied_info *session_info);
 bool change_to_root_user(void);
-bool smbd_change_to_root_user(void);
-bool become_authenticated_pipe_user(struct auth_session_info *session_info);
+bool become_authenticated_pipe_user(struct auth_serversupplied_info *session_info);
 bool unbecome_authenticated_pipe_user(void);
 void become_root(void);
 void unbecome_root(void);
-void smbd_become_root(void);
-void smbd_unbecome_root(void);
-bool become_user(connection_struct *conn, uint64_t vuid);
+bool become_user(connection_struct *conn, uint16 vuid);
 bool become_user_by_session(connection_struct *conn,
-			    const struct auth_session_info *session_info);
+			    const struct auth_serversupplied_info *session_info);
 bool unbecome_user(void);
 uid_t get_current_uid(connection_struct *conn);
 gid_t get_current_gid(connection_struct *conn);
 const struct security_unix_token *get_current_utok(connection_struct *conn);
 const struct security_token *get_current_nttok(connection_struct *conn);
-uint64_t get_current_vuid(connection_struct *conn);
+uint16_t get_current_vuid(connection_struct *conn);
 
 /* The following definitions come from smbd/utmp.c  */
 
 void sys_utmp_claim(const char *username, const char *hostname,
-		    const char *id_str, int id_num);
+			const char *ip_addr_str,
+			const char *id_str, int id_num);
+void sys_utmp_yield(const char *username, const char *hostname,
+			const char *ip_addr_str,
+			const char *id_str, int id_num);
 void sys_utmp_yield(const char *username, const char *hostname,
-		    const char *id_str, int id_num);
+			const char *ip_addr_str,
+			const char *id_str, int id_num);
+void sys_utmp_claim(const char *username, const char *hostname,
+			const char *ip_addr_str,
+			const char *id_str, int id_num);
 
 /* The following definitions come from smbd/vfs.c  */
 
+NTSTATUS smb_register_vfs(int version, const char *name,
+			  const struct vfs_fn_pointers *fns);
 bool vfs_init_custom(connection_struct *conn, const char *vfs_object);
+void *vfs_add_fsp_extension_notype(vfs_handle_struct *handle,
+				   files_struct *fsp, size_t ext_size,
+				   void (*destroy_fn)(void *p_data));
+void vfs_remove_fsp_extension(vfs_handle_struct *handle, files_struct *fsp);
+void *vfs_memctx_fsp_extension(vfs_handle_struct *handle, files_struct *fsp);
+void *vfs_fetch_fsp_extension(vfs_handle_struct *handle, files_struct *fsp);
 bool smbd_vfs_init(connection_struct *conn);
 NTSTATUS vfs_file_exist(connection_struct *conn, struct smb_filename *smb_fname);
 ssize_t vfs_read_data(files_struct *fsp, char *buf, size_t byte_count);
 ssize_t vfs_pread_data(files_struct *fsp, char *buf,
-                size_t byte_count, off_t offset);
+                size_t byte_count, SMB_OFF_T offset);
 ssize_t vfs_write_data(struct smb_request *req,
 			files_struct *fsp,
 			const char *buffer,
@@ -1138,20 +1166,17 @@
 			files_struct *fsp,
 			const char *buffer,
 			size_t N,
-			off_t offset);
+			SMB_OFF_T offset);
 int vfs_allocate_file_space(files_struct *fsp, uint64_t len);
-int vfs_set_filelen(files_struct *fsp, off_t len);
-int vfs_slow_fallocate(files_struct *fsp, off_t offset, off_t len);
-int vfs_fill_sparse(files_struct *fsp, off_t len);
-off_t vfs_transfer_file(files_struct *in, files_struct *out, off_t n);
+int vfs_set_filelen(files_struct *fsp, SMB_OFF_T len);
+int vfs_slow_fallocate(files_struct *fsp, SMB_OFF_T offset, SMB_OFF_T len);
+int vfs_fill_sparse(files_struct *fsp, SMB_OFF_T len);
+SMB_OFF_T vfs_transfer_file(files_struct *in, files_struct *out, SMB_OFF_T n);
 const char *vfs_readdirname(connection_struct *conn, void *p,
 			    SMB_STRUCT_STAT *sbuf, char **talloced);
 int vfs_ChDir(connection_struct *conn, const char *path);
 char *vfs_GetWd(TALLOC_CTX *ctx, connection_struct *conn);
 NTSTATUS check_reduced_name(connection_struct *conn, const char *fname);
-NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
-			const char *fname,
-			struct smb_request *smbreq);
 int vfs_stat_smb_fname(struct connection_struct *conn, const char *fname,
 		       SMB_STRUCT_STAT *psbuf);
 int vfs_lstat_smb_fname(struct connection_struct *conn, const char *fname,
@@ -1170,21 +1195,8 @@
 void *avahi_start_register(TALLOC_CTX *mem_ctx, struct tevent_context *ev,
 			   uint16_t port);
 
-/* The following definitions come from smbd/smb2_create.c */
+/* The following definitions come from smbd/msg_idmap.c */
 
-NTSTATUS vfs_default_durable_cookie(struct files_struct *fsp,
-				    TALLOC_CTX *mem_ctx,
-				    DATA_BLOB *cookie_blob);
-NTSTATUS vfs_default_durable_disconnect(struct files_struct *fsp,
-					const DATA_BLOB old_cookie,
-					TALLOC_CTX *mem_ctx,
-					DATA_BLOB *new_cookie);
-NTSTATUS vfs_default_durable_reconnect(struct connection_struct *conn,
-				       struct smb_request *smb1req,
-				       struct smbXsrv_open *op,
-				       const DATA_BLOB old_cookie,
-				       TALLOC_CTX *mem_ctx,
-				       files_struct **result,
-				       DATA_BLOB *new_cookie);
+void msg_idmap_register_msgs(struct messaging_context *ctx);
 
 #endif /* _SMBD_PROTO_H_ */
Only in smbd: pysmbd.c
diff -ur smbd/quotas.c ../../samba-3.6.24/source3/smbd/quotas.c
--- smbd/quotas.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/quotas.c	2015-01-28 10:52:25.149068676 +0800
@@ -51,34 +51,1131 @@
 
 #endif /* VXFS_QUOTA */
 
+#ifdef LINUX
 
-#if defined(SUNOS5) || defined(SUNOS4)
+#include <sys/types.h>
+#include <mntent.h>
+
+/*
+ * This shouldn't be neccessary - it should be /usr/include/sys/quota.h
+ * So we include all the files has *should* be in the system into a large,
+ * grungy samba_linux_quoatas.h Sometimes I *hate* Linux :-). JRA.
+ */
+
+#include "samba_linux_quota.h"
+
+typedef struct _LINUX_SMB_DISK_QUOTA {
+	uint64_t bsize;
+	uint64_t hardlimit; /* In bsize units. */
+	uint64_t softlimit; /* In bsize units. */
+	uint64_t curblocks; /* In bsize units. */
+	uint64_t ihardlimit; /* inode hard limit. */
+	uint64_t isoftlimit; /* inode soft limit. */
+	uint64_t curinodes; /* Current used inodes. */
+} LINUX_SMB_DISK_QUOTA;
+
+
+/*
+ * nfs quota support
+ * (essentially taken from FreeBSD / SUNOS5 section)
+ */
+#include <rpc/rpc.h>
+#include <rpc/types.h>
+#include <rpcsvc/rquota.h>
+#ifdef HAVE_RPC_NETTYPE_H
+#include <rpc/nettype.h>
+#endif
+#include <rpc/xdr.h>
+
+static int my_xdr_getquota_args(XDR *xdrsp, struct getquota_args *args)
+{
+	if (!xdr_string(xdrsp, &args->gqa_pathp, RQ_PATHLEN ))
+		return(0);
+	if (!xdr_int(xdrsp, &args->gqa_uid))
+		return(0);
+	return (1);
+}
+
+static int my_xdr_getquota_rslt(XDR *xdrsp, struct getquota_rslt *gqr)
+{
+	int quotastat;
+
+	if (!xdr_int(xdrsp, &quotastat)) {
+		DEBUG(6,("nfs_quotas: Status bad or zero\n"));
+		return 0;
+	}
+	gqr->status = quotastat;
+
+	if (!xdr_int(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_bsize)) {
+		DEBUG(6,("nfs_quotas: Block size bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_bool(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_active)) {
+		DEBUG(6,("nfs_quotas: Active bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_int(xdrsp, (int *)&gqr->getquota_rslt_u.gqr_rquota.rq_bhardlimit)) {
+		DEBUG(6,("nfs_quotas: Hardlimit bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_int(xdrsp, (int *)&gqr->getquota_rslt_u.gqr_rquota.rq_bsoftlimit)) {
+		DEBUG(6,("nfs_quotas: Softlimit bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_int(xdrsp, (int *)&gqr->getquota_rslt_u.gqr_rquota.rq_curblocks)) {
+		DEBUG(6,("nfs_quotas: Currentblocks bad or zero\n"));
+		return 0;
+	}
+	return 1;
+}
+
+static bool nfs_quotas(char *nfspath, uid_t euser_id, uint64_t *bsize,
+		       uint64_t *dfree, uint64_t *dsize)
+{
+	uid_t uid = euser_id;
+	LINUX_SMB_DISK_QUOTA D;
+	char *mnttype = nfspath;
+	CLIENT *clnt;
+	struct getquota_rslt gqr;
+	struct getquota_args args;
+	char *cutstr, *pathname, *host, *testpath;
+	int len;
+	static struct timeval timeout = {2,0};
+	enum clnt_stat clnt_stat;
+	bool ret = True;
+
+	*bsize = *dfree = *dsize = (uint64_t)0;
+
+	len=strcspn(mnttype, ":");
+	pathname=strstr(mnttype, ":");
+	cutstr = (char *) SMB_MALLOC(len+1);
+	if (!cutstr)
+		return False;
+
+	memset(cutstr, '\0', len+1);
+	host = strncat(cutstr,mnttype, sizeof(char) * len );
+	DEBUG(5,("nfs_quotas: looking for mount on \"%s\"\n", cutstr));
+	DEBUG(5,("nfs_quotas: of path \"%s\"\n", mnttype));
+	testpath=strchr_m(mnttype, ':');
+	args.gqa_pathp = testpath+1;
+	args.gqa_uid = uid;
+
+	DEBUG(5, ("nfs_quotas: Asking for host \"%s\" rpcprog \"%i\" rpcvers "
+		  "\"%i\" network \"%s\"\n", host, RQUOTAPROG, RQUOTAVERS,
+		  "udp"));
+
+	if ((clnt = clnt_create(host, RQUOTAPROG, RQUOTAVERS, "udp")) == NULL) {
+		ret = False;
+		goto out;
+	}
+
+	clnt->cl_auth = authunix_create_default();
+	DEBUG(9,("nfs_quotas: auth_success\n"));
+
+	clnt_stat=clnt_call(clnt,
+			    RQUOTAPROC_GETQUOTA,
+			    (const xdrproc_t)my_xdr_getquota_args,
+			    (caddr_t)&args,
+			    (const xdrproc_t)my_xdr_getquota_rslt,
+			    (caddr_t)&gqr, timeout);
+
+	if (clnt_stat != RPC_SUCCESS) {
+		DEBUG(9,("nfs_quotas: clnt_call fail\n"));
+		ret = False;
+		goto out;
+	}
+
+	/*
+	 * gqr.status returns 0 if the rpc call fails, 1 if quotas exist, 2 if there is
+	 * no quota set, and 3 if no permission to get the quota.  If 0 or 3 return
+	 * something sensible.
+	 */
+
+	switch (gqr.status) {
+	case 0:
+		DEBUG(9, ("nfs_quotas: Remote Quotas Failed!  Error \"%i\" \n",
+			  gqr.status));
+		ret = False;
+		goto out;
+
+	case 1:
+		DEBUG(9,("nfs_quotas: Good quota data\n"));
+		D.softlimit = gqr.getquota_rslt_u.gqr_rquota.rq_bsoftlimit;
+		D.hardlimit = gqr.getquota_rslt_u.gqr_rquota.rq_bhardlimit;
+		D.curblocks = gqr.getquota_rslt_u.gqr_rquota.rq_curblocks;
+		break;
+
+	case 2:
+	case 3:
+		D.softlimit = 1;
+		D.curblocks = 1;
+		DEBUG(9, ("nfs_quotas: Remote Quotas returned \"%i\" \n",
+			  gqr.status));
+		break;
+
+	default:
+		DEBUG(9, ("nfs_quotas: Remote Quotas Questionable!  "
+			  "Error \"%i\" \n", gqr.status));
+		break;
+	}
+
+	DEBUG(10, ("nfs_quotas: Let`s look at D a bit closer... "
+		   "status \"%i\" bsize \"%i\" active? \"%i\" bhard "
+		   "\"%i\" bsoft \"%i\" curb \"%i\" \n",
+		   gqr.status,
+		   gqr.getquota_rslt_u.gqr_rquota.rq_bsize,
+		   gqr.getquota_rslt_u.gqr_rquota.rq_active,
+		   gqr.getquota_rslt_u.gqr_rquota.rq_bhardlimit,
+		   gqr.getquota_rslt_u.gqr_rquota.rq_bsoftlimit,
+		   gqr.getquota_rslt_u.gqr_rquota.rq_curblocks));
+
+	if (D.softlimit == 0)
+		D.softlimit = D.hardlimit;
+	if (D.softlimit == 0)
+		return False;
+
+	*bsize = gqr.getquota_rslt_u.gqr_rquota.rq_bsize;
+	*dsize = D.softlimit;
+
+	if (D.curblocks == 1)
+		*bsize = DEV_BSIZE;
+
+	if (D.curblocks > D.softlimit) {
+		*dfree = 0;
+		*dsize = D.curblocks;
+	} else
+		*dfree = D.softlimit - D.curblocks;
+
+  out:
+
+	if (clnt) {
+		if (clnt->cl_auth)
+			auth_destroy(clnt->cl_auth);
+		clnt_destroy(clnt);
+	}
+
+	DEBUG(5, ("nfs_quotas: For path \"%s\" returning "
+		  "bsize %.0f, dfree %.0f, dsize %.0f\n",
+		  args.gqa_pathp, (double)*bsize, (double)*dfree,
+		  (double)*dsize));
+
+	SAFE_FREE(cutstr);
+	DEBUG(10,("nfs_quotas: End of nfs_quotas\n" ));
+	return ret;
+}
+
+/* end of nfs quota section */
+
+#ifdef HAVE_LINUX_DQBLK_XFS_H
+#include <linux/dqblk_xfs.h>
+
+/****************************************************************************
+ Abstract out the XFS Quota Manager quota get call.
+****************************************************************************/
+
+static int get_smb_linux_xfs_quota(char *path, uid_t euser_id, gid_t egrp_id, LINUX_SMB_DISK_QUOTA *dp)
+{
+	struct fs_disk_quota D;
+	int ret;
+
+	ZERO_STRUCT(D);
+
+	ret = quotactl(QCMD(Q_XGETQUOTA,USRQUOTA), path, euser_id, (caddr_t)&D);
+
+	if (ret)
+		ret = quotactl(QCMD(Q_XGETQUOTA,GRPQUOTA), path, egrp_id, (caddr_t)&D);
+
+	if (ret)
+		return ret;
+
+	dp->bsize = (uint64_t)512;
+	dp->softlimit = (uint64_t)D.d_blk_softlimit;
+	dp->hardlimit = (uint64_t)D.d_blk_hardlimit;
+	dp->ihardlimit = (uint64_t)D.d_ino_hardlimit;
+	dp->isoftlimit = (uint64_t)D.d_ino_softlimit;
+	dp->curinodes = (uint64_t)D.d_icount;
+	dp->curblocks = (uint64_t)D.d_bcount;
+
+	return ret;
+}
+#else
+static int get_smb_linux_xfs_quota(char *path, uid_t euser_id, gid_t egrp_id, LINUX_SMB_DISK_QUOTA *dp)
+{
+	DEBUG(0,("XFS quota support not available\n"));
+	errno = ENOSYS;
+	return -1;
+}
+#endif
+
+
+/****************************************************************************
+ Abstract out the old and new Linux quota get calls.
+****************************************************************************/
+
+static int get_smb_linux_v1_quota(char *path, uid_t euser_id, gid_t egrp_id, LINUX_SMB_DISK_QUOTA *dp)
+{
+	struct v1_kern_dqblk D;
+	int ret;
+
+	ZERO_STRUCT(D);
+
+	ret = quotactl(QCMD(Q_V1_GETQUOTA,USRQUOTA), path, euser_id, (caddr_t)&D);
+
+	if (ret && errno != EDQUOT)
+		ret = quotactl(QCMD(Q_V1_GETQUOTA,GRPQUOTA), path, egrp_id, (caddr_t)&D);
+
+	if (ret && errno != EDQUOT)
+		return ret;
+
+	dp->bsize = (uint64_t)QUOTABLOCK_SIZE;
+	dp->softlimit = (uint64_t)D.dqb_bsoftlimit;
+	dp->hardlimit = (uint64_t)D.dqb_bhardlimit;
+	dp->ihardlimit = (uint64_t)D.dqb_ihardlimit;
+	dp->isoftlimit = (uint64_t)D.dqb_isoftlimit;
+	dp->curinodes = (uint64_t)D.dqb_curinodes;
+	dp->curblocks = (uint64_t)D.dqb_curblocks;
+
+	return ret;
+}
+
+static int get_smb_linux_v2_quota(char *path, uid_t euser_id, gid_t egrp_id, LINUX_SMB_DISK_QUOTA *dp)
+{
+	struct v2_kern_dqblk D;
+	int ret;
+
+	ZERO_STRUCT(D);
+
+	ret = quotactl(QCMD(Q_V2_GETQUOTA,USRQUOTA), path, euser_id, (caddr_t)&D);
+
+	if (ret && errno != EDQUOT)
+		ret = quotactl(QCMD(Q_V2_GETQUOTA,GRPQUOTA), path, egrp_id, (caddr_t)&D);
+
+	if (ret && errno != EDQUOT)
+		return ret;
+
+	dp->bsize = (uint64_t)QUOTABLOCK_SIZE;
+	dp->softlimit = (uint64_t)D.dqb_bsoftlimit;
+	dp->hardlimit = (uint64_t)D.dqb_bhardlimit;
+	dp->ihardlimit = (uint64_t)D.dqb_ihardlimit;
+	dp->isoftlimit = (uint64_t)D.dqb_isoftlimit;
+	dp->curinodes = (uint64_t)D.dqb_curinodes;
+	dp->curblocks = ((uint64_t)D.dqb_curspace) / dp->bsize;
+
+	return ret;
+}
+
+/****************************************************************************
+ Brand-new generic quota interface.
+****************************************************************************/
+
+static int get_smb_linux_gen_quota(char *path, uid_t euser_id, gid_t egrp_id, LINUX_SMB_DISK_QUOTA *dp)
+{
+	struct if_dqblk D;
+	int ret;
+
+	ZERO_STRUCT(D);
+
+	ret = quotactl(QCMD(Q_GETQUOTA,USRQUOTA), path, euser_id, (caddr_t)&D);
+
+	if (ret && errno != EDQUOT)
+		ret = quotactl(QCMD(Q_GETQUOTA,GRPQUOTA), path, egrp_id, (caddr_t)&D);
+
+	if (ret && errno != EDQUOT)
+		return ret;
+
+	dp->bsize = (uint64_t)QUOTABLOCK_SIZE;
+	dp->softlimit = (uint64_t)D.dqb_bsoftlimit;
+	dp->hardlimit = (uint64_t)D.dqb_bhardlimit;
+	dp->ihardlimit = (uint64_t)D.dqb_ihardlimit;
+	dp->isoftlimit = (uint64_t)D.dqb_isoftlimit;
+	dp->curinodes = (uint64_t)D.dqb_curinodes;
+	dp->curblocks = ((uint64_t)D.dqb_curspace) / dp->bsize;
+
+	return ret;
+}
+
+/****************************************************************************
+ Try to get the disk space from disk quotas (LINUX version).
+****************************************************************************/
+
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	int r;
+	SMB_STRUCT_STAT S;
+	FILE *fp;
+	LINUX_SMB_DISK_QUOTA D;
+	struct mntent *mnt;
+	SMB_DEV_T devno;
+	int found;
+	uid_t euser_id;
+	gid_t egrp_id;
+
+	ZERO_STRUCT(D);
+
+	euser_id = geteuid();
+	egrp_id = getegid();
+
+	/* find the block device file */
+
+	if (sys_stat(path, &S, false) == -1 )
+		return(False) ;
+
+	devno = S.st_ex_dev ;
+
+	if ((fp = setmntent(MOUNTED,"r")) == NULL)
+		return(False) ;
+
+	found = False ;
+
+	while ((mnt = getmntent(fp))) {
+		if (sys_stat(mnt->mnt_dir, &S, false) == -1)
+			continue ;
+
+		if (S.st_ex_dev == devno) {
+			found = True ;
+			break;
+		}
+	}
+
+	endmntent(fp) ;
+
+	if (!found)
+		return(False);
+
+	become_root();
+
+	if (strcmp(mnt->mnt_type, "nfs") == 0) {
+		bool retval;
+		retval = nfs_quotas(mnt->mnt_fsname , euser_id, bsize, dfree, dsize);
+		unbecome_root();
+		return retval;
+	}
+
+	if (strcmp(mnt->mnt_type, "xfs")==0) {
+		r=get_smb_linux_xfs_quota(mnt->mnt_fsname, euser_id, egrp_id, &D);
+	} else {
+		r=get_smb_linux_gen_quota(mnt->mnt_fsname, euser_id, egrp_id, &D);
+		if (r == -1 && errno != EDQUOT) {
+			r=get_smb_linux_v2_quota(mnt->mnt_fsname, euser_id, egrp_id, &D);
+			if (r == -1 && errno != EDQUOT)
+				r=get_smb_linux_v1_quota(mnt->mnt_fsname, euser_id, egrp_id, &D);
+		}
+	}
+
+	unbecome_root();
+
+	/* Use softlimit to determine disk space, except when it has been exceeded */
+	*bsize = D.bsize;
+	if (r == -1) {
+		if (errno == EDQUOT) {
+			*dfree =0;
+			*dsize =D.curblocks;
+			return (True);
+		} else {
+			return(False);
+		}
+	}
+
+	/* Use softlimit to determine disk space, except when it has been exceeded */
+	if (
+		(D.softlimit && D.curblocks >= D.softlimit) ||
+		(D.hardlimit && D.curblocks >= D.hardlimit) ||
+		(D.isoftlimit && D.curinodes >= D.isoftlimit) ||
+		(D.ihardlimit && D.curinodes>=D.ihardlimit)
+	) {
+		*dfree = 0;
+		*dsize = D.curblocks;
+	} else if (D.softlimit==0 && D.hardlimit==0) {
+		return(False);
+	} else {
+		if (D.softlimit == 0)
+			D.softlimit = D.hardlimit;
+		*dfree = D.softlimit - D.curblocks;
+		*dsize = D.softlimit;
+	}
+
+	return (True);
+}
+
+#elif defined(CRAY)
+
+#include <sys/quota.h>
+#include <mntent.h>
+
+/****************************************************************************
+try to get the disk space from disk quotas (CRAY VERSION)
+****************************************************************************/
+
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	struct mntent *mnt;
+	FILE *fd;
+	SMB_STRUCT_STAT sbuf;
+	SMB_DEV_T devno ;
+	struct q_request request ;
+	struct qf_header header ;
+	int quota_default = 0 ;
+	bool found = false;
+
+	if (sys_stat(path, &sbuf, false) == -1) {
+		return false;
+	}
+
+	devno = sbuf.st_ex_dev ;
+
+	if ((fd = setmntent(KMTAB)) == NULL) {
+		return false;
+	}
+
+	while ((mnt = getmntent(fd)) != NULL) {
+		if (sys_stat(mnt->mnt_dir, &sbuf, false) == -1) {
+			continue;
+		}
+		if (sbuf.st_ex_dev == devno) {
+			found = frue ;
+			break;
+		}
+	}
+
+	name = talloc_strdup(talloc_tos(), mnt->mnt_dir);
+	endmntent(fd);
+	if (!found) {
+		return false;
+	}
+
+	if (!name) {
+		return false;
+	}
+
+	request.qf_magic = QF_MAGIC ;
+	request.qf_entry.id = geteuid() ;
+
+	if (quotactl(name, Q_GETQUOTA, &request) == -1) {
+		return false;
+	}
+
+	if (!request.user) {
+		return False;
+	}
+
+	if (request.qf_entry.user_q.f_quota == QFV_DEFAULT) {
+		if (!quota_default) {
+			if (quotactl(name, Q_GETHEADER, &header) == -1) {
+				return false;
+			} else {
+				quota_default = header.user_h.def_fq;
+			}
+		}
+		*dfree = quota_default;
+	} else if (request.qf_entry.user_q.f_quota == QFV_PREVENT) {
+		*dfree = 0;
+	} else {
+		*dfree = request.qf_entry.user_q.f_quota;
+	}
+
+	*dsize = request.qf_entry.user_q.f_use;
+
+	if (*dfree < *dsize) {
+		*dfree = 0;
+	} else {
+		*dfree -= *dsize;
+	}
+
+	*bsize = 4096 ;  /* Cray blocksize */
+	return true;
+}
+
+
+#elif defined(SUNOS5) || defined(SUNOS4)
+
+#include <fcntl.h>
+#include <sys/param.h>
+#if defined(SUNOS5)
+#include <sys/fs/ufs_quota.h>
+#include <sys/mnttab.h>
+#include <sys/mntent.h>
+#else /* defined(SUNOS4) */
+#include <ufs/quota.h>
+#include <mntent.h>
+#endif
+
+#if defined(SUNOS5)
+
+/****************************************************************************
+ Allows querying of remote hosts for quotas on NFS mounted shares.
+ Supports normal NFS and AMD mounts.
+ Alan Romeril <a.romeril@ic.ac.uk> July 2K.
+****************************************************************************/
+
+#include <rpc/rpc.h>
+#include <rpc/types.h>
+#include <rpcsvc/rquota.h>
+#include <rpc/nettype.h>
+#include <rpc/xdr.h>
+
+static int my_xdr_getquota_args(XDR *xdrsp, struct getquota_args *args)
+{
+	if (!xdr_string(xdrsp, &args->gqa_pathp, RQ_PATHLEN ))
+		return(0);
+	if (!xdr_int(xdrsp, &args->gqa_uid))
+		return(0);
+	return (1);
+}
+
+static int my_xdr_getquota_rslt(XDR *xdrsp, struct getquota_rslt *gqr)
+{
+	int quotastat;
+
+	if (!xdr_int(xdrsp, &quotastat)) {
+		DEBUG(6,("nfs_quotas: Status bad or zero\n"));
+		return 0;
+	}
+	gqr->status = quotastat;
+
+	if (!xdr_int(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_bsize)) {
+		DEBUG(6,("nfs_quotas: Block size bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_bool(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_active)) {
+		DEBUG(6,("nfs_quotas: Active bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_int(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_bhardlimit)) {
+		DEBUG(6,("nfs_quotas: Hardlimit bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_int(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_bsoftlimit)) {
+		DEBUG(6,("nfs_quotas: Softlimit bad or zero\n"));
+		return 0;
+	}
+	if (!xdr_int(xdrsp, &gqr->getquota_rslt_u.gqr_rquota.rq_curblocks)) {
+		DEBUG(6,("nfs_quotas: Currentblocks bad or zero\n"));
+		return 0;
+	}
+	return (1);
+}
+
+/* Restricted to SUNOS5 for the moment, I haven`t access to others to test. */
+static bool nfs_quotas(char *nfspath, uid_t euser_id, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	uid_t uid = euser_id;
+	struct dqblk D;
+	char *mnttype = nfspath;
+	CLIENT *clnt;
+	struct getquota_rslt gqr;
+	struct getquota_args args;
+	char *cutstr, *pathname, *host, *testpath;
+	int len;
+	static struct timeval timeout = {2,0};
+	enum clnt_stat clnt_stat;
+	bool ret = True;
+
+	*bsize = *dfree = *dsize = (uint64_t)0;
+
+	len=strcspn(mnttype, ":");
+	pathname=strstr(mnttype, ":");
+	cutstr = (char *) SMB_MALLOC(len+1);
+	if (!cutstr)
+		return False;
+
+	memset(cutstr, '\0', len+1);
+	host = strncat(cutstr,mnttype, sizeof(char) * len );
+	DEBUG(5,("nfs_quotas: looking for mount on \"%s\"\n", cutstr));
+	DEBUG(5,("nfs_quotas: of path \"%s\"\n", mnttype));
+	testpath=strchr_m(mnttype, ':');
+	args.gqa_pathp = testpath+1;
+	args.gqa_uid = uid;
+
+	DEBUG(5,("nfs_quotas: Asking for host \"%s\" rpcprog \"%i\" rpcvers \"%i\" network \"%s\"\n", host, RQUOTAPROG, RQUOTAVERS, "udp"));
+
+	if ((clnt = clnt_create(host, RQUOTAPROG, RQUOTAVERS, "udp")) == NULL) {
+		ret = False;
+		goto out;
+	}
+
+	clnt->cl_auth = authunix_create_default();
+	DEBUG(9,("nfs_quotas: auth_success\n"));
+
+	clnt_stat=clnt_call(clnt, RQUOTAPROC_GETQUOTA, my_xdr_getquota_args, (caddr_t)&args, my_xdr_getquota_rslt, (caddr_t)&gqr, timeout);
+
+	if (clnt_stat != RPC_SUCCESS) {
+		DEBUG(9,("nfs_quotas: clnt_call fail\n"));
+		ret = False;
+		goto out;
+	}
+
+	/*
+	 * gqr.status returns 0 if the rpc call fails, 1 if quotas exist, 2 if there is
+	 * no quota set, and 3 if no permission to get the quota.  If 0 or 3 return
+	 * something sensible.
+	 */
+
+	switch (gqr.status) {
+	case 0:
+		DEBUG(9,("nfs_quotas: Remote Quotas Failed!  Error \"%i\" \n", gqr.status));
+		ret = False;
+		goto out;
+
+	case 1:
+		DEBUG(9,("nfs_quotas: Good quota data\n"));
+		D.dqb_bsoftlimit = gqr.getquota_rslt_u.gqr_rquota.rq_bsoftlimit;
+		D.dqb_bhardlimit = gqr.getquota_rslt_u.gqr_rquota.rq_bhardlimit;
+		D.dqb_curblocks = gqr.getquota_rslt_u.gqr_rquota.rq_curblocks;
+		break;
+
+	case 2:
+	case 3:
+		D.dqb_bsoftlimit = 1;
+		D.dqb_curblocks = 1;
+		DEBUG(9,("nfs_quotas: Remote Quotas returned \"%i\" \n", gqr.status));
+		break;
+
+	default:
+		DEBUG(9,("nfs_quotas: Remote Quotas Questionable!  Error \"%i\" \n", gqr.status ));
+		break;
+	}
+
+	DEBUG(10,("nfs_quotas: Let`s look at D a bit closer... status \"%i\" bsize \"%i\" active? \"%i\" bhard \"%i\" bsoft \"%i\" curb \"%i\" \n",
+			gqr.status,
+			gqr.getquota_rslt_u.gqr_rquota.rq_bsize,
+			gqr.getquota_rslt_u.gqr_rquota.rq_active,
+			gqr.getquota_rslt_u.gqr_rquota.rq_bhardlimit,
+			gqr.getquota_rslt_u.gqr_rquota.rq_bsoftlimit,
+			gqr.getquota_rslt_u.gqr_rquota.rq_curblocks));
+
+	*bsize = gqr.getquota_rslt_u.gqr_rquota.rq_bsize;
+	*dsize = D.dqb_bsoftlimit;
+
+	if (D.dqb_curblocks > D.dqb_bsoftlimit) {
+		*dfree = 0;
+		*dsize = D.dqb_curblocks;
+	} else
+		*dfree = D.dqb_bsoftlimit - D.dqb_curblocks;
+
+  out:
+
+	if (clnt) {
+		if (clnt->cl_auth)
+			auth_destroy(clnt->cl_auth);
+		clnt_destroy(clnt);
+	}
+
+	DEBUG(5,("nfs_quotas: For path \"%s\" returning  bsize %.0f, dfree %.0f, dsize %.0f\n",args.gqa_pathp,(double)*bsize,(double)*dfree,(double)*dsize));
+
+	SAFE_FREE(cutstr);
+	DEBUG(10,("nfs_quotas: End of nfs_quotas\n" ));
+	return ret;
+}
+#endif
+
+/****************************************************************************
+try to get the disk space from disk quotas (SunOS & Solaris2 version)
+Quota code by Peter Urbanec (amiga@cse.unsw.edu.au).
+****************************************************************************/
+
+bool disk_quotas(const char *path,
+		uint64_t *bsize,
+		uint64_t *dfree,
+		uint64_t *dsize)
+{
+	uid_t euser_id;
+	int ret;
+	struct dqblk D;
+#if defined(SUNOS5)
+	struct quotctl command;
+	int file;
+	struct mnttab mnt;
+#else /* SunOS4 */
+	struct mntent *mnt;
+#endif
+	char *name = NULL;
+	FILE *fd;
+	SMB_STRUCT_STAT sbuf;
+	SMB_DEV_T devno;
+	bool found = false;
 
-#include <fcntl.h>
-#include <sys/param.h>
+	euser_id = geteuid();
+
+	if (sys_stat(path, &sbuf, false) == -1) {
+		return false;
+	}
+
+	devno = sbuf.st_ex_dev ;
+	DEBUG(5,("disk_quotas: looking for path \"%s\" devno=%x\n",
+		path, (unsigned int)devno));
 #if defined(SUNOS5)
-#include <sys/fs/ufs_quota.h>
-#include <sys/mnttab.h>
-#include <sys/mntent.h>
-#else /* defined(SUNOS4) */
+	if ((fd = sys_fopen(MNTTAB, "r")) == NULL) {
+		return false;
+	}
+
+	while (getmntent(fd, &mnt) == 0) {
+		if (sys_stat(mnt.mnt_mountp, &sbuf, false) == -1) {
+			continue;
+		}
+
+		DEBUG(5,("disk_quotas: testing \"%s\" devno=%x\n",
+			mnt.mnt_mountp, (unsigned int)devno));
+
+		/* quotas are only on vxfs, UFS or NFS */
+		if ((sbuf.st_ex_dev == devno) && (
+			strcmp( mnt.mnt_fstype, MNTTYPE_UFS ) == 0 ||
+			strcmp( mnt.mnt_fstype, "nfs" ) == 0    ||
+			strcmp( mnt.mnt_fstype, "vxfs" ) == 0 )) {
+				found = true;
+				name = talloc_asprintf(talloc_tos(),
+						"%s/quotas",
+						mnt.mnt_mountp);
+				break;
+		}
+	}
+
+	fclose(fd);
+#else /* SunOS4 */
+	if ((fd = setmntent(MOUNTED, "r")) == NULL) {
+		return false;
+	}
+
+	while ((mnt = getmntent(fd)) != NULL) {
+		if (sys_stat(mnt->mnt_dir, &sbuf, false) == -1) {
+			continue;
+		}
+		DEBUG(5,("disk_quotas: testing \"%s\" devno=%x\n",
+					mnt->mnt_dir,
+					(unsigned int)sbuf.st_ex_dev));
+		if (sbuf.st_ex_dev == devno) {
+			found = true;
+			name = talloc_strdup(talloc_tos(),
+					mnt->mnt_fsname);
+			break;
+		}
+	}
+
+	endmntent(fd);
+#endif
+	if (!found) {
+		return false;
+	}
+
+	if (!name) {
+		return false;
+	}
+	become_root();
+
+#if defined(SUNOS5)
+	if (strcmp(mnt.mnt_fstype, "nfs") == 0) {
+		bool retval;
+		DEBUG(5,("disk_quotas: looking for mountpath (NFS) \"%s\"\n",
+					mnt.mnt_special));
+		retval = nfs_quotas(mnt.mnt_special,
+				euser_id, bsize, dfree, dsize);
+		unbecome_root();
+		return retval;
+	}
+
+	DEBUG(5,("disk_quotas: looking for quotas file \"%s\"\n", name));
+	if((file=sys_open(name, O_RDONLY,0))<0) {
+		unbecome_root();
+		return false;
+	}
+	command.op = Q_GETQUOTA;
+	command.uid = euser_id;
+	command.addr = (caddr_t) &D;
+	ret = ioctl(file, Q_QUOTACTL, &command);
+	close(file);
+#else
+	DEBUG(5,("disk_quotas: trying quotactl on device \"%s\"\n", name));
+	ret = quotactl(Q_GETQUOTA, name, euser_id, &D);
+#endif
+
+	unbecome_root();
+
+	if (ret < 0) {
+		DEBUG(5,("disk_quotas ioctl (Solaris) failed. Error = %s\n",
+					strerror(errno) ));
+
+#if defined(SUNOS5) && defined(VXFS_QUOTA)
+		/* If normal quotactl() fails, try vxfs private calls */
+		set_effective_uid(euser_id);
+		DEBUG(5,("disk_quotas: mount type \"%s\"\n", mnt.mnt_fstype));
+		if ( 0 == strcmp ( mnt.mnt_fstype, "vxfs" )) {
+			bool retval;
+			retval = disk_quotas_vxfs(name, path,
+					bsize, dfree, dsize);
+			return retval;
+		}
+#else
+		return false;
+#endif
+	}
+
+	/* If softlimit is zero, set it equal to hardlimit.
+	 */
+
+	if (D.dqb_bsoftlimit==0) {
+		D.dqb_bsoftlimit = D.dqb_bhardlimit;
+	}
+
+	/* Use softlimit to determine disk space. A user exceeding the quota
+	 * is told that there's no space left. Writes might actually work for
+	 * a bit if the hardlimit is set higher than softlimit. Effectively
+	 * the disk becomes made of rubber latex and begins to expand to
+	 * accommodate the user :-)
+	 */
+
+	if (D.dqb_bsoftlimit==0)
+		return(False);
+	*bsize = DEV_BSIZE;
+	*dsize = D.dqb_bsoftlimit;
+
+	if (D.dqb_curblocks > D.dqb_bsoftlimit) {
+		*dfree = 0;
+		*dsize = D.dqb_curblocks;
+	} else {
+		*dfree = D.dqb_bsoftlimit - D.dqb_curblocks;
+	}
+
+	DEBUG(5,("disk_quotas for path \"%s\" returning "
+		"bsize %.0f, dfree %.0f, dsize %.0f\n",
+		path,(double)*bsize,(double)*dfree,(double)*dsize));
+
+	return true;
+}
+
+
+#elif defined(OSF1)
 #include <ufs/quota.h>
+
+/****************************************************************************
+try to get the disk space from disk quotas - OSF1 version
+****************************************************************************/
+
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+  int r, save_errno;
+  struct dqblk D;
+  SMB_STRUCT_STAT S;
+  uid_t euser_id;
+
+  /*
+   * This code presumes that OSF1 will only
+   * give out quota info when the real uid 
+   * matches the effective uid. JRA.
+   */
+  euser_id = geteuid();
+  save_re_uid();
+  if (set_re_uid() != 0) return False;
+
+  r= quotactl(path,QCMD(Q_GETQUOTA, USRQUOTA),euser_id,(char *) &D);
+  if (r) {
+     save_errno = errno;
+  }
+
+  restore_re_uid();
+
+  *bsize = DEV_BSIZE;
+
+  if (r)
+  {
+      if (save_errno == EDQUOT)   /* disk quota exceeded */
+      {
+         *dfree = 0;
+         *dsize = D.dqb_curblocks;
+         return (True);
+      }
+      else
+         return (False);  
+  }
+
+  /* If softlimit is zero, set it equal to hardlimit.
+   */
+
+  if (D.dqb_bsoftlimit==0)
+    D.dqb_bsoftlimit = D.dqb_bhardlimit;
+
+  /* Use softlimit to determine disk space, except when it has been exceeded */
+
+  if (D.dqb_bsoftlimit==0)
+    return(False);
+
+  if ((D.dqb_curblocks>D.dqb_bsoftlimit)) {
+    *dfree = 0;
+    *dsize = D.dqb_curblocks;
+  } else {
+    *dfree = D.dqb_bsoftlimit - D.dqb_curblocks;
+    *dsize = D.dqb_bsoftlimit;
+  }
+  return (True);
+}
+
+#elif defined (IRIX6)
+/****************************************************************************
+try to get the disk space from disk quotas (IRIX 6.2 version)
+****************************************************************************/
+
+#include <sys/quota.h>
 #include <mntent.h>
+
+bool disk_quotas(const char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+  uid_t euser_id;
+  int r;
+  struct dqblk D;
+  struct fs_disk_quota        F;
+  SMB_STRUCT_STAT S;
+  FILE *fp;
+  struct mntent *mnt;
+  SMB_DEV_T devno;
+  int found;
+  
+  /* find the block device file */
+  
+  if ( sys_stat(path, &S, false) == -1 ) {
+    return(False) ;
+  }
+
+  devno = S.st_ex_dev ;
+  
+  fp = setmntent(MOUNTED,"r");
+  found = False ;
+  
+  while ((mnt = getmntent(fp))) {
+    if ( sys_stat(mnt->mnt_dir, &S, false) == -1 )
+      continue ;
+    if (S.st_ex_dev == devno) {
+      found = True ;
+      break ;
+    }
+  }
+  endmntent(fp) ;
+  
+  if (!found) {
+    return(False);
+  }
+
+  euser_id=geteuid();
+  become_root();
+
+  /* Use softlimit to determine disk space, except when it has been exceeded */
+
+  *bsize = 512;
+
+  if ( 0 == strcmp ( mnt->mnt_type, "efs" ))
+  {
+    r=quotactl (Q_GETQUOTA, mnt->mnt_fsname, euser_id, (caddr_t) &D);
+
+    unbecome_root();
+
+    if (r==-1)
+      return(False);
+        
+    /* Use softlimit to determine disk space, except when it has been exceeded */
+    if (
+        (D.dqb_bsoftlimit && D.dqb_curblocks>=D.dqb_bsoftlimit) ||
+        (D.dqb_bhardlimit && D.dqb_curblocks>=D.dqb_bhardlimit) ||
+        (D.dqb_fsoftlimit && D.dqb_curfiles>=D.dqb_fsoftlimit) ||
+        (D.dqb_fhardlimit && D.dqb_curfiles>=D.dqb_fhardlimit)
+       )
+    {
+      *dfree = 0;
+      *dsize = D.dqb_curblocks;
+    }
+    else if (D.dqb_bsoftlimit==0 && D.dqb_bhardlimit==0)
+    {
+      return(False);
+    }
+    else 
+    {
+      *dfree = D.dqb_bsoftlimit - D.dqb_curblocks;
+      *dsize = D.dqb_bsoftlimit;
+    }
+
+  }
+  else if ( 0 == strcmp ( mnt->mnt_type, "xfs" ))
+  {
+    r=quotactl (Q_XGETQUOTA, mnt->mnt_fsname, euser_id, (caddr_t) &F);
+
+    unbecome_root();
+
+    if (r==-1)
+    {
+      DEBUG(5, ("quotactl for uid=%u: %s", euser_id, strerror(errno)));
+      return(False);
+    }
+        
+    /* No quota for this user. */
+    if (F.d_blk_softlimit==0 && F.d_blk_hardlimit==0)
+    {
+      return(False);
+    }
+
+    /* Use softlimit to determine disk space, except when it has been exceeded */
+    if (
+        (F.d_blk_softlimit && F.d_bcount>=F.d_blk_softlimit) ||
+        (F.d_blk_hardlimit && F.d_bcount>=F.d_blk_hardlimit) ||
+        (F.d_ino_softlimit && F.d_icount>=F.d_ino_softlimit) ||
+        (F.d_ino_hardlimit && F.d_icount>=F.d_ino_hardlimit)
+       )
+    {
+      *dfree = 0;
+      *dsize = F.d_bcount;
+    }
+    else 
+    {
+      *dfree = (F.d_blk_softlimit - F.d_bcount);
+      *dsize = F.d_blk_softlimit ? F.d_blk_softlimit : F.d_blk_hardlimit;
+    }
+
+  }
+  else
+  {
+	  unbecome_root();
+	  return(False);
+  }
+
+  return (True);
+
+}
+
+#else
+
+#if    defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+#include <ufs/ufs/quota.h>
+#include <machine/param.h>
+#elif         AIX
+/* AIX quota patch from Ole Holm Nielsen <ohnielse@fysik.dtu.dk> */
+#include <jfs/quota.h>
+/* AIX 4.X: Rename members of the dqblk structure (ohnielse@fysik.dtu.dk) */
+#define dqb_curfiles dqb_curinodes
+#define dqb_fhardlimit dqb_ihardlimit
+#define dqb_fsoftlimit dqb_isoftlimit
+#ifdef _AIXVERSION_530 
+#include <sys/statfs.h>
+#include <sys/vmount.h>
+#endif /* AIX 5.3 */
+#else /* !__FreeBSD__ && !AIX && !__OpenBSD__ && !__DragonFly__ */
+#include <sys/quota.h>
+#include <devnm.h>
 #endif
 
-#if defined(SUNOS5)
-
-/****************************************************************************
- Allows querying of remote hosts for quotas on NFS mounted shares.
- Supports normal NFS and AMD mounts.
- Alan Romeril <a.romeril@ic.ac.uk> July 2K.
-****************************************************************************/
+#if defined(__FreeBSD__) || defined(__DragonFly__)
 
 #include <rpc/rpc.h>
 #include <rpc/types.h>
 #include <rpcsvc/rquota.h>
+#ifdef HAVE_RPC_NETTYPE_H
 #include <rpc/nettype.h>
+#endif
 #include <rpc/xdr.h>
 
+static int my_xdr_getquota_args(XDR *xdrsp, struct getquota_args *args)
+{
+	if (!xdr_string(xdrsp, &args->gqa_pathp, RQ_PATHLEN ))
+		return(0);
+	if (!xdr_int(xdrsp, &args->gqa_uid))
+		return(0);
+	return (1);
+}
+
 static int my_xdr_getquota_rslt(XDR *xdrsp, struct getquota_rslt *gqr)
 {
 	int quotastat;
@@ -112,16 +1209,7 @@
 	return (1);
 }
 
-static int my_xdr_getquota_args(XDR *xdrsp, struct getquota_args *args)
-{
-	if (!xdr_string(xdrsp, &args->gqa_pathp, RQ_PATHLEN ))
-		return(0);
-	if (!xdr_int(xdrsp, &args->gqa_uid))
-		return(0);
-	return (1);
-}
-
-/* Restricted to SUNOS5 for the moment, I haven`t access to others to test. */
+/* Works on FreeBSD, too. :-) */
 static bool nfs_quotas(char *nfspath, uid_t euser_id, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
 {
 	uid_t uid = euser_id;
@@ -162,7 +1250,7 @@
 	clnt->cl_auth = authunix_create_default();
 	DEBUG(9,("nfs_quotas: auth_success\n"));
 
-	clnt_stat=clnt_call(clnt, RQUOTAPROC_GETQUOTA, my_xdr_getquota_args, (caddr_t)&args, my_xdr_getquota_rslt, (caddr_t)&gqr, timeout);
+	clnt_stat=clnt_call(clnt, RQUOTAPROC_GETQUOTA, (const xdrproc_t) my_xdr_getquota_args, (caddr_t)&args, (const xdrproc_t) my_xdr_getquota_rslt, (caddr_t)&gqr, timeout);
 
 	if (clnt_stat != RPC_SUCCESS) {
 		DEBUG(9,("nfs_quotas: clnt_call fail\n"));
@@ -170,11 +1258,11 @@
 		goto out;
 	}
 
-	/*
-	 * gqr.status returns 0 if the rpc call fails, 1 if quotas exist, 2 if there is
+	/* 
+	 * gqr->status returns 0 if the rpc call fails, 1 if quotas exist, 2 if there is
 	 * no quota set, and 3 if no permission to get the quota.  If 0 or 3 return
 	 * something sensible.
-	 */
+	 */   
 
 	switch (gqr.status) {
 	case 0:
@@ -197,7 +1285,7 @@
 		break;
 
 	default:
-		DEBUG(9,("nfs_quotas: Remote Quotas Questionable!  Error \"%i\" \n", gqr.status ));
+		DEBUG(9,("nfs_quotas: Remote Quotas Questionable!  Error \"%i\" \n", gqr.status));
 		break;
 	}
 
@@ -209,9 +1297,17 @@
 			gqr.getquota_rslt_u.gqr_rquota.rq_bsoftlimit,
 			gqr.getquota_rslt_u.gqr_rquota.rq_curblocks));
 
+	if (D.dqb_bsoftlimit == 0)
+		D.dqb_bsoftlimit = D.dqb_bhardlimit;
+	if (D.dqb_bsoftlimit == 0)
+		return False;
+
 	*bsize = gqr.getquota_rslt_u.gqr_rquota.rq_bsize;
 	*dsize = D.dqb_bsoftlimit;
 
+	if (D.dqb_curblocks == 1)
+		*bsize = DEV_BSIZE;
+
 	if (D.dqb_curblocks > D.dqb_bsoftlimit) {
 		*dfree = 0;
 		*dsize = D.dqb_curblocks;
@@ -232,201 +1328,9 @@
 	DEBUG(10,("nfs_quotas: End of nfs_quotas\n" ));
 	return ret;
 }
-#endif
-
-/****************************************************************************
-try to get the disk space from disk quotas (SunOS & Solaris2 version)
-Quota code by Peter Urbanec (amiga@cse.unsw.edu.au).
-****************************************************************************/
-
-bool disk_quotas(const char *path,
-		uint64_t *bsize,
-		uint64_t *dfree,
-		uint64_t *dsize)
-{
-	uid_t euser_id;
-	int ret;
-	struct dqblk D;
-#if defined(SUNOS5)
-	struct quotctl command;
-	int file;
-	struct mnttab mnt;
-#else /* SunOS4 */
-	struct mntent *mnt;
-#endif
-	char *name = NULL;
-	FILE *fd;
-	SMB_STRUCT_STAT sbuf;
-	SMB_DEV_T devno;
-	bool found = false;
-
-	euser_id = geteuid();
-
-	if (sys_stat(path, &sbuf, false) == -1) {
-		return false;
-	}
-
-	devno = sbuf.st_ex_dev ;
-	DEBUG(5,("disk_quotas: looking for path \"%s\" devno=%x\n",
-		path, (unsigned int)devno));
-#if defined(SUNOS5)
-	if ((fd = fopen(MNTTAB, "r")) == NULL) {
-		return false;
-	}
-
-	while (getmntent(fd, &mnt) == 0) {
-		if (sys_stat(mnt.mnt_mountp, &sbuf, false) == -1) {
-			continue;
-		}
-
-		DEBUG(5,("disk_quotas: testing \"%s\" devno=%x\n",
-			mnt.mnt_mountp, (unsigned int)devno));
-
-		/* quotas are only on vxfs, UFS or NFS */
-		if ((sbuf.st_ex_dev == devno) && (
-			strcmp( mnt.mnt_fstype, MNTTYPE_UFS ) == 0 ||
-			strcmp( mnt.mnt_fstype, "nfs" ) == 0    ||
-			strcmp( mnt.mnt_fstype, "vxfs" ) == 0 )) {
-				found = true;
-				name = talloc_asprintf(talloc_tos(),
-						"%s/quotas",
-						mnt.mnt_mountp);
-				break;
-		}
-	}
-
-	fclose(fd);
-#else /* SunOS4 */
-	if ((fd = setmntent(MOUNTED, "r")) == NULL) {
-		return false;
-	}
-
-	while ((mnt = getmntent(fd)) != NULL) {
-		if (sys_stat(mnt->mnt_dir, &sbuf, false) == -1) {
-			continue;
-		}
-		DEBUG(5,("disk_quotas: testing \"%s\" devno=%x\n",
-					mnt->mnt_dir,
-					(unsigned int)sbuf.st_ex_dev));
-		if (sbuf.st_ex_dev == devno) {
-			found = true;
-			name = talloc_strdup(talloc_tos(),
-					mnt->mnt_fsname);
-			break;
-		}
-	}
-
-	endmntent(fd);
-#endif
-	if (!found) {
-		return false;
-	}
-
-	if (!name) {
-		return false;
-	}
-	become_root();
-
-#if defined(SUNOS5)
-	if (strcmp(mnt.mnt_fstype, "nfs") == 0) {
-		bool retval;
-		DEBUG(5,("disk_quotas: looking for mountpath (NFS) \"%s\"\n",
-					mnt.mnt_special));
-		retval = nfs_quotas(mnt.mnt_special,
-				euser_id, bsize, dfree, dsize);
-		unbecome_root();
-		return retval;
-	}
-
-	DEBUG(5,("disk_quotas: looking for quotas file \"%s\"\n", name));
-	if((file=open(name, O_RDONLY,0))<0) {
-		unbecome_root();
-		return false;
-	}
-	command.op = Q_GETQUOTA;
-	command.uid = euser_id;
-	command.addr = (caddr_t) &D;
-	ret = ioctl(file, Q_QUOTACTL, &command);
-	close(file);
-#else
-	DEBUG(5,("disk_quotas: trying quotactl on device \"%s\"\n", name));
-	ret = quotactl(Q_GETQUOTA, name, euser_id, &D);
-#endif
-
-	unbecome_root();
-
-	if (ret < 0) {
-		DEBUG(5,("disk_quotas ioctl (Solaris) failed. Error = %s\n",
-					strerror(errno) ));
-
-#if defined(SUNOS5) && defined(VXFS_QUOTA)
-		/* If normal quotactl() fails, try vxfs private calls */
-		set_effective_uid(euser_id);
-		DEBUG(5,("disk_quotas: mount type \"%s\"\n", mnt.mnt_fstype));
-		if ( 0 == strcmp ( mnt.mnt_fstype, "vxfs" )) {
-			bool retval;
-			retval = disk_quotas_vxfs(name, path,
-					bsize, dfree, dsize);
-			return retval;
-		}
-#else
-		return false;
-#endif
-	}
-
-	/* If softlimit is zero, set it equal to hardlimit.
-	 */
-
-	if (D.dqb_bsoftlimit==0) {
-		D.dqb_bsoftlimit = D.dqb_bhardlimit;
-	}
-
-	/* Use softlimit to determine disk space. A user exceeding the quota
-	 * is told that there's no space left. Writes might actually work for
-	 * a bit if the hardlimit is set higher than softlimit. Effectively
-	 * the disk becomes made of rubber latex and begins to expand to
-	 * accommodate the user :-)
-	 */
-
-	if (D.dqb_bsoftlimit==0)
-		return(False);
-	*bsize = DEV_BSIZE;
-	*dsize = D.dqb_bsoftlimit;
-
-	if (D.dqb_curblocks > D.dqb_bsoftlimit) {
-		*dfree = 0;
-		*dsize = D.dqb_curblocks;
-	} else {
-		*dfree = D.dqb_bsoftlimit - D.dqb_curblocks;
-	}
-
-	DEBUG(5,("disk_quotas for path \"%s\" returning "
-		"bsize %.0f, dfree %.0f, dsize %.0f\n",
-		path,(double)*bsize,(double)*dfree,(double)*dsize));
-
-	return true;
-}
-
-
-#else
 
-#if           AIX
-/* AIX quota patch from Ole Holm Nielsen <ohnielse@fysik.dtu.dk> */
-#include <jfs/quota.h>
-/* AIX 4.X: Rename members of the dqblk structure (ohnielse@fysik.dtu.dk) */
-#define dqb_curfiles dqb_curinodes
-#define dqb_fhardlimit dqb_ihardlimit
-#define dqb_fsoftlimit dqb_isoftlimit
-#ifdef _AIXVERSION_530 
-#include <sys/statfs.h>
-#include <sys/vmount.h>
-#endif /* AIX 5.3 */
-#else /* !AIX */
-#include <sys/quota.h>
-#include <devnm.h>
 #endif
 
-
 /****************************************************************************
 try to get the disk space from disk quotas - default version
 ****************************************************************************/
@@ -436,21 +1340,89 @@
   int r;
   struct dqblk D;
   uid_t euser_id;
-#if !defined(AIX)
+#if !defined(__FreeBSD__) && !defined(AIX) && !defined(__OpenBSD__) && !defined(__DragonFly__)
   char dev_disk[256];
   SMB_STRUCT_STAT S;
 
   /* find the block device file */
 
+#ifdef HPUX
+  /* Need to set the cache flag to 1 for HPUX. Seems
+   * to have a significant performance boost when
+   * lstat calls on /dev access this function.
+   */
+  if ((sys_stat(path, &S, false)<0)
+      || (devnm(S_IFBLK, S.st_ex_dev, dev_disk, 256, 1)<0))
+#else
   if ((sys_stat(path, &S, false)<0)
       || (devnm(S_IFBLK, S.st_ex_dev, dev_disk, 256, 0)<0))
 	return (False);
+#endif /* ifdef HPUX */
 
-#endif /* !defined(AIX) */
+#endif /* !defined(__FreeBSD__) && !defined(AIX) && !defined(__OpenBSD__) && !defined(__DragonFly__) */
 
   euser_id = geteuid();
 
-#if   defined(AIX)
+#ifdef HPUX
+  /* for HPUX, real uid must be same as euid to execute quotactl for euid */
+  save_re_uid();
+  if (set_re_uid() != 0) return False;
+  
+  r=quotactl(Q_GETQUOTA, dev_disk, euser_id, &D);
+
+  restore_re_uid();
+#else 
+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+  {
+    /* FreeBSD patches from Marty Moll <martym@arbor.edu> */
+    gid_t egrp_id;
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+    SMB_DEV_T devno;
+    struct statfs *mnts;
+    SMB_STRUCT_STAT st;
+    int mntsize, i;
+    
+    if (sys_stat(path, &st, false) < 0)
+        return False;
+    devno = st.st_ex_dev;
+
+    mntsize = getmntinfo(&mnts,MNT_NOWAIT);
+    if (mntsize <= 0)
+        return False;
+
+    for (i = 0; i < mntsize; i++) {
+	if (sys_stat(mnts[i].f_mntonname, &st, false) < 0)
+            return False;
+        if (st.st_ex_dev == devno)
+            break;
+    }
+    if (i == mntsize)
+        return False;
+#endif
+    
+    become_root();
+
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+    if (strcmp(mnts[i].f_fstypename,"nfs") == 0) {
+        bool retval;
+        retval = nfs_quotas(mnts[i].f_mntfromname,euser_id,bsize,dfree,dsize);
+        unbecome_root();
+        return retval;
+    }
+#endif
+
+    egrp_id = getegid();
+    r= quotactl(path,QCMD(Q_GETQUOTA,USRQUOTA),euser_id,(char *) &D);
+
+    /* As FreeBSD has group quotas, if getting the user
+       quota fails, try getting the group instead. */
+    if (r) {
+	    r= quotactl(path,QCMD(Q_GETQUOTA,GRPQUOTA),egrp_id,(char *) &D);
+    }
+
+    unbecome_root();
+  }
+#elif defined(AIX)
   /* AIX has both USER and GROUP quotas: 
      Get the USER quota (ohnielse@fysik.dtu.dk) */
 #ifdef _AIXVERSION_530
@@ -487,12 +1459,17 @@
       r = 1; /* Fail for other FS-types */
   }
 #endif /* AIX 5.3 */
-#else /* !AIX */
+#else /* !__FreeBSD__ && !AIX && !__OpenBSD__ && !__DragonFly__ */
   r=quotactl(Q_GETQUOTA, dev_disk, euser_id, &D);
-#endif /* !AIX */
+#endif /* !__FreeBSD__ && !AIX && !__OpenBSD__ && !__DragonFly__ */
+#endif /* HPUX */
 
   /* Use softlimit to determine disk space, except when it has been exceeded */
+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+  *bsize = DEV_BSIZE;
+#else /* !__FreeBSD__ && !__OpenBSD__ && !__DragonFly__ */
   *bsize = 1024;
+#endif /*!__FreeBSD__ && !__OpenBSD__ && !__DragonFly__ */
 
   if (r)
     {
@@ -515,7 +1492,9 @@
     return(False);
   /* Use softlimit to determine disk space, except when it has been exceeded */
   if ((D.dqb_curblocks>D.dqb_bsoftlimit)
+#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__DragonFly__)
 ||((D.dqb_curfiles>D.dqb_fsoftlimit) && (D.dqb_fsoftlimit != 0))
+#endif
     ) {
       *dfree = 0;
       *dsize = D.dqb_curblocks;
@@ -603,7 +1582,7 @@
   set_effective_uid(0);
 
   DEBUG(5,("disk_quotas: looking for VxFS quotas file \"%s\"\n", qfname));
-  if((file=open(qfname, O_RDONLY,0))<0) {
+  if((file=sys_open(qfname, O_RDONLY,0))<0) {
     set_effective_uid(euser_id);
     return(False);
   }
Only in ../../samba-3.6.24/source3/smbd: quotas.o
diff -ur smbd/reply.c ../../samba-3.6.24/source3/smbd/reply.c
--- smbd/reply.c	2014-05-28 01:20:37.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/reply.c	2015-01-28 10:52:25.149068676 +0800
@@ -32,7 +32,6 @@
 #include "fake_file.h"
 #include "rpc_client/rpc_client.h"
 #include "../librpc/gen_ndr/ndr_spoolss_c.h"
-#include "../librpc/gen_ndr/open_files.h"
 #include "rpc_client/cli_spoolss.h"
 #include "rpc_client/init_spoolss.h"
 #include "rpc_server/rpc_ncacn_np.h"
@@ -40,9 +39,6 @@
 #include "libsmb/nmblib.h"
 #include "auth.h"
 #include "smbprofile.h"
-#include "../lib/tsocket/tsocket.h"
-#include "lib/tevent_wait.h"
-#include "libcli/smb/smb_signing.h"
 
 /****************************************************************************
  Ensure we check the path in *exactly* the same way as W2K for a findfirst/findnext
@@ -318,16 +314,9 @@
 				 char **pp_dest, const char *src, int flags,
 				 NTSTATUS *err, bool *contains_wcard)
 {
-	ssize_t bufrem = smbreq_bufrem(req, src);
-
-	if (bufrem < 0) {
-		*err = NT_STATUS_INVALID_PARAMETER;
-		return 0;
-	}
-
-	return srvstr_get_path_wcard(mem_ctx, (const char *)req->inbuf,
-				     req->flags2, pp_dest, src, bufrem, flags,
-				     err, contains_wcard);
+	return srvstr_get_path_wcard(mem_ctx, (char *)req->inbuf, req->flags2,
+				     pp_dest, src, smbreq_bufrem(req, src),
+				     flags, err, contains_wcard);
 }
 
 size_t srvstr_get_path_req(TALLOC_CTX *mem_ctx, struct smb_request *req,
@@ -339,23 +328,6 @@
 					 flags, err, &ignore);
 }
 
-/* pull a string from the smb_buf part of a packet. In this case the
-   string can either be null terminated or it can be terminated by the
-   end of the smbbuf area
-*/
-size_t srvstr_pull_req_talloc(TALLOC_CTX *ctx, struct smb_request *req,
-			      char **dest, const char *src, int flags)
-{
-	ssize_t bufrem = smbreq_bufrem(req, src);
-
-	if (bufrem < 0) {
-		return 0;
-	}
-
-	return pull_string_talloc(ctx, req->inbuf, req->flags2, dest, src,
-				  bufrem, flags);
-}
-
 /****************************************************************************
  Check if we have a correct fsp pointing to a file. Basic check for open fsp.
 ****************************************************************************/
@@ -436,13 +408,13 @@
 	char *retarget;
 	char *p;
 	int retarget_type = 0x20;
-	int retarget_port = NBT_SMB_PORT;
+	int retarget_port = 139;
 	struct sockaddr_storage retarget_addr;
 	struct sockaddr_in *in_addr;
 	bool ret = false;
 	uint8_t outbuf[10];
 
-	if (get_socket_port(sconn->sock) != NBT_SMB_PORT) {
+	if (get_socket_port(sconn->sock) != 139) {
 		return false;
 	}
 
@@ -509,7 +481,7 @@
 
 	if (!srv_send_smb(sconn, (char *)outbuf, false, 0, false,
 			  NULL)) {
-		exit_server_cleanly("netbios_session_retarget: srv_send_smb "
+		exit_server_cleanly("netbios_session_regarget: srv_send_smb "
 				    "failed.");
 	}
 
@@ -519,13 +491,6 @@
 	return ret;
 }
 
-static void reply_called_name_not_present(char *outbuf)
-{
-	smb_setlen(outbuf, 1);
-	SCVAL(outbuf, 0, 0x83);
-	SCVAL(outbuf, 4, 0x82);
-}
-
 /****************************************************************************
  Reply to a (netbios-level) special message. 
 ****************************************************************************/
@@ -546,7 +511,7 @@
 	smb_setlen(outbuf,0);
 
 	switch (msg_type) {
-	case NBSSrequest: /* session request */
+	case 0x81: /* session request */
 	{
 		/* inbuf_size is guarenteed to be at least 4. */
 		fstring name1,name2;
@@ -559,20 +524,18 @@
 			exit_server_cleanly("multiple session request not permitted");
 		}
 
-		SCVAL(outbuf,0,NBSSpositive);
+		SCVAL(outbuf,0,0x82);
 		SCVAL(outbuf,3,0);
 
 		/* inbuf_size is guaranteed to be at least 4. */
 		name_len1 = name_len((unsigned char *)(inbuf+4),inbuf_size - 4);
 		if (name_len1 <= 0 || name_len1 > inbuf_size - 4) {
 			DEBUG(0,("Invalid name length in session request\n"));
-			reply_called_name_not_present(outbuf);
 			break;
 		}
 		name_len2 = name_len((unsigned char *)(inbuf+4+name_len1),inbuf_size - 4 - name_len1);
 		if (name_len2 <= 0 || name_len2 > inbuf_size - 4 - name_len1) {
 			DEBUG(0,("Invalid name length in session request\n"));
-			reply_called_name_not_present(outbuf);
 			break;
 		}
 
@@ -583,7 +546,6 @@
 
 		if (name_type1 == -1 || name_type2 == -1) {
 			DEBUG(0,("Invalid name type in session request\n"));
-			reply_called_name_not_present(outbuf);
 			break;
 		}
 
@@ -600,33 +562,12 @@
 		 */
 		if (strequal(name1, "*SMBSERVER     ")
 		    || strequal(name1, "*SMBSERV       "))  {
-			char *raddr;
-
-			raddr = tsocket_address_inet_addr_string(sconn->remote_address,
-								 talloc_tos());
-			if (raddr == NULL) {
-				exit_server_cleanly("could not allocate raddr");
-			}
-
-			fstrcpy(name1, raddr);
+			fstrcpy(name1, sconn->client_id.addr);
 		}
 
 		set_local_machine_name(name1, True);
 		set_remote_machine_name(name2, True);
 
-		if (is_ipaddress(sconn->remote_hostname)) {
-			char *p = discard_const_p(char, sconn->remote_hostname);
-
-			talloc_free(p);
-
-			sconn->remote_hostname = talloc_strdup(sconn,
-						get_remote_machine_name());
-			if (sconn->remote_hostname == NULL) {
-				exit_server_cleanly("could not copy remote name");
-			}
-			sconn->conn->remote_hostname = sconn->remote_hostname;
-		}
-
 		DEBUG(2,("netbios connect: local=%s remote=%s, name type = %x\n",
 			 get_local_machine_name(), get_remote_machine_name(),
 			 name_type2));
@@ -634,11 +575,18 @@
 		if (name_type2 == 'R') {
 			/* We are being asked for a pathworks session --- 
 			   no thanks! */
-			reply_called_name_not_present(outbuf);
+			SCVAL(outbuf, 0,0x83);
 			break;
 		}
 
-		reload_services(sconn, conn_snum_used, true);
+		/* only add the client's machine name to the list
+		   of possibly valid usernames if we are operating
+		   in share mode security */
+		if (lp_security() == SEC_SHARE) {
+			add_session_user(sconn, get_remote_machine_name());
+		}
+
+		reload_services(sconn->msg_ctx, sconn->sock, True);
 		reopen_logs();
 
 		sconn->nbt.got_session = true;
@@ -647,17 +595,17 @@
 
 	case 0x89: /* session keepalive request 
 		      (some old clients produce this?) */
-		SCVAL(outbuf,0,NBSSkeepalive);
+		SCVAL(outbuf,0,SMBkeepalive);
 		SCVAL(outbuf,3,0);
 		break;
 
-	case NBSSpositive: /* positive session response */
-	case NBSSnegative: /* negative session response */
-	case NBSSretarget: /* retarget session response */
+	case 0x82: /* positive session response */
+	case 0x83: /* negative session response */
+	case 0x84: /* retarget session response */
 		DEBUG(0,("Unexpected session response\n"));
 		break;
 
-	case NBSSkeepalive: /* session keepalive */
+	case SMBkeepalive: /* session keepalive */
 	default:
 		return;
 	}
@@ -666,10 +614,6 @@
 		    msg_type, msg_flags));
 
 	srv_send_smb(sconn, outbuf, false, 0, false, NULL);
-
-	if (CVAL(outbuf, 0) != 0x82) {
-		exit_server_cleanly("invalid netbios session");
-	}
 	return;
 }
 
@@ -688,9 +632,9 @@
 	int pwlen=0;
 	NTSTATUS nt_status;
 	const char *p;
+	DATA_BLOB password_blob;
 	TALLOC_CTX *ctx = talloc_tos();
 	struct smbd_server_connection *sconn = req->sconn;
-	NTTIME now = timeval_to_nttime(&req->request_time);
 
 	START_PROFILE(SMBtcon);
 
@@ -720,10 +664,14 @@
 		service = service_buf;
 	}
 
-	conn = make_connection(sconn, now, service, dev,
+	password_blob = data_blob(password, pwlen+1);
+
+	conn = make_connection(sconn,service,password_blob,dev,
 			       req->vuid,&nt_status);
 	req->conn = conn;
 
+	data_blob_clear_free(&password_blob);
+
 	if (!conn) {
 		reply_nterror(req, nt_status);
 		END_PROFILE(SMBtcon);
@@ -751,6 +699,7 @@
 {
 	connection_struct *conn = req->conn;
 	const char *service = NULL;
+	DATA_BLOB password;
 	TALLOC_CTX *ctx = talloc_tos();
 	/* what the cleint thinks the device is */
 	char *client_devicetype = NULL;
@@ -760,11 +709,7 @@
 	int passlen;
 	char *path = NULL;
 	const char *p, *q;
-	uint16_t tcon_flags;
-	struct smbXsrv_session *session = NULL;
-	NTTIME now = timeval_to_nttime(&req->request_time);
-	bool session_key_updated = false;
-	uint16_t optional_support = 0;
+	uint16 tcon_flags;
 	struct smbd_server_connection *sconn = req->sconn;
 
 	START_PROFILE(SMBtconX);
@@ -779,32 +724,10 @@
 	tcon_flags = SVAL(req->vwv+2, 0);
 
 	/* we might have to close an old one */
-	if ((tcon_flags & TCONX_FLAG_DISCONNECT_TID) && conn) {
-		struct smbXsrv_tcon *tcon;
-		NTSTATUS status;
-
-		tcon = conn->tcon;
+	if ((tcon_flags & 0x1) && conn) {
+		close_cnum(conn,req->vuid);
 		req->conn = NULL;
 		conn = NULL;
-
-		/*
-		 * TODO: cancel all outstanding requests on the tcon
-		 */
-		status = smbXsrv_tcon_disconnect(tcon, req->vuid);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0, ("reply_tcon_and_X: "
-				  "smbXsrv_tcon_disconnect() failed: %s\n",
-				  nt_errstr(status)));
-			/*
-			 * If we hit this case, there is something completely
-			 * wrong, so we better disconnect the transport connection.
-			 */
-			END_PROFILE(SMBtconX);
-			exit_server(__location__ ": smbXsrv_tcon_disconnect failed");
-			return;
-		}
-
-		TALLOC_FREE(tcon);
 	}
 
 	if ((passlen > MAX_PASS_LEN) || (passlen >= req->buflen)) {
@@ -814,14 +737,27 @@
 	}
 
 	if (sconn->smb1.negprot.encrypted_passwords) {
-		p = (const char *)req->buf + passlen;
+		password = data_blob_talloc(talloc_tos(), req->buf, passlen);
+		if (lp_security() == SEC_SHARE) {
+			/*
+			 * Security = share always has a pad byte
+			 * after the password.
+			 */
+			p = (const char *)req->buf + passlen + 1;
+		} else {
+			p = (const char *)req->buf + passlen;
+		}
 	} else {
+		password = data_blob_talloc(talloc_tos(), req->buf, passlen+1);
+		/* Ensure correct termination */
+		password.data[passlen]=0;
 		p = (const char *)req->buf + passlen + 1;
 	}
 
 	p += srvstr_pull_req_talloc(ctx, req, &path, p, STR_TERMINATE);
 
 	if (path == NULL) {
+		data_blob_clear_free(&password);
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
 		END_PROFILE(SMBtconX);
 		return;
@@ -834,6 +770,7 @@
 	if (*path=='\\') {
 		q = strchr_m(path+2,'\\');
 		if (!q) {
+			data_blob_clear_free(&password);
 			reply_nterror(req, NT_STATUS_BAD_NETWORK_NAME);
 			END_PROFILE(SMBtconX);
 			return;
@@ -848,6 +785,7 @@
 				MIN(6, smbreq_bufrem(req, p)), STR_ASCII);
 
 	if (client_devicetype == NULL) {
+		data_blob_clear_free(&password);
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
 		END_PROFILE(SMBtconX);
 		return;
@@ -855,99 +793,13 @@
 
 	DEBUG(4,("Client requested device type [%s] for share [%s]\n", client_devicetype, service));
 
-	nt_status = smb1srv_session_lookup(req->sconn->conn,
-					   req->vuid, now, &session);
-	if (NT_STATUS_EQUAL(nt_status, NT_STATUS_USER_SESSION_DELETED)) {
-		reply_force_doserror(req, ERRSRV, ERRbaduid);
-		END_PROFILE(SMBtconX);
-		return;
-	}
-	if (NT_STATUS_EQUAL(nt_status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {
-		reply_nterror(req, nt_status);
-		END_PROFILE(SMBtconX);
-		return;
-	}
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
-		END_PROFILE(SMBtconX);
-		return;
-	}
-
-	if (session->global->auth_session_info == NULL) {
-		reply_nterror(req, NT_STATUS_INVALID_HANDLE);
-		END_PROFILE(SMBtconX);
-		return;
-	}
-
-	/*
-	 * If there is no application key defined yet
-	 * we create one.
-	 *
-	 * This means we setup the application key on the
-	 * first tcon that happens via the given session.
-	 *
-	 * Once the application key is defined, it does not
-	 * change any more.
-	 */
-	if (session->global->application_key.length == 0 &&
-	    session->global->signing_key.length > 0)
-	{
-		struct smbXsrv_session *x = session;
-		struct auth_session_info *session_info =
-			session->global->auth_session_info;
-		uint8_t session_key[16];
-
-		ZERO_STRUCT(session_key);
-		memcpy(session_key, x->global->signing_key.data,
-		       MIN(x->global->signing_key.length, sizeof(session_key)));
-
-		/*
-		 * The application key is truncated/padded to 16 bytes
-		 */
-		x->global->application_key = data_blob_talloc(x->global,
-							     session_key,
-							     sizeof(session_key));
-		ZERO_STRUCT(session_key);
-		if (x->global->application_key.data == NULL) {
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			END_PROFILE(SMBtconX);
-			return;
-		}
-
-		if (tcon_flags & TCONX_FLAG_EXTENDED_SIGNATURES) {
-			smb_key_derivation(x->global->application_key.data,
-					   x->global->application_key.length,
-					   x->global->application_key.data);
-			optional_support |= SMB_EXTENDED_SIGNATURES;
-		}
-
-		/*
-		 * Place the application key into the session_info
-		 */
-		data_blob_clear_free(&session_info->session_key);
-		session_info->session_key = data_blob_dup_talloc(session_info,
-						x->global->application_key);
-		if (session_info->session_key.data == NULL) {
-			data_blob_clear_free(&x->global->application_key);
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			END_PROFILE(SMBtconX);
-			return;
-		}
-		session_key_updated = true;
-	}
-
-	conn = make_connection(sconn, now, service, client_devicetype,
+	conn = make_connection(sconn, service, password, client_devicetype,
 			       req->vuid, &nt_status);
 	req->conn =conn;
 
+	data_blob_clear_free(&password);
+
 	if (!conn) {
-		if (session_key_updated) {
-			struct smbXsrv_session *x = session;
-			struct auth_session_info *session_info =
-				session->global->auth_session_info;
-			data_blob_clear_free(&x->global->application_key);
-			data_blob_clear_free(&session_info->session_key);
-		}
 		reply_nterror(req, nt_status);
 		END_PROFILE(SMBtconX);
 		return;
@@ -970,7 +822,7 @@
 		}
 	} else {
 		/* NT sets the fstype of IPC$ to the null string */
-		const char *fstype = IS_IPC(conn) ? "" : lp_fstype(ctx, SNUM(conn));
+		const char *fstype = IS_IPC(conn) ? "" : lp_fstype(SNUM(conn));
 
 		if (tcon_flags & TCONX_FLAG_EXTENDED_RESPONSE) {
 			/* Return permissions. */
@@ -1003,32 +855,30 @@
 
 		/* what does setting this bit do? It is set by NT4 and
 		   may affect the ability to autorun mounted cdroms */
-		optional_support |= SMB_SUPPORT_SEARCH_BITS;
-		optional_support |=
-			(lp_csc_policy(SNUM(conn)) << SMB_CSC_POLICY_SHIFT);
+		SSVAL(req->outbuf, smb_vwv2, SMB_SUPPORT_SEARCH_BITS|
+		      (lp_csc_policy(SNUM(conn)) << 2));
 
 		if (lp_msdfs_root(SNUM(conn)) && lp_host_msdfs()) {
 			DEBUG(2,("Serving %s as a Dfs root\n",
-				 lp_servicename(ctx, SNUM(conn)) ));
-			optional_support |= SMB_SHARE_IN_DFS;
+				 lp_servicename(SNUM(conn)) ));
+			SSVAL(req->outbuf, smb_vwv2,
+			      SMB_SHARE_IN_DFS | SVAL(req->outbuf, smb_vwv2));
 		}
-
-		SSVAL(req->outbuf, smb_vwv2, optional_support);
 	}
 
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
 
 	DEBUG(3,("tconX service=%s \n",
 		 service));
 
 	/* set the incoming and outgoing tid to the just created one */
-	SSVAL(discard_const_p(uint8_t, req->inbuf),smb_tid,conn->cnum);
+	SSVAL(req->inbuf,smb_tid,conn->cnum);
 	SSVAL(req->outbuf,smb_tid,conn->cnum);
 
 	END_PROFILE(SMBtconX);
 
 	req->tid = conn->cnum;
+	chain_reply(req);
+	return;
 }
 
 /****************************************************************************
@@ -1100,16 +950,17 @@
 				return;
 			}
 			/* Job number */
-			SSVAL(p, 0, print_spool_rap_jobid(fsp->print_file));
-
+			if (fsp->print_file) {
+				SSVAL(p, 0, fsp->print_file->rap_jobid);
+			} else {
+				SSVAL(p, 0, 0);
+			}
 			srvstr_push((char *)req->outbuf, req->flags2, p+2,
-				    lp_netbios_name(), 15,
+				    global_myname(), 15,
 				    STR_TERMINATE|STR_ASCII);
 			if (conn) {
 				srvstr_push((char *)req->outbuf, req->flags2,
-					    p+18,
-					    lp_servicename(talloc_tos(),
-							   SNUM(conn)),
+					    p+18, lp_servicename(SNUM(conn)),
 					    13, STR_TERMINATE|STR_ASCII);
 			} else {
 				memset(p+18, 0, 13);
@@ -1236,7 +1087,7 @@
 	struct smb_filename *smb_fname = NULL;
 	char *fname = NULL;
 	int mode=0;
-	off_t size=0;
+	SMB_OFF_T size=0;
 	time_t mtime=0;
 	const char *p;
 	NTSTATUS status;
@@ -1395,19 +1246,19 @@
 	mode = SVAL(req->vwv+0, 0);
 	mtime = srv_make_unix_date3(req->vwv+1);
 
+	ft.mtime = convert_time_t_to_timespec(mtime);
+	status = smb_set_file_time(conn, NULL, smb_fname, &ft, true);
+	if (!NT_STATUS_IS_OK(status)) {
+		reply_nterror(req, status);
+		goto out;
+	}
+
 	if (mode != FILE_ATTRIBUTE_NORMAL) {
 		if (VALID_STAT_OF_DIR(smb_fname->st))
 			mode |= FILE_ATTRIBUTE_DIRECTORY;
 		else
 			mode &= ~FILE_ATTRIBUTE_DIRECTORY;
 
-		status = check_access(conn, NULL, smb_fname,
-					FILE_WRITE_ATTRIBUTES);
-		if (!NT_STATUS_IS_OK(status)) {
-			reply_nterror(req, status);
-			goto out;
-		}
-
 		if (file_set_dosmode(conn, smb_fname, mode, NULL,
 				     false) != 0) {
 			reply_nterror(req, map_nt_error_from_unix(errno));
@@ -1415,13 +1266,6 @@
 		}
 	}
 
-	ft.mtime = convert_time_t_to_timespec(mtime);
-	status = smb_set_file_time(conn, NULL, smb_fname, &ft, true);
-	if (!NT_STATUS_IS_OK(status)) {
-		reply_nterror(req, status);
-		goto out;
-	}
-
 	reply_outbuf(req, 0, 0);
 
 	DEBUG(3, ("setatr name=%s mode=%d\n", smb_fname_str_dbg(smb_fname),
@@ -1529,7 +1373,7 @@
 	char *directory = NULL;
 	struct smb_filename *smb_fname = NULL;
 	char *fname = NULL;
-	off_t size;
+	SMB_OFF_T size;
 	uint32 mode;
 	struct timespec date;
 	uint32 dirtype;
@@ -1622,7 +1466,6 @@
 		SCVAL(status,0,(dirtype & 0x1F));
 
 		nt_status = dptr_create(conn,
-					NULL, /* req */
 					NULL, /* fsp */
 					directory,
 					True,
@@ -1678,7 +1521,7 @@
 	if ((dirtype&0x1F) == FILE_ATTRIBUTE_VOLUME) {
 		char buf[DIR_STRUCT_SIZE];
 		memcpy(buf,status,21);
-		if (!make_dir_struct(ctx,buf,"???????????",volume_label(ctx, SNUM(conn)),
+		if (!make_dir_struct(ctx,buf,"???????????",volume_label(SNUM(conn)),
 				0,FILE_ATTRIBUTE_VOLUME,0,!allow_long_path_components)) {
 			reply_nterror(req, NT_STATUS_NO_MEMORY);
 			goto out;
@@ -1697,14 +1540,15 @@
 		}
 	} else {
 		unsigned int i;
-		size_t hdr_size = ((uint8_t *)smb_buf(req->outbuf) + 3 - req->outbuf);
-		size_t available_space = sconn->smb1.sessions.max_send - hdr_size;
-
-		maxentries = MIN(maxentries, available_space/DIR_STRUCT_SIZE);
+		maxentries = MIN(
+			maxentries,
+			((BUFFER_SIZE -
+			  ((uint8 *)smb_buf(req->outbuf) + 3 - req->outbuf))
+			 /DIR_STRUCT_SIZE));
 
 		DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-			 directory,lp_dontdescend(ctx, SNUM(conn))));
-		if (in_list(directory, lp_dontdescend(ctx, SNUM(conn)),True)) {
+			directory,lp_dontdescend(SNUM(conn))));
+		if (in_list(directory, lp_dontdescend(SNUM(conn)),True)) {
 			check_descend = True;
 		}
 
@@ -1870,7 +1714,7 @@
 	struct smb_filename *smb_fname = NULL;
 	char *fname = NULL;
 	uint32 fattr=0;
-	off_t size = 0;
+	SMB_OFF_T size = 0;
 	time_t mtime=0;
 	int info;
 	files_struct *fsp;
@@ -1905,9 +1749,9 @@
 	}
 
 	if (!map_open_params_to_ntcreate(fname, deny_mode,
-					 OPENX_FILE_EXISTS_OPEN, &access_mask,
-					 &share_mode, &create_disposition,
-					 &create_options, &private_flags)) {
+					OPENX_FILE_EXISTS_OPEN, &access_mask,
+					&share_mode, &create_disposition,
+					&create_options, &private_flags)) {
 		reply_force_doserror(req, ERRDOS, ERRbadaccess);
 		goto out;
 	}
@@ -1916,7 +1760,8 @@
 				conn,
 				req->flags2 & FLAGS2_DFS_PATHNAMES,
 				fname,
-				UCF_PREP_CREATEFILE,
+				(create_disposition == FILE_CREATE)
+					? UCF_CREATING_FILE : 0,
 				NULL,
 				&smb_fname);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -1949,7 +1794,7 @@
 		&info);					/* pinfo */
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -2080,11 +1925,11 @@
 	}
 
 	if (!map_open_params_to_ntcreate(fname, deny_mode,
-					 smb_ofun,
-					 &access_mask, &share_mode,
-					 &create_disposition,
-					 &create_options,
-					 &private_flags)) {
+					smb_ofun,
+					&access_mask, &share_mode,
+					&create_disposition,
+					&create_options,
+					&private_flags)) {
 		reply_force_doserror(req, ERRDOS, ERRbadaccess);
 		goto out;
 	}
@@ -2093,7 +1938,8 @@
 				conn,
 				req->flags2 & FLAGS2_DFS_PATHNAMES,
 				fname,
-				UCF_PREP_CREATEFILE,
+				(create_disposition == FILE_CREATE)
+					? UCF_CREATING_FILE : 0,
 				NULL,
 				&smb_fname);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2126,7 +1972,7 @@
 		&smb_action);				/* pinfo */
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -2143,7 +1989,7 @@
 			reply_nterror(req, NT_STATUS_DISK_FULL);
 			goto out;
 		}
-		retval = vfs_set_filelen(fsp, (off_t)allocation_size);
+		retval = vfs_set_filelen(fsp, (SMB_OFF_T)allocation_size);
 		if (retval < 0) {
 			close_file(req, fsp, ERROR_CLOSE);
 			reply_nterror(req, NT_STATUS_DISK_FULL);
@@ -2189,9 +2035,6 @@
 		reply_outbuf(req, 15, 0);
 	}
 
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	if (core_oplock_request && lp_fake_oplocks(SNUM(conn))) {
 		SCVAL(req->outbuf, smb_flg,
 		      CVAL(req->outbuf,smb_flg)|CORE_OPLOCK_GRANTED);
@@ -2217,6 +2060,7 @@
 		SIVAL(req->outbuf, smb_vwv15, SEC_STD_ALL);
 	}
 
+	chain_reply(req);
  out:
 	TALLOC_FREE(smb_fname);
 	END_PROFILE(SMBopenX);
@@ -2230,55 +2074,32 @@
 void reply_ulogoffX(struct smb_request *req)
 {
 	struct smbd_server_connection *sconn = req->sconn;
-	struct user_struct *vuser;
-	struct smbXsrv_session *session = NULL;
-	NTSTATUS status;
+	user_struct *vuser;
 
 	START_PROFILE(SMBulogoffX);
 
 	vuser = get_valid_user_struct(sconn, req->vuid);
 
 	if(vuser == NULL) {
-		DEBUG(3,("ulogoff, vuser id %llu does not map to user.\n",
-			 (unsigned long long)req->vuid));
-
-		req->vuid = UID_FIELD_INVALID;
-		reply_force_doserror(req, ERRSRV, ERRbaduid);
-		END_PROFILE(SMBulogoffX);
-		return;
+		DEBUG(3,("ulogoff, vuser id %d does not map to user.\n",
+			 req->vuid));
 	}
 
-	session = vuser->session;
-	vuser = NULL;
-
-	/*
-	 * TODO: cancel all outstanding requests on the session
-	 */
-	status = smbXsrv_session_logoff(session);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(0, ("reply_ulogoff: "
-			  "smbXsrv_session_logoff() failed: %s\n",
-			  nt_errstr(status)));
-		/*
-		 * If we hit this case, there is something completely
-		 * wrong, so we better disconnect the transport connection.
-		 */
-		END_PROFILE(SMBulogoffX);
-		exit_server(__location__ ": smbXsrv_session_logoff failed");
-		return;
+	/* in user level security we are supposed to close any files
+		open by this user */
+	if ((vuser != NULL) && (lp_security() != SEC_SHARE)) {
+		file_close_user(sconn, req->vuid);
 	}
 
-	TALLOC_FREE(session);
+	invalidate_vuid(sconn, req->vuid);
 
 	reply_outbuf(req, 2, 0);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
 
-	DEBUG(3, ("ulogoffX vuid=%llu\n",
-		  (unsigned long long)req->vuid));
+	DEBUG( 3, ( "ulogoffX vuid=%d\n", req->vuid ) );
 
 	END_PROFILE(SMBulogoffX);
 	req->vuid = UID_FIELD_INVALID;
+	chain_reply(req);
 }
 
 /****************************************************************************
@@ -2326,7 +2147,7 @@
 				conn,
 				req->flags2 & FLAGS2_DFS_PATHNAMES,
 				fname,
-				UCF_PREP_CREATEFILE,
+				UCF_CREATING_FILE,
 				NULL,
 				&smb_fname);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -2373,7 +2194,7 @@
 		NULL);					/* pinfo */
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -2467,7 +2288,7 @@
 		status = filename_convert(ctx, conn,
 				req->flags2 & FLAGS2_DFS_PATHNAMES,
 				fname,
-				UCF_PREP_CREATEFILE,
+				UCF_CREATING_FILE,
 				NULL,
 				&smb_fname);
 		if (!NT_STATUS_IS_OK(status)) {
@@ -2482,22 +2303,22 @@
 
 		/* Create the file. */
 		status = SMB_VFS_CREATE_FILE(
-			conn,					/* conn */
-			req,					/* req */
-			0,					/* root_dir_fid */
-			smb_fname,				/* fname */
+			conn,                                   /* conn */
+			req,                                    /* req */
+			0,                                      /* root_dir_fid */
+			smb_fname,                              /* fname */
 			FILE_GENERIC_READ | FILE_GENERIC_WRITE, /* access_mask */
-			FILE_SHARE_READ | FILE_SHARE_WRITE,	/* share_access */
-			FILE_CREATE,				/* create_disposition*/
-			0,					/* create_options */
-			fattr,					/* file_attributes */
-			oplock_request,				/* oplock_request */
-			0,					/* allocation_size */
-			0,					/* private_flags */
-			NULL,					/* sd */
-			NULL,					/* ea_list */
-			&fsp,					/* result */
-			NULL);					/* pinfo */
+			FILE_SHARE_READ | FILE_SHARE_WRITE,     /* share_access */
+			FILE_CREATE,                            /* create_disposition*/
+			0,                                      /* create_options */
+			fattr,                                  /* file_attributes */
+			oplock_request,                         /* oplock_request */
+			0,                                      /* allocation_size */
+			0,                                      /* private_flags */
+			NULL,                                   /* sd */
+			NULL,                                   /* ea_list */
+			&fsp,                                   /* result */
+			NULL);                                  /* pinfo */
 
 		if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_COLLISION)) {
 			TALLOC_FREE(fname);
@@ -2506,7 +2327,7 @@
 		}
 
 		if (!NT_STATUS_IS_OK(status)) {
-			if (open_was_deferred(req->sconn, req->mid)) {
+			if (open_was_deferred(req->mid)) {
 				/* We have re-scheduled this call. */
 				goto out;
 			}
@@ -2560,6 +2381,7 @@
 		    fsp->fh->fd, (unsigned int)smb_fname->st.st_ex_mode));
  out:
 	TALLOC_FREE(smb_fname);
+	TALLOC_FREE(fname);
 	TALLOC_FREE(wire_name);
 	END_PROFILE(SMBctemp);
 	return;
@@ -2733,9 +2555,9 @@
 	}
 
 	/* The set is across all open files on this dev/inode pair. */
-	if (!set_delete_on_close(fsp, True,
+	if (!set_delete_on_close(fsp, true,
 				conn->session_info->security_token,
-				conn->session_info->unix_token)) {
+				&conn->session_info->utok)) {
 		close_file(req, fsp, NORMAL_CLOSE);
 		return NT_STATUS_ACCESS_DENIED;
 	}
@@ -2916,10 +2738,9 @@
 
 			status = do_unlink(conn, req, smb_fname, dirtype);
 			if (!NT_STATUS_IS_OK(status)) {
-				TALLOC_FREE(dir_hnd);
 				TALLOC_FREE(frame);
 				TALLOC_FREE(talloced);
-				goto out;
+				continue;
 			}
 
 			count++;
@@ -2994,7 +2815,7 @@
 	status = unlink_internals(conn, req, dirtype, smb_fname,
 				  path_contains_wcard);
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -3028,7 +2849,7 @@
  Fake (read/write) sendfile. Returns -1 on read or write fail.
 ****************************************************************************/
 
-ssize_t fake_sendfile(files_struct *fsp, off_t startpos, size_t nread)
+ssize_t fake_sendfile(files_struct *fsp, SMB_OFF_T startpos, size_t nread)
 {
 	size_t bufsize;
 	size_t tosend = nread;
@@ -3191,7 +3012,7 @@
 static void send_file_readbraw(connection_struct *conn,
 			       struct smb_request *req,
 			       files_struct *fsp,
-			       off_t startpos,
+			       SMB_OFF_T startpos,
 			       size_t nread,
 			       ssize_t mincount)
 {
@@ -3274,9 +3095,9 @@
 
 normal_readbraw:
 
-	outbuf = talloc_array(NULL, char, nread+4);
+	outbuf = TALLOC_ARRAY(NULL, char, nread+4);
 	if (!outbuf) {
-		DEBUG(0,("send_file_readbraw: talloc_array failed for size %u.\n",
+		DEBUG(0,("send_file_readbraw: TALLOC_ARRAY failed for size %u.\n",
 			(unsigned)(nread+4)));
 		reply_readbraw_error(sconn);
 		return;
@@ -3322,10 +3143,10 @@
 	struct smbd_server_connection *sconn = req->sconn;
 	ssize_t maxcount,mincount;
 	size_t nread = 0;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	files_struct *fsp;
 	struct lock_struct lock;
-	off_t size = 0;
+	SMB_OFF_T size = 0;
 
 	START_PROFILE(SMBreadbraw);
 
@@ -3394,8 +3215,27 @@
 		/*
 		 * This is a large offset (64 bit) read.
 		 */
+#ifdef LARGE_SMB_OFF_T
+
+		startpos |= (((SMB_OFF_T)IVAL(req->vwv+8, 0)) << 32);
+
+#else /* !LARGE_SMB_OFF_T */
+
+		/*
+		 * Ensure we haven't been sent a >32 bit offset.
+		 */
+
+		if(IVAL(req->vwv+8, 0) != 0) {
+			DEBUG(0,("reply_readbraw: large offset "
+				"(%x << 32) used and we don't support "
+				"64 bit offsets.\n",
+			(unsigned int)IVAL(req->vwv+8, 0) ));
+			reply_readbraw_error(sconn);
+			END_PROFILE(SMBreadbraw);
+			return;
+		}
 
-		startpos |= (((off_t)IVAL(req->vwv+8, 0)) << 32);
+#endif /* LARGE_SMB_OFF_T */
 
 		if(startpos < 0) {
 			DEBUG(0,("reply_readbraw: negative 64 bit "
@@ -3438,9 +3278,9 @@
 		nread = 0;
 #endif
 
-	DEBUG( 3, ( "reply_readbraw: %s start=%.0f max=%lu "
+	DEBUG( 3, ( "reply_readbraw: fnum=%d start=%.0f max=%lu "
 		"min=%lu nread=%lu\n",
-		fsp_fnum_dbg(fsp), (double)startpos,
+		fsp->fnum, (double)startpos,
 		(unsigned long)maxcount,
 		(unsigned long)mincount,
 		(unsigned long)nread ) );
@@ -3467,9 +3307,8 @@
 	connection_struct *conn = req->conn;
 	ssize_t nread = -1;
 	char *data;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	size_t numtoread;
-	size_t maxtoread;
 	NTSTATUS status;
 	files_struct *fsp;
 	struct byte_range_lock *br_lck = NULL;
@@ -3500,12 +3339,18 @@
 	numtoread = SVAL(req->vwv+1, 0);
 	startpos = IVAL_TO_SMB_OFF_T(req->vwv+2, 0);
 
+	numtoread = MIN(BUFFER_SIZE - (smb_size + 3*2 + 3), numtoread);
+
+	reply_outbuf(req, 5, numtoread + 3);
+
+	data = smb_buf(req->outbuf) + 3;
+
 	/*
 	 * NB. Discovered by Menny Hamburger at Mainsoft. This is a core+
 	 * protocol request that predates the read/write lock concept. 
 	 * Thus instead of asking for a read lock here we need to ask
 	 * for a write lock. JRA.
-	 * Note that the requested lock size is unaffected by max_send.
+	 * Note that the requested lock size is unaffected by max_recv.
 	 */
 
 	br_lck = do_lock(req->sconn->msg_ctx,
@@ -3528,22 +3373,16 @@
 	}
 
 	/*
-	 * However the requested READ size IS affected by max_send. Insanity.... JRA.
+	 * However the requested READ size IS affected by max_recv. Insanity.... JRA.
 	 */
-	maxtoread = sconn->smb1.sessions.max_send - (smb_size + 5*2 + 3);
 
-	if (numtoread > maxtoread) {
-		DEBUG(0,("reply_lockread: requested read size (%u) is greater than maximum allowed (%u/%u). \
+	if (numtoread > sconn->smb1.negprot.max_recv) {
+		DEBUG(0,("reply_lockread: requested read size (%u) is greater than maximum allowed (%u). \
 Returning short read of maximum allowed for compatibility with Windows 2000.\n",
-			(unsigned int)numtoread, (unsigned int)maxtoread,
-			(unsigned int)sconn->smb1.sessions.max_send));
-		numtoread = maxtoread;
+			(unsigned int)numtoread,
+			(unsigned int)sconn->smb1.negprot.max_recv));
+		numtoread = MIN(numtoread, sconn->smb1.negprot.max_recv);
 	}
-
-	reply_outbuf(req, 5, numtoread + 3);
-
-	data = smb_buf(req->outbuf) + 3;
-
 	nread = read_file(fsp,data,startpos,numtoread);
 
 	if (nread < 0) {
@@ -3560,8 +3399,8 @@
 	SCVAL(p,0,0); /* pad byte. */
 	SSVAL(p,1,nread);
 
-	DEBUG(3,("lockread %s num=%d nread=%d\n",
-		 fsp_fnum_dbg(fsp), (int)numtoread, (int)nread));
+	DEBUG(3,("lockread fnum=%d num=%d nread=%d\n",
+		 fsp->fnum, (int)numtoread, (int)nread));
 
 	END_PROFILE(SMBlockread);
 	return;
@@ -3578,10 +3417,10 @@
 {
 	connection_struct *conn = req->conn;
 	size_t numtoread;
-	size_t maxtoread;
 	ssize_t nread = 0;
 	char *data;
-	off_t startpos;
+	SMB_OFF_T startpos;
+	int outsize = 0;
 	files_struct *fsp;
 	struct lock_struct lock;
 	struct smbd_server_connection *sconn = req->sconn;
@@ -3610,17 +3449,17 @@
 	numtoread = SVAL(req->vwv+1, 0);
 	startpos = IVAL_TO_SMB_OFF_T(req->vwv+2, 0);
 
+	numtoread = MIN(BUFFER_SIZE-outsize,numtoread);
+
 	/*
-	 * The requested read size cannot be greater than max_send. JRA.
+	 * The requested read size cannot be greater than max_recv. JRA.
 	 */
-	maxtoread = sconn->smb1.sessions.max_send - (smb_size + 5*2 + 3);
-
-	if (numtoread > maxtoread) {
-		DEBUG(0,("reply_read: requested read size (%u) is greater than maximum allowed (%u/%u). \
+	if (numtoread > sconn->smb1.negprot.max_recv) {
+		DEBUG(0,("reply_read: requested read size (%u) is greater than maximum allowed (%u). \
 Returning short read of maximum allowed for compatibility with Windows 2000.\n",
-			(unsigned int)numtoread, (unsigned int)maxtoread,
-			(unsigned int)sconn->smb1.sessions.max_send));
-		numtoread = maxtoread;
+			(unsigned int)numtoread,
+			(unsigned int)sconn->smb1.negprot.max_recv));
+		numtoread = MIN(numtoread, sconn->smb1.negprot.max_recv);
 	}
 
 	reply_outbuf(req, 5, numtoread+3);
@@ -3652,8 +3491,8 @@
 	SCVAL(smb_buf(req->outbuf),0,1);
 	SSVAL(smb_buf(req->outbuf),1,nread);
 
-	DEBUG(3, ("read %s num=%d nread=%d\n",
-		  fsp_fnum_dbg(fsp), (int)numtoread, (int)nread));
+	DEBUG( 3, ( "read fnum=%d num=%d nread=%d\n",
+		fsp->fnum, (int)numtoread, (int)nread ) );
 
 strict_unlock:
 	SMB_VFS_STRICT_UNLOCK(conn, fsp, &lock);
@@ -3670,8 +3509,10 @@
 			      size_t smb_maxcnt)
 {
 	int outsize;
+	char *data;
 
 	outsize = srv_set_message(outbuf,12,smb_maxcnt,False);
+	data = smb_buf(outbuf);
 
 	memset(outbuf+smb_vwv0,'\0',24); /* valgrind init. */
 
@@ -3679,7 +3520,7 @@
 	SSVAL(outbuf,smb_vwv2,0xFFFF); /* Remaining - must be -1. */
 	SSVAL(outbuf,smb_vwv5,smb_maxcnt);
 	SSVAL(outbuf,smb_vwv6,
-	      (smb_wct - 4)	/* offset from smb header to wct */
+	      req_wct_ofs(req)
 	      + 1 		/* the wct field */
 	      + 12 * sizeof(uint16_t) /* vwv */
 	      + 2);		/* the buflen field */
@@ -3695,7 +3536,7 @@
 ****************************************************************************/
 
 static void send_file_readX(connection_struct *conn, struct smb_request *req,
-			    files_struct *fsp, off_t startpos,
+			    files_struct *fsp, SMB_OFF_T startpos,
 			    size_t smb_maxcnt)
 {
 	ssize_t nread = -1;
@@ -3718,8 +3559,7 @@
 	 */
 
 	if (!req_is_in_chain(req) &&
-	    !req->encrypted &&
-	    (fsp->base_fsp == NULL) &&
+	    !req->encrypted && (fsp->base_fsp == NULL) &&
 	    (fsp->wcp == NULL) &&
 	    lp_use_sendfile(SNUM(conn), req->sconn->smb1.signing_state) ) {
 		uint8 headerbuf[smb_size + 12 * 2];
@@ -3780,8 +3620,8 @@
 						 strerror(errno)));
 					exit_server_cleanly("send_file_readX: fake_sendfile failed");
 				}
-				DEBUG(3, ("send_file_readX: fake_sendfile %s max=%d nread=%d\n",
-					  fsp_fnum_dbg(fsp), (int)smb_maxcnt, (int)nread));
+				DEBUG( 3, ( "send_file_readX: fake_sendfile fnum=%d max=%d nread=%d\n",
+					fsp->fnum, (int)smb_maxcnt, (int)nread ) );
 				/* No outbuf here means successful sendfile. */
 				goto strict_unlock;
 			}
@@ -3804,8 +3644,8 @@
 			goto normal_read;
 		}
 
-		DEBUG(3, ("send_file_readX: sendfile %s max=%d nread=%d\n",
-			  fsp_fnum_dbg(fsp), (int)smb_maxcnt, (int)nread));
+		DEBUG( 3, ( "send_file_readX: sendfile fnum=%d max=%d nread=%d\n",
+			fsp->fnum, (int)smb_maxcnt, (int)nread ) );
 
 		/* Deal with possible short send. */
 		if (nread != smb_maxcnt + sizeof(headerbuf)) {
@@ -3858,8 +3698,6 @@
 nosendfile_read:
 
 	reply_outbuf(req, 12, smb_maxcnt);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
 
 	nread = read_file(fsp, smb_buf(req->outbuf), startpos, smb_maxcnt);
 	saved_errno = errno;
@@ -3873,8 +3711,10 @@
 
 	setup_readX_header(req, (char *)req->outbuf, nread);
 
-	DEBUG(3, ("send_file_readX %s max=%d nread=%d\n",
-		  fsp_fnum_dbg(fsp), (int)smb_maxcnt, (int)nread));
+	DEBUG( 3, ( "send_file_readX fnum=%d max=%d nread=%d\n",
+		    fsp->fnum, (int)smb_maxcnt, (int)nread ) );
+
+	chain_reply(req);
 	return;
 
  strict_unlock:
@@ -3884,84 +3724,6 @@
 }
 
 /****************************************************************************
- Work out how much space we have for a read return.
-****************************************************************************/
-
-static size_t calc_max_read_pdu(const struct smb_request *req)
-{
-	if (req->sconn->conn->protocol < PROTOCOL_NT1) {
-		return req->sconn->smb1.sessions.max_send;
-	}
-
-	if (!lp_large_readwrite()) {
-		return req->sconn->smb1.sessions.max_send;
-	}
-
-	if (req_is_in_chain(req)) {
-		return req->sconn->smb1.sessions.max_send;
-	}
-
-	if (req->encrypted) {
-		/*
-		 * Don't take encrypted traffic up to the
-		 * limit. There are padding considerations
-		 * that make that tricky.
-		 */
-		return req->sconn->smb1.sessions.max_send;
-	}
-
-	if (srv_is_signing_active(req->sconn)) {
-		return 0x1FFFF;
-	}
-
-	if (!lp_unix_extensions()) {
-		return 0x1FFFF;
-	}
-
-	/*
-	 * We can do ultra-large POSIX reads.
-	 */
-	return 0xFFFFFF;
-}
-
-/****************************************************************************
- Calculate how big a read can be. Copes with all clients. It's always
- safe to return a short read - Windows does this.
-****************************************************************************/
-
-static size_t calc_read_size(const struct smb_request *req,
-			     size_t upper_size,
-			     size_t lower_size)
-{
-	size_t max_pdu = calc_max_read_pdu(req);
-	size_t total_size = 0;
-	size_t hdr_len = MIN_SMB_SIZE + VWV(12);
-	size_t max_len = max_pdu - hdr_len;
-
-	/*
-	 * Windows explicitly ignores upper size of 0xFFFF.
-	 * See [MS-SMB].pdf <26> Section 2.2.4.2.1:
-	 * We must do the same as these will never fit even in
-	 * an extended size NetBIOS packet.
-	 */
-	if (upper_size == 0xFFFF) {
-		upper_size = 0;
-	}
-
-	if (req->sconn->conn->protocol < PROTOCOL_NT1) {
-		upper_size = 0;
-	}
-
-	total_size = ((upper_size<<16) | lower_size);
-
-	/*
-	 * LARGE_READX test shows it's always safe to return
-	 * a short read. Windows does so.
-	 */
-	return MIN(total_size, max_len);
-}
-
-/****************************************************************************
  Reply to a read and X.
 ****************************************************************************/
 
@@ -3969,9 +3731,8 @@
 {
 	connection_struct *conn = req->conn;
 	files_struct *fsp;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	size_t smb_maxcnt;
-	size_t upper_size;
 	bool big_readX = False;
 #if 0
 	size_t smb_mincnt = SVAL(req->vwv+6, 0);
@@ -4006,22 +3767,56 @@
 		return;
 	}
 
-	upper_size = SVAL(req->vwv+7, 0);
-	smb_maxcnt = calc_read_size(req, upper_size, smb_maxcnt);
-	if (smb_maxcnt > (0x1FFFF - (MIN_SMB_SIZE + VWV(12)))) {
-		/*
-		 * This is a heuristic to avoid keeping large
-		 * outgoing buffers around over long-lived aio
-		 * requests.
-		 */
-		big_readX = True;
+	if (global_client_caps & CAP_LARGE_READX) {
+		size_t upper_size = SVAL(req->vwv+7, 0);
+		smb_maxcnt |= (upper_size<<16);
+		if (upper_size > 1) {
+			/* Can't do this on a chained packet. */
+			if ((CVAL(req->vwv+0, 0) != 0xFF)) {
+				reply_nterror(req, NT_STATUS_NOT_SUPPORTED);
+				END_PROFILE(SMBreadX);
+				return;
+			}
+			/* We currently don't do this on signed or sealed data. */
+			if (srv_is_signing_active(req->sconn) || req->encrypted) {
+				reply_nterror(req, NT_STATUS_NOT_SUPPORTED);
+				END_PROFILE(SMBreadX);
+				return;
+			}
+			/* Is there room in the reply for this data ? */
+			if (smb_maxcnt > (0xFFFFFF - (smb_size -4 + 12*2)))  {
+				reply_nterror(req,
+					      NT_STATUS_INVALID_PARAMETER);
+				END_PROFILE(SMBreadX);
+				return;
+			}
+			big_readX = True;
+		}
 	}
 
 	if (req->wct == 12) {
+#ifdef LARGE_SMB_OFF_T
 		/*
 		 * This is a large offset (64 bit) read.
 		 */
-		startpos |= (((off_t)IVAL(req->vwv+10, 0)) << 32);
+		startpos |= (((SMB_OFF_T)IVAL(req->vwv+10, 0)) << 32);
+
+#else /* !LARGE_SMB_OFF_T */
+
+		/*
+		 * Ensure we haven't been sent a >32 bit offset.
+		 */
+
+		if(IVAL(req->vwv+10, 0) != 0) {
+			DEBUG(0,("reply_read_and_X - large offset (%x << 32) "
+				 "used and we don't support 64 bit offsets.\n",
+				 (unsigned int)IVAL(req->vwv+10, 0) ));
+			END_PROFILE(SMBreadX);
+			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+			return;
+		}
+
+#endif /* LARGE_SMB_OFF_T */
 
 	}
 
@@ -4077,9 +3872,9 @@
 static NTSTATUS read_smb_length(int fd, char *inbuf, unsigned int timeout,
 				size_t *len)
 {
-	uint8_t msgtype = NBSSkeepalive;
+	uint8_t msgtype = SMBkeepalive;
 
-	while (msgtype == NBSSkeepalive) {
+	while (msgtype == SMBkeepalive) {
 		NTSTATUS status;
 
 		status = read_smb_length_return_keepalive(fd, inbuf, timeout,
@@ -4116,8 +3911,8 @@
 	ssize_t total_written=0;
 	size_t numtowrite=0;
 	size_t tcount;
-	off_t startpos;
-	const char *data=NULL;
+	SMB_OFF_T startpos;
+	char *data=NULL;
 	bool write_through;
 	files_struct *fsp;
 	struct lock_struct lock;
@@ -4130,7 +3925,7 @@
 	 * type of SMBwritec, not SMBwriteBraw, as this tells the client
 	 * we're finished.
 	 */
-	SCVAL(discard_const_p(uint8_t, req->inbuf),smb_com,SMBwritec);
+	SCVAL(req->inbuf,smb_com,SMBwritec);
 
 	if (srv_is_signing_active(req->sconn)) {
 		END_PROFILE(SMBwritebraw);
@@ -4176,8 +3971,8 @@
 		on whether we are using the core+ or lanman1.0 protocol */
 
 	if(get_Protocol() <= PROTOCOL_COREPLUS) {
-		numtowrite = SVAL(smb_buf_const(req->inbuf),-2);
-		data = smb_buf_const(req->inbuf);
+		numtowrite = SVAL(smb_buf(req->inbuf),-2);
+		data = smb_buf(req->inbuf);
 	} else {
 		numtowrite = SVAL(req->vwv+10, 0);
 		data = smb_base(req->inbuf) + SVAL(req->vwv+11, 0);
@@ -4208,9 +4003,9 @@
 		nwritten = write_file(req,fsp,data,startpos,numtowrite);
 	}
 
-	DEBUG(3, ("reply_writebraw: initial write %s start=%.0f num=%d "
+	DEBUG(3,("reply_writebraw: initial write fnum=%d start=%.0f num=%d "
 			"wrote=%d sync=%d\n",
-		fsp_fnum_dbg(fsp), (double)startpos, (int)numtowrite,
+		fsp->fnum, (double)startpos, (int)numtowrite,
 		(int)nwritten, (int)write_through));
 
 	if (nwritten < (ssize_t)numtowrite)  {
@@ -4222,7 +4017,7 @@
 	total_written = nwritten;
 
 	/* Allocate a buffer of 64k + length. */
-	buf = talloc_array(NULL, char, 65540);
+	buf = TALLOC_ARRAY(NULL, char, 65540);
 	if (!buf) {
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
 		error_to_writebrawerr(req);
@@ -4315,9 +4110,9 @@
 		goto strict_unlock;
 	}
 
-	DEBUG(3,("reply_writebraw: secondart write %s start=%.0f num=%d "
+	DEBUG(3,("reply_writebraw: secondart write fnum=%d start=%.0f num=%d "
 		"wrote=%d\n",
-		fsp_fnum_dbg(fsp), (double)startpos, (int)numtowrite,
+		fsp->fnum, (double)startpos, (int)numtowrite,
 		(int)total_written));
 
 	if (!fsp->print_file) {
@@ -4333,7 +4128,7 @@
 #if RABBIT_PELLET_FIX
 		/*
 		 * Fix for "rabbit pellet" mode, trigger an early TCP ack by
-		 * sending a NBSSkeepalive. Thanks to DaveCB at Sun for this.
+		 * sending a SMBkeepalive. Thanks to DaveCB at Sun for this.
 		 * JRA.
 		 */
 		if (!send_keepalive(req->sconn->sock)) {
@@ -4366,7 +4161,7 @@
 	connection_struct *conn = req->conn;
 	ssize_t nwritten = -1;
 	size_t numtowrite;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	const char *data;
 	NTSTATUS status = NT_STATUS_OK;
 	files_struct *fsp;
@@ -4456,8 +4251,8 @@
 
 	SSVAL(req->outbuf,smb_vwv0,nwritten);
 
-	DEBUG(3, ("writeunlock %s num=%d wrote=%d\n",
-		  fsp_fnum_dbg(fsp), (int)numtowrite, (int)nwritten));
+	DEBUG(3,("writeunlock fnum=%d num=%d wrote=%d\n",
+		 fsp->fnum, (int)numtowrite, (int)nwritten));
 
 strict_unlock:
 	if (numtowrite && !fsp->print_file) {
@@ -4480,7 +4275,7 @@
 	connection_struct *conn = req->conn;
 	size_t numtowrite;
 	ssize_t nwritten = -1;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	const char *data;
 	files_struct *fsp;
 	struct lock_struct lock;
@@ -4541,12 +4336,12 @@
 		/*
 		 * This is actually an allocate call, and set EOF. JRA.
 		 */
-		nwritten = vfs_allocate_file_space(fsp, (off_t)startpos);
+		nwritten = vfs_allocate_file_space(fsp, (SMB_OFF_T)startpos);
 		if (nwritten < 0) {
 			reply_nterror(req, NT_STATUS_DISK_FULL);
 			goto strict_unlock;
 		}
-		nwritten = vfs_set_filelen(fsp, (off_t)startpos);
+		nwritten = vfs_set_filelen(fsp, (SMB_OFF_T)startpos);
 		if (nwritten < 0) {
 			reply_nterror(req, NT_STATUS_DISK_FULL);
 			goto strict_unlock;
@@ -4583,7 +4378,7 @@
 		SSVAL(req->outbuf,smb_err,ERRdiskfull);
 	}
 
-	DEBUG(3, ("write %s num=%d wrote=%d\n", fsp_fnum_dbg(fsp), (int)numtowrite, (int)nwritten));
+	DEBUG(3,("write fnum=%d num=%d wrote=%d\n", fsp->fnum, (int)numtowrite, (int)nwritten));
 
 strict_unlock:
 	if (!fsp->print_file) {
@@ -4609,11 +4404,8 @@
 	connection_struct *conn = NULL;
 	unsigned int doff = 0;
 	size_t len = smb_len_large(inbuf);
-	struct smbXsrv_tcon *tcon;
-	NTSTATUS status;
-	NTTIME now = 0;
 
-	if (is_encrypted_packet(sconn, inbuf)) {
+	if (is_encrypted_packet(inbuf)) {
 		/* Can't do this on encrypted
 		 * connections. */
 		return false;
@@ -4630,14 +4422,11 @@
 		return false;
 	}
 
-	status = smb1srv_tcon_lookup(sconn->conn, SVAL(inbuf, smb_tid),
-				     now, &tcon);
-	if (!NT_STATUS_IS_OK(status)) {
+	conn = conn_find(sconn, SVAL(inbuf, smb_tid));
+	if (conn == NULL) {
 		DEBUG(10,("is_valid_writeX_buffer: bad tid\n"));
 		return false;
 	}
-	conn = tcon->compat;
-
 	if (IS_IPC(conn)) {
 		DEBUG(10,("is_valid_writeX_buffer: IPC$ tid\n"));
 		return false;
@@ -4695,13 +4484,13 @@
 	connection_struct *conn = req->conn;
 	files_struct *fsp;
 	struct lock_struct lock;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	size_t numtowrite;
 	bool write_through;
 	ssize_t nwritten;
 	unsigned int smb_doff;
 	unsigned int smblen;
-	const char *data;
+	char *data;
 	NTSTATUS status;
 	int saved_errno = 0;
 
@@ -4709,7 +4498,8 @@
 
 	if ((req->wct != 12) && (req->wct != 14)) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
-		goto out;
+		END_PROFILE(SMBwriteX);
+		return;
 	}
 
 	numtowrite = SVAL(req->vwv+10, 0);
@@ -4726,17 +4516,20 @@
 		/* Can't do a recvfile write on IPC$ */
 		if (IS_IPC(conn)) {
 			reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			goto out;
+			END_PROFILE(SMBwriteX);
+			return;
 		}
 	       	if (numtowrite != req->unread_bytes) {
 			reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			goto out;
+			END_PROFILE(SMBwriteX);
+			return;
 		}
 	} else {
 		if (smb_doff > smblen || smb_doff + numtowrite < numtowrite ||
 				smb_doff + numtowrite > smblen) {
 			reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			goto out;
+			END_PROFILE(SMBwriteX);
+			return;
 		}
 	}
 
@@ -4744,10 +4537,12 @@
 	if (IS_IPC(conn)) {
 		if (req->unread_bytes) {
 			reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			goto out;
+			END_PROFILE(SMBwriteX);
+			return;
 		}
 		reply_pipe_write_and_X(req);
-		goto out;
+		END_PROFILE(SMBwriteX);
+		return;
 	}
 
 	fsp = file_fsp(req, SVAL(req->vwv+2, 0));
@@ -4755,22 +4550,41 @@
 	write_through = BITSETW(req->vwv+7,0);
 
 	if (!check_fsp(conn, req, fsp)) {
-		goto out;
+		END_PROFILE(SMBwriteX);
+		return;
 	}
 
 	if (!CHECK_WRITE(fsp)) {
 		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
-		goto out;
+		END_PROFILE(SMBwriteX);
+		return;
 	}
 
 	data = smb_base(req->inbuf) + smb_doff;
 
 	if(req->wct == 14) {
+#ifdef LARGE_SMB_OFF_T
 		/*
 		 * This is a large offset (64 bit) write.
 		 */
-		startpos |= (((off_t)IVAL(req->vwv+12, 0)) << 32);
+		startpos |= (((SMB_OFF_T)IVAL(req->vwv+12, 0)) << 32);
+
+#else /* !LARGE_SMB_OFF_T */
+
+		/*
+		 * Ensure we haven't been sent a >32 bit offset.
+		 */
 
+		if(IVAL(req->vwv+12, 0) != 0) {
+			DEBUG(0,("reply_write_and_X - large offset (%x << 32) "
+				 "used and we don't support 64 bit offsets.\n",
+				 (unsigned int)IVAL(req->vwv+12, 0) ));
+			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+			END_PROFILE(SMBwriteX);
+			return;
+		}
+
+#endif /* LARGE_SMB_OFF_T */
 	}
 
 	/* X/Open SMB protocol says that, unlike SMBwrite
@@ -4827,13 +4641,11 @@
 	}
 
 	reply_outbuf(req, 6, 0);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
 	SSVAL(req->outbuf,smb_vwv2,nwritten);
 	SSVAL(req->outbuf,smb_vwv4,nwritten>>16);
 
-	DEBUG(3,("writeX %s num=%d wrote=%d\n",
-		fsp_fnum_dbg(fsp), (int)numtowrite, (int)nwritten));
+	DEBUG(3,("writeX fnum=%d num=%d wrote=%d\n",
+		fsp->fnum, (int)numtowrite, (int)nwritten));
 
 	status = sync_file(conn, fsp, write_through);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -4844,18 +4656,10 @@
 	}
 
 	END_PROFILE(SMBwriteX);
+	chain_reply(req);
 	return;
 
 out:
-	if (req->unread_bytes) {
-		/* writeX failed. drain socket. */
-		if (drain_socket(req->sconn->sock, req->unread_bytes) !=
-				req->unread_bytes) {
-			smb_panic("failed to drain pending bytes");
-		}
-		req->unread_bytes = 0;
-	}
-
 	END_PROFILE(SMBwriteX);
 	return;
 }
@@ -4867,8 +4671,8 @@
 void reply_lseek(struct smb_request *req)
 {
 	connection_struct *conn = req->conn;
-	off_t startpos;
-	off_t res= -1;
+	SMB_OFF_T startpos;
+	SMB_OFF_T res= -1;
 	int mode,umode;
 	files_struct *fsp;
 
@@ -4890,7 +4694,7 @@
 
 	mode = SVAL(req->vwv+1, 0) & 3;
 	/* NB. This doesn't use IVAL_TO_SMB_OFF_T as startpos can be signed in this case. */
-	startpos = (off_t)IVALS(req->vwv+2, 0);
+	startpos = (SMB_OFF_T)IVALS(req->vwv+2, 0);
 
 	switch (mode) {
 		case 0:
@@ -4913,7 +4717,7 @@
 	if (umode == SEEK_END) {
 		if((res = SMB_VFS_LSEEK(fsp,startpos,umode)) == -1) {
 			if(errno == EINVAL) {
-				off_t current_pos = startpos;
+				SMB_OFF_T current_pos = startpos;
 
 				if(fsp_stat(fsp) == -1) {
 					reply_nterror(req,
@@ -4940,8 +4744,8 @@
 	reply_outbuf(req, 2, 0);
 	SIVAL(req->outbuf,smb_vwv0,res);
 
-	DEBUG(3,("lseek %s ofs=%.0f newpos = %.0f mode=%d\n",
-		fsp_fnum_dbg(fsp), (double)startpos, (double)res, mode));
+	DEBUG(3,("lseek fnum=%d ofs=%.0f newpos = %.0f mode=%d\n",
+		fsp->fnum, (double)startpos, (double)res, mode));
 
 	END_PROFILE(SMBlseek);
 	return;
@@ -5010,12 +4814,9 @@
 	return;
 }
 
-struct reply_close_state {
-	files_struct *fsp;
-	struct smb_request *smbreq;
-};
-
-static void do_smb1_close(struct tevent_req *req);
+/****************************************************************************
+ Reply to a close - has to deal with closing a directory opened by NT SMB's.
+****************************************************************************/
 
 void reply_close(struct smb_request *req)
 {
@@ -5042,13 +4843,21 @@
 		return;
 	}
 
-	DEBUG(3, ("Close %s fd=%d %s (numopen=%d)\n",
-		  fsp->is_directory ? "directory" : "file",
-		  fsp->fh->fd, fsp_fnum_dbg(fsp),
-		  conn->num_files_open));
-
-	if (!fsp->is_directory) {
+	if(fsp->is_directory) {
+		/*
+		 * Special case - close NT SMB directory handle.
+		 */
+		DEBUG(3,("close directory fnum=%d\n", fsp->fnum));
+		status = close_file(req, fsp, NORMAL_CLOSE);
+	} else {
 		time_t t;
+		/*
+		 * Close ordinary file.
+		 */
+
+		DEBUG(3,("close fd=%d fnum=%d (numopen=%d)\n",
+			 fsp->fh->fd, fsp->fnum,
+			 conn->num_files_open));
 
 		/*
 		 * Take care of any time sent in the close.
@@ -5056,49 +4865,16 @@
 
 		t = srv_make_unix_date3(req->vwv+1);
 		set_close_write_time(fsp, convert_time_t_to_timespec(t));
-	}
-
-	if (fsp->num_aio_requests != 0) {
-
-		struct reply_close_state *state;
-
-		DEBUG(10, ("closing with aio %u requests pending\n",
-			   fsp->num_aio_requests));
 
 		/*
-		 * We depend on the aio_extra destructor to take care of this
-		 * close request once fsp->num_aio_request drops to 0.
+		 * close_file() returns the unix errno if an error
+		 * was detected on close - normally this is due to
+		 * a disk full error. If not then it was probably an I/O error.
 		 */
 
-		fsp->deferred_close = tevent_wait_send(
-			fsp, fsp->conn->sconn->ev_ctx);
-		if (fsp->deferred_close == NULL) {
-			status = NT_STATUS_NO_MEMORY;
-			goto done;
-		}
-
-		state = talloc(fsp, struct reply_close_state);
-		if (state == NULL) {
-			TALLOC_FREE(fsp->deferred_close);
-			status = NT_STATUS_NO_MEMORY;
-			goto done;
-		}
-		state->fsp = fsp;
-		state->smbreq = talloc_move(fsp, &req);
-		tevent_req_set_callback(fsp->deferred_close, do_smb1_close,
-					state);
-		END_PROFILE(SMBclose);
-		return;
-	}
-
-	/*
-	 * close_file() returns the unix errno if an error was detected on
-	 * close - normally this is due to a disk full error. If not then it
-	 * was probably an I/O error.
-	 */
+		status = close_file(req, fsp, NORMAL_CLOSE);
+	}  
 
-	status = close_file(req, fsp, NORMAL_CLOSE);
-done:
 	if (!NT_STATUS_IS_OK(status)) {
 		reply_nterror(req, status);
 		END_PROFILE(SMBclose);
@@ -5110,49 +4886,6 @@
 	return;
 }
 
-static void do_smb1_close(struct tevent_req *req)
-{
-	struct reply_close_state *state = tevent_req_callback_data(
-		req, struct reply_close_state);
-	struct smb_request *smbreq;
-	NTSTATUS status;
-	int ret;
-
-	ret = tevent_wait_recv(req);
-	TALLOC_FREE(req);
-	if (ret != 0) {
-		DEBUG(10, ("tevent_wait_recv returned %s\n",
-			   strerror(ret)));
-		/*
-		 * Continue anyway, this should never happen
-		 */
-	}
-
-	/*
-	 * fsp->smb2_close_request right now is a talloc grandchild of
-	 * fsp. When we close_file(fsp), it would go with it. No chance to
-	 * reply...
-	 */
-	smbreq = talloc_move(talloc_tos(), &state->smbreq);
-
-	status = close_file(smbreq, state->fsp, NORMAL_CLOSE);
-	if (NT_STATUS_IS_OK(status)) {
-		reply_outbuf(smbreq, 0, 0);
-	} else {
-		reply_nterror(smbreq, status);
-	}
-	if (!srv_send_smb(smbreq->sconn,
-			(char *)smbreq->outbuf,
-			true,
-			smbreq->seqnum+1,
-			IS_CONN_ENCRYPTED(smbreq->conn)||smbreq->encrypted,
-			NULL)) {
-		exit_server_cleanly("handle_aio_read_complete: srv_send_smb "
-				    "failed.");
-	}
-	TALLOC_FREE(smbreq);
-}
-
 /****************************************************************************
  Reply to a writeclose (Core+ protocol).
 ****************************************************************************/
@@ -5163,7 +4896,7 @@
 	size_t numtowrite;
 	ssize_t nwritten = -1;
 	NTSTATUS close_status = NT_STATUS_OK;
-	off_t startpos;
+	SMB_OFF_T startpos;
 	const char *data;
 	struct timespec mtime;
 	files_struct *fsp;
@@ -5194,7 +4927,7 @@
 	mtime = convert_time_t_to_timespec(srv_make_unix_date3(req->vwv+4));
 	data = (const char *)req->buf + 1;
 
-	if (fsp->print_file == NULL) {
+	if (!fsp->print_file) {
 		init_strict_lock_struct(fsp, (uint64_t)req->smbpid,
 		    (uint64_t)startpos, (uint64_t)numtowrite, WRITE_LOCK,
 		    &lock);
@@ -5208,10 +4941,6 @@
 
 	nwritten = write_file(req,fsp,data,startpos,numtowrite);
 
-	if (fsp->print_file == NULL) {
-		SMB_VFS_STRICT_UNLOCK(conn, fsp, &lock);
-	}
-
 	set_close_write_time(fsp, mtime);
 
 	/*
@@ -5219,32 +4948,34 @@
 	 * JRA.
 	 */
 
-	DEBUG(3,("writeclose %s num=%d wrote=%d (numopen=%d)\n",
-		fsp_fnum_dbg(fsp), (int)numtowrite, (int)nwritten,
-		(numtowrite) ? conn->num_files_open - 1 : conn->num_files_open));
-
 	if (numtowrite) {
 		DEBUG(3,("reply_writeclose: zero length write doesn't close "
 			 "file %s\n", fsp_str_dbg(fsp)));
 		close_status = close_file(req, fsp, NORMAL_CLOSE);
-		fsp = NULL;
 	}
 
+	DEBUG(3,("writeclose fnum=%d num=%d wrote=%d (numopen=%d)\n",
+		 fsp->fnum, (int)numtowrite, (int)nwritten,
+		 conn->num_files_open));
+
 	if(((nwritten == 0) && (numtowrite != 0))||(nwritten < 0)) {
 		reply_nterror(req, NT_STATUS_DISK_FULL);
-		goto out;
+		goto strict_unlock;
 	}
 
 	if(!NT_STATUS_IS_OK(close_status)) {
 		reply_nterror(req, close_status);
-		goto out;
+		goto strict_unlock;
 	}
 
 	reply_outbuf(req, 1, 0);
 
 	SSVAL(req->outbuf,smb_vwv0,nwritten);
 
-out:
+strict_unlock:
+	if (numtowrite && !fsp->print_file) {
+		SMB_VFS_STRICT_UNLOCK(conn, fsp, &lock);
+	}
 
 	END_PROFILE(SMBwriteclose);
 	return;
@@ -5283,8 +5014,8 @@
 	count = (uint64_t)IVAL(req->vwv+1, 0);
 	offset = (uint64_t)IVAL(req->vwv+3, 0);
 
-	DEBUG(3,("lock fd=%d %s offset=%.0f count=%.0f\n",
-		 fsp->fh->fd, fsp_fnum_dbg(fsp), (double)offset, (double)count));
+	DEBUG(3,("lock fd=%d fnum=%d offset=%.0f count=%.0f\n",
+		 fsp->fh->fd, fsp->fnum, (double)offset, (double)count));
 
 	br_lck = do_lock(req->sconn->msg_ctx,
 			fsp,
@@ -5354,8 +5085,8 @@
 		return;
 	}
 
-	DEBUG( 3, ( "unlock fd=%d %s offset=%.0f count=%.0f\n",
-		    fsp->fh->fd, fsp_fnum_dbg(fsp), (double)offset, (double)count ) );
+	DEBUG( 3, ( "unlock fd=%d fnum=%d offset=%.0f count=%.0f\n",
+		    fsp->fh->fd, fsp->fnum, (double)offset, (double)count ) );
 
 	reply_outbuf(req, 0, 0);
 
@@ -5373,40 +5104,20 @@
 
 void reply_tdis(struct smb_request *req)
 {
-	NTSTATUS status;
 	connection_struct *conn = req->conn;
-	struct smbXsrv_tcon *tcon;
-
 	START_PROFILE(SMBtdis);
 
 	if (!conn) {
 		DEBUG(4,("Invalid connection in tdis\n"));
-		reply_force_doserror(req, ERRSRV, ERRinvnid);
+		reply_nterror(req, NT_STATUS_NETWORK_NAME_DELETED);
 		END_PROFILE(SMBtdis);
 		return;
 	}
 
-	tcon = conn->tcon;
-	req->conn = NULL;
-
-	/*
-	 * TODO: cancel all outstanding requests on the tcon
-	 */
-	status = smbXsrv_tcon_disconnect(tcon, req->vuid);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(0, ("reply_tdis: "
-			  "smbXsrv_tcon_disconnect() failed: %s\n",
-			  nt_errstr(status)));
-		/*
-		 * If we hit this case, there is something completely
-		 * wrong, so we better disconnect the transport connection.
-		 */
-		END_PROFILE(SMBtdis);
-		exit_server(__location__ ": smbXsrv_tcon_disconnect failed");
-		return;
-	}
+	conn->used = False;
 
-	TALLOC_FREE(tcon);
+	close_cnum(conn,req->vuid);
+	req->conn = NULL;
 
 	reply_outbuf(req, 0, 0);
 	END_PROFILE(SMBtdis);
@@ -5523,8 +5234,8 @@
 	reply_outbuf(req, 1, 0);
 	SSVAL(req->outbuf,smb_vwv0,fsp->fnum);
 
-	DEBUG(3,("openprint fd=%d %s\n",
-		 fsp->fh->fd, fsp_fnum_dbg(fsp)));
+	DEBUG(3,("openprint fd=%d fnum=%d\n",
+		 fsp->fh->fd, fsp->fnum));
 
 	END_PROFILE(SMBsplopen);
 	return;
@@ -5561,8 +5272,8 @@
 		return;
 	}
 
-	DEBUG(3,("printclose fd=%d %s\n",
-		 fsp->fh->fd, fsp_fnum_dbg(fsp)));
+	DEBUG(3,("printclose fd=%d fnum=%d\n",
+		 fsp->fh->fd,fsp->fnum));
 
 	status = close_file(req, fsp, NORMAL_CLOSE);
 
@@ -5622,7 +5333,7 @@
 		TALLOC_CTX *mem_ctx = talloc_tos();
 		NTSTATUS status;
 		WERROR werr;
-		const char *sharename = lp_servicename(mem_ctx, SNUM(conn));
+		const char *sharename = lp_servicename(SNUM(conn));
 		struct rpc_pipe_client *cli = NULL;
 		struct dcerpc_binding_handle *b = NULL;
 		struct policy_handle handle;
@@ -5638,7 +5349,7 @@
 		status = rpc_pipe_open_interface(conn,
 						 &ndr_table_spoolss.syntax_id,
 						 conn->session_info,
-						 conn->sconn->remote_address,
+						 &conn->sconn->client_id,
 						 conn->sconn->msg_ctx,
 						 &cli);
 		if (!NT_STATUS_IS_OK(status)) {
@@ -5794,13 +5505,13 @@
 
 	data = (const char *)req->buf + 3;
 
-	if (write_file(req,fsp,data,(off_t)-1,numtowrite) != numtowrite) {
+	if (write_file(req,fsp,data,(SMB_OFF_T)-1,numtowrite) != numtowrite) {
 		reply_nterror(req, map_nt_error_from_unix(errno));
 		END_PROFILE(SMBsplwr);
 		return;
 	}
 
-	DEBUG(3, ("printwrite %s num=%d\n", fsp_fnum_dbg(fsp), numtowrite));
+	DEBUG( 3, ( "printwrite fnum=%d num=%d\n", fsp->fnum, numtowrite ) );
 
 	END_PROFILE(SMBsplwr);
 	return;
@@ -5830,7 +5541,7 @@
 	status = filename_convert(ctx, conn,
 				 req->flags2 & FLAGS2_DFS_PATHNAMES,
 				 directory,
-				 UCF_PREP_CREATEFILE,
+				 UCF_CREATING_FILE,
 				 NULL,
 				 &smb_dname);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -5938,7 +5649,7 @@
 		&info);                                 /* pinfo */
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -5955,7 +5666,7 @@
 
 	if (!set_delete_on_close(fsp, true,
 			conn->session_info->security_token,
-			conn->session_info->unix_token)) {
+			&conn->session_info->utok)) {
 		close_file(req, fsp, ERROR_CLOSE);
 		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 		goto out;
@@ -6117,9 +5828,9 @@
 	files_struct *fsp;
 	bool did_rename = False;
 	NTSTATUS status;
-	uint32_t new_name_hash = 0;
+	uint32_t new_name_hash;
 
-	for(fsp = file_find_di_first(conn->sconn, lck->data->id); fsp;
+	for(fsp = file_find_di_first(conn->sconn, lck->id); fsp;
 	    fsp = file_find_di_next(fsp)) {
 		/* fsp_name is a relative path under the fsp. To change this for other
 		   sharepaths we need to manipulate relative paths. */
@@ -6131,8 +5842,8 @@
 		if (fsp->name_hash != orig_name_hash) {
 			continue;
 		}
-		DEBUG(10, ("rename_open_files: renaming file %s "
-			   "(file_id %s) from %s -> %s\n", fsp_fnum_dbg(fsp),
+		DEBUG(10, ("rename_open_files: renaming file fnum %d "
+			   "(file_id %s) from %s -> %s\n", fsp->fnum,
 			   file_id_string_tos(&fsp->file_id), fsp_str_dbg(fsp),
 			   smb_fname_str_dbg(smb_fname_dst)));
 
@@ -6145,7 +5856,7 @@
 
 	if (!did_rename) {
 		DEBUG(10, ("rename_open_files: no open files on file_id %s "
-			   "for %s\n", file_id_string_tos(&lck->data->id),
+			   "for %s\n", file_id_string_tos(&lck->id),
 			   smb_fname_str_dbg(smb_fname_dst)));
 	}
 
@@ -6471,7 +6182,8 @@
 		status = NT_STATUS_ACCESS_DENIED;
 	}
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
 
 	/*
 	 * We have the file open ourselves, so not being able to get the
@@ -7003,7 +6715,7 @@
 				  attrs, False, src_has_wcard, dest_has_wcard,
 				  DELETE_ACCESS);
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -7036,7 +6748,7 @@
 			bool target_is_directory)
 {
 	struct smb_filename *smb_fname_dst_tmp = NULL;
-	off_t ret=-1;
+	SMB_OFF_T ret=-1;
 	files_struct *fsp1,*fsp2;
  	uint32 dosattrs;
 	uint32 new_create_disposition;
@@ -7181,7 +6893,7 @@
 		goto out;
 	}
 
-	if (ret != (off_t)smb_fname_src->st.st_ex_size) {
+	if (ret != (SMB_OFF_T)smb_fname_src->st.st_ex_size) {
 		status = NT_STATUS_DISK_FULL;
 		goto out;
 	}
@@ -7908,8 +7620,8 @@
 		return status;
 	}
 
-	DEBUG(3, ("smbd_do_locking: %s type=%d num_locks=%d num_ulocks=%d\n",
-		  fsp_fnum_dbg(fsp), (unsigned int)type, num_locks, num_ulocks));
+	DEBUG(3, ("smbd_do_locking: fnum=%d type=%d num_locks=%d num_ulocks=%d\n",
+		  fsp->fnum, (unsigned int)type, num_locks, num_ulocks));
 
 	return NT_STATUS_OK;
 }
@@ -7977,8 +7689,8 @@
 		bool result;
 
 		DEBUG(5,("reply_lockingX: oplock break reply (%u) from client "
-			 "for %s\n", (unsigned int)oplocklevel,
-			 fsp_fnum_dbg(fsp)));
+			 "for fnum = %d\n", (unsigned int)oplocklevel,
+			 fsp->fnum ));
 
 		/*
 		 * Make sure we have granted an exclusive or batch oplock on
@@ -7994,9 +7706,9 @@
 			   message here - just ignore it. JRA. */
 
 			DEBUG(5,("reply_lockingX: Error : oplock break from "
-				 "client for %s (oplock=%d) and no "
+				 "client for fnum = %d (oplock=%d) and no "
 				 "oplock granted on this file (%s).\n",
-				 fsp_fnum_dbg(fsp), fsp->oplock_type,
+				 fsp->fnum, fsp->oplock_type,
 				 fsp_str_dbg(fsp)));
 
 			/* if this is a pure oplock break request then don't
@@ -8131,13 +7843,12 @@
 	}
 
 	reply_outbuf(req, 2, 0);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
 
-	DEBUG(3, ("lockingX %s type=%d num_locks=%d num_ulocks=%d\n",
-		  fsp_fnum_dbg(fsp), (unsigned int)locktype, num_locks, num_ulocks));
+	DEBUG(3, ("lockingX fnum=%d type=%d num_locks=%d num_ulocks=%d\n",
+		  fsp->fnum, (unsigned int)locktype, num_locks, num_ulocks));
 
 	END_PROFILE(SMBlockingX);
+	chain_reply(req);
 }
 
 #undef DBGC_CLASS
@@ -8222,20 +7933,15 @@
 		goto out;
 	}
 
-	if (!(fsp->access_mask & FILE_WRITE_ATTRIBUTES)) {
-		reply_nterror(req, NT_STATUS_ACCESS_DENIED);
-		goto out;
-	}
-
 	status = smb_set_file_time(conn, fsp, fsp->fsp_name, &ft, true);
 	if (!NT_STATUS_IS_OK(status)) {
 		reply_nterror(req, status);
 		goto out;
 	}
 
-	DEBUG( 3, ( "reply_setattrE %s actime=%u modtime=%u "
+	DEBUG( 3, ( "reply_setattrE fnum=%d actime=%u modtime=%u "
 	       " createtime=%u\n",
-		fsp_fnum_dbg(fsp),
+		fsp->fnum,
 		(unsigned int)ft.atime.tv_sec,
 		(unsigned int)ft.mtime.tv_sec,
 		(unsigned int)ft.create_time.tv_sec
@@ -8338,7 +8044,7 @@
 	}
 	SSVAL(req->outbuf,smb_vwv10, mode);
 
-	DEBUG( 3, ( "reply_getattrE %s\n", fsp_fnum_dbg(fsp)));
+	DEBUG( 3, ( "reply_getattrE fnum=%d\n", fsp->fnum));
 
 	END_PROFILE(SMBgetattrE);
 	return;
Only in ../../samba-3.6.24/source3/smbd: reply.o
Only in smbd: scavenger.c
Only in smbd: scavenger.h
diff -ur smbd/seal.c ../../samba-3.6.24/source3/smbd/seal.c
--- smbd/seal.c	2014-05-28 01:20:37.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/seal.c	2015-01-28 10:52:25.149068676 +0800
@@ -2,17 +2,17 @@
    Unix SMB/CIFS implementation.
    SMB Transport encryption (sealing) code - server code.
    Copyright (C) Jeremy Allison 2007.
-
+   
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@@ -21,32 +21,40 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "../libcli/auth/spnego.h"
-#include "../libcli/smb/smb_seal.h"
+#include "../libcli/auth/ntlmssp.h"
+#include "ntlmssp_wrap.h"
+#include "smb_crypt.h"
 #include "../lib/util/asn1.h"
 #include "auth.h"
 #include "libsmb/libsmb.h"
-#include "../lib/tsocket/tsocket.h"
-#include "auth/gensec/gensec.h"
 
 /******************************************************************************
  Server side encryption.
 ******************************************************************************/
 
 /******************************************************************************
+ Global server state.
+******************************************************************************/
+
+struct smb_srv_trans_enc_ctx {
+	struct smb_trans_enc_state *es;
+	struct auth_ntlmssp_state *auth_ntlmssp_state; /* Must be kept in sync with pointer in ec->ntlmssp_state. */
+};
+
+/******************************************************************************
  Return global enc context - this must change if we ever do multiple contexts.
 ******************************************************************************/
 
-static uint16_t srv_enc_ctx(const struct smb_trans_enc_state *es)
+uint16_t srv_enc_ctx(void)
 {
-	return es->enc_ctx_num;
+	return srv_trans_enc_ctx->es->enc_ctx_num;
 }
 
 /******************************************************************************
  Is this an incoming encrypted packet ?
 ******************************************************************************/
 
-bool is_encrypted_packet(struct smbd_server_connection *sconn,
-			 const uint8_t *inbuf)
+bool is_encrypted_packet(const uint8_t *inbuf)
 {
 	NTSTATUS status;
 	uint16_t enc_num;
@@ -64,70 +72,236 @@
 	}
 
 	/* Encrypted messages are 0xFF'E'<ctx> */
-	if (srv_trans_enc_ctx && enc_num == srv_enc_ctx(srv_trans_enc_ctx)) {
+	if (srv_trans_enc_ctx && enc_num == srv_enc_ctx()) {
 		return true;
 	}
 	return false;
 }
 
 /******************************************************************************
- Create an gensec_security and ensure pointer copy is correct.
+ Create an auth_ntlmssp_state and ensure pointer copy is correct.
 ******************************************************************************/
 
-static NTSTATUS make_auth_gensec(const struct tsocket_address *remote_address,
-				 struct smb_trans_enc_state *es)
+static NTSTATUS make_auth_ntlmssp(struct smb_srv_trans_enc_ctx *ec)
 {
-	NTSTATUS status;
-
-	status = auth_generic_prepare(es, remote_address,
-				      &es->gensec_security);
+	NTSTATUS status = auth_ntlmssp_start(&ec->auth_ntlmssp_state);
 	if (!NT_STATUS_IS_OK(status)) {
 		return nt_status_squash(status);
 	}
 
-	gensec_want_feature(es->gensec_security, GENSEC_FEATURE_SEAL);
+	/*
+	 * We must remember to update the pointer copy for the common
+	 * functions after any auth_ntlmssp_start/auth_ntlmssp_end.
+	 */
+	ec->es->s.ntlmssp_state = auth_ntlmssp_get_ntlmssp_state(ec->auth_ntlmssp_state);
+	return status;
+}
+
+/******************************************************************************
+ Destroy an auth_ntlmssp_state and ensure pointer copy is correct.
+******************************************************************************/
+
+static void destroy_auth_ntlmssp(struct smb_srv_trans_enc_ctx *ec)
+{
+	/*
+	 * We must remember to update the pointer copy for the common
+	 * functions after any auth_ntlmssp_start/auth_ntlmssp_end.
+	 */
+
+	if (ec->auth_ntlmssp_state) {
+		TALLOC_FREE(ec->auth_ntlmssp_state);
+		/* The auth_ntlmssp_end killed this already. */
+		ec->es->s.ntlmssp_state = NULL;
+	}
+}
+
+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)
+
+/******************************************************************************
+ Import a name.
+******************************************************************************/
+
+static NTSTATUS get_srv_gss_creds(const char *service,
+				const char *name,
+				gss_cred_usage_t cred_type,
+				gss_cred_id_t *p_srv_cred)
+{
+	OM_uint32 ret;
+	OM_uint32 min;
+	gss_name_t srv_name;
+	gss_buffer_desc input_name;
+	char *host_princ_s = NULL;
+	NTSTATUS status = NT_STATUS_OK;
+
+	gss_OID_desc nt_hostbased_service =
+	{10, CONST_DISCARD(char *,"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x04")};
+
+	if (asprintf(&host_princ_s, "%s@%s", service, name) == -1) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	input_name.value = host_princ_s;
+	input_name.length = strlen(host_princ_s) + 1;
+
+	ret = gss_import_name(&min,
+				&input_name,
+				&nt_hostbased_service,
+				&srv_name);
+
+	DEBUG(10,("get_srv_gss_creds: imported name %s\n",
+		host_princ_s ));
+
+	if (ret != GSS_S_COMPLETE) {
+		SAFE_FREE(host_princ_s);
+		return map_nt_error_from_gss(ret, min);
+	}
 
 	/*
-	 * We could be accessing the secrets.tdb or krb5.keytab file here.
+	 * We're accessing the krb5.keytab file here.
  	 * ensure we have permissions to do so.
  	 */
 	become_root();
 
-	status = gensec_start_mech_by_oid(es->gensec_security, GENSEC_OID_SPNEGO);
-
+	ret = gss_acquire_cred(&min,
+				srv_name,
+				GSS_C_INDEFINITE,
+				GSS_C_NULL_OID_SET,
+				cred_type,
+				p_srv_cred,
+				NULL,
+				NULL);
 	unbecome_root();
 
-	if (!NT_STATUS_IS_OK(status)) {
-		return nt_status_squash(status);
+	if (ret != GSS_S_COMPLETE) {
+		ADS_STATUS adss = ADS_ERROR_GSS(ret, min);
+		DEBUG(10,("get_srv_gss_creds: gss_acquire_cred failed with %s\n",
+			ads_errstr(adss)));
+		status = map_nt_error_from_gss(ret, min);
 	}
 
+	SAFE_FREE(host_princ_s);
+	gss_release_name(&min, &srv_name);
 	return status;
 }
 
 /******************************************************************************
- Create a server encryption context.
+ Create a gss state.
+ Try and get the cifs/server@realm principal first, then fall back to
+ host/server@realm.
 ******************************************************************************/
 
-static NTSTATUS make_srv_encryption_context(const struct tsocket_address *remote_address,
-					    struct smb_trans_enc_state **pp_es)
+static NTSTATUS make_auth_gss(struct smb_srv_trans_enc_ctx *ec)
 {
 	NTSTATUS status;
-	struct smb_trans_enc_state *es;
+	gss_cred_id_t srv_cred;
+	fstring fqdn;
+
+	name_to_fqdn(fqdn, global_myname());
+	strlower_m(fqdn);
+
+	status = get_srv_gss_creds("cifs", fqdn, GSS_C_ACCEPT, &srv_cred);
+	if (!NT_STATUS_IS_OK(status)) {
+		status = get_srv_gss_creds("host", fqdn, GSS_C_ACCEPT, &srv_cred);
+		if (!NT_STATUS_IS_OK(status)) {
+			return nt_status_squash(status);
+		}
+	}
+
+	ec->es->s.gss_state = SMB_MALLOC_P(struct smb_tran_enc_state_gss);
+	if (!ec->es->s.gss_state) {
+		OM_uint32 min;
+		gss_release_cred(&min, &srv_cred);
+		return NT_STATUS_NO_MEMORY;
+	}
+	ZERO_STRUCTP(ec->es->s.gss_state);
+	ec->es->s.gss_state->creds = srv_cred;
+
+	/* No context yet. */
+	ec->es->s.gss_state->gss_ctx = GSS_C_NO_CONTEXT;
+
+	return NT_STATUS_OK;
+}
+#endif
+
+/******************************************************************************
+ Shutdown a server encryption context.
+******************************************************************************/
+
+static void srv_free_encryption_context(struct smb_srv_trans_enc_ctx **pp_ec)
+{
+	struct smb_srv_trans_enc_ctx *ec = *pp_ec;
+
+	if (!ec) {
+		return;
+	}
+
+	if (ec->es) {
+		switch (ec->es->smb_enc_type) {
+			case SMB_TRANS_ENC_NTLM:
+				destroy_auth_ntlmssp(ec);
+				break;
+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)
+			case SMB_TRANS_ENC_GSS:
+				break;
+#endif
+		}
+		common_free_encryption_state(&ec->es);
+	}
 
-	*pp_es = NULL;
+	SAFE_FREE(ec);
+	*pp_ec = NULL;
+}
+
+/******************************************************************************
+ Create a server encryption context.
+******************************************************************************/
+
+static NTSTATUS make_srv_encryption_context(enum smb_trans_enc_type smb_enc_type, struct smb_srv_trans_enc_ctx **pp_ec)
+{
+	struct smb_srv_trans_enc_ctx *ec;
+
+	*pp_ec = NULL;
 
+	ec = SMB_MALLOC_P(struct smb_srv_trans_enc_ctx);
+	if (!ec) {
+		return NT_STATUS_NO_MEMORY;
+	}
 	ZERO_STRUCTP(partial_srv_trans_enc_ctx);
-	es = talloc_zero(NULL, struct smb_trans_enc_state);
-	if (!es) {
+	ec->es = SMB_MALLOC_P(struct smb_trans_enc_state);
+	if (!ec->es) {
+		SAFE_FREE(ec);
 		return NT_STATUS_NO_MEMORY;
 	}
-	status = make_auth_gensec(remote_address,
-				  es);
-	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(es);
-		return status;
+	ZERO_STRUCTP(ec->es);
+	ec->es->smb_enc_type = smb_enc_type;
+	switch (smb_enc_type) {
+		case SMB_TRANS_ENC_NTLM:
+			{
+				NTSTATUS status = make_auth_ntlmssp(ec);
+				if (!NT_STATUS_IS_OK(status)) {
+					srv_free_encryption_context(&ec);
+					return status;
+				}
+			}
+			break;
+
+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)
+		case SMB_TRANS_ENC_GSS:
+			/* Acquire our credentials by calling gss_acquire_cred here. */
+			{
+				NTSTATUS status = make_auth_gss(ec);
+				if (!NT_STATUS_IS_OK(status)) {
+					srv_free_encryption_context(&ec);
+					return status;
+				}
+			}
+			break;
+#endif
+		default:
+			srv_free_encryption_context(&ec);
+			return NT_STATUS_INVALID_PARAMETER;
 	}
-	*pp_es = es;
+	*pp_ec = ec;
 	return NT_STATUS_OK;
 }
 
@@ -135,7 +309,7 @@
  Free an encryption-allocated buffer.
 ******************************************************************************/
 
-void srv_free_enc_buffer(struct smbd_server_connection *sconn, char *buf)
+void srv_free_enc_buffer(char *buf)
 {
 	/* We know this is an smb buffer, and we
 	 * didn't malloc, only copy, for a keepalive,
@@ -146,7 +320,7 @@
 	}
 
 	if (srv_trans_enc_ctx) {
-		common_free_enc_buffer(srv_trans_enc_ctx, buf);
+		common_free_enc_buffer(srv_trans_enc_ctx->es, buf);
 	}
 }
 
@@ -154,7 +328,7 @@
  Decrypt an incoming buffer.
 ******************************************************************************/
 
-NTSTATUS srv_decrypt_buffer(struct smbd_server_connection *sconn, char *buf)
+NTSTATUS srv_decrypt_buffer(char *buf)
 {
 	/* Ignore non-session messages. */
 	if(CVAL(buf,0)) {
@@ -162,7 +336,7 @@
 	}
 
 	if (srv_trans_enc_ctx) {
-		return common_decrypt_buffer(srv_trans_enc_ctx, buf);
+		return common_decrypt_buffer(srv_trans_enc_ctx->es, buf);
 	}
 
 	return NT_STATUS_OK;
@@ -172,8 +346,7 @@
  Encrypt an outgoing buffer. Return the encrypted pointer in buf_out.
 ******************************************************************************/
 
-NTSTATUS srv_encrypt_buffer(struct smbd_server_connection *sconn, char *buf,
-			    char **buf_out)
+NTSTATUS srv_encrypt_buffer(char *buf, char **buf_out)
 {
 	*buf_out = buf;
 
@@ -183,69 +356,307 @@
 	}
 
 	if (srv_trans_enc_ctx) {
-		return common_encrypt_buffer(srv_trans_enc_ctx, buf, buf_out);
+		return common_encrypt_buffer(srv_trans_enc_ctx->es, buf, buf_out);
 	}
 	/* Not encrypting. */
 	return NT_STATUS_OK;
 }
 
 /******************************************************************************
+ Do the gss encryption negotiation. Parameters are in/out.
+ Until success we do everything on the partial enc ctx.
+******************************************************************************/
+
+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)
+static NTSTATUS srv_enc_spnego_gss_negotiate(unsigned char **ppdata, size_t *p_data_size, DATA_BLOB secblob)
+{
+	OM_uint32 ret;
+	OM_uint32 min;
+	OM_uint32 flags = 0;
+	gss_buffer_desc in_buf, out_buf;
+	struct smb_tran_enc_state_gss *gss_state;
+	DATA_BLOB auth_reply = data_blob_null;
+	DATA_BLOB response = data_blob_null;
+	NTSTATUS status;
+
+	if (!partial_srv_trans_enc_ctx) {
+		status = make_srv_encryption_context(SMB_TRANS_ENC_GSS, &partial_srv_trans_enc_ctx);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+	}
+
+	gss_state = partial_srv_trans_enc_ctx->es->s.gss_state;
+
+	in_buf.value = secblob.data;
+	in_buf.length = secblob.length;
+
+	out_buf.value = NULL;
+	out_buf.length = 0;
+
+	become_root();
+
+	ret = gss_accept_sec_context(&min,
+				&gss_state->gss_ctx,
+				gss_state->creds,
+				&in_buf,
+				GSS_C_NO_CHANNEL_BINDINGS,
+				NULL,
+				NULL,		/* Ignore oids. */
+				&out_buf,	/* To return. */
+				&flags,
+				NULL,		/* Ingore time. */
+				NULL);		/* Ignore delegated creds. */
+	unbecome_root();
+
+	status = gss_err_to_ntstatus(ret, min);
+	if (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {
+		return status;
+	}
+
+	/* Ensure we've got sign+seal available. */
+	if (ret == GSS_S_COMPLETE) {
+		if ((flags & (GSS_C_INTEG_FLAG|GSS_C_CONF_FLAG|GSS_C_REPLAY_FLAG|GSS_C_SEQUENCE_FLAG)) !=
+				(GSS_C_INTEG_FLAG|GSS_C_CONF_FLAG|GSS_C_REPLAY_FLAG|GSS_C_SEQUENCE_FLAG)) {
+			DEBUG(0,("srv_enc_spnego_gss_negotiate: quality of service not good enough "
+				"for SMB sealing.\n"));
+			gss_release_buffer(&min, &out_buf);
+			return NT_STATUS_ACCESS_DENIED;
+		}
+	}
+
+	auth_reply = data_blob(out_buf.value, out_buf.length);
+	gss_release_buffer(&min, &out_buf);
+
+	/* Wrap in SPNEGO. */
+	response = spnego_gen_auth_response(talloc_tos(), &auth_reply, status, OID_KERBEROS5);
+	data_blob_free(&auth_reply);
+
+	SAFE_FREE(*ppdata);
+	*ppdata = (unsigned char *)memdup(response.data, response.length);
+	if ((*ppdata) == NULL && response.length > 0) {
+		status = NT_STATUS_NO_MEMORY;
+	}
+	*p_data_size = response.length;
+
+	data_blob_free(&response);
+
+	return status;
+}
+#endif
+
+/******************************************************************************
+ Do the NTLM SPNEGO (or raw) encryption negotiation. Parameters are in/out.
+ Until success we do everything on the partial enc ctx.
+******************************************************************************/
+
+static NTSTATUS srv_enc_ntlm_negotiate(unsigned char **ppdata, size_t *p_data_size, DATA_BLOB secblob, bool spnego_wrap)
+{
+	NTSTATUS status;
+	DATA_BLOB chal = data_blob_null;
+	DATA_BLOB response = data_blob_null;
+
+	status = make_srv_encryption_context(SMB_TRANS_ENC_NTLM, &partial_srv_trans_enc_ctx);
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	status = auth_ntlmssp_update(partial_srv_trans_enc_ctx->auth_ntlmssp_state, secblob, &chal);
+
+	/* status here should be NT_STATUS_MORE_PROCESSING_REQUIRED
+	 * for success ... */
+
+	if (spnego_wrap) {
+		response = spnego_gen_auth_response(talloc_tos(), &chal, status, OID_NTLMSSP);
+		data_blob_free(&chal);
+	} else {
+		/* Return the raw blob. */
+		response = chal;
+	}
+
+	SAFE_FREE(*ppdata);
+	*ppdata = (unsigned char *)memdup(response.data, response.length);
+	if ((*ppdata) == NULL && response.length > 0) {
+		status = NT_STATUS_NO_MEMORY;
+	}
+	*p_data_size = response.length;
+	data_blob_free(&response);
+
+	return status;
+}
+
+/******************************************************************************
  Do the SPNEGO encryption negotiation. Parameters are in/out.
+ Based off code in smbd/sesssionsetup.c
+ Until success we do everything on the partial enc ctx.
 ******************************************************************************/
 
-NTSTATUS srv_request_encryption_setup(connection_struct *conn,
+static NTSTATUS srv_enc_spnego_negotiate(connection_struct *conn,
 					unsigned char **ppdata,
 					size_t *p_data_size,
 					unsigned char **pparam,
 					size_t *p_param_size)
 {
 	NTSTATUS status;
-	DATA_BLOB blob = data_blob_const(*ppdata, *p_data_size);
+	DATA_BLOB blob = data_blob_null;
+	DATA_BLOB secblob = data_blob_null;
+	char *kerb_mech = NULL;
+
+	blob = data_blob_const(*ppdata, *p_data_size);
+
+	status = parse_spnego_mechanisms(talloc_tos(), blob, &secblob, &kerb_mech);
+	if (!NT_STATUS_IS_OK(status)) {
+		return nt_status_squash(status);
+	}
+
+	/* We should have no partial context at this point. */
+
+	srv_free_encryption_context(&partial_srv_trans_enc_ctx);
+
+	if (kerb_mech) {
+		TALLOC_FREE(kerb_mech);
+
+#if defined(HAVE_GSSAPI) && defined(HAVE_KRB5)
+		status = srv_enc_spnego_gss_negotiate(ppdata, p_data_size, secblob);
+#else
+		/* Currently we don't SPNEGO negotiate
+		 * back to NTLMSSP as we do in sessionsetupX. We should... */
+		return NT_STATUS_LOGON_FAILURE;
+#endif
+	} else {
+		status = srv_enc_ntlm_negotiate(ppdata, p_data_size, secblob, true);
+	}
+
+	data_blob_free(&secblob);
+
+	if (!NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED) && !NT_STATUS_IS_OK(status)) {
+		srv_free_encryption_context(&partial_srv_trans_enc_ctx);
+		return nt_status_squash(status);
+	}
+
+	if (NT_STATUS_IS_OK(status)) {
+		/* Return the context we're using for this encryption state. */
+		if (!(*pparam = SMB_MALLOC_ARRAY(unsigned char, 2))) {
+			return NT_STATUS_NO_MEMORY;
+		}
+		SSVAL(*pparam,0,partial_srv_trans_enc_ctx->es->enc_ctx_num);
+		*p_param_size = 2;
+	}
+
+	return status;
+}
+
+/******************************************************************************
+ Complete a SPNEGO encryption negotiation. Parameters are in/out.
+ We only get this for a NTLM auth second stage.
+******************************************************************************/
+
+static NTSTATUS srv_enc_spnego_ntlm_auth(connection_struct *conn,
+					unsigned char **ppdata,
+					size_t *p_data_size,
+					unsigned char **pparam,
+					size_t *p_param_size)
+{
+	NTSTATUS status;
+	DATA_BLOB blob = data_blob_null;
+	DATA_BLOB auth = data_blob_null;
+	DATA_BLOB auth_reply = data_blob_null;
 	DATA_BLOB response = data_blob_null;
-	struct smb_trans_enc_state *es;
+	struct smb_srv_trans_enc_ctx *ec = partial_srv_trans_enc_ctx;
 
-	SAFE_FREE(*pparam);
-	*p_param_size = 0;
+	/* We must have a partial context here. */
+
+	if (!ec || !ec->es || ec->auth_ntlmssp_state == NULL || ec->es->smb_enc_type != SMB_TRANS_ENC_NTLM) {
+		srv_free_encryption_context(&partial_srv_trans_enc_ctx);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	blob = data_blob_const(*ppdata, *p_data_size);
+	if (!spnego_parse_auth(talloc_tos(), blob, &auth)) {
+		srv_free_encryption_context(&partial_srv_trans_enc_ctx);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	status = auth_ntlmssp_update(ec->auth_ntlmssp_state, auth, &auth_reply);
+	data_blob_free(&auth);
+
+	/* From RFC4178.
+	 *
+	 *    supportedMech
+	 *
+	 *          This field SHALL only be present in the first reply from the
+	 *                target.
+	 * So set mechOID to NULL here.
+	 */
+
+	response = spnego_gen_auth_response(talloc_tos(), &auth_reply, status, NULL);
+	data_blob_free(&auth_reply);
+
+	if (NT_STATUS_IS_OK(status)) {
+		/* Return the context we're using for this encryption state. */
+		if (!(*pparam = SMB_MALLOC_ARRAY(unsigned char, 2))) {
+			return NT_STATUS_NO_MEMORY;
+		}
+		SSVAL(*pparam,0,ec->es->enc_ctx_num);
+		*p_param_size = 2;
+	}
+
+	SAFE_FREE(*ppdata);
+	*ppdata = (unsigned char *)memdup(response.data, response.length);
+	if ((*ppdata) == NULL && response.length > 0)
+		return NT_STATUS_NO_MEMORY;
+	*p_data_size = response.length;
+	data_blob_free(&response);
+	return status;
+}
+
+/******************************************************************************
+ Raw NTLM encryption negotiation. Parameters are in/out.
+ This function does both steps.
+******************************************************************************/
+
+static NTSTATUS srv_enc_raw_ntlm_auth(connection_struct *conn,
+					unsigned char **ppdata,
+					size_t *p_data_size,
+					unsigned char **pparam,
+					size_t *p_param_size)
+{
+	NTSTATUS status;
+	DATA_BLOB blob = data_blob_const(*ppdata, *p_data_size);
+	DATA_BLOB response = data_blob_null;
+	struct smb_srv_trans_enc_ctx *ec;
 
 	if (!partial_srv_trans_enc_ctx) {
 		/* This is the initial step. */
-		status = make_srv_encryption_context(conn->sconn->remote_address,
-					&partial_srv_trans_enc_ctx);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
+		status = srv_enc_ntlm_negotiate(ppdata, p_data_size, blob, false);
+		if (!NT_STATUS_EQUAL(status,NT_STATUS_MORE_PROCESSING_REQUIRED) && !NT_STATUS_IS_OK(status)) {
+			srv_free_encryption_context(&partial_srv_trans_enc_ctx);
+			return nt_status_squash(status);
 		}
+		return status;
 	}
 
-	es = partial_srv_trans_enc_ctx;
-	if (!es || es->gensec_security == NULL) {
-		TALLOC_FREE(partial_srv_trans_enc_ctx);
+	ec = partial_srv_trans_enc_ctx;
+	if (!ec || !ec->es || ec->auth_ntlmssp_state == NULL || ec->es->smb_enc_type != SMB_TRANS_ENC_NTLM) {
+		srv_free_encryption_context(&partial_srv_trans_enc_ctx);
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
 	/* Second step. */
-	become_root();
-	status = gensec_update(es->gensec_security,
-			       talloc_tos(), NULL,
-			       blob, &response);
-	unbecome_root();
-	if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED) &&
-	    !NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(partial_srv_trans_enc_ctx);
-		return nt_status_squash(status);
-	}
+	status = auth_ntlmssp_update(partial_srv_trans_enc_ctx->auth_ntlmssp_state, blob, &response);
 
 	if (NT_STATUS_IS_OK(status)) {
 		/* Return the context we're using for this encryption state. */
 		if (!(*pparam = SMB_MALLOC_ARRAY(unsigned char, 2))) {
 			return NT_STATUS_NO_MEMORY;
 		}
-		SSVAL(*pparam, 0, es->enc_ctx_num);
+		SSVAL(*pparam,0,ec->es->enc_ctx_num);
 		*p_param_size = 2;
 	}
 
 	/* Return the raw blob. */
 	SAFE_FREE(*ppdata);
-	*ppdata = (unsigned char *)smb_memdup(response.data, response.length);
+	*ppdata = (unsigned char *)memdup(response.data, response.length);
 	if ((*ppdata) == NULL && response.length > 0)
 		return NT_STATUS_NO_MEMORY;
 	*p_data_size = response.length;
@@ -254,22 +665,69 @@
 }
 
 /******************************************************************************
- Negotiation was successful - turn on server-side encryption.
+ Do the SPNEGO encryption negotiation. Parameters are in/out.
 ******************************************************************************/
 
-static NTSTATUS check_enc_good(struct smb_trans_enc_state *es)
+NTSTATUS srv_request_encryption_setup(connection_struct *conn,
+					unsigned char **ppdata,
+					size_t *p_data_size,
+					unsigned char **pparam,
+					size_t *p_param_size)
 {
-	if (!es) {
-		return NT_STATUS_LOGON_FAILURE;
-	}
+	unsigned char *pdata = *ppdata;
+
+	SAFE_FREE(*pparam);
+	*p_param_size = 0;
 
-	if (!gensec_have_feature(es->gensec_security, GENSEC_FEATURE_SIGN)) {
+	if (*p_data_size < 1) {
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	if (!gensec_have_feature(es->gensec_security, GENSEC_FEATURE_SEAL)) {
+	if (pdata[0] == ASN1_APPLICATION(0)) {
+		/* its a negTokenTarg packet */
+		return srv_enc_spnego_negotiate(conn, ppdata, p_data_size, pparam, p_param_size);
+	}
+
+	if (pdata[0] == ASN1_CONTEXT(1)) {
+		/* It's an auth packet */
+		return srv_enc_spnego_ntlm_auth(conn, ppdata, p_data_size, pparam, p_param_size);
+	}
+
+	/* Maybe it's a raw unwrapped auth ? */
+	if (*p_data_size < 7) {
 		return NT_STATUS_INVALID_PARAMETER;
 	}
+
+	if (strncmp((char *)pdata, "NTLMSSP", 7) == 0) {
+		return srv_enc_raw_ntlm_auth(conn, ppdata, p_data_size, pparam, p_param_size);
+	}
+
+	DEBUG(1,("srv_request_encryption_setup: Unknown packet\n"));
+
+	return NT_STATUS_LOGON_FAILURE;
+}
+
+/******************************************************************************
+ Negotiation was successful - turn on server-side encryption.
+******************************************************************************/
+
+static NTSTATUS check_enc_good(struct smb_srv_trans_enc_ctx *ec)
+{
+	if (!ec || !ec->es) {
+		return NT_STATUS_LOGON_FAILURE;
+	}
+
+	if (ec->es->smb_enc_type == SMB_TRANS_ENC_NTLM) {
+		if (!auth_ntlmssp_negotiated_sign((ec->auth_ntlmssp_state))) {
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		if (!auth_ntlmssp_negotiated_seal((ec->auth_ntlmssp_state))) {
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+	}
+	/* Todo - check gssapi case. */
+
 	return NT_STATUS_OK;
 }
 
@@ -287,11 +745,11 @@
 		return status;
 	}
 	/* Throw away the context we're using currently (if any). */
-	TALLOC_FREE(srv_trans_enc_ctx);
+	srv_free_encryption_context(&srv_trans_enc_ctx);
 
 	/* Steal the partial pointer. Deliberate shallow copy. */
 	srv_trans_enc_ctx = partial_srv_trans_enc_ctx;
-	srv_trans_enc_ctx->enc_on = true;
+	srv_trans_enc_ctx->es->enc_on = true;
 
 	partial_srv_trans_enc_ctx = NULL;
 
@@ -303,8 +761,8 @@
  Shutdown all server contexts.
 ******************************************************************************/
 
-void server_encryption_shutdown(struct smbd_server_connection *sconn)
+void server_encryption_shutdown(void)
 {
-	TALLOC_FREE(partial_srv_trans_enc_ctx);
-	TALLOC_FREE(srv_trans_enc_ctx);
+	srv_free_encryption_context(&partial_srv_trans_enc_ctx);
+	srv_free_encryption_context(&srv_trans_enc_ctx);
 }
Only in ../../samba-3.6.24/source3/smbd: seal.o
diff -ur smbd/sec_ctx.c ../../samba-3.6.24/source3/smbd/sec_ctx.c
--- smbd/sec_ctx.c	2014-05-28 01:20:37.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/sec_ctx.c	2015-01-28 10:52:25.149068676 +0800
@@ -18,13 +18,11 @@
 */
 
 #include "includes.h"
-#include "system/passwd.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "libcli/security/security_token.h"
 #include "auth.h"
 #include "smbprofile.h"
-#include "../lib/util/setid.h"
 
 extern struct current_user current_user;
 
@@ -152,7 +150,7 @@
 	   returned from getgroups() (tridge) */
 	save_re_gid();
 	set_effective_gid(gid);
-	samba_setgid(gid);
+	setgid(gid);
 
 	ngroups = sys_getgroups(0,&grp);
 	if (ngroups <= 0) {
@@ -291,7 +289,7 @@
 	if (syscall(SYS_initgroups, (ngroups > max) ? max : ngroups,
 			groups, uid) == -1 && !non_root_mode()) {
 		DEBUG(0, ("WARNING: failed to set group list "
-			"(%d groups) for UID %d: %s\n",
+			"(%d groups) for UID %ld: %s\n",
 			ngroups, uid, strerror(errno)));
 		smb_panic("sys_setgroups failed");
 	}
@@ -331,8 +329,8 @@
 	TALLOC_FREE(ctx_p->token);
 
 	if (ngroups) {
-		ctx_p->ut.groups = (gid_t *)smb_memdup(groups,
-						       sizeof(gid_t) * ngroups);
+		ctx_p->ut.groups = (gid_t *)memdup(groups,
+						   sizeof(gid_t) * ngroups);
 		if (!ctx_p->ut.groups) {
 			smb_panic("memdup failed");
 		}
@@ -466,28 +464,3 @@
 	current_user.vuid = UID_FIELD_INVALID;
 	current_user.nt_user_token = NULL;
 }
-
-/*************************************************************
- Called when we're inside a become_root() temporary escalation
- of privileges and the nt_user_token is NULL. Return the last
- active token on the context stack. We know there is at least
- one valid non-NULL token on the stack so panic if we underflow.
-*************************************************************/
-
-const struct security_token *sec_ctx_active_token(void)
-{
-	int stack_index = sec_ctx_stack_ndx;
-	struct sec_ctx *ctx_p = &sec_ctx_stack[stack_index];
-
-	while (ctx_p->token == NULL) {
-		stack_index--;
-		if (stack_index < 0) {
-			DEBUG(0, ("Security context active token "
-				  "stack underflow!\n"));
-			smb_panic("Security context active token "
-				  "stack underflow!");
-		}
-		ctx_p = &sec_ctx_stack[stack_index];
-	}
-	return ctx_p->token;
-}
Only in ../../samba-3.6.24/source3/smbd: sec_ctx.o
diff -ur smbd/server.c ../../samba-3.6.24/source3/smbd/server.c
--- smbd/server.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/server.c	2015-01-28 10:52:25.149068676 +0800
@@ -31,84 +31,156 @@
 #include "secrets.h"
 #include "memcache.h"
 #include "ctdbd_conn.h"
-#include "printing/queue_process.h"
-#include "rpc_server/rpc_service_setup.h"
-#include "rpc_server/rpc_config.h"
+#include "printing/printer_list.h"
+#include "rpc_server/rpc_ep_setup.h"
+#include "printing/pcap.h"
+#include "printing.h"
 #include "serverid.h"
 #include "passdb.h"
 #include "auth.h"
 #include "messages.h"
 #include "smbprofile.h"
-#include "lib/id_cache.h"
-#include "lib/param/param.h"
-#include "lib/background.h"
-#include "lib/conn_tdb.h"
-#include "../lib/util/pidfile.h"
-#include "lib/smbd_shim.h"
-#include "scavenger.h"
 
-struct smbd_open_socket;
-struct smbd_child_pid;
+extern void start_epmd(struct tevent_context *ev_ctx,
+		       struct messaging_context *msg_ctx);
 
-struct smbd_parent_context {
-	bool interactive;
+extern void start_spoolssd(struct event_context *ev_ctx,
+			   struct messaging_context *msg_ctx);
 
-	struct tevent_context *ev_ctx;
-	struct messaging_context *msg_ctx;
+#ifdef WITH_DFS
+extern int dcelogin_atmost_once;
+#endif /* WITH_DFS */
 
-	/* the list of listening sockets */
-	struct smbd_open_socket *sockets;
+static void smbd_set_server_fd(int fd)
+{
+	struct smbd_server_connection *sconn = smbd_server_conn;
+	char addr[INET6_ADDRSTRLEN];
+	const char *name;
 
-	/* the list of current child processes */
-	struct smbd_child_pid *children;
-	size_t num_children;
+	sconn->sock = fd;
 
-	struct timed_event *cleanup_te;
-};
+	/*
+	 * Initialize sconn->client_id: If we can't find the client's
+	 * name, default to its address.
+	 */
 
-struct smbd_open_socket {
-	struct smbd_open_socket *prev, *next;
-	struct smbd_parent_context *parent;
-	int fd;
-	struct tevent_fd *fde;
-};
+	if (sconn->client_id.name != NULL &&
+	    sconn->client_id.name != sconn->client_id.addr) {
+		talloc_free(discard_const_p(char, sconn->client_id.name));
+		sconn->client_id.name = NULL;
+	}
 
-struct smbd_child_pid {
-	struct smbd_child_pid *prev, *next;
-	pid_t pid;
-};
+	client_addr(fd, sconn->client_id.addr, sizeof(sconn->client_id.addr));
 
-extern void start_epmd(struct tevent_context *ev_ctx,
-		       struct messaging_context *msg_ctx);
+	name = client_name(sconn->sock);
+	if (strcmp(name, "UNKNOWN") != 0) {
+		name = talloc_strdup(sconn, name);
+	} else {
+		name = NULL;
+	}
+	sconn->client_id.name =
+		(name != NULL) ? name : sconn->client_id.addr;
 
-extern void start_lsasd(struct event_context *ev_ctx,
-			struct messaging_context *msg_ctx);
+	sub_set_socket_ids(sconn->client_id.addr, sconn->client_id.name,
+			   client_socket_addr(sconn->sock, addr,
+					      sizeof(addr)));
+}
 
-#ifdef WITH_DFS
-extern int dcelogin_atmost_once;
-#endif /* WITH_DFS */
+struct event_context *smbd_event_context(void)
+{
+	return server_event_context();
+}
 
 /*******************************************************************
  What to do when smb.conf is updated.
  ********************************************************************/
 
-static void smbd_parent_conf_updated(struct messaging_context *msg,
-				     void *private_data,
-				     uint32_t msg_type,
-				     struct server_id server_id,
-				     DATA_BLOB *data)
+static void smb_conf_updated(struct messaging_context *msg,
+			     void *private_data,
+			     uint32_t msg_type,
+			     struct server_id server_id,
+			     DATA_BLOB *data)
 {
 	struct tevent_context *ev_ctx =
 		talloc_get_type_abort(private_data, struct tevent_context);
 
-	DEBUG(10,("smbd_parent_conf_updated: Got message saying smb.conf was "
+	DEBUG(10,("smb_conf_updated: Got message saying smb.conf was "
 		  "updated. Reloading.\n"));
 	change_to_root_user();
-	reload_services(NULL, NULL, false);
-	printing_subsystem_update(ev_ctx, msg, false);
+	reload_services(msg, smbd_server_conn->sock, False);
+	/* printer reload triggered by background printing process */
 }
 
 /*******************************************************************
+ What to do when printcap is updated.
+ ********************************************************************/
+
+static void smb_pcap_updated(struct messaging_context *msg,
+			     void *private_data,
+			     uint32_t msg_type,
+			     struct server_id server_id,
+			     DATA_BLOB *data)
+{
+	struct tevent_context *ev_ctx =
+		talloc_get_type_abort(private_data, struct tevent_context);
+
+	DEBUG(10,("Got message saying pcap was updated. Reloading.\n"));
+	change_to_root_user();
+	reload_printers(ev_ctx, msg);
+}
+
+static void smbd_sig_term_handler(struct tevent_context *ev,
+				  struct tevent_signal *se,
+				  int signum,
+				  int count,
+				  void *siginfo,
+				  void *private_data)
+{
+	exit_server_cleanly("termination signal");
+}
+
+static void smbd_setup_sig_term_handler(void)
+{
+	struct tevent_signal *se;
+
+	se = tevent_add_signal(smbd_event_context(),
+			       smbd_event_context(),
+			       SIGTERM, 0,
+			       smbd_sig_term_handler,
+			       NULL);
+	if (!se) {
+		exit_server("failed to setup SIGTERM handler");
+	}
+}
+
+static void smbd_sig_hup_handler(struct tevent_context *ev,
+				 struct tevent_signal *se,
+				 int signum,
+				 int count,
+				 void *siginfo,
+				 void *private_data)
+{
+	struct messaging_context *msg_ctx = talloc_get_type_abort(
+		private_data, struct messaging_context);
+	change_to_root_user();
+	DEBUG(1,("Reloading services after SIGHUP\n"));
+	reload_services(msg_ctx, smbd_server_conn->sock, false);
+}
+
+static void smbd_setup_sig_hup_handler(struct tevent_context *ev,
+				       struct messaging_context *msg_ctx)
+{
+	struct tevent_signal *se;
+
+	se = tevent_add_signal(ev, ev, SIGHUP, 0, smbd_sig_hup_handler,
+			       msg_ctx);
+	if (!se) {
+		exit_server("failed to setup SIGHUP handler");
+	}
+}
+
+
+/*******************************************************************
  Delete a statcache entry.
  ********************************************************************/
 
@@ -132,6 +204,20 @@
 	if(am_parent) kill(0,SIGTERM);
 }
 
+/****************************************************************************
+ Process a sam sync message - not sure whether to do this here or
+ somewhere else.
+****************************************************************************/
+
+static void msg_sam_sync(struct messaging_context *msg,
+			 void *private_data,
+			 uint32_t msg_type,
+			 struct server_id server_id,
+			 DATA_BLOB *data)
+{
+        DEBUG(10, ("** sam sync message received, ignoring\n"));
+}
+
 static void msg_exit_server(struct messaging_context *msg,
 			    void *private_data,
 			    uint32_t msg_type,
@@ -171,32 +257,10 @@
 		  procid_str_static(&src), sig));
 #endif
 
-	kill(getpid(), sig);
+	kill(sys_getpid(), sig);
 }
 #endif /* DEVELOPER */
 
-NTSTATUS messaging_send_to_children(struct messaging_context *msg_ctx,
-				    uint32_t msg_type, DATA_BLOB* data)
-{
-	NTSTATUS status;
-	struct smbd_parent_context *parent = am_parent;
-	struct smbd_child_pid *child;
-
-	if (parent == NULL) {
-		return NT_STATUS_INTERNAL_ERROR;
-	}
-
-	for (child = parent->children; child != NULL; child = child->next) {
-		status = messaging_send(parent->msg_ctx,
-					pid_to_procid(child->pid),
-					msg_type, data);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	}
-	return NT_STATUS_OK;
-}
-
 /*
  * Parent smbd process sets its own debug level first and then
  * sends a message to all the smbd children to adjust their debug
@@ -209,161 +273,30 @@
 			   struct server_id server_id,
 			   DATA_BLOB *data)
 {
-	debug_message(msg_ctx, private_data, MSG_DEBUG, server_id, data);
-
-	messaging_send_to_children(msg_ctx, MSG_DEBUG, data);
-}
-
-static void smbd_parent_id_cache_kill(struct messaging_context *msg_ctx,
-				      void *private_data,
-				      uint32_t msg_type,
-				      struct server_id server_id,
-				      DATA_BLOB* data)
-{
-	const char *msg = (data && data->data)
-		? (const char *)data->data : "<NULL>";
-	struct id_cache_ref id;
-
-	if (!id_cache_ref_parse(msg, &id)) {
-		DEBUG(0, ("Invalid ?ID: %s\n", msg));
-		return;
-	}
-
-	id_cache_delete_from_cache(&id);
-
-	messaging_send_to_children(msg_ctx, msg_type, data);
-}
-
-static void smbd_parent_id_cache_delete(struct messaging_context *ctx,
-					void* data,
-					uint32_t msg_type,
-					struct server_id srv_id,
-					DATA_BLOB* msg_data)
-{
-	id_cache_delete_message(ctx, data, msg_type, srv_id, msg_data);
-
-	messaging_send_to_children(ctx, msg_type, msg_data);
-}
-
-struct smbd_parent_notify_state {
-	struct tevent_context *ev;
-	struct messaging_context *msg;
-	uint32_t msgtype;
-	struct notify_context *notify;
-};
-
-static int smbd_parent_notify_cleanup(void *private_data);
-static void smbd_parent_notify_cleanup_done(struct tevent_req *req);
-static void smbd_parent_notify_proxy_done(struct tevent_req *req);
-
-static bool smbd_parent_notify_init(TALLOC_CTX *mem_ctx,
-				    struct messaging_context *msg,
-				    struct tevent_context *ev)
-{
-	struct smbd_parent_notify_state *state;
-	struct tevent_req *req;
-
-	state = talloc(mem_ctx, struct smbd_parent_notify_state);
-	if (state == NULL) {
-		return NULL;
-	}
-	state->msg = msg;
-	state->ev = ev;
-	state->msgtype = MSG_SMB_NOTIFY_CLEANUP;
-
-	state->notify = notify_init(state, msg, ev);
-	if (state->notify == NULL) {
-		goto fail;
-	}
-	req = background_job_send(
-		state, state->ev, state->msg, &state->msgtype, 1,
-		lp_parm_int(-1, "smbd", "notify cleanup interval", 60),
-		smbd_parent_notify_cleanup, state->notify);
-	if (req == NULL) {
-		goto fail;
-	}
-	tevent_req_set_callback(req, smbd_parent_notify_cleanup_done, state);
+	struct child_pid *child;
 
-	if (!lp_clustering()) {
-		return true;
-	}
-
-	req = notify_cluster_proxy_send(state, ev, state->notify);
-	if (req == NULL) {
-		goto fail;
-	}
-	tevent_req_set_callback(req, smbd_parent_notify_proxy_done, state);
-
-	return true;
-fail:
-	TALLOC_FREE(state);
-	return false;
-}
-
-static int smbd_parent_notify_cleanup(void *private_data)
-{
-	struct notify_context *notify = talloc_get_type_abort(
-		private_data, struct notify_context);
-	notify_cleanup(notify);
-	return lp_parm_int(-1, "smbd", "notify cleanup interval", 60);
-}
-
-static void smbd_parent_notify_cleanup_done(struct tevent_req *req)
-{
-	struct smbd_parent_notify_state *state = tevent_req_callback_data(
-		req, struct smbd_parent_notify_state);
-	NTSTATUS status;
-
-	status = background_job_recv(req);
-	TALLOC_FREE(req);
-	DEBUG(1, ("notify cleanup job ended with %s\n", nt_errstr(status)));
+	debug_message(msg_ctx, private_data, MSG_DEBUG, server_id, data);
 
-	/*
-	 * Provide self-healing: Whatever the error condition was, it
-	 * will have printed it into log.smbd. Just retrying and
-	 * spamming log.smbd once a minute should be fine.
-	 */
-	req = background_job_send(
-		state, state->ev, state->msg, &state->msgtype, 1, 60,
-		smbd_parent_notify_cleanup, state->notify);
-	if (req == NULL) {
-		DEBUG(1, ("background_job_send failed\n"));
-		return;
+	for (child = children; child != NULL; child = child->next) {
+		messaging_send_buf(msg_ctx, pid_to_procid(child->pid),
+				   MSG_DEBUG,
+				   data->data,
+				   strlen((char *) data->data) + 1);
 	}
-	tevent_req_set_callback(req, smbd_parent_notify_cleanup_done, state);
 }
 
-static void smbd_parent_notify_proxy_done(struct tevent_req *req)
+static void add_child_pid(pid_t pid)
 {
-	int ret;
+	struct child_pid *child;
 
-	ret = notify_cluster_proxy_recv(req);
-	TALLOC_FREE(req);
-	DEBUG(1, ("notify proxy job ended with %s\n", strerror(ret)));
-}
-
-static void smb_parent_force_tdis(struct messaging_context *ctx,
-				  void* data,
-				  uint32_t msg_type,
-				  struct server_id srv_id,
-				  DATA_BLOB* msg_data)
-{
-	messaging_send_to_children(ctx, msg_type, msg_data);
-}
-
-static void add_child_pid(struct smbd_parent_context *parent,
-			  pid_t pid)
-{
-	struct smbd_child_pid *child;
-
-	child = talloc_zero(parent, struct smbd_child_pid);
+	child = SMB_MALLOC_P(struct child_pid);
 	if (child == NULL) {
 		DEBUG(0, ("Could not add child struct -- malloc failed\n"));
 		return;
 	}
 	child->pid = pid;
-	DLIST_ADD(parent->children, child);
-	parent->num_children += 1;
+	DLIST_ADD(children, child);
+	num_children += 1;
 }
 
 /*
@@ -382,34 +315,31 @@
 				struct timeval now,
 				void *private_data)
 {
-	struct smbd_parent_context *parent =
-		talloc_get_type_abort(private_data,
-		struct smbd_parent_context);
-
-	parent->cleanup_te = NULL;
+	struct timed_event **cleanup_te = (struct timed_event **)private_data;
 
 	DEBUG(1,("Cleaning up brl and lock database after unclean shutdown\n"));
-	message_send_all(parent->msg_ctx, MSG_SMB_UNLOCK, NULL, 0, NULL);
-	messaging_send_buf(parent->msg_ctx,
-			   messaging_server_id(parent->msg_ctx),
-			   MSG_SMB_BRL_VALIDATE, NULL, 0);
+	message_send_all(smbd_messaging_context(), MSG_SMB_UNLOCK, NULL, 0, NULL);
+	messaging_send_buf(smbd_messaging_context(), procid_self(),
+				MSG_SMB_BRL_VALIDATE, NULL, 0);
+	/* mark the cleanup as having been done */
+	(*cleanup_te) = NULL;
 }
 
-static void remove_child_pid(struct smbd_parent_context *parent,
-			     pid_t pid,
-			     bool unclean_shutdown)
+static void remove_child_pid(pid_t pid, bool unclean_shutdown)
 {
-	struct smbd_child_pid *child;
+	struct child_pid *child;
+	static struct timed_event *cleanup_te;
 	struct server_id child_id;
 
-	child_id = pid_to_procid(pid);
+	child_id = procid_self(); /* Just initialize pid and potentially vnn */
+	child_id.pid = pid;
 
-	for (child = parent->children; child != NULL; child = child->next) {
+	for (child = children; child != NULL; child = child->next) {
 		if (child->pid == pid) {
-			struct smbd_child_pid *tmp = child;
-			DLIST_REMOVE(parent->children, child);
-			TALLOC_FREE(tmp);
-			parent->num_children -= 1;
+			struct child_pid *tmp = child;
+			DLIST_REMOVE(children, child);
+			SAFE_FREE(tmp);
+			num_children -= 1;
 			break;
 		}
 	}
@@ -427,23 +357,15 @@
                 */
 		DEBUG(3,(__location__ " Unclean shutdown of pid %u\n",
 			(unsigned int)pid));
-		if (parent->cleanup_te == NULL) {
+		if (!cleanup_te) {
 			/* call the cleanup timer, but not too often */
 			int cleanup_time = lp_parm_int(-1, "smbd", "cleanuptime", 20);
-			parent->cleanup_te = tevent_add_timer(parent->ev_ctx,
-						parent,
+			cleanup_te = event_add_timed(smbd_event_context(), NULL,
 						timeval_current_ofs(cleanup_time, 0),
 						cleanup_timeout_fn,
-						parent);
+						&cleanup_te);
 			DEBUG(1,("Scheduled cleanup of brl and lock database after unclean shutdown\n"));
 		}
-
-		/*
-		 * Ensure we flush any stored messages
-		 * queued for the child process that
-		 * terminated uncleanly.
-		 */
-		messaging_cleanup_server(parent->msg_ctx, child_id);
 	}
 
 	if (!serverid_deregister(child_id)) {
@@ -456,14 +378,14 @@
  Have we reached the process limit ?
 ****************************************************************************/
 
-static bool allowable_number_of_smbd_processes(struct smbd_parent_context *parent)
+static bool allowable_number_of_smbd_processes(void)
 {
 	int max_processes = lp_max_smbd_processes();
 
 	if (!max_processes)
 		return True;
 
-	return parent->num_children < max_processes;
+	return num_children < max_processes;
 }
 
 static void smbd_sig_chld_handler(struct tevent_context *ev,
@@ -475,9 +397,6 @@
 {
 	pid_t pid;
 	int status;
-	struct smbd_parent_context *parent =
-		talloc_get_type_abort(private_data,
-		struct smbd_parent_context);
 
 	while ((pid = sys_waitpid(-1, &status, WNOHANG)) > 0) {
 		bool unclean_shutdown = False;
@@ -495,24 +414,40 @@
 		if (WIFSIGNALED(status)) {
 			unclean_shutdown = True;
 		}
-		remove_child_pid(parent, pid, unclean_shutdown);
+		remove_child_pid(pid, unclean_shutdown);
 	}
 }
 
-static void smbd_setup_sig_chld_handler(struct smbd_parent_context *parent)
+static void smbd_setup_sig_chld_handler(void)
 {
 	struct tevent_signal *se;
 
-	se = tevent_add_signal(parent->ev_ctx,
-			       parent, /* mem_ctx */
+	se = tevent_add_signal(smbd_event_context(),
+			       smbd_event_context(),
 			       SIGCHLD, 0,
 			       smbd_sig_chld_handler,
-			       parent);
+			       NULL);
 	if (!se) {
 		exit_server("failed to setup SIGCHLD handler");
 	}
 }
 
+struct smbd_open_socket;
+
+struct smbd_parent_context {
+	bool interactive;
+
+	/* the list of listening sockets */
+	struct smbd_open_socket *sockets;
+};
+
+struct smbd_open_socket {
+	struct smbd_open_socket *prev, *next;
+	struct smbd_parent_context *parent;
+	int fd;
+	struct tevent_fd *fde;
+};
+
 static void smbd_open_socket_close_fn(struct tevent_context *ev,
 				      struct tevent_fd *fde,
 				      int fd,
@@ -529,7 +464,6 @@
 {
 	struct smbd_open_socket *s = talloc_get_type_abort(private_data,
 				     struct smbd_open_socket);
-	struct messaging_context *msg_ctx = s->parent->msg_ctx;
 	struct sockaddr_storage addr;
 	socklen_t in_addrlen = sizeof(addr);
 	int fd;
@@ -537,6 +471,8 @@
 	uint64_t unique_id;
 
 	fd = accept(s->fd, (struct sockaddr *)(void *)&addr,&in_addrlen);
+	smbd_set_server_fd(fd);
+
 	if (fd == -1 && errno == EINTR)
 		return;
 
@@ -547,14 +483,14 @@
 	}
 
 	if (s->parent->interactive) {
-		reinit_after_fork(msg_ctx, ev, true);
-		smbd_process(ev, msg_ctx, fd, true);
+		smbd_process(smbd_server_conn);
 		exit_server_cleanly("end of interactive mode");
 		return;
 	}
 
-	if (!allowable_number_of_smbd_processes(s->parent)) {
+	if (!allowable_number_of_smbd_processes()) {
 		close(fd);
+		smbd_set_server_fd(-1);
 		return;
 	}
 
@@ -564,12 +500,22 @@
 	 */
 	unique_id = serverid_get_random_unique_id();
 
-	pid = fork();
+	pid = sys_fork();
 	if (pid == 0) {
 		NTSTATUS status = NT_STATUS_OK;
 
 		/* Child code ... */
-		am_parent = NULL;
+		am_parent = 0;
+
+		set_my_unique_id(unique_id);
+
+		/* Stop zombies, the parent explicitly handles
+		 * them, counting worker smbds. */
+		CatchChild();
+
+		/* close our standard file
+		   descriptors */
+		close_low_fds(False);
 
 		/*
 		 * Can't use TALLOC_FREE here. Nulling out the argument to it
@@ -578,14 +524,8 @@
 		talloc_free(s->parent);
 		s = NULL;
 
-		set_my_unique_id(unique_id);
-
-		/* Stop zombies, the parent explicitly handles
-		 * them, counting worker smbds. */
-		CatchChild();
-
-		status = reinit_after_fork(msg_ctx,
-					   ev,
+		status = reinit_after_fork(smbd_messaging_context(),
+					   smbd_event_context(), procid_self(),
 					   true);
 		if (!NT_STATUS_IS_OK(status)) {
 			if (NT_STATUS_EQUAL(status,
@@ -607,14 +547,26 @@
 			smb_panic("reinit_after_fork() failed");
 		}
 
-		smbd_process(ev, msg_ctx, fd, false);
+		smbd_setup_sig_term_handler();
+		smbd_setup_sig_hup_handler(server_event_context(),
+					   server_messaging_context());
+
+		if (!serverid_register(procid_self(),
+				       FLAG_MSG_GENERAL|FLAG_MSG_SMBD
+				       |FLAG_MSG_DBWRAP
+				       |FLAG_MSG_PRINT_GENERAL)) {
+			exit_server_cleanly("Could not register myself in "
+					    "serverid.tdb");
+		}
+
+		smbd_process(smbd_server_conn);
 	 exit:
 		exit_server_cleanly("end of child");
 		return;
 	}
 
 	if (pid < 0) {
-		DEBUG(0,("smbd_accept_connection: fork() failed: %s\n",
+		DEBUG(0,("smbd_accept_connection: sys_fork() failed: %s\n",
 			 strerror(errno)));
 	}
 
@@ -629,8 +581,10 @@
 		and use %I in the filename.
 	*/
 
+	smbd_set_server_fd(-1);
+
 	if (pid != 0) {
-		add_child_pid(s->parent, pid);
+		add_child_pid(pid);
 	}
 
 	/* Force parent to check log size after
@@ -651,8 +605,6 @@
 }
 
 static bool smbd_open_one_socket(struct smbd_parent_context *parent,
-				 struct tevent_context *ev_ctx,
-				 struct messaging_context *msg_ctx,
 				 const struct sockaddr_storage *ifss,
 				 uint16_t port)
 {
@@ -695,7 +647,7 @@
 		return false;
 	}
 
-	s->fde = tevent_add_fd(ev_ctx,
+	s->fde = tevent_add_fd(smbd_event_context(),
 			       s,
 			       s->fd, TEVENT_FD_READ,
 			       smbd_accept_connection,
@@ -720,13 +672,14 @@
 ****************************************************************************/
 
 static bool open_sockets_smbd(struct smbd_parent_context *parent,
-			      struct tevent_context *ev_ctx,
 			      struct messaging_context *msg_ctx,
 			      const char *smb_ports)
 {
 	int num_interfaces = iface_count();
-	int i,j;
-	const char **ports;
+	int i;
+	char *ports;
+	char *tok;
+	const char *ptr;
 	unsigned dns_port = 0;
 
 #ifdef HAVE_ATEXIT
@@ -734,17 +687,23 @@
 #endif
 
 	/* Stop zombies */
-	smbd_setup_sig_chld_handler(parent);
-
-	ports = lp_smb_ports();
+	smbd_setup_sig_chld_handler();
 
 	/* use a reasonable default set of ports - listing on 445 and 139 */
-	if (smb_ports) {
-		ports = (const char **)str_list_make_v3(talloc_tos(), smb_ports, NULL);
+	if (!smb_ports) {
+		ports = lp_smb_ports();
+		if (!ports || !*ports) {
+			ports = talloc_strdup(talloc_tos(), SMB_PORTS);
+		} else {
+			ports = talloc_strdup(talloc_tos(), ports);
+		}
+	} else {
+		ports = talloc_strdup(talloc_tos(), smb_ports);
 	}
 
-	for (j = 0; ports && ports[j]; j++) {
-		unsigned port = atoi(ports[j]);
+	for (ptr = ports;
+	     next_token_talloc(talloc_tos(),&ptr, &tok, " \t,");) {
+		unsigned port = atoi(tok);
 
 		if (port == 0 || port > 0xffff) {
 			exit_server_cleanly("Invalid port in the config or on "
@@ -763,6 +722,7 @@
 		for(i = 0; i < num_interfaces; i++) {
 			const struct sockaddr_storage *ifss =
 					iface_n_sockaddr_storage(i);
+
 			if (ifss == NULL) {
 				DEBUG(0,("open_sockets_smbd: "
 					"interface %d has NULL IP address !\n",
@@ -770,8 +730,9 @@
 				continue;
 			}
 
-			for (j = 0; ports && ports[j]; j++) {
-				unsigned port = atoi(ports[j]);
+			for (ptr=ports;
+			     next_token_talloc(talloc_tos(),&ptr, &tok, " \t,");) {
+				unsigned port = atoi(tok);
 
 				/* Keep the first port for mDNS service
 				 * registration.
@@ -780,11 +741,7 @@
 					dns_port = port;
 				}
 
-				if (!smbd_open_one_socket(parent,
-							  ev_ctx,
-							  msg_ctx,
-							  ifss,
-							  port)) {
+				if (!smbd_open_one_socket(parent, ifss, port)) {
 					return false;
 				}
 			}
@@ -793,21 +750,24 @@
 		/* Just bind to 0.0.0.0 - accept connections
 		   from anywhere. */
 
-		const char *sock_addr;
+		const char *sock_addr = lp_socket_address();
 		char *sock_tok;
 		const char *sock_ptr;
 
+		if (strequal(sock_addr, "0.0.0.0") ||
+		    strequal(sock_addr, "::")) {
 #if HAVE_IPV6
-		sock_addr = "::,0.0.0.0";
+			sock_addr = "::,0.0.0.0";
 #else
-		sock_addr = "0.0.0.0";
+			sock_addr = "0.0.0.0";
 #endif
+		}
 
 		for (sock_ptr=sock_addr;
 		     next_token_talloc(talloc_tos(), &sock_ptr, &sock_tok, " \t,"); ) {
-			for (j = 0; ports && ports[j]; j++) {
+			for (ptr=ports; next_token_talloc(talloc_tos(), &ptr, &tok, " \t,"); ) {
 				struct sockaddr_storage ss;
-				unsigned port = atoi(ports[j]);
+				unsigned port = atoi(tok);
 
 				/* Keep the first port for mDNS service
 				 * registration.
@@ -822,11 +782,9 @@
 					continue;
 				}
 
-				(void)smbd_open_one_socket(parent,
-							  ev_ctx,
-							  msg_ctx,
-							  &ss,
-							  port);
+				if (!smbd_open_one_socket(parent, &ss, port)) {
+					return false;
+				}
 			}
 		}
 	}
@@ -843,9 +801,8 @@
 	   operations until it has gone thru a full startup, which
 	   includes checking to see that smbd is listening. */
 
-	if (!serverid_register(messaging_server_id(msg_ctx),
+	if (!serverid_register(procid_self(),
 			       FLAG_MSG_GENERAL|FLAG_MSG_SMBD
-			       |FLAG_MSG_PRINT_GENERAL
 			       |FLAG_MSG_DBWRAP)) {
 		DEBUG(0, ("open_sockets_smbd: Failed to register "
 			  "myself in serverid.tdb\n"));
@@ -854,21 +811,18 @@
 
         /* Listen to messages */
 
+	messaging_register(msg_ctx, NULL, MSG_SMB_SAM_SYNC, msg_sam_sync);
 	messaging_register(msg_ctx, NULL, MSG_SHUTDOWN, msg_exit_server);
-	messaging_register(msg_ctx, ev_ctx, MSG_SMB_CONF_UPDATED,
-			   smbd_parent_conf_updated);
+	messaging_register(msg_ctx, NULL, MSG_SMB_FILE_RENAME,
+			   msg_file_was_renamed);
+	messaging_register(msg_ctx, server_event_context(), MSG_SMB_CONF_UPDATED,
+			   smb_conf_updated);
 	messaging_register(msg_ctx, NULL, MSG_SMB_STAT_CACHE_DELETE,
 			   smb_stat_cache_delete);
 	messaging_register(msg_ctx, NULL, MSG_DEBUG, smbd_msg_debug);
-	messaging_register(msg_ctx, NULL, MSG_SMB_BRL_VALIDATE,
-			   brl_revalidate);
-	messaging_register(msg_ctx, NULL, MSG_SMB_FORCE_TDIS,
-			   smb_parent_force_tdis);
-
-	messaging_register(msg_ctx, NULL,
-			   ID_CACHE_DELETE, smbd_parent_id_cache_delete);
-	messaging_register(msg_ctx, NULL,
-			   ID_CACHE_KILL, smbd_parent_id_cache_kill);
+	brl_register_msgs(msg_ctx);
+
+	msg_idmap_register_msgs(msg_ctx);
 
 #ifdef CLUSTER_SUPPORT
 	if (lp_clustering()) {
@@ -883,15 +837,14 @@
 
 	if (lp_multicast_dns_register() && (dns_port != 0)) {
 #ifdef WITH_DNSSD_SUPPORT
-		smbd_setup_mdns_registration(ev_ctx,
+		smbd_setup_mdns_registration(smbd_event_context(),
 					     parent, dns_port);
 #endif
 #ifdef WITH_AVAHI_SUPPORT
 		void *avahi_conn;
 
-		avahi_conn = avahi_start_register(ev_ctx,
-						  ev_ctx,
-						  dns_port);
+		avahi_conn = avahi_start_register(
+			smbd_event_context(), smbd_event_context(), dns_port);
 		if (avahi_conn == NULL) {
 			DEBUG(10, ("avahi_start_register failed\n"));
 		}
@@ -901,25 +854,7 @@
 	return true;
 }
 
-
-/*
-  handle stdin becoming readable when we are in --foreground mode
- */
-static void smbd_stdin_handler(struct tevent_context *ev,
-			       struct tevent_fd *fde,
-			       uint16_t flags,
-			       void *private_data)
-{
-	char c;
-	if (read(0, &c, 1) != 1) {
-		/* we have reached EOF on stdin, which means the
-		   parent has exited. Shutdown the server */
-		exit_server_cleanly("EOF on stdin");
-	}
-}
-
-static void smbd_parent_loop(struct tevent_context *ev_ctx,
-			     struct smbd_parent_context *parent)
+static void smbd_parent_loop(struct smbd_parent_context *parent)
 {
 	/* now accept incoming connections - forking a new process
 	   for each incoming connection */
@@ -928,7 +863,7 @@
 		int ret;
 		TALLOC_CTX *frame = talloc_stackframe();
 
-		ret = tevent_loop_once(ev_ctx);
+		ret = tevent_loop_once(smbd_event_context());
 		if (ret != 0) {
 			exit_server_cleanly("tevent_loop_once() error");
 		}
@@ -960,34 +895,6 @@
 	return True;
 }
 
-static void smbd_parent_sig_term_handler(struct tevent_context *ev,
-					 struct tevent_signal *se,
-					 int signum,
-					 int count,
-					 void *siginfo,
-					 void *private_data)
-{
-	exit_server_cleanly("termination signal");
-}
-
-static void smbd_parent_sig_hup_handler(struct tevent_context *ev,
-					struct tevent_signal *se,
-					int signum,
-					int count,
-					void *siginfo,
-					void *private_data)
-{
-	struct smbd_parent_context *parent =
-		talloc_get_type_abort(private_data,
-		struct smbd_parent_context);
-
-	change_to_root_user();
-	DEBUG(1,("parent: Reloading services after SIGHUP\n"));
-	reload_services(NULL, NULL, false);
-
-	printing_subsystem_update(parent->ev_ctx, parent->msg_ctx, true);
-}
-
 /****************************************************************************
  main program.
 ****************************************************************************/
@@ -1035,26 +942,6 @@
 	struct smbd_parent_context *parent = NULL;
 	TALLOC_CTX *frame;
 	NTSTATUS status;
-	struct tevent_context *ev_ctx;
-	struct messaging_context *msg_ctx;
-	struct server_id server_id;
-	struct tevent_signal *se;
-	char *np_dir = NULL;
-	static const struct smbd_shim smbd_shim_fns =
-	{
-		.cancel_pending_lock_requests_by_fid = smbd_cancel_pending_lock_requests_by_fid,
-		.send_stat_cache_delete_message = smbd_send_stat_cache_delete_message,
-		.change_to_root_user = smbd_change_to_root_user,
-
-		.contend_level2_oplocks_begin = smbd_contend_level2_oplocks_begin,
-		.contend_level2_oplocks_end = smbd_contend_level2_oplocks_end,
-
-		.become_root = smbd_become_root,
-		.unbecome_root = smbd_unbecome_root,
-
-		.exit_server = smbd_exit_server,
-		.exit_server_cleanly = smbd_exit_server_cleanly,
-	};
 
 	/*
 	 * Do this before any other talloc operation
@@ -1062,11 +949,10 @@
 	talloc_enable_null_tracking();
 	frame = talloc_stackframe();
 
-	setup_logging(argv[0], DEBUG_DEFAULT_STDOUT);
-
 	load_case_tables();
 
-	set_smbd_shim(&smbd_shim_fns);
+	/* Initialize the event context, it will panic on error */
+	smbd_event_context();
 
 	smbd_init_globals();
 
@@ -1150,8 +1036,8 @@
 	gain_root_privilege();
 	gain_root_group_privilege();
 
-	fault_setup();
-	dump_core_setup("smbd", lp_logfile(talloc_tos()));
+	fault_setup((void (*)(void *))exit_server_fault);
+	dump_core_setup("smbd");
 
 	/* we are never interested in SIGPIPE */
 	BlockSignals(True,SIGPIPE);
@@ -1198,45 +1084,21 @@
 	}
 
 	if (!lp_load_initial_only(get_dyn_CONFIGFILE())) {
-		DEBUG(0, ("error opening config file '%s'\n", get_dyn_CONFIGFILE()));
+		DEBUG(0, ("error opening config file\n"));
 		exit(1);
 	}
 
 	/* Init the security context and global current_user */
 	init_sec_ctx();
 
-	/*
-	 * Initialize the event context. The event context needs to be
-	 * initialized before the messaging context, cause the messaging
-	 * context holds an event context.
-	 * FIXME: This should be s3_tevent_context_init()
-	 */
-	ev_ctx = server_event_context();
-	if (ev_ctx == NULL) {
-		exit(1);
-	}
-
-	/*
-	 * Init the messaging context
-	 * FIXME: This should only call messaging_init()
-	 */
-	msg_ctx = server_messaging_context();
-	if (msg_ctx == NULL) {
+	if (smbd_messaging_context() == NULL)
 		exit(1);
-	}
 
 	/*
 	 * Reloading of the printers will not work here as we don't have a
 	 * server info and rpc services set up. It will be called later.
 	 */
-	if (!reload_services(NULL, NULL, false)) {
-		exit(1);
-	}
-
-	if (lp_server_role() == ROLE_ACTIVE_DIRECTORY_DC
-	    && !lp_parm_bool(-1, "server role check", "inhibit", false)) {
-		DEBUG(0, ("server role = 'active directory domain controller' not compatible with running smbd standalone. \n"));
-		DEBUGADD(0, ("You should start 'samba' instead, and it will control starting smbd if required\n"));
+	if (!reload_services(smbd_messaging_context(), -1, False)) {
 		exit(1);
 	}
 
@@ -1247,7 +1109,7 @@
 	init_structs();
 
 #ifdef WITH_PROFILE
-	if (!profile_setup(msg_ctx, False)) {
+	if (!profile_setup(smbd_messaging_context(), False)) {
 		DEBUG(0,("ERROR: failed to setup profiling\n"));
 		return -1;
 	}
@@ -1278,7 +1140,7 @@
 		become_daemon(Fork, no_process_group, log_stdout);
 	}
 
-        set_my_unique_id(serverid_get_random_unique_id());
+	set_my_unique_id(serverid_get_random_unique_id());
 
 #if HAVE_SETPGID
 	/*
@@ -1292,58 +1154,22 @@
 	if (!directory_exist(lp_lockdir()))
 		mkdir(lp_lockdir(), 0755);
 
-	if (!directory_exist(lp_piddir()))
-		mkdir(lp_piddir(), 0755);
-
 	if (is_daemon)
-		pidfile_create(lp_piddir(), "smbd");
+		pidfile_create("smbd");
 
-	status = reinit_after_fork(msg_ctx,
-				   ev_ctx,
-				   false);
+	status = reinit_after_fork(smbd_messaging_context(),
+				   smbd_event_context(),
+				   procid_self(), false);
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(0,("reinit_after_fork() failed\n"));
 		exit(1);
 	}
 
-	if (!interactive) {
-		/*
-		 * Do not initialize the parent-child-pipe before becoming a
-		 * daemon: this is used to detect a died parent in the child
-		 * process.
-		 */
-		status = init_before_fork();
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0, ("init_before_fork failed: %s\n", nt_errstr(status)));
-			exit(1);
-		}
-	}
+	smbd_server_conn->msg_ctx = smbd_messaging_context();
 
-	parent = talloc_zero(ev_ctx, struct smbd_parent_context);
-	if (!parent) {
-		exit_server("talloc(struct smbd_parent_context) failed");
-	}
-	parent->interactive = interactive;
-	parent->ev_ctx = ev_ctx;
-	parent->msg_ctx = msg_ctx;
-	am_parent = parent;
-
-	se = tevent_add_signal(parent->ev_ctx,
-			       parent,
-			       SIGTERM, 0,
-			       smbd_parent_sig_term_handler,
-			       parent);
-	if (!se) {
-		exit_server("failed to setup SIGTERM handler");
-	}
-	se = tevent_add_signal(parent->ev_ctx,
-			       parent,
-			       SIGHUP, 0,
-			       smbd_parent_sig_hup_handler,
-			       parent);
-	if (!se) {
-		exit_server("failed to setup SIGHUP handler");
-	}
+	smbd_setup_sig_term_handler();
+	smbd_setup_sig_hup_handler(smbd_event_context(),
+				   smbd_server_conn->msg_ctx);
 
 	/* Setup all the TDB's - including CLEAR_IF_FIRST tdb's. */
 
@@ -1356,7 +1182,7 @@
 	/* Initialise the password backed before the global_sam_sid
 	   to ensure that we fetch from ldap before we make a domain sid up */
 
-	if(!initialize_password_db(false, ev_ctx))
+	if(!initialize_password_db(False, smbd_event_context()))
 		exit(1);
 
 	if (!secrets_init()) {
@@ -1365,12 +1191,10 @@
 	}
 
 	if (lp_server_role() == ROLE_DOMAIN_BDC || lp_server_role() == ROLE_DOMAIN_PDC) {
-		struct loadparm_context *lp_ctx = loadparm_init_s3(NULL, loadparm_s3_helpers());
-		if (!open_schannel_session_store(NULL, lp_ctx)) {
+		if (!open_schannel_session_store(NULL, lp_private_dir())) {
 			DEBUG(0,("ERROR: Samba cannot open schannel store for secured NETLOGON operations.\n"));
 			exit(1);
 		}
-		TALLOC_FREE(lp_ctx);
 	}
 
 	if(!get_global_sam_sid()) {
@@ -1378,38 +1202,29 @@
 		exit(1);
 	}
 
-	server_id = messaging_server_id(msg_ctx);
-	status = smbXsrv_version_global_init(&server_id);
-	if (!NT_STATUS_IS_OK(status)) {
+	if (!sessionid_init()) {
 		exit(1);
 	}
 
-	status = smbXsrv_session_global_init();
-	if (!NT_STATUS_IS_OK(status)) {
-		exit(1);
-	}
-
-	status = smbXsrv_tcon_global_init();
-	if (!NT_STATUS_IS_OK(status)) {
+	if (!connections_init(True))
 		exit(1);
-	}
 
 	if (!locking_init())
 		exit(1);
 
-	if (!messaging_tdb_parent_init(ev_ctx)) {
+	if (!messaging_tdb_parent_init(smbd_event_context())) {
 		exit(1);
 	}
 
-	if (!smbd_parent_notify_init(NULL, msg_ctx, ev_ctx)) {
+	if (!notify_internal_parent_init(smbd_event_context())) {
 		exit(1);
 	}
 
-	if (!smbd_scavenger_init(NULL, msg_ctx, ev_ctx)) {
+	if (!serverid_parent_init(smbd_event_context())) {
 		exit(1);
 	}
 
-	if (!serverid_parent_init(ev_ctx)) {
+	if (!printer_list_parent_init()) {
 		exit(1);
 	}
 
@@ -1425,7 +1240,7 @@
 		exit(1);
 	}
 
-	status = init_system_session_info();
+	status = init_system_info();
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(1, ("ERROR: failed to setup system user info: %s.\n",
 			  nt_errstr(status)));
@@ -1437,132 +1252,109 @@
 		return -1;
 	}
 
-	if (!file_init_global()) {
-		DEBUG(0, ("ERROR: file_init_global() failed\n"));
-		return -1;
-	}
-	status = smbXsrv_open_global_init();
-	if (!NT_STATUS_IS_OK(status)) {
-		exit(1);
-	}
-
-	/* This MUST be done before start_epmd() because otherwise
-	 * start_epmd() forks and races against dcesrv_ep_setup() to
-	 * call directory_create_or_exist() */
-	if (!directory_create_or_exist(lp_ncalrpc_dir(), geteuid(), 0755)) {
-		DEBUG(0, ("Failed to create pipe directory %s - %s\n",
-			  lp_ncalrpc_dir(), strerror(errno)));
-		return -1;
-	}
-
-	np_dir = talloc_asprintf(talloc_tos(), "%s/np", lp_ncalrpc_dir());
-	if (!np_dir) {
-		DEBUG(0, ("%s: Out of memory\n", __location__));
-		return -1;
-	}
-
-	if (!directory_create_or_exist(np_dir, geteuid(), 0700)) {
-		DEBUG(0, ("Failed to create pipe directory %s - %s\n",
-			  np_dir, strerror(errno)));
+	if (!file_init(smbd_server_conn)) {
+		DEBUG(0, ("ERROR: file_init failed\n"));
 		return -1;
 	}
 
 	if (is_daemon && !interactive) {
-		if (rpc_epmapper_daemon() == RPC_DAEMON_FORK) {
-			start_epmd(ev_ctx, msg_ctx);
+		const char *rpcsrv_type;
+
+		rpcsrv_type = lp_parm_const_string(GLOBAL_SECTION_SNUM,
+						   "rpc_server", "epmapper",
+						   "none");
+		if (StrCaseCmp(rpcsrv_type, "daemon") == 0) {
+			start_epmd(smbd_event_context(),
+				   smbd_server_conn->msg_ctx);
 		}
 	}
 
-	if (!dcesrv_ep_setup(ev_ctx, msg_ctx)) {
+	if (!dcesrv_ep_setup(smbd_event_context(), smbd_server_conn->msg_ctx)) {
 		exit(1);
 	}
 
-	/* only start other daemons if we are running as a daemon
-	 * -- bad things will happen if smbd is launched via inetd
-	 *  and we fork a copy of ourselves here */
-	if (is_daemon && !interactive) {
-
-		if (rpc_lsasd_daemon() == RPC_DAEMON_FORK) {
-			start_lsasd(ev_ctx, msg_ctx);
-		}
-
-		if (!lp__disable_spoolss() &&
-		    (rpc_spoolss_daemon() != RPC_DAEMON_DISABLED)) {
-			bool bgq = lp_parm_bool(-1, "smbd", "backgroundqueue", true);
+	/*
+	 * The print backend init also migrates the printing tdb's,
+	 * this requires a winreg pipe.
+	 */
+	if (!print_backend_init(smbd_messaging_context()))
+		exit(1);
 
-			if (!printing_subsystem_init(ev_ctx, msg_ctx, true, bgq)) {
-				exit(1);
-			}
-		}
-	} else if (!lp__disable_spoolss() &&
-		   (rpc_spoolss_daemon() != RPC_DAEMON_DISABLED)) {
-		if (!printing_subsystem_init(ev_ctx, msg_ctx, false, false)) {
-			exit(1);
+	/* only start the background queue daemon if we are 
+	   running as a daemon -- bad things will happen if
+	   smbd is launched via inetd and we fork a copy of 
+	   ourselves here */
+
+	if (is_daemon && !interactive
+	    && lp_parm_bool(-1, "smbd", "backgroundqueue", true)) {
+		/* background queue is responsible for printcap cache updates */
+		messaging_register(smbd_server_conn->msg_ctx,
+				   smbd_event_context(),
+				   MSG_PRINTER_PCAP, smb_pcap_updated);
+		start_background_queue(server_event_context(),
+				       smbd_server_conn->msg_ctx);
+	} else {
+		DEBUG(3, ("running without background printer process, dynamic "
+			  "printer updates disabled\n"));
+		/* Publish nt printers, this requires a working winreg pipe */
+		pcap_cache_reload(server_event_context(),
+				  smbd_messaging_context(),
+				  &reload_printers_full);
+	}
+
+	if (is_daemon && !_lp_disable_spoolss()) {
+		const char *rpcsrv_type;
+
+		/* start spoolss daemon */
+		/* start as a separate daemon only if enabled */
+		rpcsrv_type = lp_parm_const_string(GLOBAL_SECTION_SNUM,
+						   "rpc_server", "spoolss",
+						   "embedded");
+		if (StrCaseCmp(rpcsrv_type, "daemon") == 0) {
+			start_spoolssd(smbd_event_context(),
+				       smbd_messaging_context());
 		}
 	}
 
 	if (!is_daemon) {
-		int sock;
-
 		/* inetd mode */
 		TALLOC_FREE(frame);
 
 		/* Started from inetd. fd 0 is the socket. */
 		/* We will abort gracefully when the client or remote system
 		   goes away */
-		sock = dup(0);
+		smbd_set_server_fd(dup(0));
 
-		/* close stdin, stdout (if not logging to it), but not stderr */
-		close_low_fds(true, !debug_get_output_is_stdout(), false);
+		/* close our standard file descriptors */
+		close_low_fds(False); /* Don't close stderr */
 
 #ifdef HAVE_ATEXIT
 		atexit(killkids);
 #endif
 
 	        /* Stop zombies */
-		smbd_setup_sig_chld_handler(parent);
+		smbd_setup_sig_chld_handler();
 
-		smbd_process(ev_ctx, msg_ctx, sock, true);
+		smbd_process(smbd_server_conn);
 
 		exit_server_cleanly(NULL);
 		return(0);
 	}
 
-	if (!open_sockets_smbd(parent, ev_ctx, msg_ctx, ports))
-		exit_server("open_sockets_smbd() failed");
-
-	/* do a printer update now that all messaging has been set up,
-	 * before we allow clients to start connecting */
-	if (!lp__disable_spoolss() &&
-	    (rpc_spoolss_daemon() != RPC_DAEMON_DISABLED)) {
-		printing_subsystem_update(ev_ctx, msg_ctx, false);
+	parent = talloc_zero(smbd_event_context(), struct smbd_parent_context);
+	if (!parent) {
+		exit_server("talloc(struct smbd_parent_context) failed");
 	}
+	parent->interactive = interactive;
+
+	if (!open_sockets_smbd(parent, smbd_messaging_context(), ports))
+		exit_server("open_sockets_smbd() failed");
 
 	TALLOC_FREE(frame);
 	/* make sure we always have a valid stackframe */
 	frame = talloc_stackframe();
 
-	if (!Fork) {
-		/* if we are running in the foreground then look for
-		   EOF on stdin, and exit if it happens. This allows
-		   us to die if the parent process dies
-		   Only do this on a pipe or socket, no other device.
-		*/
-		struct stat st;
-		if (fstat(0, &st) != 0) {
-			return false;
-		}
-		if (S_ISFIFO(st.st_mode) || S_ISSOCK(st.st_mode)) {
-			tevent_add_fd(ev_ctx,
-					parent,
-					0,
-					TEVENT_FD_READ,
-					smbd_stdin_handler,
-					NULL);
-		}
-	}
-
-	smbd_parent_loop(ev_ctx, parent);
+	smbd_parent_loop(parent);
 
 	exit_server_cleanly(NULL);
 	TALLOC_FREE(frame);
diff -ur smbd/server_exit.c ../../samba-3.6.24/source3/smbd/server_exit.c
--- smbd/server_exit.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/server_exit.c	2015-01-28 10:52:25.149068676 +0800
@@ -43,8 +43,6 @@
 #include "printing/notify.h"
 #include "printing.h"
 #include "serverid.h"
-#include "messages.h"
-#include "../lib/util/pidfile.h"
 
 static struct files_struct *log_writeable_file_fn(
 	struct files_struct *fsp, void *private_data)
@@ -80,18 +78,12 @@
 enum server_exit_reason { SERVER_EXIT_NORMAL, SERVER_EXIT_ABNORMAL };
 
 static void exit_server_common(enum server_exit_reason how,
-	const char *reason) _NORETURN_;
+	const char *const reason) _NORETURN_;
 
 static void exit_server_common(enum server_exit_reason how,
-	const char *reason)
+	const char *const reason)
 {
-	struct smbXsrv_connection *conn = global_smbXsrv_connection;
-	struct smbd_server_connection *sconn = NULL;
-	struct messaging_context *msg_ctx = server_messaging_context();
-
-	if (conn != NULL) {
-		sconn = conn->sconn;
-	}
+	struct smbd_server_connection *sconn = smbd_server_conn;
 
 	if (!exit_firsttime)
 		exit(0);
@@ -99,65 +91,28 @@
 
 	change_to_root_user();
 
-	if (sconn) {
-		NTSTATUS status;
-
-		if (NT_STATUS_IS_OK(sconn->status)) {
-			switch (how) {
-			case SERVER_EXIT_ABNORMAL:
-				sconn->status = NT_STATUS_INTERNAL_ERROR;
-				break;
-			case SERVER_EXIT_NORMAL:
-				sconn->status = NT_STATUS_LOCAL_DISCONNECT;
-				break;
-			}
-		}
-
+	if (sconn && sconn->smb1.negprot.auth_context) {
 		TALLOC_FREE(sconn->smb1.negprot.auth_context);
+	}
 
+	if (sconn) {
 		if (lp_log_writeable_files_on_exit()) {
 			bool found = false;
 			files_forall(sconn, log_writeable_file_fn, &found);
 		}
-
-		/*
-		 * Note: this is a no-op for smb2 as
-		 * conn->tcon_table is empty
-		 */
-		status = smb1srv_tcon_disconnect_all(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0,("Server exit (%s)\n",
-				(reason ? reason : "normal exit")));
-			DEBUG(0, ("exit_server_common: "
-				  "smb1srv_tcon_disconnect_all() failed (%s) - "
-				  "triggering cleanup\n", nt_errstr(status)));
-			how = SERVER_EXIT_ABNORMAL;
-			reason = "smb1srv_tcon_disconnect_all failed";
-		}
-
-		status = smbXsrv_session_logoff_all(conn);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0,("Server exit (%s)\n",
-				(reason ? reason : "normal exit")));
-			DEBUG(0, ("exit_server_common: "
-				  "smbXsrv_session_logoff_all() failed (%s) - "
-				  "triggering cleanup\n", nt_errstr(status)));
-			how = SERVER_EXIT_ABNORMAL;
-			reason = "smbXsrv_session_logoff_all failed";
-		}
-
-		change_to_root_user();
+		(void)conn_close_all(sconn);
+		invalidate_all_vuids(sconn);
 	}
 
 	/* 3 second timeout. */
-	print_notify_send_messages(msg_ctx, 3);
+	print_notify_send_messages(sconn->msg_ctx, 3);
 
 	/* delete our entry in the serverid database. */
 	if (am_parent) {
 		/*
 		 * For children the parent takes care of cleaning up
 		 */
-		serverid_deregister(messaging_server_id(msg_ctx));
+		serverid_deregister(sconn_server_id(sconn));
 	}
 
 #ifdef WITH_DFS
@@ -201,8 +156,7 @@
 	 * because smbd_msg_ctx is not a talloc child of smbd_server_conn.
 	 */
 	sconn = NULL;
-	conn = NULL;
-	TALLOC_FREE(global_smbXsrv_connection);
+	TALLOC_FREE(smbd_server_conn);
 	server_messaging_context_free();
 	server_event_context_free();
 	TALLOC_FREE(smbd_memcache_ctx);
@@ -226,7 +180,7 @@
 		DEBUG(3,("Server exit (%s)\n",
 			(reason ? reason : "normal exit")));
 		if (am_parent) {
-			pidfile_unlink(lp_piddir(), "smbd");
+			pidfile_unlink();
 		}
 		gencache_stabilize();
 	}
@@ -234,12 +188,17 @@
 	exit(0);
 }
 
-void smbd_exit_server(const char *const explanation)
+void exit_server(const char *const explanation)
 {
 	exit_server_common(SERVER_EXIT_ABNORMAL, explanation);
 }
 
-void smbd_exit_server_cleanly(const char *const explanation)
+void exit_server_cleanly(const char *const explanation)
 {
 	exit_server_common(SERVER_EXIT_NORMAL, explanation);
 }
+
+void exit_server_fault(void)
+{
+	exit_server("critical server fault");
+}
Only in ../../samba-3.6.24/source3/smbd: server_exit.o
Only in ../../samba-3.6.24/source3/smbd: server.o
diff -ur smbd/server_reload.c ../../samba-3.6.24/source3/smbd/server_reload.c
--- smbd/server_reload.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/server_reload.c	2015-01-28 10:52:25.149068676 +0800
@@ -29,57 +29,17 @@
 #include "printing/load.h"
 #include "auth.h"
 #include "messages.h"
-#include "lib/param/loadparm.h"
 
-/*
- * The persistent pcap cache is populated by the background print process. Per
- * client smbds should only reload their printer share inventories if this
- * information has changed. Use reload_last_pcap_time to detect this.
- */
-static time_t reload_last_pcap_time = 0;
-
-bool snum_is_shared_printer(int snum)
-{
-	return (lp_browseable(snum) && lp_snum_ok(snum) && lp_print_ok(snum));
-}
-
-/**
- * @brief Purge stale printer shares and reload from pre-populated pcap cache.
- *
- * This function should normally only be called as a callback on a successful
- * pcap_cache_reload(), or on client enumeration.
- *
- * @param[in] ev        The event context.
- *
- * @param[in] msg_ctx   The messaging context.
- */
-void delete_and_reload_printers(struct tevent_context *ev,
-				struct messaging_context *msg_ctx)
+/****************************************************************************
+ purge stale printers and reload from pre-populated pcap cache
+**************************************************************************/
+void reload_printers(struct tevent_context *ev,
+		     struct messaging_context *msg_ctx)
 {
 	int n_services;
 	int pnum;
 	int snum;
 	const char *pname;
-	bool ok;
-	time_t pcap_last_update;
-	TALLOC_CTX *frame = talloc_stackframe();
-
-	ok = pcap_cache_loaded(&pcap_last_update);
-	if (!ok) {
-		DEBUG(1, ("pcap cache not loaded\n"));
-		talloc_free(frame);
-		return;
-	}
-
-	if (reload_last_pcap_time == pcap_last_update) {
-		DEBUG(5, ("skipping printer reload, already up to date.\n"));
-		talloc_free(frame);
-		return;
-	}
-	reload_last_pcap_time = pcap_last_update;
-
-	/* Get pcap printers updated */
-	load_printers(ev, msg_ctx);
 
 	n_services = lp_numservices();
 	pnum = lp_servicenumber(PRINTERS_NAME);
@@ -97,36 +57,108 @@
 		}
 
 		/* skip no-printer services */
-		if (!snum_is_shared_printer(snum)) {
+		if (!(lp_snum_ok(snum) && lp_print_ok(snum))) {
 			continue;
 		}
 
-		pname = lp_printername(frame, snum);
+		pname = lp_printername(snum);
 
 		/* check printer, but avoid removing non-autoloaded printers */
 		if (lp_autoloaded(snum) && !pcap_printername_ok(pname)) {
+			DEBUG(3, ("removing stale printer %s\n", pname));
 			lp_killservice(snum);
 		}
 	}
 
 	/* Make sure deleted printers are gone */
 	load_printers(ev, msg_ctx);
+}
+
+/****************************************************************************
+ purge stale printers and reload from pre-populated pcap cache
+**************************************************************************/
+void reload_printers_full(struct tevent_context *ev,
+			  struct messaging_context *msg_ctx)
+{
+	struct auth_serversupplied_info *session_info = NULL;
+	int n_services;
+	int pnum;
+	int snum;
+	const char *pname;
+	const char *sname;
+	NTSTATUS status;
+
+	n_services = lp_numservices();
+	pnum = lp_servicenumber(PRINTERS_NAME);
 
-	talloc_free(frame);
+	status = make_session_info_system(talloc_new(NULL), &session_info);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(3, ("Could not create system session_info\n"));
+		/* can't remove stale printers before we
+		 * are fully initilized */
+		return;
+	}
+
+	/*
+	 * Add default config for printers added to smb.conf file and remove
+	 * stale printers
+	 */
+	for (snum = 0; snum < n_services; snum++) {
+		/* avoid removing PRINTERS_NAME */
+		if (snum == pnum) {
+			continue;
+		}
+
+		/* skip no-printer services */
+		if (!(lp_snum_ok(snum) && lp_print_ok(snum))) {
+			continue;
+		}
+
+		sname = lp_const_servicename(snum);
+		pname = lp_printername(snum);
+
+		/* check printer, but avoid removing non-autoloaded printers */
+		if (lp_autoloaded(snum) && !pcap_printername_ok(pname)) {
+			struct spoolss_PrinterInfo2 *pinfo2 = NULL;
+			if (is_printer_published(session_info, session_info,
+						 msg_ctx,
+						 NULL,
+						 lp_servicename(snum),
+						 &pinfo2)) {
+				nt_printer_publish(session_info,
+						   session_info,
+						   msg_ctx,
+						   pinfo2,
+						   DSPRINT_UNPUBLISH);
+				TALLOC_FREE(pinfo2);
+			}
+			nt_printer_remove(session_info, session_info, msg_ctx,
+					  pname);
+		} else {
+			DEBUG(8, ("Adding default registry entry for printer "
+				  "[%s], if it doesn't exist.\n", sname));
+			nt_printer_add(session_info, session_info, msg_ctx,
+				       sname);
+		}
+	}
+
+	/* finally, purge old snums */
+	reload_printers(ev, msg_ctx);
+
+	TALLOC_FREE(session_info);
 }
 
 /****************************************************************************
  Reload the services file.
 **************************************************************************/
 
-bool reload_services(struct smbd_server_connection *sconn,
-		     bool (*snumused) (struct smbd_server_connection *, int),
+bool reload_services(struct messaging_context *msg_ctx, int smb_sock,
 		     bool test)
 {
 	bool ret;
 
 	if (lp_loaded()) {
-		char *fname = lp_configfile(talloc_tos());
+		char *fname = lp_configfile();
 		if (file_exist(fname) &&
 		    !strcsequal(fname, get_dyn_CONFIGFILE())) {
 			set_dyn_CONFIGFILE(fname);
@@ -140,26 +172,21 @@
 	if (test && !lp_file_list_changed())
 		return(True);
 
-	lp_killunused(sconn, snumused);
+	lp_killunused(conn_snum_used);
 
-	ret = lp_load(get_dyn_CONFIGFILE(),
-		      false, /* global only */
-		      false, /* save defaults */
-		      true,  /* add_ipc */
-		      true); /* initialize globals */
+	ret = lp_load(get_dyn_CONFIGFILE(), False, False, True, True);
 
 	/* perhaps the config filename is now set */
-	if (!test) {
-		reload_services(sconn, snumused, true);
-	}
+	if (!test)
+		reload_services(msg_ctx, smb_sock, True);
 
 	reopen_logs();
 
 	load_interfaces();
 
-	if (sconn != NULL) {
-		set_socket_options(sconn->sock, "SO_KEEPALIVE");
-		set_socket_options(sconn->sock, lp_socket_options());
+	if (smb_sock != -1) {
+		set_socket_options(smb_sock,"SO_KEEPALIVE");
+		set_socket_options(smb_sock, lp_socket_options());
 	}
 
 	mangle_reset_cache();
Only in ../../samba-3.6.24/source3/smbd: server_reload.o
diff -ur smbd/service.c ../../samba-3.6.24/source3/smbd/service.c
--- smbd/service.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/service.c	2015-01-28 10:52:25.149068676 +0800
@@ -19,7 +19,6 @@
 
 #include "includes.h"
 #include "system/filesys.h"
-#include "system/passwd.h" /* uid_wrapper */
 #include "../lib/tsocket/tsocket.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
@@ -28,8 +27,8 @@
 #include "printing/pcap.h"
 #include "passdb/lookup_sid.h"
 #include "auth.h"
-#include "lib/param/loadparm.h"
-#include "messages.h"
+
+extern userdom_struct current_user_info;
 
 static bool canonicalize_connect_path(connection_struct *conn)
 {
@@ -61,7 +60,7 @@
 	}
 
 	/* Allocate for strlen + '\0' + possible leading '/' */
-	destname = (char *)talloc_size(conn, strlen(connectpath) + 2);
+	destname = (char *)SMB_MALLOC(strlen(connectpath) + 2);
 	if (!destname) {
 		return false;
 	}
@@ -160,16 +159,10 @@
 	}
 
 	DEBUG(10,("set_conn_connectpath: service %s, connectpath = %s\n",
-		lp_servicename(talloc_tos(), SNUM(conn)), destname ));
+		lp_servicename(SNUM(conn)), destname ));
 
-	talloc_free(conn->connectpath);
-	conn->connectpath = destname;
-	/* Ensure conn->cwd is initialized - start as conn->connectpath. */
-	TALLOC_FREE(conn->cwd);
-	conn->cwd = talloc_strdup(conn, conn->connectpath);
-	if (!conn->cwd) {
-		return false;
-	}
+	string_set(&conn->connectpath, destname);
+	SAFE_FREE(destname);
 	return true;
 }
 
@@ -229,50 +222,263 @@
 	return(True);
 }
 
+static int load_registry_service(const char *servicename)
+{
+	if (!lp_registry_shares()) {
+		return -1;
+	}
+
+	if ((servicename == NULL) || (*servicename == '\0')) {
+		return -1;
+	}
+
+	if (strequal(servicename, GLOBAL_NAME)) {
+		return -2;
+	}
+
+	if (!process_registry_service(servicename)) {
+		return -1;
+	}
+
+	return lp_servicenumber(servicename);
+}
+
+void load_registry_shares(void)
+{
+	DEBUG(8, ("load_registry_shares()\n"));
+	if (!lp_registry_shares()) {
+		return;
+	}
+
+	process_registry_shares();
+
+	return;
+}
+
 /****************************************************************************
- do some basic sainity checks on the share.  
- This function modifies dev, ecode.
+ Add a home service. Returns the new service number or -1 if fail.
 ****************************************************************************/
 
-static NTSTATUS share_sanity_checks(const struct tsocket_address *remote_address,
-				    const char *rhost,
-				    int snum,
-				    fstring dev)
+int add_home_service(const char *service, const char *username, const char *homedir)
 {
-	char *raddr;
+	int iHomeService;
+
+	if (!service || !homedir || homedir[0] == '\0')
+		return -1;
+
+	if ((iHomeService = lp_servicenumber(HOMES_NAME)) < 0) {
+		if ((iHomeService = load_registry_service(HOMES_NAME)) < 0) {
+			return -1;
+		}
+	}
+
+	/*
+	 * If this is a winbindd provided username, remove
+	 * the domain component before adding the service.
+	 * Log a warning if the "path=" parameter does not
+	 * include any macros.
+	 */
+
+	{
+		const char *p = strchr(service,*lp_winbind_separator());
+
+		/* We only want the 'user' part of the string */
+		if (p) {
+			service = p + 1;
+		}
+	}
+
+	if (!lp_add_home(service, iHomeService, username, homedir)) {
+		return -1;
+	}
+
+	return lp_servicenumber(service);
+
+}
+
+/**
+ * Find a service entry.
+ *
+ * @param service is modified (to canonical form??)
+ **/
+
+int find_service(TALLOC_CTX *ctx, const char *service_in, char **p_service_out)
+{
+	int iService;
+
+	if (!service_in) {
+		return -1;
+	}
+
+	/* First make a copy. */
+	*p_service_out = talloc_strdup(ctx, service_in);
+	if (!*p_service_out) {
+		return -1;
+	}
+
+	all_string_sub(*p_service_out,"\\","/",0);
 
-	raddr = tsocket_address_inet_addr_string(remote_address,
-						 talloc_tos());
-	if (raddr == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	iService = lp_servicenumber(*p_service_out);
+
+	/* now handle the special case of a home directory */
+	if (iService < 0) {
+		char *phome_dir = get_user_home_dir(ctx, *p_service_out);
+
+		if(!phome_dir) {
+			/*
+			 * Try mapping the servicename, it may
+			 * be a Windows to unix mapped user name.
+			 */
+			if(map_username(ctx, *p_service_out, p_service_out)) {
+				if (*p_service_out == NULL) {
+					/* Out of memory. */
+					return -1;
+				}
+				phome_dir = get_user_home_dir(
+						ctx, *p_service_out);
+			}
+		}
+
+		DEBUG(3,("checking for home directory %s gave %s\n",*p_service_out,
+			phome_dir?phome_dir:"(NULL)"));
+
+		iService = add_home_service(*p_service_out,*p_service_out /* 'username' */, phome_dir);
 	}
 
-	if (!lp_snum_ok(snum) ||
+	/* If we still don't have a service, attempt to add it as a printer. */
+	if (iService < 0) {
+		int iPrinterService;
+
+		if ((iPrinterService = lp_servicenumber(PRINTERS_NAME)) < 0) {
+			iPrinterService = load_registry_service(PRINTERS_NAME);
+		}
+		if (iPrinterService >= 0) {
+			DEBUG(3,("checking whether %s is a valid printer name...\n",
+				*p_service_out));
+			if (pcap_printername_ok(*p_service_out)) {
+				DEBUG(3,("%s is a valid printer name\n",
+					*p_service_out));
+				DEBUG(3,("adding %s as a printer service\n",
+					*p_service_out));
+				lp_add_printer(*p_service_out, iPrinterService);
+				iService = lp_servicenumber(*p_service_out);
+				if (iService < 0) {
+					DEBUG(0,("failed to add %s as a printer service!\n",
+						*p_service_out));
+				}
+			} else {
+				DEBUG(3,("%s is not a valid printer name\n",
+					*p_service_out));
+			}
+		}
+	}
+
+	/* Check for default vfs service?  Unsure whether to implement this */
+	if (iService < 0) {
+	}
+
+	if (iService < 0) {
+		iService = load_registry_service(*p_service_out);
+	}
+
+	/* Is it a usershare service ? */
+	if (iService < 0 && *lp_usershare_path()) {
+		/* Ensure the name is canonicalized. */
+		strlower_m(*p_service_out);
+		iService = load_usershare_service(*p_service_out);
+	}
+
+	/* just possibly it's a default service? */
+	if (iService < 0) {
+		char *pdefservice = lp_defaultservice();
+		if (pdefservice &&
+				*pdefservice &&
+				!strequal(pdefservice, *p_service_out)
+				&& !strstr_m(*p_service_out,"..")) {
+			/*
+			 * We need to do a local copy here as lp_defaultservice() 
+			 * returns one of the rotating lp_string buffers that
+			 * could get overwritten by the recursive find_service() call
+			 * below. Fix from Josef Hinteregger <joehtg@joehtg.co.at>.
+			 */
+			char *defservice = talloc_strdup(ctx, pdefservice);
+
+			if (!defservice) {
+				goto fail;
+			}
+
+			/* Disallow anything except explicit share names. */
+			if (strequal(defservice,HOMES_NAME) ||
+					strequal(defservice, PRINTERS_NAME) ||
+					strequal(defservice, "IPC$")) {
+				TALLOC_FREE(defservice);
+				goto fail;
+			}
+
+			iService = find_service(ctx, defservice, p_service_out);
+			if (!*p_service_out) {
+				TALLOC_FREE(defservice);
+				iService = -1;
+				goto fail;
+			}
+			if (iService >= 0) {
+				all_string_sub(*p_service_out, "_","/",0);
+				iService = lp_add_service(*p_service_out, iService);
+			}
+			TALLOC_FREE(defservice);
+		}
+	}
+
+	if (iService >= 0) {
+		if (!VALID_SNUM(iService)) {
+			DEBUG(0,("Invalid snum %d for %s\n",iService,
+				*p_service_out));
+			iService = -1;
+		}
+	}
+
+  fail:
+
+	if (iService < 0) {
+		DEBUG(3,("find_service() failed to find service %s\n",
+			*p_service_out));
+	}
+
+	return (iService);
+}
+
+
+/****************************************************************************
+ do some basic sainity checks on the share.  
+ This function modifies dev, ecode.
+****************************************************************************/
+
+static NTSTATUS share_sanity_checks(struct client_address *client_id, int snum,
+				    fstring dev)
+{
+	if (!lp_snum_ok(snum) || 
 	    !allow_access(lp_hostsdeny(snum), lp_hostsallow(snum),
-			  rhost, raddr)) {
+			  client_id->name, client_id->addr)) {
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
 	if (dev[0] == '?' || !dev[0]) {
 		if (lp_print_ok(snum)) {
 			fstrcpy(dev,"LPT1:");
-		} else if (strequal(lp_fstype(talloc_tos(), snum), "IPC")) {
+		} else if (strequal(lp_fstype(snum), "IPC")) {
 			fstrcpy(dev, "IPC");
 		} else {
 			fstrcpy(dev,"A:");
 		}
 	}
 
-	if (!strupper_m(dev)) {
-		DEBUG(2,("strupper_m %s failed\n", dev));
-		return NT_STATUS_INVALID_PARAMETER;
-	}
+	strupper_m(dev);
 
 	if (lp_print_ok(snum)) {
 		if (!strequal(dev, "LPT1:")) {
 			return NT_STATUS_BAD_DEVICE_TYPE;
 		}
-	} else if (strequal(lp_fstype(talloc_tos(), snum), "IPC")) {
+	} else if (strequal(lp_fstype(snum), "IPC")) {
 		if (!strequal(dev, "IPC")) {
 			return NT_STATUS_BAD_DEVICE_TYPE;
 		}
@@ -308,7 +514,7 @@
 	bool user_must_be_member = False;
 	gid_t gid;
 
-	groupname = lp_force_group(talloc_tos(), snum);
+	groupname = talloc_strdup(talloc_tos(), lp_force_group(snum));
 	if (groupname == NULL) {
 		DEBUG(1, ("talloc_strdup failed\n"));
 		result = NT_STATUS_NO_MEMORY;
@@ -321,7 +527,7 @@
 	}
 
 	groupname = talloc_string_sub(talloc_tos(), groupname,
-				      "%S", lp_servicename(talloc_tos(), snum));
+				      "%S", lp_servicename(snum));
 	if (groupname == NULL) {
 		DEBUG(1, ("talloc_string_sub failed\n"));
 		result = NT_STATUS_NO_MEMORY;
@@ -382,51 +588,80 @@
 }
 
 /****************************************************************************
-  Create an auth_session_info structure for a connection_struct
+  Create an auth_serversupplied_info structure for a connection_struct
 ****************************************************************************/
 
 static NTSTATUS create_connection_session_info(struct smbd_server_connection *sconn,
 					      TALLOC_CTX *mem_ctx, int snum,
-                                              struct auth_session_info *session_info,
-                                              struct auth_session_info **presult)
+                                              struct auth_serversupplied_info *vuid_serverinfo,
+					      DATA_BLOB password,
+                                              struct auth_serversupplied_info **presult)
 {
-	struct auth_session_info *result;
-
         if (lp_guest_only(snum)) {
-                return make_session_info_guest(mem_ctx, presult);
+                return make_server_info_guest(mem_ctx, presult);
         }
 
-	/*
-	 * This is the normal security != share case where we have a
-	 * valid vuid from the session setup.                 */
+        if (vuid_serverinfo != NULL) {
 
-	if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
-		if (!lp_guest_ok(snum)) {
-			DEBUG(2, ("guest user (from session setup) "
-				  "not permitted to access this share "
-				  "(%s)\n", lp_servicename(talloc_tos(), snum)));
-			return NT_STATUS_ACCESS_DENIED;
-		}
-	} else {
-		if (!user_ok_token(session_info->unix_info->unix_name,
-				   session_info->info->domain_name,
-				   session_info->security_token, snum)) {
-			DEBUG(2, ("user '%s' (from session setup) not "
-				  "permitted to access this share "
-				  "(%s)\n",
-				  session_info->unix_info->unix_name,
-				  lp_servicename(talloc_tos(), snum)));
-			return NT_STATUS_ACCESS_DENIED;
+		struct auth_serversupplied_info *result;
+
+                /*
+                 * This is the normal security != share case where we have a
+                 * valid vuid from the session setup.                 */
+
+                if (vuid_serverinfo->guest) {
+                        if (!lp_guest_ok(snum)) {
+                                DEBUG(2, ("guest user (from session setup) "
+                                          "not permitted to access this share "
+                                          "(%s)\n", lp_servicename(snum)));
+                                return NT_STATUS_ACCESS_DENIED;
+                        }
+                } else {
+                        if (!user_ok_token(vuid_serverinfo->unix_name,
+					   vuid_serverinfo->info3->base.domain.string,
+                                           vuid_serverinfo->security_token, snum)) {
+                                DEBUG(2, ("user '%s' (from session setup) not "
+                                          "permitted to access this share "
+                                          "(%s)\n",
+                                          vuid_serverinfo->unix_name,
+                                          lp_servicename(snum)));
+                                return NT_STATUS_ACCESS_DENIED;
+                        }
+                }
+
+                result = copy_serverinfo(mem_ctx, vuid_serverinfo);
+		if (result == NULL) {
+			return NT_STATUS_NO_MEMORY;
 		}
-	}
 
-	result = copy_session_info(mem_ctx, session_info);
-	if (result == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
+		*presult = result;
+		return NT_STATUS_OK;
+        }
 
-	*presult = result;
-	return NT_STATUS_OK;
+        if (lp_security() == SEC_SHARE) {
+
+                fstring user;
+		bool guest;
+
+                /* add the sharename as a possible user name if we
+                   are in share mode security */
+
+                add_session_user(sconn, lp_servicename(snum));
+
+                /* shall we let them in? */
+
+                if (!authorise_login(sconn, snum,user,password,&guest)) {
+                        DEBUG( 2, ( "Invalid username/password for [%s]\n",
+                                    lp_servicename(snum)) );
+			return NT_STATUS_WRONG_PASSWORD;
+                }
+
+		return make_serverinfo_from_username(mem_ctx, user, guest, guest,
+						     presult);
+        }
+
+	DEBUG(0, ("invalid VUID (vuser) but not in security=share\n"));
+	return NT_STATUS_ACCESS_DENIED;
 }
 
 /****************************************************************************
@@ -438,7 +673,7 @@
 {
 	NTSTATUS status;
 
-	if (*lp_force_user(talloc_tos(), snum)) {
+	if (*lp_force_user(snum)) {
 
 		/*
 		 * Replace conn->session_info with a completely faked up one
@@ -446,21 +681,16 @@
 		 */
 
 		char *fuser;
-		char *sanitized_username;
-		struct auth_session_info *forced_serverinfo;
-		bool guest;
+		struct auth_serversupplied_info *forced_serverinfo;
 
-		fuser = talloc_string_sub(conn, lp_force_user(talloc_tos(), snum), "%S",
+		fuser = talloc_string_sub(conn, lp_force_user(snum), "%S",
 					  lp_const_servicename(snum));
 		if (fuser == NULL) {
 			return NT_STATUS_NO_MEMORY;
 		}
 
-		guest = security_session_user_level(conn->session_info, NULL) < SECURITY_USER;
-
-		status = make_session_info_from_username(
-			conn, fuser,
-			guest,
+		status = make_serverinfo_from_username(
+			conn, fuser, false, conn->session_info->guest,
 			&forced_serverinfo);
 		if (!NT_STATUS_IS_OK(status)) {
 			return status;
@@ -469,12 +699,10 @@
 		/* We don't want to replace the original sanitized_username
 		   as it is the original user given in the connect attempt.
 		   This is used in '%U' substitutions. */
-		sanitized_username = discard_const_p(char,
-			forced_serverinfo->unix_info->sanitized_username);
-		TALLOC_FREE(sanitized_username);
-		forced_serverinfo->unix_info->sanitized_username =
-			talloc_move(forced_serverinfo->unix_info,
-				&conn->session_info->unix_info->sanitized_username);
+		TALLOC_FREE(forced_serverinfo->sanitized_username);
+		forced_serverinfo->sanitized_username =
+			talloc_move(forced_serverinfo,
+				&conn->session_info->sanitized_username);
 
 		TALLOC_FREE(conn->session_info);
 		conn->session_info = forced_serverinfo;
@@ -488,12 +716,12 @@
 	 * any groupid stored for the connecting user.
 	 */
 
-	if (*lp_force_group(talloc_tos(), snum)) {
+	if (*lp_force_group(snum)) {
 
 		status = find_forced_group(
-			conn->force_user, snum, conn->session_info->unix_info->unix_name,
+			conn->force_user, snum, conn->session_info->unix_name,
 			&conn->session_info->security_token->sids[1],
-			&conn->session_info->unix_token->gid);
+			&conn->session_info->utok.gid);
 
 		if (!NT_STATUS_IS_OK(status)) {
 			return status;
@@ -505,58 +733,89 @@
 		 * struct. We only use conn->session_info directly if
 		 * "force_user" was set.
 		 */
-		conn->force_group_gid = conn->session_info->unix_token->gid;
+		conn->force_group_gid = conn->session_info->utok.gid;
 	}
 
 	return NT_STATUS_OK;
 }
 
 /****************************************************************************
+  Setup the share access mask for a connection.
+****************************************************************************/
+
+static void create_share_access_mask(connection_struct *conn, int snum)
+{
+	const struct security_token *token = conn->session_info->security_token;
+
+	share_access_check(token,
+			lp_servicename(snum),
+			MAXIMUM_ALLOWED_ACCESS,
+			&conn->share_access);
+
+	if (security_token_has_privilege(token, SEC_PRIV_SECURITY)) {
+		conn->share_access |= SEC_FLAG_SYSTEM_SECURITY;
+	}
+	if (security_token_has_privilege(token, SEC_PRIV_RESTORE)) {
+		conn->share_access |= (SEC_RIGHTS_PRIV_RESTORE);
+	}
+	if (security_token_has_privilege(token, SEC_PRIV_BACKUP)) {
+		conn->share_access |= (SEC_RIGHTS_PRIV_BACKUP);
+	}
+	if (security_token_has_privilege(token, SEC_PRIV_TAKE_OWNERSHIP)) {
+		conn->share_access |= (SEC_STD_WRITE_OWNER);
+	}
+}
+
+/****************************************************************************
   Make a connection, given the snum to connect to, and the vuser of the
   connecting user if appropriate.
 ****************************************************************************/
 
-static NTSTATUS make_connection_snum(struct smbd_server_connection *sconn,
+static connection_struct *make_connection_snum(struct smbd_server_connection *sconn,
 					connection_struct *conn,
-					int snum, struct user_struct *vuser,
-					const char *pdev)
+					int snum, user_struct *vuser,
+					DATA_BLOB password,
+					const char *pdev,
+					NTSTATUS *pstatus)
 {
 	struct smb_filename *smb_fname_cpath = NULL;
 	fstring dev;
 	int ret;
 	bool on_err_call_dis_hook = false;
+	bool claimed_connection = false;
 	uid_t effuid;
 	gid_t effgid;
 	NTSTATUS status;
 
 	fstrcpy(dev, pdev);
 
-	status = share_sanity_checks(sconn->remote_address,
-				       sconn->remote_hostname,
-				       snum,
-				       dev);
-	if (NT_STATUS_IS_ERR(status)) {
+	*pstatus = share_sanity_checks(&sconn->client_id, snum, dev);
+	if (NT_STATUS_IS_ERR(*pstatus)) {
 		goto err_root_exit;
 	}
 
 	conn->params->service = snum;
 
 	status = create_connection_session_info(sconn,
-		conn, snum, vuser->session_info,
+		conn, snum, vuser ? vuser->session_info : NULL, password,
 		&conn->session_info);
 
 	if (!NT_STATUS_IS_OK(status)) {
 		DEBUG(1, ("create_connection_session_info failed: %s\n",
 			  nt_errstr(status)));
+		*pstatus = status;
 		goto err_root_exit;
 	}
 
-	if (lp_guest_only(snum)) {
+	if ((lp_guest_only(snum)) || (lp_security() == SEC_SHARE)) {
 		conn->force_user = true;
 	}
 
+	add_session_user(sconn, conn->session_info->unix_name);
+
 	conn->num_files_open = 0;
 	conn->lastused = conn->lastused_count = time(NULL);
+	conn->used = True;
 	conn->printer = (strncmp(dev,"LPT",3) == 0);
 	conn->ipc = ( (strncmp(dev,"IPC",3) == 0) ||
 		      ( lp_enable_asu_support() && strequal(dev,"ADMIN$")) );
@@ -584,61 +843,64 @@
 
 	status = set_conn_force_user_group(conn, snum);
 	if (!NT_STATUS_IS_OK(status)) {
-		goto err_root_exit;
+		*pstatus = status;
+		return NULL;
 	}
 
-	conn->vuid = vuser->vuid;
+	conn->vuid = (vuser != NULL) ? vuser->vuid : UID_FIELD_INVALID;
 
 	{
 		char *s = talloc_sub_advanced(talloc_tos(),
-					lp_servicename(talloc_tos(), SNUM(conn)),
-					conn->session_info->unix_info->unix_name,
+					lp_servicename(SNUM(conn)),
+					conn->session_info->unix_name,
 					conn->connectpath,
-					conn->session_info->unix_token->gid,
-					conn->session_info->unix_info->sanitized_username,
-					conn->session_info->info->domain_name,
-					lp_pathname(talloc_tos(), snum));
+					conn->session_info->utok.gid,
+					conn->session_info->sanitized_username,
+					conn->session_info->info3->base.domain.string,
+					lp_pathname(snum));
 		if (!s) {
-			status = NT_STATUS_NO_MEMORY;
+			*pstatus = NT_STATUS_NO_MEMORY;
 			goto err_root_exit;
 		}
 
 		if (!set_conn_connectpath(conn,s)) {
 			TALLOC_FREE(s);
-			status = NT_STATUS_NO_MEMORY;
+			*pstatus = NT_STATUS_NO_MEMORY;
 			goto err_root_exit;
 		}
 		DEBUG(3,("Connect path is '%s' for service [%s]\n",s,
-			 lp_servicename(talloc_tos(), snum)));
+			 lp_servicename(snum)));
 		TALLOC_FREE(s);
 	}
 
-        /*
-         * Set up the share security descripter.
-	 * NOTE - we use the *INCOMING USER* session_info
-	 * here, as does (indirectly) change_to_user(),
-	 * which can be called on any incoming packet.
-	 * This way we set up the share access based
-	 * on the authenticated user, not the forced
-	 * user. See bug:
+	/*
+	 * New code to check if there's a share security descripter
+	 * added from NT server manager. This is done after the
+	 * smb.conf checks are done as we need a uid and token. JRA.
 	 *
-	 * https://bugzilla.samba.org/show_bug.cgi?id=9878
-         */
+	 */
 
-	status = check_user_share_access(conn,
-					vuser->session_info,
-					&conn->share_access,
-					&conn->read_only);
-	if (!NT_STATUS_IS_OK(status)) {
-		goto err_root_exit;
-	}
+	create_share_access_mask(conn, snum);
 
+	if ((conn->share_access & FILE_WRITE_DATA) == 0) {
+		if ((conn->share_access & FILE_READ_DATA) == 0) {
+			/* No access, read or write. */
+			DEBUG(0,("make_connection: connection to %s "
+				 "denied due to security "
+				 "descriptor.\n",
+				 lp_servicename(snum)));
+			*pstatus = NT_STATUS_ACCESS_DENIED;
+			goto err_root_exit;
+		} else {
+			conn->read_only = True;
+		}
+	}
 	/* Initialise VFS function pointers */
 
 	if (!smbd_vfs_init(conn)) {
 		DEBUG(0, ("vfs_init failed for service %s\n",
-			  lp_servicename(talloc_tos(), snum)));
-		status = NT_STATUS_BAD_NETWORK_NAME;
+			  lp_servicename(snum)));
+		*pstatus = NT_STATUS_BAD_NETWORK_NAME;
 		goto err_root_exit;
 	}
 
@@ -652,43 +914,44 @@
 	 */
 
 	if ((lp_max_connections(snum) > 0)
-	    && (count_current_connections(lp_servicename(talloc_tos(), SNUM(conn)), True) >=
+	    && (count_current_connections(lp_servicename(SNUM(conn)), True) >=
 		lp_max_connections(snum))) {
 
 		DEBUG(1, ("Max connections (%d) exceeded for %s\n",
-			  lp_max_connections(snum),
-			  lp_servicename(talloc_tos(), snum)));
-		status = NT_STATUS_INSUFFICIENT_RESOURCES;
+			  lp_max_connections(snum), lp_servicename(snum)));
+		*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;
+		goto err_root_exit;
+	}
+
+	/*
+	 * Get us an entry in the connections db
+	 */
+	if (!claim_connection(conn, lp_servicename(snum))) {
+		DEBUG(1, ("Could not store connections entry\n"));
+		*pstatus = NT_STATUS_INTERNAL_DB_ERROR;
 		goto err_root_exit;
 	}
+	claimed_connection = true;
 
 	/* Invoke VFS make connection hook - this must be the first
 	   filesystem operation that we do. */
 
-	if (SMB_VFS_CONNECT(conn, lp_servicename(talloc_tos(), snum),
-			    conn->session_info->unix_info->unix_name) < 0) {
+	if (SMB_VFS_CONNECT(conn, lp_servicename(snum),
+			    conn->session_info->unix_name) < 0) {
 		DEBUG(0,("make_connection: VFS make connection failed!\n"));
-		status = NT_STATUS_UNSUCCESSFUL;
+		*pstatus = NT_STATUS_UNSUCCESSFUL;
 		goto err_root_exit;
 	}
 
 	/* Any error exit after here needs to call the disconnect hook. */
 	on_err_call_dis_hook = true;
 
-	if ((!conn->printer) && (!conn->ipc) &&
-	    lp_change_notify(conn->params)) {
-		if (sconn->notify_ctx == NULL) {
-			sconn->notify_ctx = notify_init(
-				sconn, sconn->msg_ctx, sconn->ev_ctx);
-		}
-		if (sconn->sys_notify_ctx == NULL) {
-			sconn->sys_notify_ctx = sys_notify_context_create(
-				sconn, sconn->ev_ctx);
-		}
-	}
-
-	if (lp_kernel_oplocks(snum)) {
-		init_kernel_oplocks(conn->sconn);
+	if ((!conn->printer) && (!conn->ipc)) {
+		conn->notify_ctx = notify_init(conn,
+					       sconn_server_id(sconn),
+					       sconn->msg_ctx,
+					       smbd_event_context(),
+					       conn);
 	}
 
 	/*
@@ -706,22 +969,22 @@
 	/* Preexecs are done here as they might make the dir we are to ChDir
 	 * to below */
 	/* execute any "root preexec = " line */
-	if (*lp_rootpreexec(talloc_tos(), snum)) {
+	if (*lp_rootpreexec(snum)) {
 		char *cmd = talloc_sub_advanced(talloc_tos(),
-					lp_servicename(talloc_tos(), SNUM(conn)),
-					conn->session_info->unix_info->unix_name,
+					lp_servicename(SNUM(conn)),
+					conn->session_info->unix_name,
 					conn->connectpath,
-					conn->session_info->unix_token->gid,
-					conn->session_info->unix_info->sanitized_username,
-					conn->session_info->info->domain_name,
-					lp_rootpreexec(talloc_tos(), snum));
+					conn->session_info->utok.gid,
+					conn->session_info->sanitized_username,
+					conn->session_info->info3->base.domain.string,
+					lp_rootpreexec(snum));
 		DEBUG(5,("cmd=%s\n",cmd));
 		ret = smbrun(cmd,NULL);
 		TALLOC_FREE(cmd);
 		if (ret != 0 && lp_rootpreexec_close(snum)) {
 			DEBUG(1,("root preexec gave %d - failing "
 				 "connection\n", ret));
-			status = NT_STATUS_ACCESS_DENIED;
+			*pstatus = NT_STATUS_ACCESS_DENIED;
 			goto err_root_exit;
 		}
 	}
@@ -730,7 +993,7 @@
 	if (!change_to_user(conn, conn->vuid)) {
 		/* No point continuing if they fail the basic checks */
 		DEBUG(0,("Can't become connected user!\n"));
-		status = NT_STATUS_LOGON_FAILURE;
+		*pstatus = NT_STATUS_LOGON_FAILURE;
 		goto err_root_exit;
 	}
 
@@ -744,21 +1007,21 @@
 	 * to below */
 
 	/* execute any "preexec = " line */
-	if (*lp_preexec(talloc_tos(), snum)) {
+	if (*lp_preexec(snum)) {
 		char *cmd = talloc_sub_advanced(talloc_tos(),
-					lp_servicename(talloc_tos(), SNUM(conn)),
-					conn->session_info->unix_info->unix_name,
+					lp_servicename(SNUM(conn)),
+					conn->session_info->unix_name,
 					conn->connectpath,
-					conn->session_info->unix_token->gid,
-					conn->session_info->unix_info->sanitized_username,
-					conn->session_info->info->domain_name,
-					lp_preexec(talloc_tos(), snum));
+					conn->session_info->utok.gid,
+					conn->session_info->sanitized_username,
+					conn->session_info->info3->base.domain.string,
+					lp_preexec(snum));
 		ret = smbrun(cmd,NULL);
 		TALLOC_FREE(cmd);
 		if (ret != 0 && lp_preexec_close(snum)) {
 			DEBUG(1,("preexec gave %d - failing connection\n",
 				 ret));
-			status = NT_STATUS_ACCESS_DENIED;
+			*pstatus = NT_STATUS_ACCESS_DENIED;
 			goto err_root_exit;
 		}
 	}
@@ -788,27 +1051,25 @@
 		if (!canonicalize_connect_path(conn)) {
 			DEBUG(0, ("canonicalize_connect_path failed "
 			"for service %s, path %s\n",
-				lp_servicename(talloc_tos(), snum),
+				lp_servicename(snum),
 				conn->connectpath));
-			status = NT_STATUS_BAD_NETWORK_NAME;
+			*pstatus = NT_STATUS_BAD_NETWORK_NAME;
 			goto err_root_exit;
 		}
 	}
 
 	/* Add veto/hide lists */
 	if (!IS_IPC(conn) && !IS_PRINT(conn)) {
-		set_namearray( &conn->veto_list,
-			       lp_veto_files(talloc_tos(), snum));
-		set_namearray( &conn->hide_list,
-			       lp_hide_files(talloc_tos(), snum));
-		set_namearray( &conn->veto_oplock_list,
-			       lp_veto_oplocks(talloc_tos(), snum));
+		set_namearray( &conn->veto_list, lp_veto_files(snum));
+		set_namearray( &conn->hide_list, lp_hide_files(snum));
+		set_namearray( &conn->veto_oplock_list, lp_veto_oplocks(snum));
 		set_namearray( &conn->aio_write_behind_list,
-				lp_aio_write_behind(talloc_tos(), snum));
+				lp_aio_write_behind(snum));
 	}
 	status = create_synthetic_smb_fname(talloc_tos(), conn->connectpath,
 					    NULL, NULL, &smb_fname_cpath);
 	if (!NT_STATUS_IS_OK(status)) {
+		*pstatus = status;
 		goto err_root_exit;
 	}
 
@@ -823,21 +1084,19 @@
 		if (ret == 0 && !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {
 			DEBUG(0,("'%s' is not a directory, when connecting to "
 				 "[%s]\n", conn->connectpath,
-				 lp_servicename(talloc_tos(), snum)));
+				 lp_servicename(snum)));
 		} else {
 			DEBUG(0,("'%s' does not exist or permission denied "
 				 "when connecting to [%s] Error was %s\n",
-				 conn->connectpath,
-				 lp_servicename(talloc_tos(), snum),
+				 conn->connectpath, lp_servicename(snum),
 				 strerror(errno) ));
 		}
-		status = NT_STATUS_BAD_NETWORK_NAME;
+		*pstatus = NT_STATUS_BAD_NETWORK_NAME;
 		goto err_root_exit;
 	}
 	conn->base_share_dev = smb_fname_cpath->st.st_ex_dev;
 
-	talloc_free(conn->origpath);
-	conn->origpath = talloc_strdup(conn, conn->connectpath);
+	string_set(&conn->origpath,conn->connectpath);
 
 	/* Figure out the characteristics of the underlying filesystem. This
 	 * assumes that all the filesystem mounted withing a share path have
@@ -854,21 +1113,18 @@
 
 	if( DEBUGLVL( IS_IPC(conn) ? 3 : 1 ) ) {
 		dbgtext( "%s (%s) ", get_remote_machine_name(),
-			 tsocket_address_string(conn->sconn->remote_address,
-						talloc_tos()) );
+			 conn->sconn->client_id.addr );
 		dbgtext( "%s", srv_is_signing_active(sconn) ? "signed " : "");
-		dbgtext( "connect to service %s ",
-			 lp_servicename(talloc_tos(), snum) );
+		dbgtext( "connect to service %s ", lp_servicename(snum) );
 		dbgtext( "initially as user %s ",
-			 conn->session_info->unix_info->unix_name );
+			 conn->session_info->unix_name );
 		dbgtext( "(uid=%d, gid=%d) ", (int)effuid, (int)effgid );
-		dbgtext( "(pid %d)\n", (int)getpid() );
+		dbgtext( "(pid %d)\n", (int)sys_getpid() );
 	}
 
-	return status;
+	return(conn);
 
   err_root_exit:
-
 	TALLOC_FREE(smb_fname_cpath);
 	/* We must exit this function as root. */
 	if (geteuid() != 0) {
@@ -878,7 +1134,10 @@
 		/* Call VFS disconnect hook */
 		SMB_VFS_DISCONNECT(conn);
 	}
-	return status;
+	if (claimed_connection) {
+		yield_connection(conn, lp_servicename(snum));
+	}
+	return NULL;
 }
 
 /****************************************************************************
@@ -886,66 +1145,30 @@
 ****************************************************************************/
 
 static connection_struct *make_connection_smb1(struct smbd_server_connection *sconn,
-					NTTIME now,
-					int snum, struct user_struct *vuser,
+					int snum, user_struct *vuser,
+					DATA_BLOB password,
 					const char *pdev,
 					NTSTATUS *pstatus)
 {
-	struct smbXsrv_tcon *tcon;
-	NTSTATUS status;
-	struct connection_struct *conn;
-
-	status = smb1srv_tcon_create(sconn->conn, now, &tcon);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(0,("make_connection_smb1: Couldn't find free tcon %s.\n",
-			 nt_errstr(status)));
-		*pstatus = status;
-		return NULL;
-	}
-
-	conn = conn_new(sconn);
+	connection_struct *ret_conn = NULL;
+	connection_struct *conn = conn_new(sconn);
 	if (!conn) {
-		TALLOC_FREE(tcon);
-
 		DEBUG(0,("make_connection_smb1: Couldn't find free connection.\n"));
 		*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;
 		return NULL;
 	}
-
-	conn->cnum = tcon->global->tcon_wire_id;
-	conn->tcon = tcon;
-
-	*pstatus = make_connection_snum(sconn,
+	ret_conn = make_connection_snum(sconn,
 					conn,
 					snum,
 					vuser,
-					pdev);
-	if (!NT_STATUS_IS_OK(*pstatus)) {
-		conn_free(conn);
-		TALLOC_FREE(tcon);
-		return NULL;
-	}
-
-	tcon->global->share_name = lp_servicename(tcon->global, SNUM(conn));
-	if (tcon->global->share_name == NULL) {
+                                        password,
+					pdev,
+					pstatus);
+	if (ret_conn != conn) {
 		conn_free(conn);
-		TALLOC_FREE(tcon);
-		*pstatus = NT_STATUS_NO_MEMORY;
 		return NULL;
 	}
-	tcon->global->session_global_id =
-		vuser->session->global->session_global_id;
-
-	tcon->compat = talloc_move(tcon, &conn);
-	tcon->status = NT_STATUS_OK;
-
-	*pstatus = smbXsrv_tcon_update(tcon);
-	if (!NT_STATUS_IS_OK(*pstatus)) {
-		TALLOC_FREE(tcon);
-		return NULL;
-	}
-
-	return tcon->compat;
+	return conn;
 }
 
 /****************************************************************************
@@ -954,28 +1177,28 @@
 ****************************************************************************/
 
 connection_struct *make_connection_smb2(struct smbd_server_connection *sconn,
-					struct smbXsrv_tcon *tcon,
-					int snum,
-					struct user_struct *vuser,
+					struct smbd_smb2_tcon *tcon,
+					user_struct *vuser,
+					DATA_BLOB password,
 					const char *pdev,
 					NTSTATUS *pstatus)
 {
+	connection_struct *ret_conn = NULL;
 	connection_struct *conn = conn_new(sconn);
 	if (!conn) {
 		DEBUG(0,("make_connection_smb2: Couldn't find free connection.\n"));
 		*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;
 		return NULL;
 	}
-
-	conn->cnum = tcon->global->tcon_wire_id;
-	conn->tcon = tcon;
-
-	*pstatus = make_connection_snum(sconn,
+	conn->cnum = tcon->tid;
+	ret_conn = make_connection_snum(sconn,
 					conn,
-					snum,
+					tcon->snum,
 					vuser,
-					pdev);
-	if (!NT_STATUS_IS_OK(*pstatus)) {
+                                        password,
+					pdev,
+					pstatus);
+	if (ret_conn != conn) {
 		conn_free(conn);
 		return NULL;
 	}
@@ -989,13 +1212,12 @@
 ****************************************************************************/
 
 connection_struct *make_connection(struct smbd_server_connection *sconn,
-				   NTTIME now,
-				   const char *service_in,
-				   const char *pdev, uint64_t vuid,
+				   const char *service_in, DATA_BLOB password,
+				   const char *pdev, uint16 vuid,
 				   NTSTATUS *status)
 {
 	uid_t euid;
-	struct user_struct *vuser = NULL;
+	user_struct *vuser = NULL;
 	char *service = NULL;
 	fstring dev;
 	int snum = -1;
@@ -1015,12 +1237,14 @@
 		return NULL;
 	}
 
-	vuser = get_valid_user_struct(sconn, vuid);
-	if (!vuser) {
-		DEBUG(1,("make_connection: refusing to connect with "
-			 "no session setup\n"));
-		*status = NT_STATUS_ACCESS_DENIED;
-		return NULL;
+	if(lp_security() != SEC_SHARE) {
+		vuser = get_valid_user_struct(sconn, vuid);
+		if (!vuser) {
+			DEBUG(1,("make_connection: refusing to connect with "
+				 "no session setup\n"));
+			*status = NT_STATUS_ACCESS_DENIED;
+			return NULL;
+		}
 	}
 
 	/* Logic to try and connect to the correct [homes] share, preferably
@@ -1033,28 +1257,57 @@
 	*/
 
 	if (strequal(service_in,HOMES_NAME)) {
-		if (vuser->homes_snum == -1) {
-			DEBUG(2, ("[homes] share not available for "
-				  "this user because it was not found "
-				  "or created at session setup "
-				  "time\n"));
-			*status = NT_STATUS_BAD_NETWORK_NAME;
-			return NULL;
+		if(lp_security() != SEC_SHARE) {
+			DATA_BLOB no_pw = data_blob_null;
+			if (vuser->homes_snum == -1) {
+				DEBUG(2, ("[homes] share not available for "
+					  "this user because it was not found "
+					  "or created at session setup "
+					  "time\n"));
+				*status = NT_STATUS_BAD_NETWORK_NAME;
+				return NULL;
+			}
+			DEBUG(5, ("making a connection to [homes] service "
+				  "created at session setup time\n"));
+			return make_connection_smb1(sconn,
+						    vuser->homes_snum,
+						    vuser, no_pw, 
+						    dev, status);
+		} else {
+			/* Security = share. Try with
+			 * current_user_info.smb_name as the username.  */
+			if (*current_user_info.smb_name) {
+				char *unix_username = NULL;
+				(void)map_username(talloc_tos(),
+						current_user_info.smb_name,
+						&unix_username);
+				snum = find_service(talloc_tos(),
+						unix_username,
+						&unix_username);
+				if (!unix_username) {
+					*status = NT_STATUS_NO_MEMORY;
+				}
+				return NULL;
+			}
+			if (snum != -1) {
+				DEBUG(5, ("making a connection to 'homes' "
+					  "service %s based on "
+					  "security=share\n", service_in));
+				return make_connection_smb1(sconn,
+							    snum, NULL,
+							    password,
+							    dev, status);
+			}
 		}
-		DEBUG(5, ("making a connection to [homes] service "
-			  "created at session setup time\n"));
-		return make_connection_smb1(sconn, now,
-					    vuser->homes_snum,
-					    vuser,
-					    dev, status);
-	} else if ((vuser->homes_snum != -1)
+	} else if ((lp_security() != SEC_SHARE) && (vuser->homes_snum != -1)
 		   && strequal(service_in,
-			       lp_servicename(talloc_tos(), vuser->homes_snum))) {
+			       lp_servicename(vuser->homes_snum))) {
+		DATA_BLOB no_pw = data_blob_null;
 		DEBUG(5, ("making a connection to 'homes' service [%s] "
 			  "created at session setup time\n", service_in));
-		return make_connection_smb1(sconn, now,
+		return make_connection_smb1(sconn,
 					    vuser->homes_snum,
-					    vuser,
+					    vuser, no_pw, 
 					    dev, status);
 	}
 
@@ -1064,11 +1317,7 @@
 		return NULL;
 	}
 
-	if (!strlower_m(service)) {
-		DEBUG(2, ("strlower_m %s failed\n", service));
-		*status = NT_STATUS_INVALID_PARAMETER;
-		return NULL;
-	}
+	strlower_m(service);
 
 	snum = find_service(talloc_tos(), service, &service);
 	if (!service) {
@@ -1094,17 +1343,18 @@
 	}
 
 	/* Handle non-Dfs clients attempting connections to msdfs proxy */
-	if (lp_host_msdfs() && (*lp_msdfs_proxy(talloc_tos(), snum) != '\0'))  {
+	if (lp_host_msdfs() && (*lp_msdfs_proxy(snum) != '\0'))  {
 		DEBUG(3, ("refusing connection to dfs proxy share '%s' "
 			  "(pointing to %s)\n", 
-			service, lp_msdfs_proxy(talloc_tos(), snum)));
+			service, lp_msdfs_proxy(snum)));
 		*status = NT_STATUS_BAD_NETWORK_NAME;
 		return NULL;
 	}
 
 	DEBUG(5, ("making a connection to 'normal' service %s\n", service));
 
-	return make_connection_smb1(sconn, now, snum, vuser,
+	return make_connection_smb1(sconn, snum, vuser,
+				    password,
 				    dev, status);
 }
 
@@ -1112,7 +1362,7 @@
  Close a cnum.
 ****************************************************************************/
 
-void close_cnum(connection_struct *conn, uint64_t vuid)
+void close_cnum(connection_struct *conn, uint16 vuid)
 {
 	file_close_conn(conn);
 
@@ -1124,27 +1374,28 @@
 
 	DEBUG(IS_IPC(conn)?3:1, ("%s (%s) closed connection to service %s\n",
 				 get_remote_machine_name(),
-				 tsocket_address_string(conn->sconn->remote_address,
-							talloc_tos()),
-				 lp_servicename(talloc_tos(), SNUM(conn))));
+				 conn->sconn->client_id.addr,
+				 lp_servicename(SNUM(conn))));
 
 	/* Call VFS disconnect hook */    
 	SMB_VFS_DISCONNECT(conn);
 
+	yield_connection(conn, lp_servicename(SNUM(conn)));
+
 	/* make sure we leave the directory available for unmount */
 	vfs_ChDir(conn, "/");
 
 	/* execute any "postexec = " line */
-	if (*lp_postexec(talloc_tos(), SNUM(conn)) &&
+	if (*lp_postexec(SNUM(conn)) && 
 	    change_to_user(conn, vuid))  {
 		char *cmd = talloc_sub_advanced(talloc_tos(),
-					lp_servicename(talloc_tos(), SNUM(conn)),
-					conn->session_info->unix_info->unix_name,
+					lp_servicename(SNUM(conn)),
+					conn->session_info->unix_name,
 					conn->connectpath,
-					conn->session_info->unix_token->gid,
-					conn->session_info->unix_info->sanitized_username,
-					conn->session_info->info->domain_name,
-					lp_postexec(talloc_tos(), SNUM(conn)));
+					conn->session_info->utok.gid,
+					conn->session_info->sanitized_username,
+					conn->session_info->info3->base.domain.string,
+					lp_postexec(SNUM(conn)));
 		smbrun(cmd,NULL);
 		TALLOC_FREE(cmd);
 		change_to_root_user();
@@ -1152,15 +1403,15 @@
 
 	change_to_root_user();
 	/* execute any "root postexec = " line */
-	if (*lp_rootpostexec(talloc_tos(), SNUM(conn)))  {
+	if (*lp_rootpostexec(SNUM(conn)))  {
 		char *cmd = talloc_sub_advanced(talloc_tos(),
-					lp_servicename(talloc_tos(), SNUM(conn)),
-					conn->session_info->unix_info->unix_name,
+					lp_servicename(SNUM(conn)),
+					conn->session_info->unix_name,
 					conn->connectpath,
-					conn->session_info->unix_token->gid,
-					conn->session_info->unix_info->sanitized_username,
-					conn->session_info->info->domain_name,
-					lp_rootpostexec(talloc_tos(), SNUM(conn)));
+					conn->session_info->utok.gid,
+					conn->session_info->sanitized_username,
+					conn->session_info->info3->base.domain.string,
+					lp_rootpostexec(SNUM(conn)));
 		smbrun(cmd,NULL);
 		TALLOC_FREE(cmd);
 	}
Only in ../../samba-3.6.24/source3/smbd: service.o
diff -ur smbd/session.c ../../samba-3.6.24/source3/smbd/session.c
--- smbd/session.c	2012-10-30 17:01:47.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/session.c	2015-01-28 10:52:25.149068676 +0800
@@ -29,83 +29,192 @@
 #include "includes.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
-#include "dbwrap/dbwrap.h"
+#include "dbwrap.h"
 #include "session.h"
 #include "auth.h"
-#include "../lib/tsocket/tsocket.h"
-#include "../libcli/security/security.h"
-#include "messages.h"
 
 /********************************************************************
  called when a session is created
 ********************************************************************/
 
-bool session_claim(struct smbXsrv_session *session)
+bool session_claim(struct smbd_server_connection *sconn, user_struct *vuser)
 {
-	struct auth_session_info *session_info =
-		session->global->auth_session_info;
-	const char *username;
-	const char *hostname;
-	unsigned int id_num;
-	fstring id_str;
+	struct server_id pid = sconn_server_id(sconn);
+	TDB_DATA data;
+	int i = 0;
+	struct sessionid sessionid;
+	fstring keystr;
+	struct db_record *rec;
+	NTSTATUS status;
+
+	vuser->session_keystr = NULL;
 
 	/* don't register sessions for the guest user - its just too
 	   expensive to go through pam session code for browsing etc */
-	if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
-		return true;
+	if (vuser->session_info->guest) {
+		return True;
+	}
+
+	if (!sessionid_init()) {
+		return False;
 	}
 
-	id_num = session->global->session_global_id;
+	ZERO_STRUCT(sessionid);
+
+	data.dptr = NULL;
+	data.dsize = 0;
 
-	snprintf(id_str, sizeof(id_str), "smb/%u", id_num);
+	if (lp_utmp()) {
 
-	/* Make clear that we require the optional unix_token in the source3 code */
-	SMB_ASSERT(session_info->unix_token);
+		for (i=1;i<MAX_SESSION_ID;i++) {
 
-	username = session_info->unix_info->unix_name;
-	hostname = session->global->channels[0].remote_name;
+			/*
+			 * This is very inefficient and needs fixing -- vl
+			 */
+
+			struct server_id sess_pid;
+
+			snprintf(keystr, sizeof(keystr), "ID/%d", i);
+
+			rec = sessionid_fetch_record(NULL, keystr);
+			if (rec == NULL) {
+				DEBUG(1, ("Could not lock \"%s\"\n", keystr));
+				return False;
+			}
+
+			if (rec->value.dsize != sizeof(sessionid)) {
+				DEBUG(1, ("Re-using invalid record\n"));
+				break;
+			}
+
+			memcpy(&sess_pid,
+			       ((char *)rec->value.dptr)
+			       + offsetof(struct sessionid, pid),
+			       sizeof(sess_pid));
+
+			if (!process_exists(sess_pid)) {
+				DEBUG(5, ("%s has died -- re-using session\n",
+					  procid_str_static(&sess_pid)));
+				break;
+			}
+
+			TALLOC_FREE(rec);
+		}
+
+		if (i == MAX_SESSION_ID) {
+			SMB_ASSERT(rec == NULL);
+			DEBUG(1,("session_claim: out of session IDs "
+				 "(max is %d)\n", MAX_SESSION_ID));
+			return False;
+		}
+
+		snprintf(sessionid.id_str, sizeof(sessionid.id_str),
+			 SESSION_UTMP_TEMPLATE, i);
+	} else
+	{
+		snprintf(keystr, sizeof(keystr), "ID/%s/%u",
+			 procid_str_static(&pid), vuser->vuid);
+
+		rec = sessionid_fetch_record(NULL, keystr);
+		if (rec == NULL) {
+			DEBUG(1, ("Could not lock \"%s\"\n", keystr));
+			return False;
+		}
+
+		snprintf(sessionid.id_str, sizeof(sessionid.id_str),
+			 SESSION_TEMPLATE, (long unsigned int)sys_getpid(),
+			 vuser->vuid);
+	}
+
+	SMB_ASSERT(rec != NULL);
+
+	/* If 'hostname lookup' == yes, then do the DNS lookup.  This is
+           needed because utmp and PAM both expect DNS names
+
+	   client_name() handles this case internally.
+	*/
+
+	fstrcpy(sessionid.username, vuser->session_info->unix_name);
+	fstrcpy(sessionid.hostname, sconn->client_id.name);
+	sessionid.id_num = i;  /* Only valid for utmp sessions */
+	sessionid.pid = pid;
+	sessionid.uid = vuser->session_info->utok.uid;
+	sessionid.gid = vuser->session_info->utok.gid;
+	fstrcpy(sessionid.remote_machine, get_remote_machine_name());
+	fstrcpy(sessionid.ip_addr_str, sconn->client_id.addr);
+	sessionid.connect_start = time(NULL);
 
-	if (!smb_pam_claim_session(username, id_str, hostname)) {
+	if (!smb_pam_claim_session(sessionid.username, sessionid.id_str,
+				   sessionid.hostname)) {
 		DEBUG(1,("pam_session rejected the session for %s [%s]\n",
-				username, id_str));
-		return false;
+				sessionid.username, sessionid.id_str));
+
+		TALLOC_FREE(rec);
+		return False;
+	}
+
+	data.dptr = (uint8 *)&sessionid;
+	data.dsize = sizeof(sessionid);
+
+	status = rec->store(rec, data, TDB_REPLACE);
+
+	TALLOC_FREE(rec);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(1,("session_claim: unable to create session id "
+			 "record: %s\n", nt_errstr(status)));
+		return False;
 	}
 
 	if (lp_utmp()) {
-		sys_utmp_claim(username, hostname, id_str, id_num);
+		sys_utmp_claim(sessionid.username, sessionid.hostname,
+			       sessionid.ip_addr_str,
+			       sessionid.id_str, sessionid.id_num);
 	}
 
-	return true;
+	vuser->session_keystr = talloc_strdup(vuser, keystr);
+	if (!vuser->session_keystr) {
+		DEBUG(0, ("session_claim:  talloc_strdup() failed for session_keystr\n"));
+		return False;
+	}
+	return True;
 }
 
 /********************************************************************
  called when a session is destroyed
 ********************************************************************/
 
-void session_yield(struct smbXsrv_session *session)
+void session_yield(user_struct *vuser)
 {
-	struct auth_session_info *session_info =
-		session->global->auth_session_info;
-	const char *username;
-	const char *hostname;
-	unsigned int id_num;
-	fstring id_str = "";
-
-	id_num = session->global->session_global_id;
+	struct sessionid sessionid;
+	struct db_record *rec;
+
+	if (!vuser->session_keystr) {
+		return;
+	}
 
-	snprintf(id_str, sizeof(id_str), "smb/%u", id_num);
+	rec = sessionid_fetch_record(NULL, vuser->session_keystr);
+	if (rec == NULL) {
+		return;
+	}
 
-	/* Make clear that we require the optional unix_token in the source3 code */
-	SMB_ASSERT(session_info->unix_token);
+	if (rec->value.dsize != sizeof(sessionid))
+		return;
 
-	username = session_info->unix_info->unix_name;
-	hostname = session->global->channels[0].remote_name;
+	memcpy(&sessionid, rec->value.dptr, sizeof(sessionid));
 
 	if (lp_utmp()) {
-		sys_utmp_yield(username, hostname, id_str, id_num);
+		sys_utmp_yield(sessionid.username, sessionid.hostname, 
+			       sessionid.ip_addr_str,
+			       sessionid.id_str, sessionid.id_num);
 	}
 
-	smb_pam_close_session(username, id_str, hostname);
+	smb_pam_close_session(sessionid.username, sessionid.id_str,
+			      sessionid.hostname);
+
+	rec->delete_rec(rec);
+
+	TALLOC_FREE(rec);
 }
 
 /********************************************************************
@@ -122,7 +231,7 @@
 {
 	struct session_list *sesslist = (struct session_list *)private_data;
 
-	sesslist->sessions = talloc_realloc(
+	sesslist->sessions = TALLOC_REALLOC_ARRAY(
 		sesslist->mem_ctx, sesslist->sessions, struct sessionid,
 		sesslist->count+1);
 
@@ -148,14 +257,14 @@
 int list_sessions(TALLOC_CTX *mem_ctx, struct sessionid **session_list)
 {
 	struct session_list sesslist;
-	NTSTATUS status;
+	int ret;
 
 	sesslist.mem_ctx = mem_ctx;
 	sesslist.count = 0;
 	sesslist.sessions = NULL;
 
-	status = sessionid_traverse_read(gather_sessioninfo, (void *) &sesslist);
-	if (!NT_STATUS_IS_OK(status)) {
+	ret = sessionid_traverse_read(gather_sessioninfo, (void *) &sesslist);
+	if (ret == -1) {
 		DEBUG(3, ("Session traverse failed\n"));
 		SAFE_FREE(sesslist.sessions);
 		*session_list = NULL;
Only in ../../samba-3.6.24/source3/smbd: session.o
diff -ur smbd/sesssetup.c ../../samba-3.6.24/source3/smbd/sesssetup.c
--- smbd/sesssetup.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/sesssetup.c	2015-01-28 10:52:25.149068676 +0800
@@ -27,16 +27,54 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "../libcli/auth/spnego.h"
-#include "../auth/ntlmssp/ntlmssp.h"
+#include "../libcli/auth/ntlmssp.h"
+#include "ntlmssp_wrap.h"
 #include "../librpc/gen_ndr/krb5pac.h"
 #include "libads/kerberos_proto.h"
 #include "../lib/util/asn1.h"
 #include "auth.h"
 #include "messages.h"
 #include "smbprofile.h"
-#include "../libcli/security/security.h"
-#include "auth/gensec/gensec.h"
-#include "lib/conn_tdb.h"
+
+/* For split krb5 SPNEGO blobs. */
+struct pending_auth_data {
+	struct pending_auth_data *prev, *next;
+	uint16 vuid; /* Tag for this entry. */
+	uint16 smbpid; /* Alternate tag for this entry. */
+	size_t needed_len;
+	DATA_BLOB partial_data;
+};
+
+/*
+  on a logon error possibly map the error to success if "map to guest"
+  is set approriately
+*/
+NTSTATUS do_map_to_guest(NTSTATUS status,
+			struct auth_serversupplied_info **server_info,
+			const char *user, const char *domain)
+{
+	user = user ? user : "";
+	domain = domain ? domain : "";
+
+	if (NT_STATUS_EQUAL(status, NT_STATUS_NO_SUCH_USER)) {
+		if ((lp_map_to_guest() == MAP_TO_GUEST_ON_BAD_USER) ||
+		    (lp_map_to_guest() == MAP_TO_GUEST_ON_BAD_PASSWORD)) {
+			DEBUG(3,("No such user %s [%s] - using guest account\n",
+				 user, domain));
+			status = make_server_info_guest(NULL, server_info);
+		}
+	}
+
+	if (NT_STATUS_EQUAL(status, NT_STATUS_WRONG_PASSWORD)) {
+		if (lp_map_to_guest() == MAP_TO_GUEST_ON_BAD_PASSWORD) {
+			DEBUG(3,("Registered username %s for guest access\n",
+				user));
+			status = make_server_info_guest(NULL, server_info);
+		}
+	}
+
+	return status;
+}
 
 /****************************************************************************
  Add the standard 'Samba' signature to the end of the session setup.
@@ -74,40 +112,940 @@
 }
 
 /****************************************************************************
+ Send a security blob via a session setup reply.
+****************************************************************************/
+
+static void reply_sesssetup_blob(struct smb_request *req,
+				 DATA_BLOB blob,
+				 NTSTATUS nt_status)
+{
+	if (!NT_STATUS_IS_OK(nt_status) &&
+	    !NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		reply_nterror(req, nt_status_squash(nt_status));
+		return;
+	}
+
+	nt_status = nt_status_squash(nt_status);
+	SIVAL(req->outbuf, smb_rcls, NT_STATUS_V(nt_status));
+	SSVAL(req->outbuf, smb_vwv0, 0xFF); /* no chaining possible */
+	SSVAL(req->outbuf, smb_vwv3, blob.length);
+
+	if ((message_push_blob(&req->outbuf, blob) == -1)
+	    || (push_signature(&req->outbuf) == -1)) {
+		reply_nterror(req, NT_STATUS_NO_MEMORY);
+	}
+}
+
+/****************************************************************************
  Do a 'guest' logon, getting back the
 ****************************************************************************/
 
-static NTSTATUS check_guest_password(const struct tsocket_address *remote_address,
-				     TALLOC_CTX *mem_ctx, 
-				     struct auth_session_info **session_info)
+static NTSTATUS check_guest_password(struct auth_serversupplied_info **server_info)
 {
-	struct auth4_context *auth_context;
+	struct auth_context *auth_context;
 	struct auth_usersupplied_info *user_info = NULL;
-	uint8_t chal[8];
+
 	NTSTATUS nt_status;
+	static unsigned char chal[8] = { 0, };
 
 	DEBUG(3,("Got anonymous request\n"));
 
-	nt_status = make_auth4_context(talloc_tos(), &auth_context);
+	nt_status = make_auth_context_fixed(talloc_tos(), &auth_context, chal);
 	if (!NT_STATUS_IS_OK(nt_status)) {
 		return nt_status;
 	}
 
-	auth_context->get_ntlm_challenge(auth_context,
-					 chal);
-
-	if (!make_user_info_guest(remote_address, &user_info)) {
+	if (!make_user_info_guest(&user_info)) {
 		TALLOC_FREE(auth_context);
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	nt_status = auth_check_password_session_info(auth_context, 
-						     mem_ctx, user_info, session_info);
-	free_user_info(&user_info);
+	nt_status = auth_context->check_ntlm_password(auth_context,
+						user_info,
+						server_info);
 	TALLOC_FREE(auth_context);
+	free_user_info(&user_info);
 	return nt_status;
 }
 
+
+#ifdef HAVE_KRB5
+
+#if 0
+/* Experiment that failed. See "only happens with a KDC" comment below. */
+/****************************************************************************
+ Cerate a clock skew error blob for a Windows client.
+****************************************************************************/
+
+static bool make_krb5_skew_error(DATA_BLOB *pblob_out)
+{
+	krb5_context context = NULL;
+	krb5_error_code kerr = 0;
+	krb5_data reply;
+	krb5_principal host_princ = NULL;
+	char *host_princ_s = NULL;
+	bool ret = False;
+
+	*pblob_out = data_blob_null;
+
+	initialize_krb5_error_table();
+	kerr = krb5_init_context(&context);
+	if (kerr) {
+		return False;
+	}
+	/* Create server principal. */
+	asprintf(&host_princ_s, "%s$@%s", global_myname(), lp_realm());
+	if (!host_princ_s) {
+		goto out;
+	}
+	strlower_m(host_princ_s);
+
+	kerr = smb_krb5_parse_name(context, host_princ_s, &host_princ);
+	if (kerr) {
+		DEBUG(10,("make_krb5_skew_error: smb_krb5_parse_name failed "
+			"for name %s: Error %s\n",
+			host_princ_s, error_message(kerr) ));
+		goto out;
+	}
+
+	kerr = smb_krb5_mk_error(context, KRB5KRB_AP_ERR_SKEW,
+			host_princ, &reply);
+	if (kerr) {
+		DEBUG(10,("make_krb5_skew_error: smb_krb5_mk_error "
+			"failed: Error %s\n",
+			error_message(kerr) ));
+		goto out;
+	}
+
+	*pblob_out = data_blob(reply.data, reply.length);
+	kerberos_free_data_contents(context,&reply);
+	ret = True;
+
+  out:
+
+	if (host_princ_s) {
+		SAFE_FREE(host_princ_s);
+	}
+	if (host_princ) {
+		krb5_free_principal(context, host_princ);
+	}
+	krb5_free_context(context);
+	return ret;
+}
+#endif
+
+/****************************************************************************
+ Reply to a session setup spnego negotiate packet for kerberos.
+****************************************************************************/
+
+static void reply_spnego_kerberos(struct smb_request *req,
+				  DATA_BLOB *secblob,
+				  const char *mechOID,
+				  uint16 vuid,
+				  bool *p_invalidate_vuid)
+{
+	TALLOC_CTX *mem_ctx;
+	DATA_BLOB ticket;
+	struct passwd *pw;
+	int sess_vuid = req->vuid;
+	NTSTATUS ret = NT_STATUS_OK;
+	DATA_BLOB ap_rep, ap_rep_wrapped, response;
+	struct auth_serversupplied_info *server_info = NULL;
+	DATA_BLOB session_key = data_blob_null;
+	uint8 tok_id[2];
+	DATA_BLOB nullblob = data_blob_null;
+	bool map_domainuser_to_guest = False;
+	bool username_was_mapped;
+	struct PAC_LOGON_INFO *logon_info = NULL;
+	struct smbd_server_connection *sconn = req->sconn;
+	char *principal;
+	char *user;
+	char *domain;
+	char *real_username;
+
+	ZERO_STRUCT(ticket);
+	ZERO_STRUCT(ap_rep);
+	ZERO_STRUCT(ap_rep_wrapped);
+	ZERO_STRUCT(response);
+
+	/* Normally we will always invalidate the intermediate vuid. */
+	*p_invalidate_vuid = True;
+
+	mem_ctx = talloc_init("reply_spnego_kerberos");
+	if (mem_ctx == NULL) {
+		reply_nterror(req, nt_status_squash(NT_STATUS_NO_MEMORY));
+		return;
+	}
+
+	if (!spnego_parse_krb5_wrap(mem_ctx, *secblob, &ticket, tok_id)) {
+		talloc_destroy(mem_ctx);
+		reply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));
+		return;
+	}
+
+	ret = ads_verify_ticket(mem_ctx, lp_realm(), 0, &ticket,
+				&principal, &logon_info, &ap_rep,
+				&session_key, True);
+
+	data_blob_free(&ticket);
+
+	if (!NT_STATUS_IS_OK(ret)) {
+#if 0
+		/* Experiment that failed.
+		 * See "only happens with a KDC" comment below. */
+
+		if (NT_STATUS_EQUAL(ret, NT_STATUS_TIME_DIFFERENCE_AT_DC)) {
+
+			/*
+			 * Windows in this case returns
+			 * NT_STATUS_MORE_PROCESSING_REQUIRED
+			 * with a negTokenTarg blob containing an krb5_error
+			 * struct ASN1 encoded containing KRB5KRB_AP_ERR_SKEW.
+			 * The client then fixes its clock and continues rather
+			 * than giving an error. JRA.
+			 * -- Looks like this only happens with a KDC. JRA.
+			 */
+
+			bool ok = make_krb5_skew_error(&ap_rep);
+			if (!ok) {
+				talloc_destroy(mem_ctx);
+				return ERROR_NT(nt_status_squash(
+						NT_STATUS_LOGON_FAILURE));
+			}
+			ap_rep_wrapped = spnego_gen_krb5_wrap(ap_rep,
+					TOK_ID_KRB_ERROR);
+			response = spnego_gen_auth_response(&ap_rep_wrapped,
+					ret, OID_KERBEROS5_OLD);
+			reply_sesssetup_blob(conn, inbuf, outbuf, response,
+					NT_STATUS_MORE_PROCESSING_REQUIRED);
+
+			/*
+			 * In this one case we don't invalidate the
+			 * intermediate vuid as we're expecting the client
+			 * to re-use it for the next sessionsetupX packet. JRA.
+			 */
+
+			*p_invalidate_vuid = False;
+
+			data_blob_free(&ap_rep);
+			data_blob_free(&ap_rep_wrapped);
+			data_blob_free(&response);
+			talloc_destroy(mem_ctx);
+			return -1; /* already replied */
+		}
+#else
+		if (!NT_STATUS_EQUAL(ret, NT_STATUS_TIME_DIFFERENCE_AT_DC)) {
+			ret = NT_STATUS_LOGON_FAILURE;
+		}
+#endif
+		DEBUG(1,("Failed to verify incoming ticket with error %s!\n",
+				nt_errstr(ret)));
+		talloc_destroy(mem_ctx);
+		reply_nterror(req, nt_status_squash(ret));
+		return;
+	}
+
+	ret = get_user_from_kerberos_info(talloc_tos(),
+					  sconn->client_id.name,
+					  principal, logon_info,
+					  &username_was_mapped,
+					  &map_domainuser_to_guest,
+					  &user, &domain,
+					  &real_username, &pw);
+	if (!NT_STATUS_IS_OK(ret)) {
+		data_blob_free(&ap_rep);
+		data_blob_free(&session_key);
+		talloc_destroy(mem_ctx);
+		reply_nterror(req,nt_status_squash(NT_STATUS_LOGON_FAILURE));
+		return;
+	}
+
+	/* save the PAC data if we have it */
+	if (logon_info) {
+		netsamlogon_cache_store(user, &logon_info->info3);
+	}
+
+	/* setup the string used by %U */
+	sub_set_smb_name(real_username);
+
+	/* reload services so that the new %U is taken into account */
+	reload_services(sconn->msg_ctx, sconn->sock, True);
+
+	ret = make_server_info_krb5(mem_ctx,
+				    user, domain, real_username, pw,
+				    logon_info, map_domainuser_to_guest,
+				    &server_info);
+	if (!NT_STATUS_IS_OK(ret)) {
+		DEBUG(1, ("make_server_info_krb5 failed!\n"));
+		data_blob_free(&ap_rep);
+		data_blob_free(&session_key);
+		TALLOC_FREE(mem_ctx);
+		reply_nterror(req, nt_status_squash(ret));
+		return;
+	}
+
+	server_info->nss_token |= username_was_mapped;
+
+	/* we need to build the token for the user. make_server_info_guest()
+	   already does this */
+
+	if ( !server_info->security_token ) {
+		ret = create_local_token( server_info );
+		if ( !NT_STATUS_IS_OK(ret) ) {
+			DEBUG(10,("failed to create local token: %s\n",
+				nt_errstr(ret)));
+			data_blob_free(&ap_rep);
+			data_blob_free(&session_key);
+			TALLOC_FREE( mem_ctx );
+			TALLOC_FREE( server_info );
+			reply_nterror(req, nt_status_squash(ret));
+			return;
+		}
+	}
+
+	if (!is_partial_auth_vuid(sconn, sess_vuid)) {
+		sess_vuid = register_initial_vuid(sconn);
+	}
+
+	data_blob_free(&server_info->user_session_key);
+	/* Set the kerberos-derived session key onto the server_info */
+	server_info->user_session_key = session_key;
+	talloc_steal(server_info, session_key.data);
+
+	session_key = data_blob_null;
+
+	/* register_existing_vuid keeps the server info */
+	/* register_existing_vuid takes ownership of session_key on success,
+	 * no need to free after this on success. A better interface would copy
+	 * it.... */
+
+	sess_vuid = register_existing_vuid(sconn, sess_vuid,
+					   server_info, nullblob, user);
+
+	reply_outbuf(req, 4, 0);
+	SSVAL(req->outbuf,smb_uid,sess_vuid);
+
+	if (sess_vuid == UID_FIELD_INVALID ) {
+		ret = NT_STATUS_LOGON_FAILURE;
+	} else {
+		/* current_user_info is changed on new vuid */
+		reload_services(sconn->msg_ctx, sconn->sock, True);
+
+		SSVAL(req->outbuf, smb_vwv3, 0);
+
+		if (server_info->guest) {
+			SSVAL(req->outbuf,smb_vwv2,1);
+		}
+
+		SSVAL(req->outbuf, smb_uid, sess_vuid);
+
+		/* Successful logon. Keep this vuid. */
+		*p_invalidate_vuid = False;
+	}
+
+        /* wrap that up in a nice GSS-API wrapping */
+	if (NT_STATUS_IS_OK(ret)) {
+		ap_rep_wrapped = spnego_gen_krb5_wrap(talloc_tos(), ap_rep,
+				TOK_ID_KRB_AP_REP);
+	} else {
+		ap_rep_wrapped = data_blob_null;
+	}
+	response = spnego_gen_auth_response(talloc_tos(), &ap_rep_wrapped, ret,
+			mechOID);
+	reply_sesssetup_blob(req, response, ret);
+
+	data_blob_free(&ap_rep);
+	data_blob_free(&ap_rep_wrapped);
+	data_blob_free(&response);
+	TALLOC_FREE(mem_ctx);
+}
+
+#endif
+
+/****************************************************************************
+ Send a session setup reply, wrapped in SPNEGO.
+ Get vuid and check first.
+ End the NTLMSSP exchange context if we are OK/complete fail
+ This should be split into two functions, one to handle each
+ leg of the NTLM auth steps.
+***************************************************************************/
+
+static void reply_spnego_ntlmssp(struct smb_request *req,
+				 uint16 vuid,
+				 struct auth_ntlmssp_state **auth_ntlmssp_state,
+				 DATA_BLOB *ntlmssp_blob, NTSTATUS nt_status,
+				 const char *OID,
+				 bool wrap)
+{
+	bool do_invalidate = true;
+	DATA_BLOB response;
+	struct auth_serversupplied_info *session_info = NULL;
+	struct smbd_server_connection *sconn = req->sconn;
+
+	if (NT_STATUS_IS_OK(nt_status)) {
+		nt_status = auth_ntlmssp_steal_session_info(talloc_tos(),
+					(*auth_ntlmssp_state), &session_info);
+	} else {
+		/* Note that this session_info won't have a session
+		 * key.  But for map to guest, that's exactly the right
+		 * thing - we can't reasonably guess the key the
+		 * client wants, as the password was wrong */
+		nt_status = do_map_to_guest(nt_status,
+					    &session_info,
+					    auth_ntlmssp_get_username(*auth_ntlmssp_state),
+					    auth_ntlmssp_get_domain(*auth_ntlmssp_state));
+	}
+
+	reply_outbuf(req, 4, 0);
+
+	SSVAL(req->outbuf, smb_uid, vuid);
+
+	if (NT_STATUS_IS_OK(nt_status)) {
+		DATA_BLOB nullblob = data_blob_null;
+
+		if (!is_partial_auth_vuid(sconn, vuid)) {
+			nt_status = NT_STATUS_LOGON_FAILURE;
+			goto out;
+		}
+
+		/* register_existing_vuid keeps the server info */
+		if (register_existing_vuid(sconn, vuid,
+					   session_info, nullblob,
+					   auth_ntlmssp_get_username(*auth_ntlmssp_state)) !=
+					   vuid) {
+			/* The problem is, *auth_ntlmssp_state points
+			 * into the vuser this will have
+			 * talloc_free()'ed in
+			 * register_existing_vuid() */
+			do_invalidate = false;
+			nt_status = NT_STATUS_LOGON_FAILURE;
+			goto out;
+		}
+
+		/* current_user_info is changed on new vuid */
+		reload_services(sconn->msg_ctx, sconn->sock, True);
+
+		SSVAL(req->outbuf, smb_vwv3, 0);
+
+		if (session_info->guest) {
+			SSVAL(req->outbuf,smb_vwv2,1);
+		}
+	}
+
+  out:
+
+	if (wrap) {
+		response = spnego_gen_auth_response(talloc_tos(),
+				ntlmssp_blob,
+				nt_status, OID);
+	} else {
+		response = *ntlmssp_blob;
+	}
+
+	reply_sesssetup_blob(req, response, nt_status);
+	if (wrap) {
+		data_blob_free(&response);
+	}
+
+	/* NT_STATUS_MORE_PROCESSING_REQUIRED from our NTLMSSP code tells us,
+	   and the other end, that we are not finished yet. */
+
+	if (!NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		/* NB. This is *NOT* an error case. JRA */
+		if (do_invalidate) {
+			TALLOC_FREE(*auth_ntlmssp_state);
+			if (!NT_STATUS_IS_OK(nt_status)) {
+				/* Kill the intermediate vuid */
+				invalidate_vuid(sconn, vuid);
+			}
+		}
+	}
+}
+
+/****************************************************************************
+ Is this a krb5 mechanism ?
+****************************************************************************/
+
+NTSTATUS parse_spnego_mechanisms(TALLOC_CTX *ctx,
+		DATA_BLOB blob_in,
+		DATA_BLOB *pblob_out,
+		char **kerb_mechOID)
+{
+	char *OIDs[ASN1_MAX_OIDS];
+	int i;
+	NTSTATUS ret = NT_STATUS_OK;
+
+	*kerb_mechOID = NULL;
+
+	/* parse out the OIDs and the first sec blob */
+	if (!spnego_parse_negTokenInit(ctx, blob_in, OIDs, NULL, pblob_out) ||
+			(OIDs[0] == NULL)) {
+		return NT_STATUS_LOGON_FAILURE;
+	}
+
+	/* only look at the first OID for determining the mechToken --
+	   according to RFC2478, we should choose the one we want
+	   and renegotiate, but i smell a client bug here..
+
+	   Problem observed when connecting to a member (samba box)
+	   of an AD domain as a user in a Samba domain.  Samba member
+	   server sent back krb5/mskrb5/ntlmssp as mechtypes, but the
+	   client (2ksp3) replied with ntlmssp/mskrb5/krb5 and an
+	   NTLMSSP mechtoken.                 --jerry              */
+
+#ifdef HAVE_KRB5
+	if (strcmp(OID_KERBEROS5, OIDs[0]) == 0 ||
+	    strcmp(OID_KERBEROS5_OLD, OIDs[0]) == 0) {
+		*kerb_mechOID = talloc_strdup(ctx, OIDs[0]);
+		if (*kerb_mechOID == NULL) {
+			ret = NT_STATUS_NO_MEMORY;
+		}
+	}
+#endif
+
+	for (i=0;OIDs[i];i++) {
+		DEBUG(5,("parse_spnego_mechanisms: Got OID %s\n", OIDs[i]));
+		talloc_free(OIDs[i]);
+	}
+	return ret;
+}
+
+/****************************************************************************
+ Fall back from krb5 to NTLMSSP.
+****************************************************************************/
+
+static void reply_spnego_downgrade_to_ntlmssp(struct smb_request *req,
+						uint16 vuid)
+{
+	DATA_BLOB response;
+
+	reply_outbuf(req, 4, 0);
+        SSVAL(req->outbuf,smb_uid,vuid);
+
+	DEBUG(3,("reply_spnego_downgrade_to_ntlmssp: Got krb5 ticket in SPNEGO "
+		"but set to downgrade to NTLMSSP\n"));
+
+	response = spnego_gen_auth_response(talloc_tos(), NULL,
+			NT_STATUS_MORE_PROCESSING_REQUIRED,
+			OID_NTLMSSP);
+	reply_sesssetup_blob(req, response, NT_STATUS_MORE_PROCESSING_REQUIRED);
+	data_blob_free(&response);
+}
+
+/****************************************************************************
+ Reply to a session setup spnego negotiate packet.
+****************************************************************************/
+
+static void reply_spnego_negotiate(struct smb_request *req,
+				   uint16 vuid,
+				   DATA_BLOB blob1,
+				   struct auth_ntlmssp_state **auth_ntlmssp_state)
+{
+	DATA_BLOB secblob;
+	DATA_BLOB chal;
+	char *kerb_mech = NULL;
+	NTSTATUS status;
+	struct smbd_server_connection *sconn = req->sconn;
+
+	status = parse_spnego_mechanisms(talloc_tos(),
+			blob1, &secblob, &kerb_mech);
+	if (!NT_STATUS_IS_OK(status)) {
+		/* Kill the intermediate vuid */
+		invalidate_vuid(sconn, vuid);
+		reply_nterror(req, nt_status_squash(status));
+		return;
+	}
+
+	DEBUG(3,("reply_spnego_negotiate: Got secblob of size %lu\n",
+				(unsigned long)secblob.length));
+
+#ifdef HAVE_KRB5
+	if (kerb_mech && ((lp_security()==SEC_ADS) ||
+				USE_KERBEROS_KEYTAB) ) {
+		bool destroy_vuid = True;
+		reply_spnego_kerberos(req, &secblob, kerb_mech,
+				      vuid, &destroy_vuid);
+		data_blob_free(&secblob);
+		if (destroy_vuid) {
+			/* Kill the intermediate vuid */
+			invalidate_vuid(sconn, vuid);
+		}
+		TALLOC_FREE(kerb_mech);
+		return;
+	}
+#endif
+
+	TALLOC_FREE(*auth_ntlmssp_state);
+
+	if (kerb_mech) {
+		data_blob_free(&secblob);
+		/* The mechtoken is a krb5 ticket, but
+		 * we need to fall back to NTLM. */
+		reply_spnego_downgrade_to_ntlmssp(req, vuid);
+		TALLOC_FREE(kerb_mech);
+		return;
+	}
+
+	status = auth_ntlmssp_start(auth_ntlmssp_state);
+	if (!NT_STATUS_IS_OK(status)) {
+		/* Kill the intermediate vuid */
+		invalidate_vuid(sconn, vuid);
+		reply_nterror(req, nt_status_squash(status));
+		return;
+	}
+
+	status = auth_ntlmssp_update(*auth_ntlmssp_state,
+					secblob, &chal);
+
+	data_blob_free(&secblob);
+
+	reply_spnego_ntlmssp(req, vuid, auth_ntlmssp_state,
+			     &chal, status, OID_NTLMSSP, true);
+
+	data_blob_free(&chal);
+
+	/* already replied */
+	return;
+}
+
+/****************************************************************************
+ Reply to a session setup spnego auth packet.
+****************************************************************************/
+
+static void reply_spnego_auth(struct smb_request *req,
+			      uint16 vuid,
+			      DATA_BLOB blob1,
+			      struct auth_ntlmssp_state **auth_ntlmssp_state)
+{
+	DATA_BLOB auth = data_blob_null;
+	DATA_BLOB auth_reply = data_blob_null;
+	DATA_BLOB secblob = data_blob_null;
+	NTSTATUS status = NT_STATUS_LOGON_FAILURE;
+	struct smbd_server_connection *sconn = req->sconn;
+
+	if (!spnego_parse_auth(talloc_tos(), blob1, &auth)) {
+#if 0
+		file_save("auth.dat", blob1.data, blob1.length);
+#endif
+		/* Kill the intermediate vuid */
+		invalidate_vuid(sconn, vuid);
+
+		reply_nterror(req, nt_status_squash(
+				      NT_STATUS_LOGON_FAILURE));
+		return;
+	}
+
+	if (auth.length > 0 && auth.data[0] == ASN1_APPLICATION(0)) {
+		/* Might be a second negTokenTarg packet */
+		char *kerb_mech = NULL;
+
+		status = parse_spnego_mechanisms(talloc_tos(),
+				auth, &secblob, &kerb_mech);
+
+		if (!NT_STATUS_IS_OK(status)) {
+			/* Kill the intermediate vuid */
+			invalidate_vuid(sconn, vuid);
+			reply_nterror(req, nt_status_squash(status));
+			return;
+		}
+
+		DEBUG(3,("reply_spnego_auth: Got secblob of size %lu\n",
+				(unsigned long)secblob.length));
+#ifdef HAVE_KRB5
+		if (kerb_mech && ((lp_security()==SEC_ADS) ||
+					USE_KERBEROS_KEYTAB)) {
+			bool destroy_vuid = True;
+			reply_spnego_kerberos(req, &secblob, kerb_mech,
+					      vuid, &destroy_vuid);
+			data_blob_free(&secblob);
+			data_blob_free(&auth);
+			if (destroy_vuid) {
+				/* Kill the intermediate vuid */
+				invalidate_vuid(sconn, vuid);
+			}
+			TALLOC_FREE(kerb_mech);
+			return;
+		}
+#endif
+		/* Can't blunder into NTLMSSP auth if we have
+		 * a krb5 ticket. */
+
+		if (kerb_mech) {
+			/* Kill the intermediate vuid */
+			invalidate_vuid(sconn, vuid);
+			DEBUG(3,("reply_spnego_auth: network "
+				"misconfiguration, client sent us a "
+				"krb5 ticket and kerberos security "
+				"not enabled\n"));
+			reply_nterror(req, nt_status_squash(
+					NT_STATUS_LOGON_FAILURE));
+			TALLOC_FREE(kerb_mech);
+		}
+	}
+
+	/* If we get here it wasn't a negTokenTarg auth packet. */
+	data_blob_free(&secblob);
+
+	if (!*auth_ntlmssp_state) {
+		status = auth_ntlmssp_start(auth_ntlmssp_state);
+		if (!NT_STATUS_IS_OK(status)) {
+			/* Kill the intermediate vuid */
+			invalidate_vuid(sconn, vuid);
+			reply_nterror(req, nt_status_squash(status));
+			return;
+		}
+	}
+
+	status = auth_ntlmssp_update(*auth_ntlmssp_state,
+					auth, &auth_reply);
+
+	data_blob_free(&auth);
+
+	/* Don't send the mechid as we've already sent this (RFC4178). */
+
+	reply_spnego_ntlmssp(req, vuid,
+			     auth_ntlmssp_state,
+			     &auth_reply, status, NULL, true);
+
+	data_blob_free(&auth_reply);
+
+	/* and tell smbd that we have already replied to this packet */
+	return;
+}
+
+/****************************************************************************
+ Delete an entry on the list.
+****************************************************************************/
+
+static void delete_partial_auth(struct smbd_server_connection *sconn,
+				struct pending_auth_data *pad)
+{
+	if (!pad) {
+		return;
+	}
+	DLIST_REMOVE(sconn->smb1.pd_list, pad);
+	data_blob_free(&pad->partial_data);
+	SAFE_FREE(pad);
+}
+
+/****************************************************************************
+ Search for a partial SPNEGO auth fragment matching an smbpid.
+****************************************************************************/
+
+static struct pending_auth_data *get_pending_auth_data(
+		struct smbd_server_connection *sconn,
+		uint16_t smbpid)
+{
+	struct pending_auth_data *pad;
+/*
+ * NOTE: using the smbpid here is completely wrong...
+ *       see [MS-SMB]
+ *       3.3.5.3 Receiving an SMB_COM_SESSION_SETUP_ANDX Request
+ */
+	for (pad = sconn->smb1.pd_list; pad; pad = pad->next) {
+		if (pad->smbpid == smbpid) {
+			break;
+		}
+	}
+	return pad;
+}
+
+/****************************************************************************
+ Check the size of an SPNEGO blob. If we need more return
+ NT_STATUS_MORE_PROCESSING_REQUIRED, else return NT_STATUS_OK. Don't allow
+ the blob to be more than 64k.
+****************************************************************************/
+
+static NTSTATUS check_spnego_blob_complete(struct smbd_server_connection *sconn,
+					   uint16 smbpid, uint16 vuid,
+					   DATA_BLOB *pblob)
+{
+	struct pending_auth_data *pad = NULL;
+	ASN1_DATA *data;
+	size_t needed_len = 0;
+
+	pad = get_pending_auth_data(sconn, smbpid);
+
+	/* Ensure we have some data. */
+	if (pblob->length == 0) {
+		/* Caller can cope. */
+		DEBUG(2,("check_spnego_blob_complete: zero blob length !\n"));
+		delete_partial_auth(sconn, pad);
+		return NT_STATUS_OK;
+	}
+
+	/* Were we waiting for more data ? */
+	if (pad) {
+		DATA_BLOB tmp_blob;
+		size_t copy_len = MIN(65536, pblob->length);
+
+		/* Integer wrap paranoia.... */
+
+		if (pad->partial_data.length + copy_len <
+				pad->partial_data.length ||
+		    pad->partial_data.length + copy_len < copy_len) {
+
+			DEBUG(2,("check_spnego_blob_complete: integer wrap "
+				"pad->partial_data.length = %u, "
+				"copy_len = %u\n",
+				(unsigned int)pad->partial_data.length,
+				(unsigned int)copy_len ));
+
+			delete_partial_auth(sconn, pad);
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+
+		DEBUG(10,("check_spnego_blob_complete: "
+			"pad->partial_data.length = %u, "
+			"pad->needed_len = %u, "
+			"copy_len = %u, "
+			"pblob->length = %u,\n",
+			(unsigned int)pad->partial_data.length,
+			(unsigned int)pad->needed_len,
+			(unsigned int)copy_len,
+			(unsigned int)pblob->length ));
+
+		if (pblob->length > pad->needed_len) {
+			DEBUG(2, ("subsequent security token data length %u "
+				  "exceeds expected length %u\n",
+				  (unsigned int)pblob->length,
+				  (unsigned int)pad->needed_len));
+		}
+
+		tmp_blob = data_blob(NULL,
+				pad->partial_data.length + copy_len);
+
+		/* Concatenate the two (up to copy_len) bytes. */
+		memcpy(tmp_blob.data,
+			pad->partial_data.data,
+			pad->partial_data.length);
+		memcpy(tmp_blob.data + pad->partial_data.length,
+			pblob->data,
+			copy_len);
+
+		/* Replace the partial data. */
+		data_blob_free(&pad->partial_data);
+		pad->partial_data = tmp_blob;
+		ZERO_STRUCT(tmp_blob);
+
+		/* Are we done ? */
+		if (pblob->length >= pad->needed_len) {
+			/* Yes, replace pblob. */
+			data_blob_free(pblob);
+			*pblob = pad->partial_data;
+			ZERO_STRUCT(pad->partial_data);
+			delete_partial_auth(sconn, pad);
+			return NT_STATUS_OK;
+		}
+
+		/* Still need more data. */
+		pad->needed_len -= copy_len;
+		return NT_STATUS_MORE_PROCESSING_REQUIRED;
+	}
+
+	if ((pblob->data[0] != ASN1_APPLICATION(0)) &&
+	    (pblob->data[0] != ASN1_CONTEXT(1))) {
+		/* Not something we can determine the
+		 * length of.
+		 */
+		return NT_STATUS_OK;
+	}
+
+	/* This is a new SPNEGO sessionsetup - see if
+	 * the data given in this blob is enough.
+	 */
+
+	data = asn1_init(NULL);
+	if (data == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	asn1_load(data, *pblob);
+	if (asn1_start_tag(data, pblob->data[0])) {
+		/* asn1_start_tag checks if the given
+		   length of the blob is enough to complete
+		   the tag. If it returns true we know
+		   there is nothing to do - the blob is
+		   complete. */
+		asn1_free(data);
+		return NT_STATUS_OK;
+	}
+
+	if (data->nesting == NULL) {
+		/* Incorrect tag, allocation failed,
+		   or reading the tag length failed.
+		   Let the caller catch. */
+		asn1_free(data);
+		return NT_STATUS_OK;
+	}
+
+	/* Here we know asn1_start_tag() has set data->has_error to true.
+	   asn1_tag_remaining() will have failed due to the given blob
+	   being too short. We need to work out how short. */
+
+	/* Integer wrap paranoia.... */
+
+	if (data->nesting->taglen + data->nesting->start < data->nesting->taglen ||
+	    data->nesting->taglen + data->nesting->start < data->nesting->start) {
+
+		DEBUG(2,("check_spnego_blob_complete: integer wrap "
+			"data.nesting->taglen = %u, "
+			"data.nesting->start = %u\n",
+			(unsigned int)data->nesting->taglen,
+			(unsigned int)data->nesting->start ));
+
+		asn1_free(data);
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	/* Total length of the needed asn1 is the tag length
+	 * plus the current offset. */
+
+	needed_len = data->nesting->taglen + data->nesting->start;
+	asn1_free(data);
+
+	DEBUG(10,("check_spnego_blob_complete: needed_len = %u, "
+		"pblob->length = %u\n",
+		(unsigned int)needed_len,
+		(unsigned int)pblob->length ));
+
+	if (needed_len <= pblob->length) {
+		/* Nothing to do - blob is complete. */
+		/* THIS SHOULD NOT HAPPEN - asn1_start_tag()
+		   above should have caught this !!! */
+		DEBUG(0,("check_spnego_blob_complete: logic "
+			"error (needed_len = %u, "
+			"pblob->length = %u).\n",
+			(unsigned int)needed_len,
+			(unsigned int)pblob->length ));
+		return NT_STATUS_OK;
+	}
+
+	/* Refuse the blob if it's bigger than 64k. */
+	if (needed_len > 65536) {
+		DEBUG(2,("check_spnego_blob_complete: needed_len "
+			"too large (%u)\n",
+			(unsigned int)needed_len ));
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	/* We must store this blob until complete. */
+	if (!(pad = SMB_MALLOC_P(struct pending_auth_data))) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	pad->needed_len = needed_len - pblob->length;
+	pad->partial_data = data_blob(pblob->data, pblob->length);
+	if (pad->partial_data.data == NULL) {
+		SAFE_FREE(pad);
+		return NT_STATUS_NO_MEMORY;
+	}
+	pad->smbpid = smbpid;
+	pad->vuid = vuid;
+	DLIST_ADD(sconn->smb1.pd_list, pad);
+
+	return NT_STATUS_MORE_PROCESSING_REQUIRED;
+}
+
 /****************************************************************************
  Reply to a session setup command.
  conn POINTER CAN BE NULL HERE !
@@ -116,8 +1054,7 @@
 static void reply_sesssetup_and_X_spnego(struct smb_request *req)
 {
 	const uint8 *p;
-	DATA_BLOB in_blob;
-	DATA_BLOB out_blob = data_blob_null;
+	DATA_BLOB blob1;
 	size_t bufrem;
 	char *tmp;
 	const char *native_os;
@@ -126,23 +1063,21 @@
 	const char *p2;
 	uint16 data_blob_len = SVAL(req->vwv+7, 0);
 	enum remote_arch_types ra_type = get_remote_arch();
-	uint64_t vuid = req->vuid;
+	int vuid = req->vuid;
+	user_struct *vuser = NULL;
 	NTSTATUS status = NT_STATUS_OK;
+	uint16 smbpid = req->smbpid;
 	struct smbd_server_connection *sconn = req->sconn;
-	uint16_t action = 0;
-	NTTIME now = timeval_to_nttime(&req->request_time);
-	struct smbXsrv_session *session = NULL;
-	uint16_t smb_bufsize = SVAL(req->vwv+2, 0);
-	uint32_t client_caps = IVAL(req->vwv+10, 0);
 
 	DEBUG(3,("Doing spnego session setup\n"));
 
-	if (!sconn->smb1.sessions.done_sesssetup) {
-		global_client_caps = client_caps;
+	if (global_client_caps == 0) {
+		global_client_caps = IVAL(req->vwv+10, 0);
 
 		if (!(global_client_caps & CAP_STATUS32)) {
 			remove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);
 		}
+
 	}
 
 	p = req->buf;
@@ -155,13 +1090,13 @@
 
 	bufrem = smbreq_bufrem(req, p);
 	/* pull the spnego blob */
-	in_blob = data_blob_const(p, MIN(bufrem, data_blob_len));
+	blob1 = data_blob(p, MIN(bufrem, data_blob_len));
 
 #if 0
-	file_save("negotiate.dat", in_blob.data, in_blob.length);
+	file_save("negotiate.dat", blob1.data, blob1.length);
 #endif
 
-	p2 = (const char *)req->buf + in_blob.length;
+	p2 = (char *)req->buf + blob1.length;
 
 	p2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,
 				     STR_TERMINATE);
@@ -198,293 +1133,112 @@
 		}
 	}
 
-	if (vuid != 0) {
-		status = smb1srv_session_lookup(sconn->conn,
-						vuid, now,
-						&session);
-		if (NT_STATUS_EQUAL(status, NT_STATUS_USER_SESSION_DELETED)) {
-			reply_force_doserror(req, ERRSRV, ERRbaduid);
-			return;
-		}
-		if (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {
-			status = NT_STATUS_OK;
-		}
-		if (NT_STATUS_IS_OK(status)) {
-			session->status = NT_STATUS_MORE_PROCESSING_REQUIRED;
-			status = NT_STATUS_MORE_PROCESSING_REQUIRED;
-			TALLOC_FREE(session->gensec);
-		}
-		if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-			reply_nterror(req, nt_status_squash(status));
-			return;
+	/* Did we get a valid vuid ? */
+	if (!is_partial_auth_vuid(sconn, vuid)) {
+		/* No, then try and see if this is an intermediate sessionsetup
+		 * for a large SPNEGO packet. */
+		struct pending_auth_data *pad;
+		pad = get_pending_auth_data(sconn, smbpid);
+		if (pad) {
+			DEBUG(10,("reply_sesssetup_and_X_spnego: found "
+				"pending vuid %u\n",
+				(unsigned int)pad->vuid ));
+			vuid = pad->vuid;
 		}
 	}
 
-	if (session == NULL) {
-		/* create a new session */
-		status = smbXsrv_session_create(sconn->conn,
-					        now, &session);
-		if (!NT_STATUS_IS_OK(status)) {
-			reply_nterror(req, nt_status_squash(status));
+	/* Do we have a valid vuid now ? */
+	if (!is_partial_auth_vuid(sconn, vuid)) {
+		/* No, start a new authentication setup. */
+		vuid = register_initial_vuid(sconn);
+		if (vuid == UID_FIELD_INVALID) {
+			data_blob_free(&blob1);
+			reply_nterror(req, nt_status_squash(
+					      NT_STATUS_INVALID_PARAMETER));
 			return;
 		}
 	}
 
-	if (!session->gensec) {
-		status = auth_generic_prepare(session, sconn->remote_address,
-					      &session->gensec);
-		if (!NT_STATUS_IS_OK(status)) {
-			TALLOC_FREE(session);
-			reply_nterror(req, nt_status_squash(status));
-			return;
-		}
+	vuser = get_partial_auth_user_struct(sconn, vuid);
+	/* This MUST be valid. */
+	if (!vuser) {
+		smb_panic("reply_sesssetup_and_X_spnego: invalid vuid.");
+	}
 
-		gensec_want_feature(session->gensec, GENSEC_FEATURE_SESSION_KEY);
-		gensec_want_feature(session->gensec, GENSEC_FEATURE_UNIX_TOKEN);
+	/* Large (greater than 4k) SPNEGO blobs are split into multiple
+	 * sessionsetup requests as the Windows limit on the security blob
+	 * field is 4k. Bug #4400. JRA.
+	 */
 
-		status = gensec_start_mech_by_oid(session->gensec,
-						  GENSEC_OID_SPNEGO);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0, ("Failed to start SPNEGO handler!\n"));
-			TALLOC_FREE(session);;
-			reply_nterror(req, nt_status_squash(status));
-			return;
+	status = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);
+	if (!NT_STATUS_IS_OK(status)) {
+		/*
+		 * Pack error response, ensuring to fill NativeOS, NativeLanMan
+		 * & PrimaryDomain fields on NT_STATUS_MORE_PROCESSING_REQUIRED
+		 */
+		reply_outbuf(req, 4, 0);
+		reply_sesssetup_blob(req, data_blob_null, status);
+		if (!NT_STATUS_EQUAL(status,
+				NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+			/* Real error - kill the intermediate vuid */
+			invalidate_vuid(sconn, vuid);
 		}
-	}
-
-	become_root();
-	status = gensec_update(session->gensec,
-			       talloc_tos(), NULL,
-			       in_blob, &out_blob);
-	unbecome_root();
-	if (!NT_STATUS_IS_OK(status) &&
-	    !NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-		TALLOC_FREE(session);
-		reply_nterror(req, nt_status_squash(status));
+		data_blob_free(&blob1);
 		return;
 	}
 
-	if (NT_STATUS_IS_OK(status) && session->global->auth_session_info == NULL) {
-		struct auth_session_info *session_info = NULL;
+	if (blob1.data[0] == ASN1_APPLICATION(0)) {
 
-		status = gensec_session_info(session->gensec,
-					     session,
-					     &session_info);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(1,("Failed to generate session_info "
-				 "(user and group token) for session setup: %s\n",
-				 nt_errstr(status)));
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, nt_status_squash(status));
-			return;
-		}
-
-		if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
-			action = 1;
-		}
-
-		if (session_info->session_key.length > 0) {
-			struct smbXsrv_session *x = session;
+		/* its a negTokenTarg packet */
 
-			/*
-			 * Note: the SMB1 signing key is not truncated to 16 byte!
-			 */
-			x->global->signing_key =
-				data_blob_dup_talloc(x->global,
-						     session_info->session_key);
-			if (x->global->signing_key.data == NULL) {
-				data_blob_free(&out_blob);
-				TALLOC_FREE(session);
-				reply_nterror(req, NT_STATUS_NO_MEMORY);
-				return;
-			}
+		reply_spnego_negotiate(req, vuid, blob1,
+				       &vuser->auth_ntlmssp_state);
+		data_blob_free(&blob1);
+		return;
+	}
 
-			/*
-			 * clear the session key
-			 * the first tcon will add setup the application key
-			 */
-			data_blob_clear_free(&session_info->session_key);
-		}
+	if (blob1.data[0] == ASN1_CONTEXT(1)) {
 
-		session->compat = talloc_zero(session, struct user_struct);
-		if (session->compat == NULL) {
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			return;
-		}
-		session->compat->session = session;
-		session->compat->homes_snum = -1;
-		session->compat->session_info = session_info;
-		session->compat->session_keystr = NULL;
-		session->compat->vuid = session->global->session_wire_id;
-		DLIST_ADD(sconn->users, session->compat);
-		sconn->num_users++;
-
-		if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
-			session->compat->homes_snum =
-				register_homes_share(session_info->unix_info->unix_name);
-		}
-
-		if (srv_is_signing_negotiated(sconn) &&
-		    action == 0 &&
-		    session->global->signing_key.length > 0)
-		{
-			/*
-			 * Try and turn on server signing on the first non-guest
-			 * sessionsetup.
-			 */
-			srv_set_signing(sconn,
-				session->global->signing_key,
-				data_blob_null);
-		}
-
-		set_current_user_info(session_info->unix_info->sanitized_username,
-				      session_info->unix_info->unix_name,
-				      session_info->info->domain_name);
-
-		session->status = NT_STATUS_OK;
-		session->global->auth_session_info = talloc_move(session->global,
-								 &session_info);
-		session->global->auth_session_info_seqnum += 1;
-		session->global->channels[0].auth_session_info_seqnum =
-			session->global->auth_session_info_seqnum;
-		if (client_caps & CAP_DYNAMIC_REAUTH) {
-			session->global->expiration_time =
-				gensec_expire_time(session->gensec);
-		} else {
-			session->global->expiration_time =
-				GENSEC_EXPIRE_TIME_INFINITY;
-		}
+		/* its a auth packet */
 
-		if (!session_claim(session)) {
-			DEBUG(1, ("smb1: Failed to claim session for vuid=%llu\n",
-				  (unsigned long long)session->compat->vuid));
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_LOGON_FAILURE);
-			return;
-		}
+		reply_spnego_auth(req, vuid, blob1,
+				  &vuser->auth_ntlmssp_state);
+		data_blob_free(&blob1);
+		return;
+	}
 
-		status = smbXsrv_session_update(session);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0, ("smb1: Failed to update session for vuid=%llu - %s\n",
-				  (unsigned long long)session->compat->vuid,
-				  nt_errstr(status)));
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_LOGON_FAILURE);
-			return;
-		}
+	if (strncmp((char *)(blob1.data), "NTLMSSP", 7) == 0) {
+		DATA_BLOB chal;
 
-		if (!sconn->smb1.sessions.done_sesssetup) {
-			if (smb_bufsize < SMB_BUFFER_SIZE_MIN) {
-				reply_force_doserror(req, ERRSRV, ERRerror);
+		if (!vuser->auth_ntlmssp_state) {
+			status = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);
+			if (!NT_STATUS_IS_OK(status)) {
+				/* Kill the intermediate vuid */
+				invalidate_vuid(sconn, vuid);
+				data_blob_free(&blob1);
+				reply_nterror(req, nt_status_squash(status));
 				return;
 			}
-			sconn->smb1.sessions.max_send = smb_bufsize;
-			sconn->smb1.sessions.done_sesssetup = true;
-		}
-
-		/* current_user_info is changed on new vuid */
-		reload_services(sconn, conn_snum_used, true);
-	} else if (NT_STATUS_IS_OK(status)) {
-		struct auth_session_info *session_info = NULL;
-
-		status = gensec_session_info(session->gensec,
-					     session,
-					     &session_info);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(1,("Failed to generate session_info "
-				 "(user and group token) for session setup: %s\n",
-				 nt_errstr(status)));
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, nt_status_squash(status));
-			return;
-		}
-
-		if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
-			action = 1;
-		}
-
-		/*
-		 * Keep the application key
-		 */
-		data_blob_clear_free(&session_info->session_key);
-		session_info->session_key =
-			session->global->auth_session_info->session_key;
-		talloc_steal(session_info, session_info->session_key.data);
-		TALLOC_FREE(session->global->auth_session_info);
-
-		session->compat->session_info = session_info;
-
-		session->compat->vuid = session->global->session_wire_id;
-
-		if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
-			session->compat->homes_snum =
-				register_homes_share(session_info->unix_info->unix_name);
-		}
-
-		set_current_user_info(session_info->unix_info->sanitized_username,
-				      session_info->unix_info->unix_name,
-				      session_info->info->domain_name);
-
-		session->status = NT_STATUS_OK;
-		session->global->auth_session_info = talloc_move(session->global,
-								 &session_info);
-		session->global->auth_session_info_seqnum += 1;
-		session->global->channels[0].auth_session_info_seqnum =
-			session->global->auth_session_info_seqnum;
-		if (client_caps & CAP_DYNAMIC_REAUTH) {
-			session->global->expiration_time =
-				gensec_expire_time(session->gensec);
-		} else {
-			session->global->expiration_time =
-				GENSEC_EXPIRE_TIME_INFINITY;
 		}
 
-		status = smbXsrv_session_update(session);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(0, ("smb1: Failed to update session for vuid=%llu - %s\n",
-				  (unsigned long long)session->compat->vuid,
-				  nt_errstr(status)));
-			data_blob_free(&out_blob);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_LOGON_FAILURE);
-			return;
-		}
+		status = auth_ntlmssp_update(vuser->auth_ntlmssp_state,
+						blob1, &chal);
 
-		conn_clear_vuid_caches(sconn, session->compat->vuid);
+		data_blob_free(&blob1);
 
-		/* current_user_info is changed on new vuid */
-		reload_services(sconn, conn_snum_used, true);
+		reply_spnego_ntlmssp(req, vuid,
+				     &vuser->auth_ntlmssp_state,
+				     &chal, status, OID_NTLMSSP, false);
+		data_blob_free(&chal);
+		return;
 	}
 
-	vuid = session->global->session_wire_id;
+	/* what sort of packet is this? */
+	DEBUG(1,("Unknown packet in reply_sesssetup_and_X_spnego\n"));
 
-	reply_outbuf(req, 4, 0);
+	data_blob_free(&blob1);
 
-	SSVAL(req->outbuf, smb_uid, vuid);
-	SIVAL(req->outbuf, smb_rcls, NT_STATUS_V(status));
-	SSVAL(req->outbuf, smb_vwv0, 0xFF); /* no chaining possible */
-	SSVAL(req->outbuf, smb_vwv2, action);
-	SSVAL(req->outbuf, smb_vwv3, out_blob.length);
-
-	if (message_push_blob(&req->outbuf, out_blob) == -1) {
-		data_blob_free(&out_blob);
-		TALLOC_FREE(session);
-		reply_nterror(req, NT_STATUS_NO_MEMORY);
-		return;
-	}
-	data_blob_free(&out_blob);
-
-	if (push_signature(&req->outbuf) == -1) {
-		TALLOC_FREE(session);
-		reply_nterror(req, NT_STATUS_NO_MEMORY);
-		return;
-	}
+	reply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));
 }
 
 /****************************************************************************
@@ -498,43 +1252,35 @@
 	struct messaging_context *msg_ctx;
 };
 
-static int shutdown_other_smbds(struct smbXsrv_session_global0 *session,
+static int shutdown_other_smbds(const struct connections_key *key,
+				const struct connections_data *crec,
 				void *private_data)
 {
 	struct shutdown_state *state = (struct shutdown_state *)private_data;
-	struct server_id self_pid = messaging_server_id(state->msg_ctx);
-	struct server_id pid = session->channels[0].server_id;
-	const char *addr = session->channels[0].remote_address;
 
 	DEBUG(10, ("shutdown_other_smbds: %s, %s\n",
-		   server_id_str(talloc_tos(), &pid), addr));
+		   procid_str(talloc_tos(), &crec->pid), crec->addr));
 
-	if (!process_exists(pid)) {
+	if (!process_exists(crec->pid)) {
 		DEBUG(10, ("process does not exist\n"));
 		return 0;
 	}
 
-	if (serverid_equal(&pid, &self_pid)) {
+	if (procid_is_me(&crec->pid)) {
 		DEBUG(10, ("It's me\n"));
 		return 0;
 	}
 
-	/*
-	 * here we use strstr() because 'addr'
-	 * (session->channels[0].remote_address)
-	 * contains a string like:
-	 * 'ipv4:127.0.0.1:48163'
-	 */
-	if (strstr(addr, state->ip)  == NULL) {
-		DEBUG(10, ("%s does not match %s\n", state->ip, addr));
+	if (strcmp(state->ip, crec->addr) != 0) {
+		DEBUG(10, ("%s does not match %s\n", state->ip, crec->addr));
 		return 0;
 	}
 
 	DEBUG(1, ("shutdown_other_smbds: shutting down pid %u "
-		  "(IP %s)\n", (unsigned int)procid_to_pid(&pid),
+		  "(IP %s)\n", (unsigned int)procid_to_pid(&crec->pid),
 		  state->ip));
 
-	messaging_send(state->msg_ctx, pid, MSG_SHUTDOWN,
+	messaging_send(state->msg_ctx, crec->pid, MSG_SHUTDOWN,
 		       &data_blob_null);
 	return 0;
 }
@@ -558,7 +1304,7 @@
 		}
 		state.ip = addr;
 		state.msg_ctx = sconn->msg_ctx;
-		smbXsrv_session_global_traverse(shutdown_other_smbds, &state);
+		connections_forall_read(shutdown_other_smbds, &state);
 		TALLOC_FREE(addr);
 	}
 }
@@ -569,8 +1315,8 @@
 
 void reply_sesssetup_and_X(struct smb_request *req)
 {
-	uint64_t sess_vuid;
-	uint16_t smb_bufsize;
+	int sess_vuid;
+	int smb_bufsize;
 	DATA_BLOB lm_resp;
 	DATA_BLOB nt_resp;
 	DATA_BLOB plaintext_password;
@@ -582,18 +1328,13 @@
 	const char *native_lanman;
 	const char *primary_domain;
 	struct auth_usersupplied_info *user_info = NULL;
-	struct auth_session_info *session_info = NULL;
+	struct auth_serversupplied_info *server_info = NULL;
 	uint16 smb_flag2 = req->flags2;
-	uint16_t action = 0;
-	NTTIME now = timeval_to_nttime(&req->request_time);
-	struct smbXsrv_session *session = NULL;
 
 	NTSTATUS nt_status;
 	struct smbd_server_connection *sconn = req->sconn;
 
 	bool doencrypt = sconn->smb1.negprot.encrypted_passwords;
-	bool signing_allowed = false;
-	bool signing_mandatory = false;
 
 	START_PROFILE(SMBsesssetupX);
 
@@ -603,22 +1344,6 @@
 
 	DEBUG(3,("wct=%d flg2=0x%x\n", req->wct, req->flags2));
 
-	if (req->flags2 & FLAGS2_SMB_SECURITY_SIGNATURES) {
-		signing_allowed = true;
-	}
-	if (req->flags2 & FLAGS2_SMB_SECURITY_SIGNATURES_REQUIRED) {
-		signing_mandatory = true;
-	}
-
-	/*
-	 * We can call srv_set_signing_negotiated() each time.
-	 * It finds out when it needs to turn into a noop
-	 * itself.
-	 */
-	srv_set_signing_negotiated(req->sconn,
-				   signing_allowed,
-				   signing_mandatory);
-
 	/* a SPNEGO session setup has 12 command words, whereas a normal
 	   NT1 session setup has 13. See the cifs spec. */
 	if (req->wct == 12 &&
@@ -681,7 +1406,8 @@
 		const uint8_t *save_p = req->buf;
 		uint16 byte_count;
 
-		if (!sconn->smb1.sessions.done_sesssetup) {
+
+		if(global_client_caps == 0) {
 			global_client_caps = IVAL(req->vwv+11, 0);
 
 			if (!(global_client_caps & CAP_STATUS32)) {
@@ -748,7 +1474,11 @@
 		if (doencrypt) {
 			lm_resp = data_blob(p, passlen1);
 			nt_resp = data_blob(p+passlen1, passlen2);
-		} else {
+		} else if (lp_security() != SEC_SHARE) {
+			/*
+			 * In share level we should ignore any passwords, so
+ 			 * only read them if we're not.
+ 			 */
 			char *pass = NULL;
 			bool unic= smb_flag2 & FLAGS2_UNICODE_STRINGS;
 
@@ -849,19 +1579,40 @@
 		}
 		fstrcpy(sub_user, user);
 	} else {
-		fstrcpy(sub_user, "");
+		fstrcpy(sub_user, lp_guestaccount());
 	}
 
 	sub_set_smb_name(sub_user);
 
-	reload_services(sconn, conn_snum_used, true);
+	reload_services(sconn->msg_ctx, sconn->sock, True);
+
+	if (lp_security() == SEC_SHARE) {
+		char *sub_user_mapped = NULL;
+		/* In share level we should ignore any passwords */
+
+		data_blob_free(&lm_resp);
+		data_blob_free(&nt_resp);
+		data_blob_clear_free(&plaintext_password);
+
+		(void)map_username(talloc_tos(), sub_user, &sub_user_mapped);
+		if (!sub_user_mapped) {
+			reply_nterror(req, NT_STATUS_NO_MEMORY);
+			END_PROFILE(SMBsesssetupX);
+			return;
+		}
+		fstrcpy(sub_user, sub_user_mapped);
+		add_session_user(sconn, sub_user);
+		add_session_workgroup(sconn, domain);
+		/* Then force it to null for the benfit of the code below */
+		user = "";
+	}
 
 	if (!*user) {
 
-		nt_status = check_guest_password(sconn->remote_address, req, &session_info);
+		nt_status = check_guest_password(&server_info);
 
 	} else if (doencrypt) {
-		struct auth4_context *negprot_auth_context = NULL;
+		struct auth_context *negprot_auth_context = NULL;
 		negprot_auth_context = sconn->smb1.negprot.auth_context;
 		if (!negprot_auth_context) {
 			DEBUG(0, ("reply_sesssetup_and_X:  Attempted encrypted "
@@ -873,16 +1624,17 @@
 		}
 		nt_status = make_user_info_for_reply_enc(&user_info, user,
 						domain,
-						sconn->remote_address,
 						lm_resp, nt_resp);
 		if (NT_STATUS_IS_OK(nt_status)) {
-			nt_status = auth_check_password_session_info(negprot_auth_context, 
-								     req, user_info, &session_info);
+			nt_status = negprot_auth_context->check_ntlm_password(
+					negprot_auth_context,
+					user_info,
+					&server_info);
 		}
 	} else {
-		struct auth4_context *plaintext_auth_context = NULL;
+		struct auth_context *plaintext_auth_context = NULL;
 
-		nt_status = make_auth4_context(
+		nt_status = make_auth_context_subsystem(
 			talloc_tos(), &plaintext_auth_context);
 
 		if (NT_STATUS_IS_OK(nt_status)) {
@@ -892,24 +1644,30 @@
 					plaintext_auth_context, chal);
 
 			if (!make_user_info_for_reply(&user_info,
-						      user, domain,
-						      sconn->remote_address,
-						      chal,
+						      user, domain, chal,
 						      plaintext_password)) {
 				nt_status = NT_STATUS_NO_MEMORY;
 			}
 
 			if (NT_STATUS_IS_OK(nt_status)) {
-				nt_status = auth_check_password_session_info(plaintext_auth_context, 
-									     req, user_info, &session_info);
+				nt_status = plaintext_auth_context->check_ntlm_password(
+						plaintext_auth_context,
+						user_info,
+						&server_info);
+
+				TALLOC_FREE(plaintext_auth_context);
 			}
-			TALLOC_FREE(plaintext_auth_context);
 		}
 	}
 
 	free_user_info(&user_info);
 
 	if (!NT_STATUS_IS_OK(nt_status)) {
+		nt_status = do_map_to_guest(nt_status, &server_info,
+				user, domain);
+	}
+
+	if (!NT_STATUS_IS_OK(nt_status)) {
 		data_blob_free(&nt_resp);
 		data_blob_free(&lm_resp);
 		data_blob_clear_free(&plaintext_password);
@@ -918,183 +1676,91 @@
 		return;
 	}
 
+	/* Ensure we can't possible take a code path leading to a
+	 * null defref. */
+	if (!server_info) {
+		reply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));
+		END_PROFILE(SMBsesssetupX);
+		return;
+	}
+
+	if (!server_info->security_token) {
+		nt_status = create_local_token(server_info);
+
+		if (!NT_STATUS_IS_OK(nt_status)) {
+			DEBUG(10, ("create_local_token failed: %s\n",
+				   nt_errstr(nt_status)));
+			data_blob_free(&nt_resp);
+			data_blob_free(&lm_resp);
+			data_blob_clear_free(&plaintext_password);
+			reply_nterror(req, nt_status_squash(nt_status));
+			END_PROFILE(SMBsesssetupX);
+			return;
+		}
+	}
+
 	data_blob_clear_free(&plaintext_password);
 
 	/* it's ok - setup a reply */
 	reply_outbuf(req, 3, 0);
-	SSVAL(req->outbuf, smb_vwv0, 0xff); /* andx chain ends */
-	SSVAL(req->outbuf, smb_vwv1, 0);    /* no andx offset */
-
 	if (get_Protocol() >= PROTOCOL_NT1) {
 		push_signature(&req->outbuf);
 		/* perhaps grab OS version here?? */
 	}
 
-	if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
-		action = 1;
+	if (server_info->guest) {
+		SSVAL(req->outbuf,smb_vwv2,1);
 	}
 
 	/* register the name and uid as being validated, so further connections
 	   to a uid can get through without a password, on the same VC */
 
-	nt_status = smbXsrv_session_create(sconn->conn,
-					   now, &session);
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		data_blob_free(&nt_resp);
-		data_blob_free(&lm_resp);
-		reply_nterror(req, nt_status_squash(nt_status));
-		END_PROFILE(SMBsesssetupX);
-		return;
-	}
-
-	if (session_info->session_key.length > 0) {
-		uint8_t session_key[16];
-
-		/*
-		 * Note: the SMB1 signing key is not truncated to 16 byte!
-		 */
-		session->global->signing_key =
-			data_blob_dup_talloc(session->global,
-					     session_info->session_key);
-		if (session->global->signing_key.data == NULL) {
-			data_blob_free(&nt_resp);
-			data_blob_free(&lm_resp);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
-			END_PROFILE(SMBsesssetupX);
-			return;
-		}
-
-		/*
-		 * The application key is truncated/padded to 16 bytes
-		 */
-		ZERO_STRUCT(session_key);
-		memcpy(session_key, session->global->signing_key.data,
-		       MIN(session->global->signing_key.length,
-			   sizeof(session_key)));
-		session->global->application_key =
-			data_blob_talloc(session->global,
-					 session_key,
-					 sizeof(session_key));
-		ZERO_STRUCT(session_key);
-		if (session->global->application_key.data == NULL) {
+	if (lp_security() == SEC_SHARE) {
+		sess_vuid = UID_FIELD_INVALID;
+		TALLOC_FREE(server_info);
+	} else {
+		/* Ignore the initial vuid. */
+		sess_vuid = register_initial_vuid(sconn);
+		if (sess_vuid == UID_FIELD_INVALID) {
 			data_blob_free(&nt_resp);
 			data_blob_free(&lm_resp);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
+			reply_nterror(req, nt_status_squash(
+					      NT_STATUS_LOGON_FAILURE));
 			END_PROFILE(SMBsesssetupX);
 			return;
 		}
-
-		/*
-		 * Place the application key into the session_info
-		 */
-		data_blob_clear_free(&session_info->session_key);
-		session_info->session_key = data_blob_dup_talloc(session_info,
-						session->global->application_key);
-		if (session_info->session_key.data == NULL) {
+		/* register_existing_vuid keeps the server info */
+		sess_vuid = register_existing_vuid(sconn, sess_vuid,
+					server_info,
+					nt_resp.data ? nt_resp : lm_resp,
+					sub_user);
+		if (sess_vuid == UID_FIELD_INVALID) {
 			data_blob_free(&nt_resp);
 			data_blob_free(&lm_resp);
-			TALLOC_FREE(session);
-			reply_nterror(req, NT_STATUS_NO_MEMORY);
+			reply_nterror(req, nt_status_squash(
+					      NT_STATUS_LOGON_FAILURE));
 			END_PROFILE(SMBsesssetupX);
 			return;
 		}
-	}
-
-	session->compat = talloc_zero(session, struct user_struct);
-	if (session->compat == NULL) {
-		data_blob_free(&nt_resp);
-		data_blob_free(&lm_resp);
-		TALLOC_FREE(session);
-		reply_nterror(req, NT_STATUS_NO_MEMORY);
-		END_PROFILE(SMBsesssetupX);
-		return;
-	}
-	session->compat->session = session;
-	session->compat->homes_snum = -1;
-	session->compat->session_info = session_info;
-	session->compat->session_keystr = NULL;
-	session->compat->vuid = session->global->session_wire_id;
-	DLIST_ADD(sconn->users, session->compat);
-	sconn->num_users++;
-
-	if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
-		session->compat->homes_snum =
-			register_homes_share(session_info->unix_info->unix_name);
-	}
-
-	if (srv_is_signing_negotiated(sconn) &&
-	    action == 0 &&
-	    session->global->signing_key.length > 0)
-	{
-		/*
-		 * Try and turn on server signing on the first non-guest
-		 * sessionsetup.
-		 */
-		srv_set_signing(sconn,
-			session->global->signing_key,
-			nt_resp.data ? nt_resp : lm_resp);
-	}
-
-	set_current_user_info(session_info->unix_info->sanitized_username,
-			      session_info->unix_info->unix_name,
-			      session_info->info->domain_name);
-
-	session->status = NT_STATUS_OK;
-	session->global->auth_session_info = talloc_move(session->global,
-							 &session_info);
-	session->global->auth_session_info_seqnum += 1;
-	session->global->channels[0].auth_session_info_seqnum =
-		session->global->auth_session_info_seqnum;
-	session->global->expiration_time = GENSEC_EXPIRE_TIME_INFINITY;
-
-	nt_status = smbXsrv_session_update(session);
-	if (!NT_STATUS_IS_OK(nt_status)) {
-		DEBUG(0, ("smb1: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
-			  nt_errstr(nt_status)));
-		data_blob_free(&nt_resp);
-		data_blob_free(&lm_resp);
-		TALLOC_FREE(session);
-		reply_nterror(req, nt_status_squash(nt_status));
-		END_PROFILE(SMBsesssetupX);
-		return;
-	}
 
-	if (!session_claim(session)) {
-		DEBUG(1, ("smb1: Failed to claim session for vuid=%llu\n",
-			  (unsigned long long)session->compat->vuid));
-		data_blob_free(&nt_resp);
-		data_blob_free(&lm_resp);
-		TALLOC_FREE(session);
-		reply_nterror(req, NT_STATUS_LOGON_FAILURE);
-		END_PROFILE(SMBsesssetupX);
-		return;
+		/* current_user_info is changed on new vuid */
+		reload_services(sconn->msg_ctx, sconn->sock, True);
 	}
 
-	/* current_user_info is changed on new vuid */
-	reload_services(sconn, conn_snum_used, true);
-
-	sess_vuid = session->global->session_wire_id;
-
 	data_blob_free(&nt_resp);
 	data_blob_free(&lm_resp);
 
-	SSVAL(req->outbuf,smb_vwv2,action);
 	SSVAL(req->outbuf,smb_uid,sess_vuid);
-	SSVAL(discard_const_p(char, req->inbuf),smb_uid,sess_vuid);
+	SSVAL(req->inbuf,smb_uid,sess_vuid);
 	req->vuid = sess_vuid;
 
 	if (!sconn->smb1.sessions.done_sesssetup) {
-		if (smb_bufsize < SMB_BUFFER_SIZE_MIN) {
-			reply_force_doserror(req, ERRSRV, ERRerror);
-			END_PROFILE(SMBsesssetupX);
-			return;
-		}
-		sconn->smb1.sessions.max_send = smb_bufsize;
-		sconn->smb1.sessions.done_sesssetup = true;
+		sconn->smb1.sessions.max_send =
+			MIN(sconn->smb1.sessions.max_send,smb_bufsize);
 	}
+	sconn->smb1.sessions.done_sesssetup = true;
 
 	END_PROFILE(SMBsesssetupX);
+	chain_reply(req);
+	return;
 }
Only in ../../samba-3.6.24/source3/smbd: sesssetup.o
diff -ur smbd/share_access.c ../../samba-3.6.24/source3/smbd/share_access.c
--- smbd/share_access.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/share_access.c	2015-01-28 10:52:25.149068676 +0800
@@ -203,7 +203,7 @@
 {
 	if (lp_invalid_users(snum) != NULL) {
 		if (token_contains_name_in_list(username, domain,
-						lp_servicename(talloc_tos(), snum),
+						lp_servicename(snum),
 						token,
 						lp_invalid_users(snum))) {
 			DEBUG(10, ("User %s in 'invalid users'\n", username));
@@ -213,8 +213,7 @@
 
 	if (lp_valid_users(snum) != NULL) {
 		if (!token_contains_name_in_list(username, domain,
-						 lp_servicename(talloc_tos(), snum),
-						 token,
+						 lp_servicename(snum), token,
 						 lp_valid_users(snum))) {
 			DEBUG(10, ("User %s not in 'valid users'\n",
 				   username));
@@ -224,14 +223,14 @@
 
 	if (lp_onlyuser(snum)) {
 		const char *list[2];
-		list[0] = lp_username(talloc_tos(), snum);
+		list[0] = lp_username(snum);
 		list[1] = NULL;
 		if ((list[0] == NULL) || (*list[0] == '\0')) {
 			DEBUG(0, ("'only user = yes' and no 'username ='\n"));
 			return False;
 		}
 		if (!token_contains_name_in_list(NULL, domain,
-						 lp_servicename(talloc_tos(), snum),
+						 lp_servicename(snum),
 						 token, list)) {
 			DEBUG(10, ("%s != 'username'\n", username));
 			return False;
@@ -239,7 +238,7 @@
 	}
 
 	DEBUG(10, ("user_ok_token: share %s is ok for unix user %s\n",
-		   lp_servicename(talloc_tos(), snum), username));
+		   lp_servicename(snum), username));
 
 	return True;
 }
@@ -268,8 +267,7 @@
 
 	if (lp_readlist(snum) != NULL) {
 		if (token_contains_name_in_list(username, domain,
-						lp_servicename(talloc_tos(), snum),
-						token,
+						lp_servicename(snum), token,
 						lp_readlist(snum))) {
 			result = True;
 		}
@@ -277,15 +275,14 @@
 
 	if (lp_writelist(snum) != NULL) {
 		if (token_contains_name_in_list(username, domain,
-						lp_servicename(talloc_tos(), snum),
-						token,
+						lp_servicename(snum), token,
 						lp_writelist(snum))) {
 			result = False;
 		}
 	}
 
 	DEBUG(10,("is_share_read_only_for_user: share %s is %s for unix user "
-		  "%s\n", lp_servicename(talloc_tos(), snum),
+		  "%s\n", lp_servicename(snum),
 		  result ? "read-only" : "read-write", username));
 
 	return result;
Only in ../../samba-3.6.24/source3/smbd: share_access.o
diff -ur smbd/signing.c ../../samba-3.6.24/source3/smbd/signing.c
--- smbd/signing.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/signing.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,7 +22,7 @@
 #include "includes.h"
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
-#include "../libcli/smb/smb_signing.h"
+#include "smb_signing.h"
 
 /***********************************************************
  Called to validate an incoming packet from the client.
@@ -32,41 +32,35 @@
 			const char *inbuf, uint32_t *seqnum,
 			bool trusted_channel)
 {
-	const uint8_t *inhdr;
-	size_t len;
-
 	/* Check if it's a non-session message. */
 	if(CVAL(inbuf,0)) {
 		return true;
 	}
 
-	len = smb_len(inbuf);
-	inhdr = (const uint8_t *)inbuf + NBT_HDR_SIZE;
-
 	if (trusted_channel) {
 		NTSTATUS status;
 
-		if (len < (HDR_SS_FIELD + 8)) {
+		if (smb_len(inbuf) < (smb_ss_field + 8 - 4)) {
 			DEBUG(1,("smb_signing_check_pdu: Can't check signature "
 				 "on short packet! smb_len = %u\n",
-				 (unsigned)len));
+				 smb_len(inbuf)));
 			return false;
 		}
 
-		status = NT_STATUS(IVAL(inhdr, HDR_SS_FIELD + 4));
+		status = NT_STATUS(IVAL(inbuf, smb_ss_field + 4));
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(1,("smb_signing_check_pdu: trusted channel passed %s\n",
 				 nt_errstr(status)));
 			return false;
 		}
 
-		*seqnum = IVAL(inhdr, HDR_SS_FIELD);
+		*seqnum = IVAL(inbuf, smb_ss_field);
 		return true;
 	}
 
 	*seqnum = smb_signing_next_seqnum(conn->smb1.signing_state, false);
 	return smb_signing_check_pdu(conn->smb1.signing_state,
-				     inhdr, len,
+				     (const uint8_t *)inbuf,
 				     *seqnum);
 }
 
@@ -77,18 +71,12 @@
 void srv_calculate_sign_mac(struct smbd_server_connection *conn,
 			    char *outbuf, uint32_t seqnum)
 {
-	uint8_t *outhdr;
-	size_t len;
-
 	/* Check if it's a non-session message. */
 	if(CVAL(outbuf,0)) {
 		return;
 	}
 
-	len = smb_len(outbuf);
-	outhdr = (uint8_t *)outbuf + NBT_HDR_SIZE;
-
-	smb_signing_sign_pdu(conn->smb1.signing_state, outhdr, len, seqnum);
+	smb_signing_sign_pdu(conn->smb1.signing_state, (uint8_t *)outbuf, seqnum);
 }
 
 
@@ -169,36 +157,26 @@
 bool srv_init_signing(struct smbd_server_connection *conn)
 {
 	bool allowed = true;
-	bool desired;
 	bool mandatory = false;
 
 	switch (lp_server_signing()) {
-	case SMB_SIGNING_REQUIRED:
+	case Required:
 		mandatory = true;
 		break;
-	case SMB_SIGNING_IF_REQUIRED:
+	case Auto:
+		break;
+	case True:
 		break;
-	case SMB_SIGNING_DEFAULT:
-	case SMB_SIGNING_OFF:
+	case False:
 		allowed = false;
 		break;
 	}
 
-	/*
-	 * if the client and server allow signing,
-	 * we desire to use it.
-	 *
-	 * This matches Windows behavior and is needed
-	 * because not every client that requires signing
-	 * sends FLAGS2_SMB_SECURITY_SIGNATURES_REQUIRED.
-	 */
-	desired = allowed;
-
 	if (lp_async_smb_echo_handler()) {
 		struct smbd_shm_signing *s;
 
 		/* setup the signing state in shared memory */
-		s = talloc_zero(conn, struct smbd_shm_signing);
+		s = talloc_zero(smbd_event_context(), struct smbd_shm_signing);
 		if (s == NULL) {
 			return false;
 		}
@@ -211,7 +189,7 @@
 		}
 		talloc_set_destructor(s, smbd_shm_signing_destructor);
 		conn->smb1.signing_state = smb_signing_init_ex(s,
-							allowed, desired, mandatory,
+							allowed, mandatory,
 							smbd_shm_signing_alloc,
 							smbd_shm_signing_free);
 		if (!conn->smb1.signing_state) {
@@ -220,8 +198,8 @@
 		return true;
 	}
 
-	conn->smb1.signing_state = smb_signing_init(conn,
-						    allowed, desired, mandatory);
+	conn->smb1.signing_state = smb_signing_init(smbd_event_context(),
+						    allowed, mandatory);
 	if (!conn->smb1.signing_state) {
 		return false;
 	}
@@ -229,11 +207,9 @@
 	return true;
 }
 
-void srv_set_signing_negotiated(struct smbd_server_connection *conn,
-				bool allowed, bool mandatory)
+void srv_set_signing_negotiated(struct smbd_server_connection *conn)
 {
-	smb_signing_set_negotiated(conn->smb1.signing_state,
-				   allowed, mandatory);
+	smb_signing_set_negotiated(conn->smb1.signing_state);
 }
 
 /***********************************************************
Only in ../../samba-3.6.24/source3/smbd: signing.o
diff -ur smbd/smb2_break.c ../../samba-3.6.24/source3/smbd/smb2_break.c
--- smbd/smb2_break.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_break.c	2015-01-28 10:52:25.149068676 +0800
@@ -38,6 +38,7 @@
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint8_t in_oplock_level;
 	uint64_t in_file_id_persistent;
 	uint64_t in_file_id_volatile;
@@ -48,7 +49,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_oplock_level		= CVAL(inbody, 0x02);
 
@@ -67,14 +68,14 @@
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_oplock_break_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_oplock_break_send(req, req->sconn->smb2.event_ctx,
 					     req, in_fsp, in_oplock_level);
 	if (subreq == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_oplock_break_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_oplock_break_done(struct tevent_req *subreq)
@@ -82,6 +83,7 @@
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint64_t in_file_id_persistent;
 	uint64_t in_file_id_volatile;
 	uint8_t out_oplock_level = 0;
@@ -101,7 +103,7 @@
 		return;
 	}
 
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_file_id_persistent	= BVAL(inbody, 0x08);
 	in_file_id_volatile	= BVAL(inbody, 0x10);
@@ -161,9 +163,9 @@
 	state->smb2req = smb2req;
 	state->out_oplock_level = SMB2_OPLOCK_LEVEL_NONE;
 
-	DEBUG(10,("smbd_smb2_oplock_break_send: %s - %s, "
+	DEBUG(10,("smbd_smb2_oplock_break_send: %s - fnum[%d] "
 		  "samba level %d\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp),
+		  fsp_str_dbg(fsp), fsp->fnum,
 		  oplocklevel));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
@@ -172,10 +174,10 @@
 	}
 
 	DEBUG(5,("smbd_smb2_oplock_break_send: got SMB2 oplock break (%u) from client "
-		"for file %s, %s\n",
+		"for file %s fnum = %d\n",
 		(unsigned int)in_oplock_level,
 		fsp_str_dbg(fsp),
-		fsp_fnum_dbg(fsp)));
+		fsp->fnum ));
 
 	/* Are we awaiting a break message ? */
 	if (fsp->oplock_timeout == NULL) {
@@ -235,38 +237,18 @@
 				SMB2_OPLOCK_LEVEL_II :
 				SMB2_OPLOCK_LEVEL_NONE;
 	NTSTATUS status;
-	struct smbXsrv_session *session = NULL;
-	struct timeval tv = timeval_current();
-	NTTIME now = timeval_to_nttime(&tv);
-
-	status = smb2srv_session_lookup(fsp->conn->sconn->conn,
-					fsp->vuid,
-					now,
-					&session);
-	if (NT_STATUS_EQUAL(status, NT_STATUS_USER_SESSION_DELETED) ||
-	    (session == NULL))
-	{
-
-		DEBUG(10,("send_break_message_smb2: skip oplock break "
-			"for file %s, %s, smb2 level %u session %llu not found\n",
-			fsp_str_dbg(fsp),
-			fsp_fnum_dbg(fsp),
-			(unsigned int)smb2_oplock_level,
-			(unsigned long long)fsp->vuid));
-		return;
-	}
+	uint64_t fsp_persistent = fsp_persistent_id(fsp);
 
 	DEBUG(10,("send_break_message_smb2: sending oplock break "
-		"for file %s, %s, smb2 level %u\n",
+		"for file %s, fnum = %d, smb2 level %u\n",
 		fsp_str_dbg(fsp),
-		fsp_fnum_dbg(fsp),
+		fsp->fnum,
 		(unsigned int)smb2_oplock_level ));
 
 	status = smbd_smb2_send_oplock_break(fsp->conn->sconn,
-					     session,
-					     fsp->conn->tcon,
-					     fsp->op,
-					     smb2_oplock_level);
+					fsp_persistent,
+					(uint64_t)fsp->fnum,
+					smb2_oplock_level);
 	if (!NT_STATUS_IS_OK(status)) {
 		smbd_server_connection_terminate(fsp->conn->sconn,
 				 nt_errstr(status));
Only in ../../samba-3.6.24/source3/smbd: smb2_break.o
diff -ur smbd/smb2_close.c ../../samba-3.6.24/source3/smbd/smb2_close.c
--- smbd/smb2_close.c	2014-07-30 16:52:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_close.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,41 +22,34 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "../libcli/smb/smb_common.h"
-#include "../lib/util/tevent_ntstatus.h"
-#include "lib/tevent_wait.h"
 
-static struct tevent_req *smbd_smb2_close_send(TALLOC_CTX *mem_ctx,
-					       struct tevent_context *ev,
-					       struct smbd_smb2_request *smb2req,
-					       struct files_struct *in_fsp,
-					       uint16_t in_flags);
-static NTSTATUS smbd_smb2_close_recv(struct tevent_req *req,
-				     uint16_t *out_flags,
-				     struct timespec *out_creation_ts,
-				     struct timespec *out_last_access_ts,
-				     struct timespec *out_last_write_ts,
-				     struct timespec *out_change_ts,
-				     uint64_t *out_allocation_size,
-				     uint64_t *out_end_of_file,
-				     uint32_t *out_file_attributes);
-
-static void smbd_smb2_request_close_done(struct tevent_req *subreq);
+static NTSTATUS smbd_smb2_close(struct smbd_smb2_request *req,
+				struct files_struct *fsp,
+				uint16_t in_flags,
+				DATA_BLOB *outbody);
 
 NTSTATUS smbd_smb2_request_process_close(struct smbd_smb2_request *req)
 {
 	const uint8_t *inbody;
+	int i = req->current_idx;
+	uint8_t *outhdr;
+	DATA_BLOB outbody;
 	uint16_t in_flags;
 	uint64_t in_file_id_persistent;
 	uint64_t in_file_id_volatile;
 	struct files_struct *in_fsp;
 	NTSTATUS status;
-	struct tevent_req *subreq;
 
 	status = smbd_smb2_request_verify_sizes(req, 0x18);
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
+
+	outbody = data_blob_talloc(req->out.vector, NULL, 0x3C);
+	if (outbody.data == NULL) {
+		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
+	}
 
 	in_flags		= SVAL(inbody, 0x02);
 	in_file_id_persistent	= BVAL(inbody, 0x08);
@@ -67,122 +60,41 @@
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_close_send(req, req->sconn->ev_ctx,
-				      req, in_fsp, in_flags);
-	if (subreq == NULL) {
-		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
-	}
-	tevent_req_set_callback(subreq, smbd_smb2_request_close_done, req);
-
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
-}
-
-static void smbd_smb2_request_close_done(struct tevent_req *subreq)
-{
-	struct smbd_smb2_request *req =
-		tevent_req_callback_data(subreq,
-		struct smbd_smb2_request);
-	DATA_BLOB outbody;
-	uint16_t out_flags;
-	connection_struct *conn = req->tcon->compat;
-	struct timespec out_creation_ts = { 0, };
-	struct timespec out_last_access_ts = { 0, };
-	struct timespec out_last_write_ts = { 0, };
-	struct timespec out_change_ts = { 0, };
-	uint64_t out_allocation_size;
-	uint64_t out_end_of_file;
-	uint32_t out_file_attributes;
-	NTSTATUS status;
-	NTSTATUS error;
-
-	status = smbd_smb2_close_recv(subreq,
-				      &out_flags,
-				      &out_creation_ts,
-				      &out_last_access_ts,
-				      &out_last_write_ts,
-				      &out_change_ts,
-				      &out_allocation_size,
-				      &out_end_of_file,
-				      &out_file_attributes);
-	TALLOC_FREE(subreq);
+	status = smbd_smb2_close(req,
+				in_fsp,
+				in_flags,
+				&outbody);
 	if (!NT_STATUS_IS_OK(status)) {
-		error = smbd_smb2_request_error(req, status);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(req->sconn,
-							 nt_errstr(error));
-			return;
-		}
-		return;
-	}
-
-	outbody = data_blob_talloc(req->out.vector, NULL, 0x3C);
-	if (outbody.data == NULL) {
-		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(req->sconn,
-							 nt_errstr(error));
-			return;
-		}
-		return;
+		return smbd_smb2_request_error(req, status);
 	}
 
-	SSVAL(outbody.data, 0x00, 0x3C);	/* struct size */
-	SSVAL(outbody.data, 0x02, out_flags);
-	SIVAL(outbody.data, 0x04, 0);		/* reserved */
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x08, out_creation_ts);
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x10, out_last_access_ts);
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x18, out_last_write_ts);
-	put_long_date_timespec(conn->ts_res,
-		(char *)outbody.data + 0x20, out_change_ts);
-	SBVAL(outbody.data, 0x28, out_allocation_size);
-	SBVAL(outbody.data, 0x30, out_end_of_file);
-	SIVAL(outbody.data, 0x38, out_file_attributes);
-
-	error = smbd_smb2_request_done(req, outbody, NULL);
-	if (!NT_STATUS_IS_OK(error)) {
-		smbd_server_connection_terminate(req->sconn,
-						 nt_errstr(error));
-		return;
-	}
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+	return smbd_smb2_request_done(req, outbody, NULL);
 }
 
 static NTSTATUS smbd_smb2_close(struct smbd_smb2_request *req,
 				struct files_struct *fsp,
 				uint16_t in_flags,
-				uint16_t *out_flags,
-				struct timespec *out_creation_ts,
-				struct timespec *out_last_access_ts,
-				struct timespec *out_last_write_ts,
-				struct timespec *out_change_ts,
-				uint64_t *out_allocation_size,
-				uint64_t *out_end_of_file,
-				uint32_t *out_file_attributes)
+				DATA_BLOB *outbody)
 {
 	NTSTATUS status;
 	struct smb_request *smbreq;
-	connection_struct *conn = req->tcon->compat;
+	connection_struct *conn = req->tcon->compat_conn;
 	struct smb_filename *smb_fname = NULL;
+	struct timespec mdate_ts, adate_ts, cdate_ts, create_date_ts;
 	uint64_t allocation_size = 0;
 	uint64_t file_size = 0;
 	uint32_t dos_attrs = 0;
-	uint16_t flags = 0;
+	uint16_t out_flags = 0;
 	bool posix_open = false;
 
-	ZERO_STRUCTP(out_creation_ts);
-	ZERO_STRUCTP(out_last_access_ts);
-	ZERO_STRUCTP(out_last_write_ts);
-	ZERO_STRUCTP(out_change_ts);
-
-	*out_flags = 0;
-	*out_allocation_size = 0;
-	*out_end_of_file = 0;
-	*out_file_attributes = 0;
+	ZERO_STRUCT(create_date_ts);
+	ZERO_STRUCT(adate_ts);
+	ZERO_STRUCT(mdate_ts);
+	ZERO_STRUCT(cdate_ts);
 
-	DEBUG(10,("smbd_smb2_close: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_close: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(req);
 	if (smbreq == NULL) {
@@ -212,18 +124,18 @@
 			ret = SMB_VFS_STAT(conn, smb_fname);
 		}
 		if (ret == 0) {
-			flags = SMB2_CLOSE_FLAGS_FULL_INFORMATION;
+			out_flags = SMB2_CLOSE_FLAGS_FULL_INFORMATION;
 			dos_attrs = dos_mode(conn, smb_fname);
-			*out_last_write_ts = smb_fname->st.st_ex_mtime;
-			*out_last_access_ts = smb_fname->st.st_ex_atime;
-			*out_creation_ts = get_create_timespec(conn, NULL, smb_fname);
-			*out_change_ts = get_change_timespec(conn, NULL, smb_fname);
+			mdate_ts = smb_fname->st.st_ex_mtime;
+			adate_ts = smb_fname->st.st_ex_atime;
+			create_date_ts = get_create_timespec(conn, NULL, smb_fname);
+			cdate_ts = get_change_timespec(conn, NULL, smb_fname);
 
 			if (lp_dos_filetime_resolution(SNUM(conn))) {
-				dos_filetime_timespec(out_creation_ts);
-				dos_filetime_timespec(out_last_write_ts);
-				dos_filetime_timespec(out_last_access_ts);
-				dos_filetime_timespec(out_change_ts);
+				dos_filetime_timespec(&create_date_ts);
+				dos_filetime_timespec(&mdate_ts);
+				dos_filetime_timespec(&adate_ts);
+				dos_filetime_timespec(&cdate_ts);
 			}
 			if (!(dos_attrs & FILE_ATTRIBUTE_DIRECTORY)) {
 				file_size = get_file_size_stat(&smb_fname->st);
@@ -233,144 +145,20 @@
 		}
 	}
 
-	*out_flags = flags;
-	*out_allocation_size = allocation_size;
-	*out_end_of_file = file_size;
-	*out_file_attributes = dos_attrs;
-
-	return NT_STATUS_OK;
-}
-
-struct smbd_smb2_close_state {
-	struct smbd_smb2_request *smb2req;
-	struct files_struct *in_fsp;
-	uint16_t in_flags;
-	uint16_t out_flags;
-	struct timespec out_creation_ts;
-	struct timespec out_last_access_ts;
-	struct timespec out_last_write_ts;
-	struct timespec out_change_ts;
-	uint64_t out_allocation_size;
-	uint64_t out_end_of_file;
-	uint32_t out_file_attributes;
-};
-
-static void smbd_smb2_close_do(struct tevent_req *subreq);
-
-static struct tevent_req *smbd_smb2_close_send(TALLOC_CTX *mem_ctx,
-					       struct tevent_context *ev,
-					       struct smbd_smb2_request *smb2req,
-					       struct files_struct *in_fsp,
-					       uint16_t in_flags)
-{
-	struct tevent_req *req;
-	struct smbd_smb2_close_state *state;
-	NTSTATUS status;
-
-	req = tevent_req_create(mem_ctx, &state,
-				struct smbd_smb2_close_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->smb2req = smb2req;
-	state->in_fsp = in_fsp;
-	state->in_flags = in_flags;
-
-	if (in_fsp->num_aio_requests != 0) {
-
-		in_fsp->deferred_close = tevent_wait_send(in_fsp, ev);
-		if (tevent_req_nomem(in_fsp->deferred_close, req)) {
-			return tevent_req_post(req, ev);
-		}
-		tevent_req_set_callback(in_fsp->deferred_close,
-					smbd_smb2_close_do, req);
-		return req;
-	}
-
-	status = smbd_smb2_close(smb2req,
-				 state->in_fsp,
-				 state->in_flags,
-				 &state->out_flags,
-				 &state->out_creation_ts,
-				 &state->out_last_access_ts,
-				 &state->out_last_write_ts,
-				 &state->out_change_ts,
-				 &state->out_allocation_size,
-				 &state->out_end_of_file,
-				 &state->out_file_attributes);
-	if (tevent_req_nterror(req, status)) {
-		return tevent_req_post(req, ev);
-	}
-
-	tevent_req_done(req);
-	return tevent_req_post(req, ev);
-}
-
-static void smbd_smb2_close_do(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smbd_smb2_close_state *state = tevent_req_data(
-		req, struct smbd_smb2_close_state);
-	NTSTATUS status;
-	int ret;
-
-	ret = tevent_wait_recv(subreq);
-	TALLOC_FREE(subreq);
-	if (ret != 0) {
-		DEBUG(10, ("tevent_wait_recv returned %s\n",
-			   strerror(ret)));
-		/*
-		 * Continue anyway, this should never happen
-		 */
-	}
-
-	status = smbd_smb2_close(state->smb2req,
-				 state->in_fsp,
-				 state->in_flags,
-				 &state->out_flags,
-				 &state->out_creation_ts,
-				 &state->out_last_access_ts,
-				 &state->out_last_write_ts,
-				 &state->out_change_ts,
-				 &state->out_allocation_size,
-				 &state->out_end_of_file,
-				 &state->out_file_attributes);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-	tevent_req_done(req);
-}
-
-static NTSTATUS smbd_smb2_close_recv(struct tevent_req *req,
-				     uint16_t *out_flags,
-				     struct timespec *out_creation_ts,
-				     struct timespec *out_last_access_ts,
-				     struct timespec *out_last_write_ts,
-				     struct timespec *out_change_ts,
-				     uint64_t *out_allocation_size,
-				     uint64_t *out_end_of_file,
-				     uint32_t *out_file_attributes)
-{
-	struct smbd_smb2_close_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_close_state);
-	NTSTATUS status;
-
-	if (tevent_req_is_nterror(req, &status)) {
-		tevent_req_received(req);
-		return status;
-	}
-
-	*out_flags = state->out_flags;
-	*out_creation_ts = state->out_creation_ts;
-	*out_last_access_ts = state->out_last_access_ts;
-	*out_last_write_ts = state->out_last_write_ts;
-	*out_change_ts = state->out_change_ts;
-	*out_allocation_size = state->out_allocation_size;
-	*out_end_of_file = state->out_end_of_file;
-	*out_file_attributes = state->out_file_attributes;
+	SSVAL(outbody->data, 0x00, 0x3C);	/* struct size */
+	SSVAL(outbody->data, 0x02, out_flags);	/* flags */
+	SIVAL(outbody->data, 0x04, 0);		/* reserved */
+	put_long_date_timespec(conn->ts_res,
+		(char *)&outbody->data[0x8],create_date_ts); /* creation time */
+	put_long_date_timespec(conn->ts_res,
+		(char *)&outbody->data[0x10],adate_ts); /* last access time */
+	put_long_date_timespec(conn->ts_res,
+		(char *)&outbody->data[0x18],mdate_ts); /* last write time */
+	put_long_date_timespec(conn->ts_res,
+		(char *)&outbody->data[0x20],cdate_ts); /* change time */
+	SBVAL(outbody->data, 0x28, allocation_size);/* allocation size */
+	SBVAL(outbody->data, 0x30, file_size);	/* end of file */
+	SIVAL(outbody->data, 0x38, dos_attrs);	/* file attributes */
 
-	tevent_req_received(req);
 	return NT_STATUS_OK;
 }
Only in ../../samba-3.6.24/source3/smbd: smb2_close.o
diff -ur smbd/smb2_create.c ../../samba-3.6.24/source3/smbd/smb2_create.c
--- smbd/smb2_create.c	2014-07-30 16:52:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_create.c	2015-01-28 10:52:25.149068676 +0800
@@ -26,7 +26,6 @@
 #include "../libcli/smb/smb_common.h"
 #include "../librpc/gen_ndr/ndr_security.h"
 #include "../lib/util/tevent_ntstatus.h"
-#include "messages.h"
 
 int map_smb2_oplock_levels_to_samba(uint8_t in_oplock_level)
 {
@@ -85,10 +84,10 @@
 			TALLOC_CTX *mem_ctx,
 			uint8_t *out_oplock_level,
 			uint32_t *out_create_action,
-			struct timespec *out_creation_ts,
-			struct timespec *out_last_access_ts,
-			struct timespec *out_last_write_ts,
-			struct timespec *out_change_ts,
+			NTTIME *out_creation_time,
+			NTTIME *out_last_access_time,
+			NTTIME *out_last_write_time,
+			NTTIME *out_change_time,
 			uint64_t *out_allocation_size,
 			uint64_t *out_end_of_file,
 			uint32_t *out_file_attributes,
@@ -100,7 +99,7 @@
 NTSTATUS smbd_smb2_request_process_create(struct smbd_smb2_request *smb2req)
 {
 	const uint8_t *inbody;
-	const struct iovec *indyniov;
+	int i = smb2req->current_idx;
 	uint8_t in_oplock_level;
 	uint32_t in_impersonation_level;
 	uint32_t in_desired_access;
@@ -130,7 +129,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(smb2req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(smb2req);
+	inbody = (const uint8_t *)smb2req->in.vector[i+1].iov_base;
 
 	in_oplock_level		= CVAL(inbody, 0x03);
 	in_impersonation_level	= IVAL(inbody, 0x04);
@@ -152,7 +151,7 @@
 	 *       overlap
 	 */
 
-	dyn_offset = SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(smb2req);
+	dyn_offset = SMB2_HDR_BODY + smb2req->in.vector[i+1].iov_len;
 
 	if (in_name_offset == 0 && in_name_length == 0) {
 		/* This is ok */
@@ -163,19 +162,18 @@
 		name_offset = in_name_offset - dyn_offset;
 	}
 
-	indyniov = SMBD_SMB2_IN_DYN_IOV(smb2req);
-
-	if (name_offset > indyniov->iov_len) {
+	if (name_offset > smb2req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	name_available_length = indyniov->iov_len - name_offset;
+	name_available_length = smb2req->in.vector[i+2].iov_len - name_offset;
 
 	if (in_name_length > name_available_length) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_name_buffer.data = (uint8_t *)indyniov->iov_base + name_offset;
+	in_name_buffer.data = (uint8_t *)smb2req->in.vector[i+2].iov_base +
+			      name_offset;
 	in_name_buffer.length = in_name_length;
 
 	if (in_context_offset == 0 && in_context_length == 0) {
@@ -187,18 +185,18 @@
 		context_offset = in_context_offset - dyn_offset;
 	}
 
-	if (context_offset > indyniov->iov_len) {
+	if (context_offset > smb2req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	context_available_length = indyniov->iov_len - context_offset;
+	context_available_length = smb2req->in.vector[i+2].iov_len - context_offset;
 
 	if (in_context_length > context_available_length) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_context_buffer.data = (uint8_t *)indyniov->iov_base +
-		context_offset;
+	in_context_buffer.data = (uint8_t *)smb2req->in.vector[i+2].iov_base +
+				  context_offset;
 	in_context_buffer.length = in_context_length;
 
 	/*
@@ -209,7 +207,7 @@
 				   in_name_buffer.data,
 				   in_name_buffer.length,
 				   &in_name_string,
-				   &in_name_string_size);
+				   &in_name_string_size, false);
 	if (!ok) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_ILLEGAL_CHARACTER);
 	}
@@ -229,7 +227,7 @@
 	}
 
 	tsubreq = smbd_smb2_create_send(smb2req,
-				       smb2req->sconn->ev_ctx,
+				       smb2req->sconn->smb2.event_ctx,
 				       smb2req,
 				       in_oplock_level,
 				       in_impersonation_level,
@@ -246,18 +244,12 @@
 	}
 	tevent_req_set_callback(tsubreq, smbd_smb2_request_create_done, smb2req);
 
-	/*
-	 * For now we keep the logic that we do not send STATUS_PENDING
-	 * for sharing violations, so we just wait 2 seconds.
-	 *
-	 * TODO: we need more tests for this.
-	 */
-	return smbd_smb2_request_pending_queue(smb2req, tsubreq, 2000000);
+	return smbd_smb2_request_pending_queue(smb2req, tsubreq);
 }
 
 static uint64_t get_mid_from_smb2req(struct smbd_smb2_request *smb2req)
 {
-	uint8_t *reqhdr = SMBD_SMB2_OUT_HDR_PTR(smb2req);
+	uint8_t *reqhdr = (uint8_t *)smb2req->out.vector[smb2req->current_idx].iov_base;
 	return BVAL(reqhdr, SMB2_HDR_MESSAGE_ID);
 }
 
@@ -265,15 +257,16 @@
 {
 	struct smbd_smb2_request *smb2req = tevent_req_callback_data(tsubreq,
 					struct smbd_smb2_request);
+	int i = smb2req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint8_t out_oplock_level = 0;
 	uint32_t out_create_action = 0;
-	connection_struct *conn = smb2req->tcon->compat;
-	struct timespec out_creation_ts = { 0, };
-	struct timespec out_last_access_ts = { 0, };
-	struct timespec out_last_write_ts = { 0, };
-	struct timespec out_change_ts = { 0, };
+	NTTIME out_creation_time = 0;
+	NTTIME out_last_access_time = 0;
+	NTTIME out_last_write_time = 0;
+	NTTIME out_change_time = 0;
 	uint64_t out_allocation_size = 0;
 	uint64_t out_end_of_file = 0;
 	uint32_t out_file_attributes = 0;
@@ -285,14 +278,27 @@
 	NTSTATUS status;
 	NTSTATUS error; /* transport error */
 
+	if (smb2req->cancelled) {
+		uint64_t mid = get_mid_from_smb2req(smb2req);
+		DEBUG(10,("smbd_smb2_request_create_done: cancelled mid %llu\n",
+			(unsigned long long)mid ));
+		error = smbd_smb2_request_error(smb2req, NT_STATUS_CANCELLED);
+		if (!NT_STATUS_IS_OK(error)) {
+			smbd_server_connection_terminate(smb2req->sconn,
+				nt_errstr(error));
+			return;
+		}
+		return;
+	}
+
 	status = smbd_smb2_create_recv(tsubreq,
 				       smb2req,
 				       &out_oplock_level,
 				       &out_create_action,
-				       &out_creation_ts,
-				       &out_last_access_ts,
-				       &out_last_write_ts,
-				       &out_change_ts,
+				       &out_creation_time,
+				       &out_last_access_time,
+				       &out_last_write_time,
+				       &out_change_time,
 				       &out_allocation_size,
 				       &out_end_of_file,
 				       &out_file_attributes,
@@ -324,6 +330,8 @@
 		out_context_buffer_offset = SMB2_HDR_BODY + 0x58;
 	}
 
+	outhdr = (uint8_t *)smb2req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(smb2req->out.vector, NULL, 0x58);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(smb2req, NT_STATUS_NO_MEMORY);
@@ -341,18 +349,14 @@
 	SCVAL(outbody.data, 0x03, 0);		/* reserved */
 	SIVAL(outbody.data, 0x04,
 	      out_create_action);		/* create action */
-	put_long_date_timespec(conn->ts_res,
-	      (char *)outbody.data + 0x08,
-	      out_creation_ts);			/* creation time */
-	put_long_date_timespec(conn->ts_res,
-	      (char *)outbody.data + 0x10,
-	      out_last_access_ts);		/* last access time */
-	put_long_date_timespec(conn->ts_res,
-	      (char *)outbody.data + 0x18,
-	      out_last_write_ts);		/* last write time */
-	put_long_date_timespec(conn->ts_res,
-	      (char *)outbody.data + 0x20,
-	      out_change_ts);			/* change time */
+	SBVAL(outbody.data, 0x08,
+	      out_creation_time);		/* creation time */
+	SBVAL(outbody.data, 0x10,
+	      out_last_access_time);		/* last access time */
+	SBVAL(outbody.data, 0x18,
+	      out_last_write_time);		/* last write time */
+	SBVAL(outbody.data, 0x20,
+	      out_change_time);			/* change time */
 	SBVAL(outbody.data, 0x28,
 	      out_allocation_size);		/* allocation size */
 	SBVAL(outbody.data, 0x30,
@@ -390,10 +394,10 @@
 	DATA_BLOB private_data;
 	uint8_t out_oplock_level;
 	uint32_t out_create_action;
-	struct timespec out_creation_ts;
-	struct timespec out_last_access_ts;
-	struct timespec out_last_write_ts;
-	struct timespec out_change_ts;
+	NTTIME out_creation_time;
+	NTTIME out_last_access_time;
+	NTTIME out_last_write_time;
+	NTTIME out_change_time;
 	uint64_t out_allocation_size;
 	uint64_t out_end_of_file;
 	uint32_t out_file_attributes;
@@ -424,20 +428,17 @@
 	struct timespec write_time_ts;
 	struct smb2_create_blobs out_context_blobs;
 	int requested_oplock_level;
-	struct smb2_create_blob *dhnc = NULL;
-	struct smb2_create_blob *dh2c = NULL;
-	struct smbXsrv_open *op = NULL;
 
 	ZERO_STRUCT(out_context_blobs);
 
-	if(lp_fake_oplocks(SNUM(smb2req->tcon->compat))) {
+	if(lp_fake_oplocks(SNUM(smb2req->tcon->compat_conn))) {
 		requested_oplock_level = SMB2_OPLOCK_LEVEL_NONE;
 	} else {
 		requested_oplock_level = in_oplock_level;
 	}
 
 
-	if (smb2req->subreq == NULL) {
+	if (!smb2req->async) {
 		/* New create call. */
 		req = tevent_req_create(mem_ctx, &state,
 				struct smbd_smb2_create_state);
@@ -445,13 +446,13 @@
 			return NULL;
 		}
 		state->smb2req = smb2req;
+		smb2req->subreq = req; /* So we can find this when going async. */
 
 		smb1req = smbd_smb2_fake_smb_request(smb2req);
 		if (tevent_req_nomem(smb1req, req)) {
 			return tevent_req_post(req, ev);
 		}
 		state->smb1req = smb1req;
-		smb2req->subreq = req;
 		DEBUG(10,("smbd_smb2_create: name[%s]\n",
 			in_name));
 	} else {
@@ -464,53 +465,19 @@
 			in_name ));
 	}
 
-	dhnc = smb2_create_blob_find(&in_context_blobs,
-				     SMB2_CREATE_TAG_DHNC);
-
-	if (dhnc) {
-		if (dhnc->data.length != 16) {
-			tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			return tevent_req_post(req, ev);
-		}
-		if (in_context_blobs.num_blobs != 1) {
-			/*
-			 * DHNC should be the only one.
-			 */
-			tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
-			return tevent_req_post(req, ev);
-		}
-	}
-
-	dh2c = smb2_create_blob_find(&in_context_blobs,
-				     SMB2_CREATE_TAG_DH2C);
-	if (dh2c) {
-		if (dh2c->data.length != 36) {
-			tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			return tevent_req_post(req, ev);
-		}
-		if (in_context_blobs.num_blobs != 1) {
-			/*
-			 * DH2C should be the only one.
-			 */
-			tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
-			return tevent_req_post(req, ev);
-		}
-	}
-
 	if (IS_IPC(smb1req->conn)) {
 		const char *pipe_name = in_name;
 
-		if (dhnc || dh2c) {
-			/* durable handles are not supported on IPC$ */
-			tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
-			return tevent_req_post(req, ev);
-		}
-
 		if (!lp_nt_pipe_support()) {
 			tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
 			return tevent_req_post(req, ev);
 		}
 
+		/* Strip \\ off the name. */
+		if (pipe_name[0] == '\\') {
+			pipe_name++;
+		}
+
 		status = open_np_file(smb1req, pipe_name, &result);
 		if (!NT_STATUS_IS_OK(status)) {
 			tevent_req_nterror(req, status);
@@ -518,12 +485,6 @@
 		}
 		info = FILE_WAS_OPENED;
 	} else if (CAN_PRINT(smb1req->conn)) {
-		if (dhnc || dh2c) {
-			/* durable handles are not supported on printers */
-			tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
-			return tevent_req_post(req, ev);
-		}
-
 		status = file_new(smb1req, smb1req->conn, &result);
 		if(!NT_STATUS_IS_OK(status)) {
 			tevent_req_nterror(req, status);
@@ -540,6 +501,7 @@
 		info = FILE_WAS_CREATED;
 	} else {
 		char *fname;
+		struct smb_filename *smb_fname = NULL;
 		struct smb2_create_blob *exta = NULL;
 		struct ea_list *ea_list = NULL;
 		struct smb2_create_blob *mxac = NULL;
@@ -547,16 +509,11 @@
 		struct smb2_create_blob *secd = NULL;
 		struct security_descriptor *sec_desc = NULL;
 		struct smb2_create_blob *dhnq = NULL;
+		struct smb2_create_blob *dhnc = NULL;
 		struct smb2_create_blob *alsi = NULL;
 		uint64_t allocation_size = 0;
 		struct smb2_create_blob *twrp = NULL;
 		struct smb2_create_blob *qfid = NULL;
-		struct GUID create_guid = GUID_zero();
-		bool update_open = false;
-		bool durable_requested = false;
-		uint32_t durable_timeout_msec = 0;
-		bool do_durable_reconnect = false;
-		struct smb2_create_blob *dh2q = NULL;
 
 		exta = smb2_create_blob_find(&in_context_blobs,
 					     SMB2_CREATE_TAG_EXTA);
@@ -566,14 +523,14 @@
 					     SMB2_CREATE_TAG_SECD);
 		dhnq = smb2_create_blob_find(&in_context_blobs,
 					     SMB2_CREATE_TAG_DHNQ);
+		dhnc = smb2_create_blob_find(&in_context_blobs,
+					     SMB2_CREATE_TAG_DHNC);
 		alsi = smb2_create_blob_find(&in_context_blobs,
 					     SMB2_CREATE_TAG_ALSI);
 		twrp = smb2_create_blob_find(&in_context_blobs,
 					     SMB2_CREATE_TAG_TWRP);
 		qfid = smb2_create_blob_find(&in_context_blobs,
 					     SMB2_CREATE_TAG_QFID);
-		dh2q = smb2_create_blob_find(&in_context_blobs,
-					     SMB2_CREATE_TAG_DH2Q);
 
 		fname = talloc_strdup(state, in_name);
 		if (tevent_req_nomem(fname, req)) {
@@ -581,6 +538,11 @@
 		}
 
 		if (exta) {
+			if (dhnc) {
+				tevent_req_nterror(req,NT_STATUS_OBJECT_NAME_NOT_FOUND);
+				return tevent_req_post(req, ev);
+			}
+
 			ea_list = read_nttrans_ea_list(mem_ctx,
 				(const char *)exta->data.data, exta->data.length);
 			if (!ea_list) {
@@ -588,14 +550,14 @@
 				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 				return tevent_req_post(req, ev);
 			}
+		}
 
-			if (ea_list_has_invalid_name(ea_list)) {
-				tevent_req_nterror(req, STATUS_INVALID_EA_NAME);
+		if (mxac) {
+			if (dhnc) {
+				tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
 				return tevent_req_post(req, ev);
 			}
-		}
 
-		if (mxac) {
 			if (mxac->data.length == 0) {
 				max_access_time = 0;
 			} else if (mxac->data.length == 8) {
@@ -609,6 +571,11 @@
 		if (secd) {
 			enum ndr_err_code ndr_err;
 
+			if (dhnc) {
+				tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
+				return tevent_req_post(req, ev);
+			}
+
 			sec_desc = talloc_zero(state, struct security_descriptor);
 			if (tevent_req_nomem(sec_desc, req)) {
 				return tevent_req_post(req, ev);
@@ -626,146 +593,37 @@
 		}
 
 		if (dhnq) {
-			if (dhnq->data.length != 16) {
-				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-				return tevent_req_post(req, ev);
-			}
-
-			if (dh2q) {
-				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
+			if (dhnc) {
+				tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
 				return tevent_req_post(req, ev);
 			}
 
-			/*
-			 * durable handle request is processed below.
-			 */
-			durable_requested = true;
-			/*
-			 * Set the timeout to 16 mins.
-			 *
-			 * TODO: test this against Windows 2012
-			 *       as the default for durable v2 is 1 min.
-			 */
-			durable_timeout_msec = (16*60*1000);
-		}
-
-		if (dh2q) {
-			const uint8_t *p = dh2q->data.data;
-			uint32_t durable_v2_timeout = 0;
-			DATA_BLOB create_guid_blob;
-
-			if (dh2q->data.length != 32) {
-				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-				return tevent_req_post(req, ev);
-			}
-
-			if (dhnq) {
+			if (dhnq->data.length != 16) {
 				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 				return tevent_req_post(req, ev);
 			}
-
-			durable_v2_timeout = IVAL(p, 0);
-			create_guid_blob = data_blob_const(p + 16, 16);
-
-			status = GUID_from_ndr_blob(&create_guid_blob,
-						    &create_guid);
-			if (tevent_req_nterror(req, status)) {
-				return tevent_req_post(req, ev);
-			}
-			/*
-			 * we need to store the create_guid later
-			 */
-			update_open = true;
-
 			/*
-			 * durable handle v2 request processed below
+			 * we don't support durable handles yet
+			 * and have to ignore this
 			 */
-			durable_requested = true;
-			durable_timeout_msec = durable_v2_timeout;
-			if (durable_timeout_msec == 0) {
-				/*
-				 * Set the timeout to 1 min as default.
-				 *
-				 * This matches Windows 2012.
-				 */
-				durable_timeout_msec = (60*1000);
-			}
 		}
 
 		if (dhnc) {
-			NTTIME now = timeval_to_nttime(&smb2req->request_time);
-			uint64_t persistent_id;
-
-			persistent_id = BVAL(dhnc->data.data, 0);
-
-			status = smb2srv_open_recreate(smb2req->sconn->conn,
-						smb1req->conn->session_info,
-						persistent_id, create_guid,
-						now, &op);
-			if (!NT_STATUS_IS_OK(status)) {
-				DEBUG(3, ("smbd_smb2_create_send: "
-					  "smb2srv_open_recreate v1 failed: %s\n",
-					  nt_errstr(status)));
-				tevent_req_nterror(req, status);
-				return tevent_req_post(req, ev);
-			}
-
-			DEBUG(10, ("smb2_create_send: DHNC: %s recreate the "
-				   "smb2srv_open struct for a durable handle.\n",
-				   op->global->durable ? "did" : "could not"));
-
-			if (!op->global->durable) {
-				talloc_free(op);
-				tevent_req_nterror(req,
-					NT_STATUS_OBJECT_NAME_NOT_FOUND);
+			if (dhnc->data.length != 16) {
+				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 				return tevent_req_post(req, ev);
 			}
-
-			do_durable_reconnect = true;
+			/* we don't support durable handles yet */
+			tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
+			return tevent_req_post(req, ev);
 		}
 
-		if (dh2c) {
-			const uint8_t *p = dh2c->data.data;
-			NTTIME now = timeval_to_nttime(&smb2req->request_time);
-			uint64_t persistent_id;
-			DATA_BLOB create_guid_blob;
-
-			persistent_id = BVAL(p, 0);
-			create_guid_blob = data_blob_const(p + 16, 16);
-
-			status = GUID_from_ndr_blob(&create_guid_blob,
-						    &create_guid);
-			if (tevent_req_nterror(req, status)) {
-				return tevent_req_post(req, ev);
-			}
-
-			status = smb2srv_open_recreate(smb2req->sconn->conn,
-						       smb1req->conn->session_info,
-						       persistent_id, create_guid,
-						       now, &op);
-			if (!NT_STATUS_IS_OK(status)) {
-				DEBUG(3, ("smbd_smb2_create_send: "
-					  "smb2srv_open_recreate v2 failed: %s\n",
-					  nt_errstr(status)));
-				tevent_req_nterror(req, status);
-				return tevent_req_post(req, ev);
-			}
-
-			DEBUG(10, ("smb2_create_send: DH2C: %s recreate the "
-				   "smb2srv_open struct for a durable handle.\n",
-				   op->global->durable ? "did" : "could not"));
-
-			if (!op->global->durable) {
-				talloc_free(op);
-				tevent_req_nterror(req,
-					NT_STATUS_OBJECT_NAME_NOT_FOUND);
+		if (alsi) {
+			if (dhnc) {
+				tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
 				return tevent_req_post(req, ev);
 			}
 
-			do_durable_reconnect = true;
-		}
-
-		if (alsi) {
 			if (alsi->data.length != 8) {
 				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 				return tevent_req_post(req, ev);
@@ -778,6 +636,11 @@
 			time_t t;
 			struct tm *tm;
 
+			if (dhnc) {
+				tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_NOT_FOUND);
+				return tevent_req_post(req, ev);
+			}
+
 			if (twrp->data.length != 8) {
 				tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 				return tevent_req_post(req, ev);
@@ -813,109 +676,58 @@
 		in_create_options &= ~(0x10);/* NTCREATEX_OPTIONS_SYNC_ALERT */
 		in_create_options &= ~(0x20);/* NTCREATEX_OPTIONS_ASYNC_ALERT */
 
-		in_file_attributes &= ~FILE_FLAG_POSIX_SEMANTICS;
-
-		DEBUG(10, ("smbd_smb2_create_send: open execution phase\n"));
-
-		/*
-		 * For the backend file open procedure, there are
-		 * two possible modes: durable_reconnect or not.
+                /*
+		 * For a DFS path the function parse_dfs_path()
+		 * will do the path processing.
 		 */
-		if (do_durable_reconnect) {
-			DATA_BLOB new_cookie = data_blob_null;
-
-			status = SMB_VFS_DURABLE_RECONNECT(smb1req->conn,
-						smb1req,
-						op,
-						op->global->backend_cookie,
-						op, &result, &new_cookie);
-			if (!NT_STATUS_IS_OK(status)) {
-				NTSTATUS return_status;
-
-				return_status = NT_STATUS_OBJECT_NAME_NOT_FOUND;
-
-				DEBUG(3, ("smbd_smb2_create_send: "
-					  "durable_reconnect failed: %s => %s\n",
-					  nt_errstr(status),
-					  nt_errstr(return_status)));
-
-				tevent_req_nterror(req, return_status);
-				return tevent_req_post(req, ev);
-			}
-
-			data_blob_free(&op->global->backend_cookie);
-			op->global->backend_cookie = new_cookie;
-
-			op->status = NT_STATUS_OK;
-			op->global->disconnect_time = 0;
-
-			/* save the timout for later update */
-			durable_timeout_msec = op->global->durable_timeout_msec;
-
-			update_open = true;
-
-			info = FILE_WAS_OPENED;
-		} else {
-			struct smb_filename *smb_fname = NULL;
-
-			/*
-			 * For a DFS path the function parse_dfs_path()
-			 * will do the path processing.
-			 */
-
-			if (!(smb1req->flags2 & FLAGS2_DFS_PATHNAMES)) {
-				/* convert '\\' into '/' */
-				status = check_path_syntax(fname);
-				if (!NT_STATUS_IS_OK(status)) {
-					tevent_req_nterror(req, status);
-					return tevent_req_post(req, ev);
-				}
-			}
 
-			status = filename_convert(req,
-						  smb1req->conn,
-						  smb1req->flags2 & FLAGS2_DFS_PATHNAMES,
-						  fname,
-						  UCF_PREP_CREATEFILE,
-						  NULL, /* ppath_contains_wcards */
-						  &smb_fname);
+		if (!(smb1req->flags2 & FLAGS2_DFS_PATHNAMES)) {
+			/* convert '\\' into '/' */
+			status = check_path_syntax(fname);
 			if (!NT_STATUS_IS_OK(status)) {
 				tevent_req_nterror(req, status);
 				return tevent_req_post(req, ev);
 			}
+		}
 
-			status = SMB_VFS_CREATE_FILE(smb1req->conn,
-						     smb1req,
-						     0, /* root_dir_fid */
-						     smb_fname,
-						     in_desired_access,
-						     in_share_access,
-						     in_create_disposition,
-						     in_create_options,
-						     in_file_attributes,
-						     map_smb2_oplock_levels_to_samba(requested_oplock_level),
-						     allocation_size,
-						     0, /* private_flags */
-						     sec_desc,
-						     ea_list,
-						     &result,
-						     &info);
-			if (!NT_STATUS_IS_OK(status)) {
-				if (open_was_deferred(smb1req->sconn, smb1req->mid)) {
-					return req;
-				}
-				tevent_req_nterror(req, status);
-				return tevent_req_post(req, ev);
-			}
-			op = result->op;
+		status = filename_convert(req,
+					  smb1req->conn,
+					  smb1req->flags2 & FLAGS2_DFS_PATHNAMES,
+					  fname,
+					  (in_create_disposition == FILE_CREATE) ?
+						UCF_CREATING_FILE : 0,
+					  NULL,
+					  &smb_fname);
+		if (!NT_STATUS_IS_OK(status)) {
+			tevent_req_nterror(req, status);
+			return tevent_req_post(req, ev);
 		}
 
-		/*
-		 * here we have op == result->op
-		 */
+		in_file_attributes &= ~FILE_FLAG_POSIX_SEMANTICS;
 
-		DEBUG(10, ("smbd_smb2_create_send: "
-			   "response construction phase\n"));
+		status = SMB_VFS_CREATE_FILE(smb1req->conn,
+					     smb1req,
+					     0, /* root_dir_fid */
+					     smb_fname,
+					     in_desired_access,
+					     in_share_access,
+					     in_create_disposition,
+					     in_create_options,
+					     in_file_attributes,
+					     map_smb2_oplock_levels_to_samba(requested_oplock_level),
+					     allocation_size,
+					     0, /* private_flags */
+					     sec_desc,
+					     ea_list,
+					     &result,
+					     &info);
+		if (!NT_STATUS_IS_OK(status)) {
+			if (open_was_deferred(smb1req->mid)) {
+				return req;
+			}
+			tevent_req_nterror(req, status);
+			return tevent_req_post(req, ev);
+		}
 
 		if (mxac) {
 			NTTIME last_write_time;
@@ -929,6 +741,11 @@
 
 				status = smbd_calculate_access_mask(smb1req->conn,
 							result->fsp_name,
+							/*
+							 * at this stage
+							 * it exists
+							 */
+							true,
 							SEC_FLAG_MAXIMUM_ALLOWED,
 							&max_access_granted);
 
@@ -946,67 +763,6 @@
 			}
 		}
 
-		if (durable_requested &&
-		    BATCH_OPLOCK_TYPE(result->oplock_type))
-		{
-			status = SMB_VFS_DURABLE_COOKIE(result,
-						op,
-						&op->global->backend_cookie);
-			if (!NT_STATUS_IS_OK(status)) {
-				op->global->backend_cookie = data_blob_null;
-			}
-		}
-		if (op->global->backend_cookie.length > 0) {
-			update_open = true;
-
-			op->global->durable = true;
-			op->global->durable_timeout_msec = durable_timeout_msec;
-		}
-
-		if (update_open) {
-			op->global->create_guid = create_guid;
-
-			status = smbXsrv_open_update(op);
-			DEBUG(10, ("smb2_create_send: smbXsrv_open_update "
-				   "returned %s\n",
-				   nt_errstr(status)));
-			if (!NT_STATUS_IS_OK(status)) {
-				tevent_req_nterror(req, status);
-				return tevent_req_post(req, ev);
-			}
-		}
-
-		if (dhnq && op->global->durable) {
-			uint8_t p[8] = { 0, };
-			DATA_BLOB blob = data_blob_const(p, sizeof(p));
-
-			status = smb2_create_blob_add(state,
-						      &out_context_blobs,
-						      SMB2_CREATE_TAG_DHNQ,
-						      blob);
-			if (!NT_STATUS_IS_OK(status)) {
-				tevent_req_nterror(req, status);
-				return tevent_req_post(req, ev);
-			}
-		}
-
-		if (dh2q && op->global->durable) {
-			uint8_t p[8] = { 0, };
-			DATA_BLOB blob = data_blob_const(p, sizeof(p));
-			uint32_t durable_v2_response_flags = 0;
-
-			SIVAL(p, 0, op->global->durable_timeout_msec);
-			SIVAL(p, 4, durable_v2_response_flags);
-
-			status = smb2_create_blob_add(state, &out_context_blobs,
-						      SMB2_CREATE_TAG_DH2Q,
-						      blob);
-			if (!NT_STATUS_IS_OK(status)) {
-				tevent_req_nterror(req, status);
-				return tevent_req_post(req, ev);
-			}
-		}
-
 		if (qfid) {
 			uint8_t p[32];
 			uint64_t file_index = get_FileIndex(result->conn,
@@ -1034,7 +790,7 @@
 
 	smb2req->compat_chain_fsp = smb1req->chain_fsp;
 
-	if(lp_fake_oplocks(SNUM(smb2req->tcon->compat))) {
+	if(lp_fake_oplocks(SNUM(smb2req->tcon->compat_conn))) {
 		state->out_oplock_level	= in_oplock_level;
 	} else {
 		state->out_oplock_level	= map_samba_oplock_levels_to_smb2(result->oplock_type);
@@ -1056,12 +812,16 @@
 		update_stat_ex_mtime(&result->fsp_name->st, write_time_ts);
 	}
 
-	state->out_creation_ts = get_create_timespec(smb1req->conn,
-					result, result->fsp_name);
-	state->out_last_access_ts = result->fsp_name->st.st_ex_atime;
-	state->out_last_write_ts = result->fsp_name->st.st_ex_mtime;
-	state->out_change_ts = get_change_timespec(smb1req->conn,
-					result, result->fsp_name);
+	unix_timespec_to_nt_time(&state->out_creation_time,
+			get_create_timespec(smb1req->conn, result,
+					result->fsp_name));
+	unix_timespec_to_nt_time(&state->out_last_access_time,
+			result->fsp_name->st.st_ex_atime);
+	unix_timespec_to_nt_time(&state->out_last_write_time,
+			result->fsp_name->st.st_ex_mtime);
+	unix_timespec_to_nt_time(&state->out_change_time,
+			get_change_timespec(smb1req->conn, result,
+					result->fsp_name));
 	state->out_allocation_size =
 			SMB_VFS_GET_ALLOC_SIZE(smb1req->conn, result,
 					       &(result->fsp_name->st));
@@ -1069,13 +829,10 @@
 	if (state->out_file_attributes == 0) {
 		state->out_file_attributes = FILE_ATTRIBUTE_NORMAL;
 	}
-	state->out_file_id_persistent = result->op->global->open_persistent_id;
-	state->out_file_id_volatile = result->op->global->open_volatile_id;
+	state->out_file_id_persistent = fsp_persistent_id(result);
+	state->out_file_id_volatile = result->fnum;
 	state->out_context_blobs = out_context_blobs;
 
-	DEBUG(10,("smbd_smb2_create_send: %s - %s\n",
-		  fsp_str_dbg(result), fsp_fnum_dbg(result)));
-
 	tevent_req_done(req);
 	return tevent_req_post(req, ev);
 }
@@ -1084,10 +841,10 @@
 			TALLOC_CTX *mem_ctx,
 			uint8_t *out_oplock_level,
 			uint32_t *out_create_action,
-			struct timespec *out_creation_ts,
-			struct timespec *out_last_access_ts,
-			struct timespec *out_last_write_ts,
-			struct timespec *out_change_ts,
+			NTTIME *out_creation_time,
+			NTTIME *out_last_access_time,
+			NTTIME *out_last_write_time,
+			NTTIME *out_change_time,
 			uint64_t *out_allocation_size,
 			uint64_t *out_end_of_file,
 			uint32_t *out_file_attributes,
@@ -1106,10 +863,10 @@
 
 	*out_oplock_level	= state->out_oplock_level;
 	*out_create_action	= state->out_create_action;
-	*out_creation_ts	= state->out_creation_ts;
-	*out_last_access_ts	= state->out_last_access_ts;
-	*out_last_write_ts	= state->out_last_write_ts;
-	*out_change_ts		= state->out_change_ts;
+	*out_creation_time	= state->out_creation_time;
+	*out_last_access_time	= state->out_last_access_time;
+	*out_last_write_time	= state->out_last_write_time;
+	*out_change_time	= state->out_change_time;
 	*out_allocation_size	= state->out_allocation_size;
 	*out_end_of_file	= state->out_end_of_file;
 	*out_file_attributes	= state->out_file_attributes;
@@ -1284,7 +1041,7 @@
 	}
 }
 
-bool schedule_deferred_open_message_smb2(
+void schedule_deferred_open_message_smb2(
 	struct smbd_server_connection *sconn, uint64_t mid)
 {
 	struct smbd_smb2_create_state *state = NULL;
@@ -1296,18 +1053,18 @@
 		DEBUG(10,("schedule_deferred_open_message_smb2: "
 			"can't find mid %llu\n",
 			(unsigned long long)mid ));
-		return false;
+		return;
 	}
 	if (!smb2req->subreq) {
-		return false;
+		return;
 	}
 	if (!tevent_req_is_in_progress(smb2req->subreq)) {
-		return false;
+		return;
 	}
 	state = tevent_req_data(smb2req->subreq,
 			struct smbd_smb2_create_state);
 	if (!state) {
-		return false;
+		return;
 	}
 
 	/* Ensure we don't have any outstanding timer event. */
@@ -1317,7 +1074,7 @@
 
 	/*
 	 * This is subtle. We must null out the callback
-	 * before rescheduling, else the first call to
+	 * before resheduling, else the first call to
 	 * tevent_req_nterror() causes the _receive()
 	 * function to be called, this causing tevent_req_post()
 	 * to crash.
@@ -1328,7 +1085,6 @@
 	if (!state->im) {
 		smbd_server_connection_terminate(smb2req->sconn,
 			nt_errstr(NT_STATUS_NO_MEMORY));
-		return false;
 	}
 
 	DEBUG(10,("schedule_deferred_open_message_smb2: "
@@ -1336,11 +1092,9 @@
 		(unsigned long long)mid ));
 
 	tevent_schedule_immediate(state->im,
-			smb2req->sconn->ev_ctx,
+			smb2req->sconn->smb2.event_ctx,
 			smbd_smb2_create_request_dispatch_immediate,
 			smb2req);
-
-	return true;
 }
 
 /*********************************************************
@@ -1377,7 +1131,7 @@
 
 	/*
 	 * This is subtle. We must null out the callback
-	 * before rescheduling, else the first call to
+	 * before resheduling, else the first call to
 	 * tevent_req_nterror() causes the _receive()
 	 * function to be called, this causing tevent_req_post()
 	 * to crash.
@@ -1410,17 +1164,12 @@
 	smb2req = state->smb2req;
 	mid = get_mid_from_smb2req(smb2req);
 
-	if (is_deferred_open_async(state->private_data.data)) {
-		/* Can't cancel an async create. */
-		return false;
-	}
-
 	remove_deferred_open_entry(state->id, mid,
-				   messaging_server_id(smb2req->sconn->msg_ctx));
+				   sconn_server_id(smb2req->sconn));
 	remove_deferred_open_message_smb2_internal(smb2req, mid);
+	smb2req->cancelled = true;
 
-	tevent_req_defer_callback(req, smb2req->sconn->ev_ctx);
-	tevent_req_nterror(req, NT_STATUS_CANCELLED);
+	tevent_req_done(req);
 	return true;
 }
 
@@ -1454,6 +1203,35 @@
 		return false;
 	}
 
+#if 1
+	/* Boo - turns out this isn't what W2K8R2
+	   does. It actually sends the STATUS_PENDING
+	   message followed by the STATUS_SHARING_VIOLATION
+	   message. Surely this means that all open
+	   calls (even on directories) will potentially
+	   fail in a chain.... ? And I've seen directory
+	   opens as the start of a chain. JRA.
+
+	   Update: 19th May 2010. Talking with Microsoft
+	   engineers at the plugfest this is a bug in
+	   Windows. Re-enable this code.
+	*/
+	/*
+	 * More subtlety. To match W2K8R2 don't
+	 * send a "gone async" message if it's simply
+	 * a STATUS_SHARING_VIOLATION (short) wait, not
+	 * an oplock break wait. We do this by prematurely
+	 * setting smb2req->async flag.
+	 */
+	if (timeout.tv_sec < 2) {
+		DEBUG(10,("push_deferred_open_message_smb2: "
+			"short timer wait (usec = %u). "
+			"Don't send async message.\n",
+			(unsigned int)timeout.tv_usec ));
+		smb2req->async = true;
+	}
+#endif
+
 	/* Re-schedule us to retry on timer expiry. */
 	end_time = timeval_sum(&request_time, &timeout);
 
@@ -1464,7 +1242,7 @@
 				true) ));
 
 	state->open_was_deferred = true;
-	state->te = tevent_add_timer(smb2req->sconn->ev_ctx,
+	state->te = event_add_timed(smb2req->sconn->smb2.event_ctx,
 				state,
 				end_time,
 				smb2_deferred_open_timer,
Only in ../../samba-3.6.24/source3/smbd: smb2_create.o
diff -ur smbd/smb2_find.c ../../samba-3.6.24/source3/smbd/smb2_find.c
--- smbd/smb2_find.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_find.c	2015-01-28 10:52:25.149068676 +0800
@@ -43,6 +43,7 @@
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint8_t in_file_info_class;
 	uint8_t in_flags;
 	uint32_t in_file_index;
@@ -62,7 +63,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_file_info_class		= CVAL(inbody, 0x02);
 	in_flags			= CVAL(inbody, 0x03);
@@ -76,11 +77,11 @@
 	if (in_file_name_offset == 0 && in_file_name_length == 0) {
 		/* This is ok */
 	} else if (in_file_name_offset !=
-		   (SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(req))) {
+		   (SMB2_HDR_BODY + req->in.vector[i+1].iov_len)) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (in_file_name_length > SMBD_SMB2_IN_DYN_LEN(req)) {
+	if (in_file_name_length > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
@@ -95,14 +96,14 @@
 	/* Take into account the output header. */
 	in_output_buffer_length -= 8;
 
-	in_file_name_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
+	in_file_name_buffer.data = (uint8_t *)req->in.vector[i+2].iov_base;
 	in_file_name_buffer.length = in_file_name_length;
 
 	ok = convert_string_talloc(req, CH_UTF16, CH_UNIX,
 				   in_file_name_buffer.data,
 				   in_file_name_buffer.length,
 				   &in_file_name_string,
-				   &in_file_name_string_size);
+				   &in_file_name_string_size, false);
 	if (!ok) {
 		return smbd_smb2_request_error(req, NT_STATUS_ILLEGAL_CHARACTER);
 	}
@@ -120,7 +121,7 @@
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_find_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_find_send(req, req->sconn->smb2.event_ctx,
 				     req, in_fsp,
 				     in_file_info_class,
 				     in_flags,
@@ -132,13 +133,15 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_find_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_find_done(struct tevent_req *subreq)
 {
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
+	int i = req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint16_t out_output_buffer_offset;
@@ -162,6 +165,8 @@
 
 	out_output_buffer_offset = SMB2_HDR_BODY + 0x08;
 
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x08);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -210,7 +215,7 @@
 	struct tevent_req *req;
 	struct smbd_smb2_find_state *state;
 	struct smb_request *smbreq;
-	connection_struct *conn = smb2req->tcon->compat;
+	connection_struct *conn = smb2req->tcon->compat_conn;
 	NTSTATUS status;
 	NTSTATUS empty_status;
 	uint32_t info_level;
@@ -224,9 +229,6 @@
 	uint32_t dirtype = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY;
 	bool dont_descend = false;
 	bool ask_sharemode = true;
-	bool wcard_has_wild;
-	struct tm tm;
-	char *p;
 
 	req = tevent_req_create(mem_ctx, &state,
 				struct smbd_smb2_find_state);
@@ -236,8 +238,8 @@
 	state->smb2req = smb2req;
 	state->out_output_buffer = data_blob_null;
 
-	DEBUG(10,("smbd_smb2_find_send: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_find_send: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
@@ -253,39 +255,16 @@
 		tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_INVALID);
 		return tevent_req_post(req, ev);
 	}
-	if (strchr_m(in_file_name, '\\') != NULL) {
+	if (strcmp(in_file_name, "\\") == 0) {
 		tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_INVALID);
 		return tevent_req_post(req, ev);
 	}
-	if (strchr_m(in_file_name, '/') != NULL) {
+	if (strcmp(in_file_name, "/") == 0) {
 		tevent_req_nterror(req, NT_STATUS_OBJECT_NAME_INVALID);
 		return tevent_req_post(req, ev);
 	}
 
-	p = strptime(in_file_name, GMT_FORMAT, &tm);
-	if ((p != NULL) && (*p =='\0')) {
-		/*
-		 * Bogus find that asks for a shadow copy timestamp as a
-		 * directory. The correct response is that it does not exist as
-		 * a directory.
-		 */
-		tevent_req_nterror(req, NT_STATUS_NO_SUCH_FILE);
-		return tevent_req_post(req, ev);
-	}
-
 	if (in_output_buffer_length > smb2req->sconn->smb2.max_trans) {
-		DEBUG(2,("smbd_smb2_find_send: "
-			 "client ignored max trans:%s: 0x%08X: 0x%08X\n",
-			 __location__, in_output_buffer_length,
-			 smb2req->sconn->smb2.max_trans));
-		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-		return tevent_req_post(req, ev);
-	}
-
-	status = smbd_smb2_request_verify_creditcharge(smb2req,
-					in_output_buffer_length);
-
-	if (!NT_STATUS_IS_OK(status)) {
 		tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
 		return tevent_req_post(req, ev);
 	}
@@ -324,43 +303,17 @@
 		dptr_CloseDir(fsp);
 	}
 
-	wcard_has_wild = ms_has_wild(in_file_name);
+	if (fsp->dptr == NULL) {
+		bool wcard_has_wild;
 
-	/* Ensure we've canonicalized any search path if not a wildcard. */
-	if (!wcard_has_wild) {
-		struct smb_filename *smb_fname = NULL;
-		const char *fullpath;
-
-		if (ISDOT(fsp->fsp_name->base_name)) {
-			fullpath = in_file_name;
-		} else {
-			fullpath = talloc_asprintf(state,
-					"%s/%s",
-					fsp->fsp_name->base_name,
-					in_file_name);
-		}
-		if (tevent_req_nomem(fullpath, req)) {
+		if (!(fsp->access_mask & SEC_DIR_LIST)) {
+			tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
 			return tevent_req_post(req, ev);
 		}
-		status = filename_convert(state,
-				conn,
-				false, /* Not a DFS path. */
-				fullpath,
-				UCF_SAVE_LCOMP | UCF_ALWAYS_ALLOW_WCARD_LCOMP,
-				&wcard_has_wild,
-				&smb_fname);
 
-		if (!NT_STATUS_IS_OK(status)) {
-			tevent_req_nterror(req, status);
-			return tevent_req_post(req, ev);
-		}
-
-		in_file_name = smb_fname->original_lcomp;
-	}
+		wcard_has_wild = ms_has_wild(in_file_name);
 
-	if (fsp->dptr == NULL) {
 		status = dptr_create(conn,
-				     NULL, /* req */
 				     fsp,
 				     fsp->fsp_name->base_name,
 				     false, /* old_handle */
@@ -412,9 +365,9 @@
 
 	DEBUG(8,("smbd_smb2_find_send: dirpath=<%s> dontdescend=<%s>, "
 		"in_output_buffer_length = %u\n",
-		fsp->fsp_name->base_name, lp_dontdescend(talloc_tos(), SNUM(conn)),
+		fsp->fsp_name->base_name, lp_dontdescend(SNUM(conn)),
 		(unsigned int)in_output_buffer_length ));
-	if (in_list(fsp->fsp_name->base_name,lp_dontdescend(talloc_tos(), SNUM(conn)),
+	if (in_list(fsp->fsp_name->base_name,lp_dontdescend(SNUM(conn)),
 			conn->case_sensitive)) {
 		dont_descend = true;
 	}
Only in ../../samba-3.6.24/source3/smbd: smb2_find.o
diff -ur smbd/smb2_flush.c ../../samba-3.6.24/source3/smbd/smb2_flush.c
--- smbd/smb2_flush.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_flush.c	2015-01-28 10:52:25.149068676 +0800
@@ -35,6 +35,7 @@
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint64_t in_file_id_persistent;
 	uint64_t in_file_id_volatile;
 	struct files_struct *in_fsp;
@@ -44,7 +45,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_file_id_persistent	= BVAL(inbody, 0x08);
 	in_file_id_volatile	= BVAL(inbody, 0x10);
@@ -54,14 +55,14 @@
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_flush_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_flush_send(req, req->sconn->smb2.event_ctx,
 				      req, in_fsp);
 	if (subreq == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_flush_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_flush_done(struct tevent_req *subreq)
@@ -127,8 +128,8 @@
 	}
 	state->smb2req = smb2req;
 
-	DEBUG(10,("smbd_smb2_flush: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_flush: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
Only in ../../samba-3.6.24/source3/smbd: smb2_flush.o
diff -ur smbd/smb2_getinfo.c ../../samba-3.6.24/source3/smbd/smb2_getinfo.c
--- smbd/smb2_getinfo.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_getinfo.c	2015-01-28 10:52:25.149068676 +0800
@@ -46,6 +46,7 @@
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint8_t in_info_type;
 	uint8_t in_file_info_class;
 	uint32_t in_output_buffer_length;
@@ -63,7 +64,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_info_type			= CVAL(inbody, 0x02);
 	in_file_info_class		= CVAL(inbody, 0x03);
@@ -79,44 +80,30 @@
 	if (in_input_buffer_offset == 0 && in_input_buffer_length == 0) {
 		/* This is ok */
 	} else if (in_input_buffer_offset !=
-		   (SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(req))) {
+		   (SMB2_HDR_BODY + req->in.vector[i+1].iov_len)) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (in_input_buffer_length > SMBD_SMB2_IN_DYN_LEN(req)) {
+	if (in_input_buffer_length > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_input_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
+	in_input_buffer.data = (uint8_t *)req->in.vector[i+2].iov_base;
 	in_input_buffer.length = in_input_buffer_length;
 
 	if (in_input_buffer.length > req->sconn->smb2.max_trans) {
-		DEBUG(2,("smbd_smb2_request_process_getinfo: "
-			 "client ignored max trans: %s: 0x%08X: 0x%08X\n",
-			 __location__, (unsigned)in_input_buffer.length,
-			 (unsigned)req->sconn->smb2.max_trans));
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 	if (in_output_buffer_length > req->sconn->smb2.max_trans) {
-		DEBUG(2,("smbd_smb2_request_process_getinfo: "
-			 "client ignored max trans: %s: 0x%08X: 0x%08X\n",
-			 __location__, in_output_buffer_length,
-			 req->sconn->smb2.max_trans));
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	status = smbd_smb2_request_verify_creditcharge(req,
-			MAX(in_input_buffer.length,in_output_buffer_length));
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	in_fsp = file_fsp_smb2(req, in_file_id_persistent, in_file_id_volatile);
 	if (in_fsp == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_getinfo_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_getinfo_send(req, req->sconn->smb2.event_ctx,
 					req, in_fsp,
 					in_info_type,
 					in_file_info_class,
@@ -129,13 +116,15 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_getinfo_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_getinfo_done(struct tevent_req *subreq)
 {
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
+	int i = req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint16_t out_output_buffer_offset;
@@ -178,6 +167,8 @@
 
 	out_output_buffer_offset = SMB2_HDR_BODY + 0x08;
 
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x08);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -255,7 +246,7 @@
 	struct tevent_req *req;
 	struct smbd_smb2_getinfo_state *state;
 	struct smb_request *smbreq;
-	connection_struct *conn = smb2req->tcon->compat;
+	connection_struct *conn = smb2req->tcon->compat_conn;
 	NTSTATUS status;
 
 	req = tevent_req_create(mem_ctx, &state,
@@ -267,8 +258,8 @@
 	state->status = NT_STATUS_OK;
 	state->out_output_buffer = data_blob_null;
 
-	DEBUG(10,("smbd_smb2_getinfo_send: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_getinfo_send: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
@@ -319,7 +310,7 @@
 
 			/* We know this name is ok, it's already passed the checks. */
 
-		} else if (fsp->fh->fd == -1) {
+		} else if (fsp && fsp->fh->fd == -1) {
 			/*
 			 * This is actually a QFILEINFO on a directory
 			 * handle (returned from an NT SMB). NT5.0 seems
@@ -358,8 +349,8 @@
 
 			if (SMB_VFS_FSTAT(fsp, &fsp->fsp_name->st) != 0) {
 				DEBUG(3, ("smbd_smb2_getinfo_send: "
-					  "fstat of %s failed (%s)\n",
-					  fsp_fnum_dbg(fsp), strerror(errno)));
+					  "fstat of fnum %d failed (%s)\n",
+					  fsp->fnum, strerror(errno)));
 				status = map_nt_error_from_unix(errno);
 				tevent_req_nterror(req, status);
 				return tevent_req_post(req, ev);
@@ -478,8 +469,7 @@
 				state,
 				fsp,
 				/* Security info wanted. */
-				in_additional_information &
-				SMB_SUPPORTED_SECINFO_FLAGS,
+				in_additional_information,
 				in_output_buffer_length,
 				&p_marshalled_sd,
 				&sd_size);
@@ -516,10 +506,6 @@
 		break;
 	}
 
-	case SMB2_GETINFO_QUOTA:
-		tevent_req_nterror(req, NT_STATUS_NOT_SUPPORTED);
-		return tevent_req_post(req, ev);
-
 	default:
 		DEBUG(10,("smbd_smb2_getinfo_send: "
 			"unknown in_info_type of %u "
Only in ../../samba-3.6.24/source3/smbd: smb2_getinfo.o
diff -ur smbd/smb2_glue.c ../../samba-3.6.24/source3/smbd/smb2_glue.c
--- smbd/smb2_glue.c	2013-05-21 14:48:46.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_glue.c	2015-01-28 10:52:25.149068676 +0800
@@ -26,21 +26,19 @@
 struct smb_request *smbd_smb2_fake_smb_request(struct smbd_smb2_request *req)
 {
 	struct smb_request *smbreq;
-	const uint8_t *inhdr = SMBD_SMB2_IN_HDR_PTR(req);
+	const uint8_t *inhdr;
+	int i = req->current_idx;
 
-	if (req->smb1req) {
-		smbreq = req->smb1req;
-	} else {
-		smbreq = talloc_zero(req, struct smb_request);
-		if (smbreq == NULL) {
-			return NULL;
-		}
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
+
+	smbreq = talloc_zero(req, struct smb_request);
+	if (smbreq == NULL) {
+		return NULL;
 	}
 
-	smbreq->request_time = req->request_time;
-	smbreq->vuid = req->session->compat->vuid;
-	smbreq->tid = req->tcon->compat->cnum;
-	smbreq->conn = req->tcon->compat;
+	smbreq->vuid = req->session->compat_vuser->vuid;
+	smbreq->tid = req->tcon->compat_conn->cnum;
+	smbreq->conn = req->tcon->compat_conn;
 	smbreq->sconn = req->sconn;
 	smbreq->smbpid = (uint16_t)IVAL(inhdr, SMB2_HDR_PID);
 	smbreq->flags2 = FLAGS2_UNICODE_STRINGS |
@@ -59,18 +57,6 @@
 }
 
 /*********************************************************
- Are there unread bytes for recvfile ?
-*********************************************************/
-
-size_t smbd_smb2_unread_bytes(struct smbd_smb2_request *req)
-{
-	if (req->smb1req) {
-		return req->smb1req->unread_bytes;
-	}
-	return 0;
-}
-
-/*********************************************************
  Called from file_free() to remove any chained fsp pointers.
 *********************************************************/
 
Only in ../../samba-3.6.24/source3/smbd: smb2_glue.o
diff -ur smbd/smb2_ioctl.c ../../samba-3.6.24/source3/smbd/smb2_ioctl.c
--- smbd/smb2_ioctl.c	2014-02-18 17:15:49.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_ioctl.c	2015-01-28 10:52:25.149068676 +0800
@@ -25,7 +25,6 @@
 #include "../lib/util/tevent_ntstatus.h"
 #include "rpc_server/srv_pipe_hnd.h"
 #include "include/ntioctl.h"
-#include "../librpc/ndr/libndr.h"
 
 static struct tevent_req *smbd_smb2_ioctl_send(TALLOC_CTX *mem_ctx,
 					       struct tevent_context *ev,
@@ -37,59 +36,39 @@
 					       uint32_t in_flags);
 static NTSTATUS smbd_smb2_ioctl_recv(struct tevent_req *req,
 				     TALLOC_CTX *mem_ctx,
-				     DATA_BLOB *out_output,
-				     bool *disconnect);
+				     DATA_BLOB *out_output);
 
 static void smbd_smb2_request_ioctl_done(struct tevent_req *subreq);
 NTSTATUS smbd_smb2_request_process_ioctl(struct smbd_smb2_request *req)
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
-	uint32_t min_buffer_offset;
-	uint32_t max_buffer_offset;
-	uint32_t min_output_offset;
-	uint32_t allowed_length_in;
-	uint32_t allowed_length_out;
+	int i = req->current_idx;
 	uint32_t in_ctl_code;
 	uint64_t in_file_id_persistent;
 	uint64_t in_file_id_volatile;
 	struct files_struct *in_fsp = NULL;
 	uint32_t in_input_offset;
 	uint32_t in_input_length;
-	DATA_BLOB in_input_buffer = data_blob_null;
-	uint32_t in_max_input_length;
-	uint32_t in_output_offset;
-	uint32_t in_output_length;
-	DATA_BLOB in_output_buffer = data_blob_null;
+	DATA_BLOB in_input_buffer;
 	uint32_t in_max_output_length;
 	uint32_t in_flags;
-	uint32_t data_length_in;
-	uint32_t data_length_out;
-	uint32_t data_length_tmp;
-	uint32_t data_length_max;
 	struct tevent_req *subreq;
 
 	status = smbd_smb2_request_verify_sizes(req, 0x39);
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_ctl_code		= IVAL(inbody, 0x04);
 	in_file_id_persistent	= BVAL(inbody, 0x08);
 	in_file_id_volatile	= BVAL(inbody, 0x10);
 	in_input_offset		= IVAL(inbody, 0x18);
 	in_input_length		= IVAL(inbody, 0x1C);
-	in_max_input_length	= IVAL(inbody, 0x20);
-	in_output_offset	= IVAL(inbody, 0x24);
-	in_output_length	= IVAL(inbody, 0x28);
 	in_max_output_length	= IVAL(inbody, 0x2C);
 	in_flags		= IVAL(inbody, 0x30);
 
-	min_buffer_offset = SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(req);
-	max_buffer_offset = min_buffer_offset + SMBD_SMB2_IN_DYN_LEN(req);
-	min_output_offset = min_buffer_offset;
-
 	/*
 	 * InputOffset (4 bytes): The offset, in bytes, from the beginning of
 	 * the SMB2 header to the input data buffer. If no input data is
@@ -98,91 +77,17 @@
 	 * <49> If no input data is required for the FSCTL/IOCTL command being
 	 * issued, Windows-based clients set this field to any value.
 	 */
-	allowed_length_in = 0;
-	if ((in_input_offset > 0) && (in_input_length > 0)) {
-		uint32_t tmp_ofs;
-
-		if (in_input_offset < min_buffer_offset) {
-			return smbd_smb2_request_error(req,
-					NT_STATUS_INVALID_PARAMETER);
-		}
-		if (in_input_offset > max_buffer_offset) {
-			return smbd_smb2_request_error(req,
-					NT_STATUS_INVALID_PARAMETER);
-		}
-		allowed_length_in = max_buffer_offset - in_input_offset;
-
-		tmp_ofs = in_input_offset - min_buffer_offset;
-		in_input_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
-		in_input_buffer.data += tmp_ofs;
-		in_input_buffer.length = in_input_length;
-		min_output_offset += tmp_ofs;
-		min_output_offset += in_input_length;
-	}
-
-	if (in_input_length > allowed_length_in) {
+	if ((in_input_length > 0)
+	 && (in_input_offset != (SMB2_HDR_BODY + req->in.vector[i+1].iov_len))) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	allowed_length_out = 0;
-	if (in_output_offset > 0) {
-		if (in_output_offset < min_buffer_offset) {
-			return smbd_smb2_request_error(req,
-					NT_STATUS_INVALID_PARAMETER);
-		}
-		if (in_output_offset > max_buffer_offset) {
-			return smbd_smb2_request_error(req,
-					NT_STATUS_INVALID_PARAMETER);
-		}
-		allowed_length_out = max_buffer_offset - in_output_offset;
-	}
-
-	if (in_output_length > allowed_length_out) {
-		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
-	}
-
-	if (in_output_length > 0) {
-		uint32_t tmp_ofs;
-
-		if (in_output_offset < min_output_offset) {
-			return smbd_smb2_request_error(req,
-					NT_STATUS_INVALID_PARAMETER);
-		}
-
-		tmp_ofs = in_output_offset - min_buffer_offset;
-		in_output_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
-		in_output_buffer.data += tmp_ofs;
-		in_output_buffer.length = in_output_length;
-	}
-
-	/*
-	 * verify the credits and avoid overflows
-	 * in_input_buffer.length and in_output_buffer.length
-	 * are already verified.
-	 */
-	data_length_in = in_input_buffer.length + in_output_buffer.length;
-
-	data_length_out = in_max_input_length;
-	data_length_tmp = UINT32_MAX - data_length_out;
-	if (data_length_tmp < in_max_output_length) {
+	if (in_input_length > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
-	data_length_out += in_max_output_length;
-
-	data_length_max = MAX(data_length_in, data_length_out);
-
-	status = smbd_smb2_request_verify_creditcharge(req, data_length_max);
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
 
-	/*
-	 * If the Flags field of the request is not SMB2_0_IOCTL_IS_FSCTL the
-	 * server MUST fail the request with STATUS_NOT_SUPPORTED.
-	 */
-	if (in_flags != SMB2_IOCTL_FLAG_IS_FSCTL) {
-		return smbd_smb2_request_error(req, NT_STATUS_NOT_SUPPORTED);
-	}
+	in_input_buffer.data = (uint8_t *)req->in.vector[i+2].iov_base;
+	in_input_buffer.length = in_input_length;
 
 	switch (in_ctl_code) {
 	case FSCTL_DFS_GET_REFERRALS:
@@ -207,14 +112,15 @@
 		break;
 	default:
 		in_fsp = file_fsp_smb2(req, in_file_id_persistent,
-				       in_file_id_volatile);
+					in_file_id_volatile);
 		if (in_fsp == NULL) {
 			return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 		}
 		break;
 	}
 
-	subreq = smbd_smb2_ioctl_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_ioctl_send(req,
+				      req->sconn->smb2.event_ctx,
 				      req, in_fsp,
 				      in_ctl_code,
 				      in_input_buffer,
@@ -225,7 +131,7 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_ioctl_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 1000);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_ioctl_done(struct tevent_req *subreq)
@@ -233,6 +139,8 @@
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
 	const uint8_t *inbody;
+	int i = req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint32_t in_ctl_code;
@@ -243,11 +151,8 @@
 	DATA_BLOB out_output_buffer = data_blob_null;
 	NTSTATUS status;
 	NTSTATUS error; /* transport error */
-	bool disconnect = false;
 
-	status = smbd_smb2_ioctl_recv(subreq, req,
-				      &out_output_buffer,
-				      &disconnect);
+	status = smbd_smb2_ioctl_recv(subreq, req, &out_output_buffer);
 
 	DEBUG(10,("smbd_smb2_request_ioctl_done: smbd_smb2_ioctl_recv returned "
 		"%u status %s\n",
@@ -255,13 +160,6 @@
 		nt_errstr(status) ));
 
 	TALLOC_FREE(subreq);
-	if (disconnect) {
-		error = status;
-		smbd_server_connection_terminate(req->sconn,
-						 nt_errstr(error));
-		return;
-	}
-
 	if (NT_STATUS_EQUAL(status, STATUS_BUFFER_OVERFLOW)) {
 		/* also ok */
 	} else if (!NT_STATUS_IS_OK(status)) {
@@ -277,12 +175,14 @@
 	out_input_offset = SMB2_HDR_BODY + 0x30;
 	out_output_offset = SMB2_HDR_BODY + 0x30;
 
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_ctl_code		= IVAL(inbody, 0x04);
 	in_file_id_persistent	= BVAL(inbody, 0x08);
 	in_file_id_volatile	= BVAL(inbody, 0x10);
 
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x30);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -335,7 +235,6 @@
 	DATA_BLOB in_input;
 	uint32_t in_max_output;
 	DATA_BLOB out_output;
-	bool disconnect;
 };
 
 static void smbd_smb2_ioctl_pipe_write_done(struct tevent_req *subreq);
@@ -367,10 +266,10 @@
 	state->in_max_output = in_max_output;
 	state->out_output = data_blob_null;
 
-	DEBUG(10, ("smbd_smb2_ioctl: ctl_code[0x%08x] %s, %s\n",
-		   (unsigned)in_ctl_code,
-		   fsp ? fsp_str_dbg(fsp) : "<no handle>",
-		   fsp_fnum_dbg(fsp)));
+	DEBUG(10, ("smbd_smb2_ioctl: ctl_code[0x%08x] %s fnum[%d]\n",
+		(unsigned)in_ctl_code,
+		fsp ? fsp_str_dbg(fsp) : "<no handle>",
+		fsp ? fsp->fnum : -1));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
@@ -414,7 +313,7 @@
 					   in_file_name_buffer.data,
 					   in_file_name_buffer.length,
 					   &in_file_name_string,
-					   &in_file_name_string_size);
+					   &in_file_name_string_size, false);
 		if (!ok) {
 			tevent_req_nterror(req, NT_STATUS_ILLEGAL_CHARACTER);
 			return tevent_req_post(req, ev);
@@ -485,97 +384,6 @@
 					req);
 		return req;
 
-	case FSCTL_VALIDATE_NEGOTIATE_INFO:
-	{
-		struct smbXsrv_connection *conn = smbreq->sconn->conn;
-		uint32_t in_capabilities;
-		DATA_BLOB in_guid_blob;
-		struct GUID in_guid;
-		uint16_t in_security_mode;
-		uint16_t in_num_dialects;
-		uint16_t i;
-		DATA_BLOB out_guid_blob;
-		NTSTATUS status;
-
-		if (in_input.length < 0x18) {
-			tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			return tevent_req_post(req, ev);
-		}
-
-		in_capabilities = IVAL(in_input.data, 0x00);
-		in_guid_blob = data_blob_const(in_input.data + 0x04, 16);
-		in_security_mode = SVAL(in_input.data, 0x14);
-		in_num_dialects = SVAL(in_input.data, 0x16);
-
-		if (in_input.length < (0x18 + in_num_dialects*2)) {
-			tevent_req_nterror(req, NT_STATUS_INVALID_PARAMETER);
-			return tevent_req_post(req, ev);
-		}
-
-		if (in_max_output < 0x18) {
-			tevent_req_nterror(req, NT_STATUS_BUFFER_TOO_SMALL);
-			return tevent_req_post(req, ev);
-		}
-
-		status = GUID_from_ndr_blob(&in_guid_blob, &in_guid);
-		if (tevent_req_nterror(req, status)) {
-			return tevent_req_post(req, ev);
-		}
-
-		if (in_num_dialects != conn->smb2.client.num_dialects) {
-			state->disconnect = true;
-			tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
-			return tevent_req_post(req, ev);
-		}
-
-		for (i=0; i < in_num_dialects; i++) {
-			uint16_t v = SVAL(in_input.data, 0x18 + i*2);
-
-			if (conn->smb2.client.dialects[i] != v) {
-				state->disconnect = true;
-				tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
-				return tevent_req_post(req, ev);
-			}
-		}
-
-		if (GUID_compare(&in_guid, &conn->smb2.client.guid) != 0) {
-			state->disconnect = true;
-			tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
-			return tevent_req_post(req, ev);
-		}
-
-		if (in_security_mode != conn->smb2.client.security_mode) {
-			state->disconnect = true;
-			tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
-			return tevent_req_post(req, ev);
-		}
-
-		if (in_capabilities != conn->smb2.client.capabilities) {
-			state->disconnect = true;
-			tevent_req_nterror(req, NT_STATUS_ACCESS_DENIED);
-			return tevent_req_post(req, ev);
-		}
-
-		status = GUID_to_ndr_blob(&conn->smb2.server.guid, state,
-					  &out_guid_blob);
-		if (tevent_req_nterror(req, status)) {
-			return tevent_req_post(req, ev);
-		}
-
-		state->out_output = data_blob_talloc(state, NULL, 0x18);
-		if (tevent_req_nomem(state->out_output.data, req)) {
-			return tevent_req_post(req, ev);
-		}
-
-		SIVAL(state->out_output.data, 0x00, conn->smb2.server.capabilities);
-		memcpy(state->out_output.data+0x04, out_guid_blob.data, 16);
-		SSVAL(state->out_output.data, 0x14, conn->smb2.server.security_mode);
-		SSVAL(state->out_output.data, 0x16, conn->smb2.server.dialect);
-
-		tevent_req_done(req);
-		return tevent_req_post(req, ev);
-	}
-
 	default: {
 		uint8_t *out_data = NULL;
 		uint32_t out_data_len = 0;
@@ -586,7 +394,7 @@
 			return tevent_req_post(req, ev);
 		}
 
-		status = SMB_VFS_FSCTL(fsp,
+		status = smb_fsctl(fsp,
 				       state,
 				       in_ctl_code,
 				       smbreq->flags2,
@@ -634,8 +442,6 @@
 
 	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
-		NTSTATUS old = status;
-		status = nt_status_np_pipe(old);
 		tevent_req_nterror(req, status);
 		return;
 	}
@@ -657,7 +463,7 @@
 
 	TALLOC_FREE(subreq);
 	subreq = np_read_send(state->smbreq->conn,
-			      state->smb2req->sconn->ev_ctx,
+			      state->smb2req->sconn->smb2.event_ctx,
 			      state->fsp->fake_file_handle,
 			      state->out_output.data,
 			      state->out_output.length);
@@ -674,24 +480,18 @@
 	struct smbd_smb2_ioctl_state *state = tevent_req_data(req,
 					      struct smbd_smb2_ioctl_state);
 	NTSTATUS status;
-	NTSTATUS old;
 	ssize_t nread = -1;
 	bool is_data_outstanding = false;
 
 	status = np_read_recv(subreq, &nread, &is_data_outstanding);
-	TALLOC_FREE(subreq);
-
-	old = status;
-	status = nt_status_np_pipe(old);
 
 	DEBUG(10,("smbd_smb2_ioctl_pipe_read_done: np_read_recv nread = %d "
-		 "is_data_outstanding = %d, status = %s%s%s\n",
+		 "is_data_outstanding = %d, status = %s\n",
 		(int)nread,
 		(int)is_data_outstanding,
-		nt_errstr(old),
-		NT_STATUS_EQUAL(old, status)?"":" => ",
-		NT_STATUS_EQUAL(old, status)?"":nt_errstr(status)));
+		nt_errstr(status) ));
 
+	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
 		tevent_req_nterror(req, status);
 		return;
@@ -709,15 +509,12 @@
 
 static NTSTATUS smbd_smb2_ioctl_recv(struct tevent_req *req,
 				     TALLOC_CTX *mem_ctx,
-				     DATA_BLOB *out_output,
-				     bool *disconnect)
+				     DATA_BLOB *out_output)
 {
 	NTSTATUS status = NT_STATUS_OK;
 	struct smbd_smb2_ioctl_state *state = tevent_req_data(req,
 					      struct smbd_smb2_ioctl_state);
 
-	*disconnect = state->disconnect;
-
 	if (tevent_req_is_nterror(req, &status)) {
 		if (!NT_STATUS_EQUAL(status, STATUS_BUFFER_OVERFLOW)) {
 			tevent_req_received(req);
Only in ../../samba-3.6.24/source3/smbd: smb2_ioctl.o
Only in ../../samba-3.6.24/source3/smbd: smb2_keepalive.o
diff -ur smbd/smb2_lock.c ../../samba-3.6.24/source3/smbd/smb2_lock.c
--- smbd/smb2_lock.c	2014-07-30 16:52:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_lock.c	2015-01-28 10:52:25.149068676 +0800
@@ -47,6 +47,7 @@
 						 struct tevent_context *ev,
 						 struct smbd_smb2_request *smb2req,
 						 struct files_struct *in_fsp,
+						 uint32_t in_smbpid,
 						 uint16_t in_lock_count,
 						 struct smbd_smb2_lock_element *in_locks);
 static NTSTATUS smbd_smb2_lock_recv(struct tevent_req *req);
@@ -54,7 +55,10 @@
 static void smbd_smb2_request_lock_done(struct tevent_req *subreq);
 NTSTATUS smbd_smb2_request_process_lock(struct smbd_smb2_request *req)
 {
+	const uint8_t *inhdr;
 	const uint8_t *inbody;
+	const int i = req->current_idx;
+	uint32_t in_smbpid;
 	uint16_t in_lock_count;
 	uint64_t in_file_id_persistent;
 	uint64_t in_file_id_volatile;
@@ -69,7 +73,10 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
+
+	in_smbpid			= IVAL(inhdr, SMB2_HDR_PID);
 
 	in_lock_count			= CVAL(inbody, 0x02);
 	/* 0x04 - 4 bytes reserved */
@@ -80,7 +87,7 @@
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (((in_lock_count - 1) * 0x18) > SMBD_SMB2_IN_DYN_LEN(req)) {
+	if (((in_lock_count - 1) * 0x18) > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
@@ -98,7 +105,7 @@
 	in_locks[l].flags	= IVAL(lock_buffer, 0x10);
 	/* 0x14 - 4 reserved bytes */
 
-	lock_buffer = SMBD_SMB2_IN_DYN_PTR(req);
+	lock_buffer = (const uint8_t *)req->in.vector[i+2].iov_base;
 
 	for (l=1; l < in_lock_count; l++) {
 		in_locks[l].offset	= BVAL(lock_buffer, 0x00);
@@ -114,8 +121,9 @@
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_lock_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_lock_send(req, req->sconn->smb2.event_ctx,
 				     req, in_fsp,
+				     in_smbpid,
 				     in_lock_count,
 				     in_locks);
 	if (subreq == NULL) {
@@ -123,7 +131,7 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_lock_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_lock_done(struct tevent_req *subreq)
@@ -134,6 +142,32 @@
 	NTSTATUS status;
 	NTSTATUS error; /* transport error */
 
+	if (smb2req->cancelled) {
+		const uint8_t *inhdr = (const uint8_t *)
+			smb2req->in.vector[smb2req->current_idx].iov_base;
+		uint64_t mid = BVAL(inhdr, SMB2_HDR_MESSAGE_ID);
+		struct smbd_smb2_lock_state *state;
+
+		DEBUG(10,("smbd_smb2_request_lock_done: cancelled mid %llu\n",
+			(unsigned long long)mid ));
+
+		state = tevent_req_data(smb2req->subreq,
+				struct smbd_smb2_lock_state);
+
+		SMB_ASSERT(state);
+		SMB_ASSERT(state->blr);
+
+		remove_pending_lock(state, state->blr);
+
+		error = smbd_smb2_request_error(smb2req, NT_STATUS_CANCELLED);
+		if (!NT_STATUS_IS_OK(error)) {
+			smbd_server_connection_terminate(smb2req->sconn,
+				nt_errstr(error));
+			return;
+		}
+		return;
+	}
+
 	status = smbd_smb2_lock_recv(subreq);
 	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -172,6 +206,7 @@
 						 struct tevent_context *ev,
 						 struct smbd_smb2_request *smb2req,
 						 struct files_struct *fsp,
+						 uint32_t in_smbpid,
 						 uint16_t in_lock_count,
 						 struct smbd_smb2_lock_element *in_locks)
 {
@@ -199,8 +234,8 @@
 	}
 	state->smb1req = smb1req;
 
-	DEBUG(10,("smbd_smb2_lock_send: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_lock_send: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	locks = talloc_array(state, struct smbd_lock_element, in_lock_count);
 	if (locks == NULL) {
@@ -282,7 +317,7 @@
 			return tevent_req_post(req, ev);
 		}
 
-		locks[i].smblctx = fsp->op->global->open_persistent_id;
+		locks[i].smblctx = fsp->fnum;
 		locks[i].offset = in_locks[i].offset;
 		locks[i].count  = in_locks[i].length;
 
@@ -368,43 +403,22 @@
 
 static bool smbd_smb2_lock_cancel(struct tevent_req *req)
 {
-	struct smbd_smb2_request *smb2req = NULL;
-	struct smbd_smb2_lock_state *state = tevent_req_data(req,
-				struct smbd_smb2_lock_state);
-	if (!state) {
-		return false;
-	}
-
-	if (!state->smb2req) {
-		return false;
-	}
-
-	smb2req = state->smb2req;
-
-	remove_pending_lock(state, state->blr);
-	tevent_req_defer_callback(req, smb2req->sconn->ev_ctx);
+        struct smbd_smb2_request *smb2req = NULL;
+        struct smbd_smb2_lock_state *state = tevent_req_data(req,
+                                struct smbd_smb2_lock_state);
+        if (!state) {
+                return false;
+        }
 
-	/*
-	 * If the request is canceled because of logoff, tdis or close
-	 * the status is NT_STATUS_RANGE_NOT_LOCKED instead of
-	 * NT_STATUS_CANCELLED.
-	 *
-	 * Note that the close case is handled in
-	 * cancel_pending_lock_requests_by_fid_smb2(SHUTDOWN_CLOSE)
-	 * for now.
-	 */
-	if (!NT_STATUS_IS_OK(smb2req->session->status)) {
-		tevent_req_nterror(req, NT_STATUS_RANGE_NOT_LOCKED);
-		return true;
-	}
+        if (!state->smb2req) {
+                return false;
+        }
 
-	if (!NT_STATUS_IS_OK(smb2req->tcon->status)) {
-		tevent_req_nterror(req, NT_STATUS_RANGE_NOT_LOCKED);
-		return true;
-	}
+        smb2req = state->smb2req;
+        smb2req->cancelled = true;
 
-	tevent_req_nterror(req, NT_STATUS_CANCELLED);
-	return true;
+        tevent_req_done(req);
+        return true;
 }
 
 /****************************************************************
@@ -418,12 +432,15 @@
 				struct server_id server_id,
 				DATA_BLOB *data)
 {
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
+	struct smbd_server_connection *sconn;
 
 	DEBUG(10,("received_unlock_msg (SMB2)\n"));
 
+	sconn = msg_ctx_to_sconn(msg);
+	if (sconn == NULL) {
+		DEBUG(1, ("could not find sconn\n"));
+		return;
+	}
 	process_blocking_lock_queue_smb2(sconn, timeval_current());
 }
 
@@ -445,7 +462,7 @@
 	if (!tevent_req_is_in_progress(smb2req->subreq)) {
 		return NULL;
 	}
-	inhdr = SMBD_SMB2_IN_HDR_PTR(smb2req);
+	inhdr = (const uint8_t *)smb2req->in.vector[smb2req->current_idx].iov_base;
 	if (SVAL(inhdr, SMB2_HDR_OPCODE) != SMB2_OP_LOCK) {
 		return NULL;
 	}
@@ -526,12 +543,12 @@
 			(int)from_now.tv_sec, (int)from_now.tv_usec));
 	}
 
-	sconn->smb2.locks.brl_timeout = tevent_add_timer(
-				sconn->ev_ctx,
+	sconn->smb2.locks.brl_timeout = event_add_timed(
+				smbd_event_context(),
 				NULL,
 				next_timeout,
 				brl_timeout_fn,
-				sconn);
+				NULL);
 	if (!sconn->smb2.locks.brl_timeout) {
 		return false;
 	}
@@ -587,7 +604,9 @@
 		blr->expire_time.tv_sec = 0;
 		blr->expire_time.tv_usec = 0; /* Never expire. */
 	} else {
-		blr->expire_time = timeval_current_ofs_msec(lock_timeout);
+		blr->expire_time = timeval_current_ofs(
+			lock_timeout/1000,
+			(lock_timeout % 1000) * 1000);
 	}
 
 	blr->lock_num = lock_num;
@@ -605,7 +624,7 @@
 	status = brl_lock(sconn->msg_ctx,
 			br_lck,
 			smblctx,
-			messaging_server_id(sconn->msg_ctx),
+			sconn_server_id(sconn),
 			offset,
 			count,
 			lock_type == READ_LOCK ? PENDING_READ_LOCK : PENDING_WRITE_LOCK,
@@ -630,7 +649,7 @@
 
 	/* Ensure we'll receive messages when this is unlocked. */
 	if (!sconn->smb2.locks.blocking_lock_unlock_state) {
-		messaging_register(sconn->msg_ctx, sconn,
+		messaging_register(sconn->msg_ctx, NULL,
 				MSG_SMB_UNLOCK, received_unlock_msg);
 		sconn->smb2.locks.blocking_lock_unlock_state = true;
         }
@@ -657,13 +676,26 @@
 	if (br_lck) {
 		brl_lock_cancel(br_lck,
 				blr->smblctx,
-				messaging_server_id(blr->fsp->conn->sconn->msg_ctx),
+				sconn_server_id(blr->fsp->conn->sconn),
 				blr->offset,
 				blr->count,
 				blr->lock_flav,
 				blr);
 		TALLOC_FREE(br_lck);
 	}
+
+	/* Remove the locks we already got. */
+
+	for(i = blr->lock_num - 1; i >= 0; i--) {
+		struct smbd_lock_element *e = &state->locks[i];
+
+		do_unlock(blr->fsp->conn->sconn->msg_ctx,
+			blr->fsp,
+			e->smblctx,
+			e->count,
+			e->offset,
+			WINDOWS_LOCK);
+	}
 }
 
 /****************************************************************
@@ -677,8 +709,6 @@
 	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;
 	struct blocking_lock_record *blr = NULL;
 	struct smbd_smb2_lock_state *state = NULL;
-	struct byte_range_lock *br_lck = NULL;
-	struct smbd_lock_element *e = NULL;
 	files_struct *fsp = NULL;
 
 	if (!smb2req->subreq) {
@@ -692,39 +722,42 @@
 	blr = state->blr;
 	fsp = blr->fsp;
 
-	/* We can only have one blocked lock in SMB2. */
-	SMB_ASSERT(state->lock_count == 1);
-	SMB_ASSERT(blr->lock_num == 0);
+	/* Try and finish off getting all the outstanding locks. */
 
-	/* Try and get the outstanding lock. */
-	e = &state->locks[blr->lock_num];
+	for (; blr->lock_num < state->lock_count; blr->lock_num++) {
+		struct byte_range_lock *br_lck = NULL;
+		struct smbd_lock_element *e = &state->locks[blr->lock_num];
+
+		br_lck = do_lock(fsp->conn->sconn->msg_ctx,
+				fsp,
+				e->smblctx,
+				e->count,
+				e->offset,
+				e->brltype,
+				WINDOWS_LOCK,
+				true,
+				&status,
+				&blr->blocking_smblctx,
+				blr);
 
-	br_lck = do_lock(fsp->conn->sconn->msg_ctx,
-			fsp,
-			e->smblctx,
-			e->count,
-			e->offset,
-			e->brltype,
-			WINDOWS_LOCK,
-			true,
-			&status,
-			&blr->blocking_smblctx,
-			blr);
+		TALLOC_FREE(br_lck);
 
-	TALLOC_FREE(br_lck);
+		if (NT_STATUS_IS_ERR(status)) {
+			break;
+		}
+	}
 
-	if (NT_STATUS_IS_OK(status)) {
+	if(blr->lock_num == state->lock_count) {
 		/*
-		 * Success - we got the lock.
+		 * Success - we got all the locks.
 		 */
 
 		DEBUG(3,("reprocess_blocked_smb2_lock SUCCESS file = %s, "
-			"%s, num_locks=%d\n",
+			"fnum=%d num_locks=%d\n",
 			fsp_str_dbg(fsp),
-			fsp_fnum_dbg(fsp),
+			fsp->fnum,
 			(int)state->lock_count));
 
-		remove_pending_lock(state, blr);
 		tevent_req_done(smb2req->subreq);
 		return;
 	}
@@ -741,7 +774,7 @@
         }
 
 	/*
-	 * We couldn't get the lock for this record.
+	 * We couldn't get the locks for this record on the list.
 	 * If the time has expired, return a lock error.
 	 */
 
@@ -753,15 +786,18 @@
 	}
 
 	/*
-	 * Still can't get the lock - keep waiting.
+	 * Still can't get all the locks - keep waiting.
 	 */
 
-	DEBUG(10,("reprocess_blocked_smb2_lock: failed to get lock "
-		"for file %s, %s. Still waiting....\n",
+	DEBUG(10,("reprocess_blocked_smb2_lock: only got %d locks of %d needed "
+		"for file %s, fnum = %d. Still waiting....\n",
+		(int)blr->lock_num,
+		(int)state->lock_count,
 		fsp_str_dbg(fsp),
-		fsp_fnum_dbg(fsp)));
+		(int)fsp->fnum));
 
         return;
+
 }
 
 /****************************************************************
@@ -788,7 +824,7 @@
 			continue;
 		}
 
-		inhdr = SMBD_SMB2_IN_HDR_PTR(smb2req);
+		inhdr = (const uint8_t *)smb2req->in.vector[smb2req->current_idx].iov_base;
 		if (SVAL(inhdr, SMB2_HDR_OPCODE) == SMB2_OP_LOCK) {
 			reprocess_blocked_smb2_lock(smb2req, tv_curr);
 		}
@@ -811,6 +847,7 @@
 	for (smb2req = sconn->smb2.requests; smb2req; smb2req = nextreq) {
 		struct smbd_smb2_lock_state *state = NULL;
 		files_struct *fsp_curr = NULL;
+		int i = smb2req->current_idx;
 		struct blocking_lock_record *blr = NULL;
 		const uint8_t *inhdr;
 
@@ -825,7 +862,7 @@
 			continue;
 		}
 
-		inhdr = SMBD_SMB2_IN_HDR_PTR(smb2req);
+		inhdr = (const uint8_t *)smb2req->in.vector[i].iov_base;
 		if (SVAL(inhdr, SMB2_HDR_OPCODE) != SMB2_OP_LOCK) {
 			/* Not a lock call. */
 			continue;
@@ -854,7 +891,7 @@
 		/* Remove the entries from the lock db. */
 		brl_lock_cancel(br_lck,
 				blr->smblctx,
-				messaging_server_id(sconn->msg_ctx),
+				sconn_server_id(sconn),
 				blr->offset,
 				blr->count,
 				blr->lock_flav,
Only in ../../samba-3.6.24/source3/smbd: smb2_lock.o
diff -ur smbd/smb2_negprot.c ../../samba-3.6.24/source3/smbd/smb2_negprot.c
--- smbd/smb2_negprot.c	2013-02-05 20:25:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_negprot.c	2015-01-28 10:52:25.149068676 +0800
@@ -22,16 +22,12 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "../libcli/smb/smb_common.h"
-#include "../lib/tsocket/tsocket.h"
-#include "../librpc/ndr/libndr.h"
-
-extern fstring remote_proto;
 
 /*
  * this is the entry point if SMB2 is selected via
- * the SMB negprot and the given dialect.
+ * the SMB negprot
  */
-static void reply_smb20xx(struct smb_request *req, uint16_t dialect)
+void reply_smb2002(struct smb_request *req, uint16_t choice)
 {
 	uint8_t *smb2_inbuf;
 	uint8_t *smb2_hdr;
@@ -55,7 +51,7 @@
 	SSVAL(smb2_body, 0x00, 0x0024);	/* struct size */
 	SSVAL(smb2_body, 0x02, 0x0001);	/* dialect count */
 
-	SSVAL(smb2_dyn,  0x00, dialect);
+	SSVAL(smb2_dyn,  0x00, 0x0202);	/* dialect 2.002 */
 
 	req->outbuf = NULL;
 
@@ -63,30 +59,12 @@
 	return;
 }
 
-/*
- * this is the entry point if SMB2 is selected via
- * the SMB negprot and the "SMB 2.002" dialect.
- */
-void reply_smb2002(struct smb_request *req, uint16_t choice)
-{
-	reply_smb20xx(req, SMB2_DIALECT_REVISION_202);
-}
-
-/*
- * this is the entry point if SMB2 is selected via
- * the SMB negprot and the "SMB 2.???" dialect.
- */
-void reply_smb20ff(struct smb_request *req, uint16_t choice)
-{
-	req->sconn->smb2.negprot_2ff = true;
-	reply_smb20xx(req, SMB2_DIALECT_REVISION_2FF);
-}
-
 NTSTATUS smbd_smb2_request_process_negprot(struct smbd_smb2_request *req)
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
 	const uint8_t *indyn = NULL;
+	int i = req->current_idx;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	DATA_BLOB negprot_spnego_blob;
@@ -96,152 +74,47 @@
 	size_t c;
 	uint16_t security_mode;
 	uint16_t dialect_count;
-	uint16_t in_security_mode;
-	uint32_t in_capabilities;
-	DATA_BLOB in_guid_blob;
-	struct GUID in_guid;
 	uint16_t dialect = 0;
 	uint32_t capabilities;
-	DATA_BLOB out_guid_blob;
-	struct GUID out_guid;
-	enum protocol_types protocol = PROTOCOL_NONE;
 	uint32_t max_limit;
 	uint32_t max_trans = lp_smb2_max_trans();
 	uint32_t max_read = lp_smb2_max_read();
 	uint32_t max_write = lp_smb2_max_write();
-	NTTIME now = timeval_to_nttime(&req->request_time);
 
 	status = smbd_smb2_request_verify_sizes(req, 0x24);
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	dialect_count = SVAL(inbody, 0x02);
-
-	in_security_mode = SVAL(inbody, 0x04);
-	in_capabilities = IVAL(inbody, 0x08);
-	in_guid_blob = data_blob_const(inbody + 0x0C, 16);
-
 	if (dialect_count == 0) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	status = GUID_from_ndr_blob(&in_guid_blob, &in_guid);
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	expected_dyn_size = dialect_count * 2;
-	if (SMBD_SMB2_IN_DYN_LEN(req) < expected_dyn_size) {
+	if (req->in.vector[i+2].iov_len < expected_dyn_size) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
-	indyn = SMBD_SMB2_IN_DYN_PTR(req);
-
-	for (c=0; protocol == PROTOCOL_NONE && c < dialect_count; c++) {
-		if (lp_srv_maxprotocol() < PROTOCOL_SMB3_00) {
-			break;
-		}
-		if (lp_srv_minprotocol() > PROTOCOL_SMB3_00) {
-			break;
-		}
-
-		dialect = SVAL(indyn, c*2);
-		if (dialect == SMB3_DIALECT_REVISION_300) {
-			protocol = PROTOCOL_SMB3_00;
-			break;
-		}
-	}
-
-	for (c=0; protocol == PROTOCOL_NONE && c < dialect_count; c++) {
-		if (lp_srv_maxprotocol() < PROTOCOL_SMB2_24) {
-			break;
-		}
-		if (lp_srv_minprotocol() > PROTOCOL_SMB2_24) {
-			break;
-		}
-
-		dialect = SVAL(indyn, c*2);
-		if (dialect == SMB2_DIALECT_REVISION_224) {
-			protocol = PROTOCOL_SMB2_24;
-			break;
-		}
-	}
-
-	for (c=0; protocol == PROTOCOL_NONE && c < dialect_count; c++) {
-		if (lp_srv_maxprotocol() < PROTOCOL_SMB2_22) {
-			break;
-		}
-		if (lp_srv_minprotocol() > PROTOCOL_SMB2_22) {
-			break;
-		}
-
-		dialect = SVAL(indyn, c*2);
-		if (dialect == SMB2_DIALECT_REVISION_222) {
-			protocol = PROTOCOL_SMB2_22;
-			break;
-		}
-	}
-
-	for (c=0; protocol == PROTOCOL_NONE && c < dialect_count; c++) {
-		if (lp_srv_maxprotocol() < PROTOCOL_SMB2_10) {
-			break;
-		}
-		if (lp_srv_minprotocol() > PROTOCOL_SMB2_10) {
-			break;
-		}
-
-		dialect = SVAL(indyn, c*2);
-		if (dialect == SMB2_DIALECT_REVISION_210) {
-			protocol = PROTOCOL_SMB2_10;
-			break;
-		}
-	}
-
-	for (c=0; protocol == PROTOCOL_NONE && c < dialect_count; c++) {
-		if (lp_srv_maxprotocol() < PROTOCOL_SMB2_02) {
-			break;
-		}
-		if (lp_srv_minprotocol() > PROTOCOL_SMB2_02) {
-			break;
-		}
+	indyn = (const uint8_t *)req->in.vector[i+2].iov_base;
 
+	for (c=0; c < dialect_count; c++) {
 		dialect = SVAL(indyn, c*2);
 		if (dialect == SMB2_DIALECT_REVISION_202) {
-			protocol = PROTOCOL_SMB2_02;
 			break;
 		}
 	}
 
-	for (c=0; protocol == PROTOCOL_NONE && c < dialect_count; c++) {
-		if (lp_srv_maxprotocol() < PROTOCOL_SMB2_10) {
-			break;
-		}
-
-		dialect = SVAL(indyn, c*2);
-		if (dialect == SMB2_DIALECT_REVISION_2FF) {
-			if (req->sconn->smb2.negprot_2ff) {
-				req->sconn->smb2.negprot_2ff = false;
-				protocol = PROTOCOL_SMB2_10;
-				break;
-			}
-		}
+	if (dialect != SMB2_DIALECT_REVISION_202) {
+		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (protocol == PROTOCOL_NONE) {
-		return smbd_smb2_request_error(req, NT_STATUS_NOT_SUPPORTED);
-	}
+	set_Protocol(PROTOCOL_SMB2);
 
 	if (get_remote_arch() != RA_SAMBA) {
 		set_remote_arch(RA_VISTA);
 	}
 
-	fstr_sprintf(remote_proto, "SMB%X_%02X",
-		     (dialect >> 8) & 0xFF, dialect & 0xFF);
-
-	reload_services(req->sconn, conn_snum_used, true);
-	DEBUG(3,("Selected protocol %s\n", remote_proto));
-
 	/* negprot_spnego() returns a the server guid in the first 16 bytes */
 	negprot_spnego_blob = negprot_spnego(req, req->sconn);
 	if (negprot_spnego_blob.data == NULL) {
@@ -253,7 +126,7 @@
 	}
 
 	security_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;
-	if (lp_server_signing() == SMB_SIGNING_REQUIRED) {
+	if (lp_server_signing() == Required) {
 		security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;
 	}
 
@@ -262,48 +135,15 @@
 		capabilities |= SMB2_CAP_DFS;
 	}
 
-	if ((protocol >= PROTOCOL_SMB2_24) &&
-	    (lp_smb_encrypt(-1) != SMB_SIGNING_OFF))
-	{
-		if (in_capabilities & SMB2_CAP_ENCRYPTION) {
-			capabilities |= SMB2_CAP_ENCRYPTION;
-		}
-	}
-
 	/*
+	 * Unless we implement SMB2_CAP_LARGE_MTU,
 	 * 0x10000 (65536) is the maximum allowed message size
-	 * for SMB 2.0
 	 */
 	max_limit = 0x10000;
 
-	if (protocol >= PROTOCOL_SMB2_10) {
-		int p = 0;
-
-		if (tsocket_address_is_inet(req->sconn->local_address, "ip")) {
-			p = tsocket_address_inet_port(req->sconn->local_address);
-		}
-
-		/* largeMTU is not supported over NBT (tcp port 139) */
-		if (p != NBT_SMB_PORT) {
-			capabilities |= SMB2_CAP_LARGE_MTU;
-			req->sconn->smb2.supports_multicredit = true;
-
-			/* SMB >= 2.1 has 1 MB of allowed size */
-			max_limit = 0x100000; /* 1MB */
-		}
-	}
-
-	/*
-	 * the defaults are 1MB, but we'll limit this to max_limit based on
-	 * the dialect (64kb for SMB2.0, 1MB for SMB2.1 with LargeMTU)
-	 *
-	 * user configured values exceeding the limits will be overwritten,
-	 * only smaller values will be accepted
-	 */
-
-	max_trans = MIN(max_limit, lp_smb2_max_trans());
-	max_read = MIN(max_limit, lp_smb2_max_read());
-	max_write = MIN(max_limit, lp_smb2_max_write());
+	max_trans = MIN(max_limit, max_trans);
+	max_read  = MIN(max_limit, max_read);
+	max_write = MIN(max_limit, max_write);
 
 	security_offset = SMB2_HDR_BODY + 0x40;
 
@@ -316,12 +156,6 @@
 	security_buffer = data_blob_const(NULL, 0);
 #endif
 
-	out_guid_blob = data_blob_const(negprot_spnego_blob.data, 16);
-	status = GUID_from_ndr_blob(&out_guid_blob, &out_guid);
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x40);
 	if (outbody.data == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -333,13 +167,13 @@
 	SSVAL(outbody.data, 0x04, dialect);	/* dialect revision */
 	SSVAL(outbody.data, 0x06, 0);		/* reserved */
 	memcpy(outbody.data + 0x08,
-	       out_guid_blob.data, 16);	/* server guid */
+	       negprot_spnego_blob.data, 16);	/* server guid */
 	SIVAL(outbody.data, 0x18,
 	      capabilities);			/* capabilities */
 	SIVAL(outbody.data, 0x1C, max_trans);	/* max transact size */
-	SIVAL(outbody.data, 0x20, max_read);	/* max read size */
-	SIVAL(outbody.data, 0x24, max_write);	/* max write size */
-	SBVAL(outbody.data, 0x28, now);		/* system time */
+	SIVAL(outbody.data, 0x20, max_trans);	/* max read size */
+	SIVAL(outbody.data, 0x24, max_trans);	/* max write size */
+	SBVAL(outbody.data, 0x28, 0);		/* system time */
 	SBVAL(outbody.data, 0x30, 0);		/* server start time */
 	SSVAL(outbody.data, 0x38,
 	      security_offset);			/* security buffer offset */
@@ -350,41 +184,9 @@
 	outdyn = security_buffer;
 
 	req->sconn->using_smb2 = true;
-
-	if (dialect != SMB2_DIALECT_REVISION_2FF) {
-		struct smbXsrv_connection *conn = req->sconn->conn;
-
-		status = smbXsrv_connection_init_tables(conn, protocol);
-		if (!NT_STATUS_IS_OK(status)) {
-			return smbd_smb2_request_error(req, status);
-		}
-
-		conn->smb2.client.capabilities = in_capabilities;
-		conn->smb2.client.security_mode = in_security_mode;
-		conn->smb2.client.guid = in_guid;
-		conn->smb2.client.num_dialects = dialect_count;
-		conn->smb2.client.dialects = talloc_array(conn,
-							  uint16_t,
-							  dialect_count);
-		if (conn->smb2.client.dialects == NULL) {
-			return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
-		}
-		for (c=0; c < dialect_count; c++) {
-			conn->smb2.client.dialects[c] = SVAL(indyn, c*2);
-		}
-
-		conn->smb2.server.capabilities = capabilities;
-		conn->smb2.server.security_mode = security_mode;
-		conn->smb2.server.guid = out_guid;
-		conn->smb2.server.dialect = dialect;
-		conn->smb2.server.max_trans = max_trans;
-		conn->smb2.server.max_read  = max_read;
-		conn->smb2.server.max_write = max_write;
-
-		req->sconn->smb2.max_trans = max_trans;
-		req->sconn->smb2.max_read  = max_read;
-		req->sconn->smb2.max_write = max_write;
-	}
+	req->sconn->smb2.max_trans = max_trans;
+	req->sconn->smb2.max_read  = max_read;
+	req->sconn->smb2.max_write = max_write;
 
 	return smbd_smb2_request_done(req, outbody, &outdyn);
 }
Only in ../../samba-3.6.24/source3/smbd: smb2_negprot.o
diff -ur smbd/smb2_notify.c ../../samba-3.6.24/source3/smbd/smb2_notify.c
--- smbd/smb2_notify.c	2014-02-18 17:15:49.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_notify.c	2015-01-28 10:52:25.149068676 +0800
@@ -28,8 +28,7 @@
 struct smbd_smb2_notify_state {
 	struct smbd_smb2_request *smb2req;
 	struct smb_request *smbreq;
-	bool has_request;
-	bool skip_reply;
+	struct tevent_immediate *im;
 	NTSTATUS status;
 	DATA_BLOB out_output_buffer;
 };
@@ -50,6 +49,7 @@
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint16_t in_flags;
 	uint32_t in_output_buffer_length;
 	uint64_t in_file_id_persistent;
@@ -62,7 +62,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_flags		= SVAL(inbody, 0x02);
 	in_output_buffer_length	= IVAL(inbody, 0x04);
@@ -78,19 +78,12 @@
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	status = smbd_smb2_request_verify_creditcharge(req,
-						in_output_buffer_length);
-
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	in_fsp = file_fsp_smb2(req, in_file_id_persistent, in_file_id_volatile);
 	if (in_fsp == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_notify_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_notify_send(req, req->sconn->smb2.event_ctx,
 				       req, in_fsp,
 				       in_flags,
 				       in_output_buffer_length,
@@ -100,13 +93,15 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_notify_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_notify_done(struct tevent_req *subreq)
 {
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
+	int i = req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint16_t out_output_buffer_offset;
@@ -114,6 +109,24 @@
 	NTSTATUS status;
 	NTSTATUS error; /* transport error */
 
+	if (req->cancelled) {
+		struct smbd_smb2_notify_state *state = tevent_req_data(subreq,
+					       struct smbd_smb2_notify_state);
+		const uint8_t *inhdr = (const uint8_t *)req->in.vector[i].iov_base;
+		uint64_t mid = BVAL(inhdr, SMB2_HDR_MESSAGE_ID);
+
+		DEBUG(10,("smbd_smb2_request_notify_done: cancelled mid %llu\n",
+			(unsigned long long)mid ));
+		error = smbd_smb2_request_error(req, NT_STATUS_CANCELLED);
+		if (!NT_STATUS_IS_OK(error)) {
+			smbd_server_connection_terminate(req->sconn,
+				nt_errstr(error));
+			return;
+		}
+		TALLOC_FREE(state->im);
+		return;
+	}
+
 	status = smbd_smb2_notify_recv(subreq,
 				       req,
 				       &out_output_buffer);
@@ -130,6 +143,8 @@
 
 	out_output_buffer_offset = SMB2_HDR_BODY + 0x08;
 
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x08);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -160,46 +175,11 @@
 static void smbd_smb2_notify_reply(struct smb_request *smbreq,
 				   NTSTATUS error_code,
 				   uint8_t *buf, size_t len);
+static void smbd_smb2_notify_reply_trigger(struct tevent_context *ctx,
+					   struct tevent_immediate *im,
+					   void *private_data);
 static bool smbd_smb2_notify_cancel(struct tevent_req *req);
 
-static int smbd_smb2_notify_state_destructor(struct smbd_smb2_notify_state *state)
-{
-	if (!state->has_request) {
-		return 0;
-	}
-
-	state->skip_reply = true;
-	smbd_notify_cancel_by_smbreq(state->smbreq);
-	return 0;
-}
-
-static int smbd_smb2_notify_smbreq_destructor(struct smb_request *smbreq)
-{
-	struct tevent_req *req = talloc_get_type_abort(smbreq->async_priv,
-						       struct tevent_req);
-	struct smbd_smb2_notify_state *state = tevent_req_data(req,
-					       struct smbd_smb2_notify_state);
-
-	/*
-	 * Our temporary parent from change_notify_add_request()
-	 * goes away.
-	 */
-	state->has_request = false;
-
-	/*
-	 * move it back to its original parent,
-	 * which means we no longer need the destructor
-	 * to protect it.
-	 */
-	talloc_steal(smbreq->smb2req, smbreq);
-	talloc_set_destructor(smbreq, NULL);
-
-	/*
-	 * We want to keep smbreq!
-	 */
-	return -1;
-}
-
 static struct tevent_req *smbd_smb2_notify_send(TALLOC_CTX *mem_ctx,
 						struct tevent_context *ev,
 						struct smbd_smb2_request *smb2req,
@@ -211,8 +191,8 @@
 	struct tevent_req *req;
 	struct smbd_smb2_notify_state *state;
 	struct smb_request *smbreq;
-	connection_struct *conn = smb2req->tcon->compat;
-	bool recursive = (in_flags & SMB2_WATCH_TREE) ? true : false;
+	connection_struct *conn = smb2req->tcon->compat_conn;
+	bool recursive = (in_flags & 0x0001) ? true : false;
 	NTSTATUS status;
 
 	req = tevent_req_create(mem_ctx, &state,
@@ -223,10 +203,10 @@
 	state->smb2req = smb2req;
 	state->status = NT_STATUS_INTERNAL_ERROR;
 	state->out_output_buffer = data_blob_null;
-	talloc_set_destructor(state, smbd_smb2_notify_state_destructor);
+	state->im = NULL;
 
-	DEBUG(10,("smbd_smb2_notify_send: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_notify_send: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
@@ -269,7 +249,7 @@
 		}
 	}
 
-	if (change_notify_fsp_has_changes(fsp)) {
+	if (fsp->notify->num_changes != 0) {
 
 		/*
 		 * We've got changes pending, respond immediately
@@ -293,6 +273,11 @@
 		return tevent_req_post(req, ev);
 	}
 
+	state->im = tevent_create_immediate(state);
+	if (tevent_req_nomem(state->im, req)) {
+		return tevent_req_post(req, ev);
+	}
+
 	/*
 	 * No changes pending, queue the request
 	 */
@@ -307,16 +292,6 @@
 		return tevent_req_post(req, ev);
 	}
 
-	/*
-	 * This is a HACK!
-	 *
-	 * change_notify_add_request() talloc_moves()
-	 * smbreq away from us, so we need a destructor
-	 * which moves it back at the end.
-	 */
-	state->has_request = true;
-	talloc_set_destructor(smbreq, smbd_smb2_notify_smbreq_destructor);
-
 	/* allow this request to be canceled */
 	tevent_req_set_cancel_fn(req, smbd_smb2_notify_cancel);
 
@@ -332,10 +307,6 @@
 	struct smbd_smb2_notify_state *state = tevent_req_data(req,
 					       struct smbd_smb2_notify_state);
 
-	if (state->skip_reply) {
-		return;
-	}
-
 	state->status = error_code;
 	if (!NT_STATUS_IS_OK(error_code)) {
 		/* nothing */
@@ -348,7 +319,30 @@
 		}
 	}
 
-	tevent_req_defer_callback(req, state->smb2req->sconn->ev_ctx);
+	if (state->im == NULL) {
+		smbd_smb2_notify_reply_trigger(NULL, NULL, req);
+		return;
+	}
+
+	/*
+	 * if this is called async, we need to go via an immediate event
+	 * because the caller replies on the smb_request (a child of req
+	 * being arround after calling this function
+	 */
+	tevent_schedule_immediate(state->im,
+				  state->smb2req->sconn->smb2.event_ctx,
+				  smbd_smb2_notify_reply_trigger,
+				  req);
+}
+
+static void smbd_smb2_notify_reply_trigger(struct tevent_context *ctx,
+					   struct tevent_immediate *im,
+					   void *private_data)
+{
+	struct tevent_req *req = talloc_get_type_abort(private_data,
+						       struct tevent_req);
+	struct smbd_smb2_notify_state *state = tevent_req_data(req,
+					       struct smbd_smb2_notify_state);
 
 	if (!NT_STATUS_IS_OK(state->status)) {
 		tevent_req_nterror(req, state->status);
@@ -363,6 +357,7 @@
 	struct smbd_smb2_notify_state *state = tevent_req_data(req,
 					       struct smbd_smb2_notify_state);
 
+	state->smb2req->cancelled = true;
 	smbd_notify_cancel_by_smbreq(state->smbreq);
 
 	return true;
Only in ../../samba-3.6.24/source3/smbd: smb2_notify.o
diff -ur smbd/smb2_read.c ../../samba-3.6.24/source3/smbd/smb2_read.c
--- smbd/smb2_read.c	2014-07-30 16:52:25.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_read.c	2015-01-28 10:52:25.149068676 +0800
@@ -31,6 +31,7 @@
 					      struct tevent_context *ev,
 					      struct smbd_smb2_request *smb2req,
 					      struct files_struct *in_fsp,
+					      uint32_t in_smbpid,
 					      uint32_t in_length,
 					      uint64_t in_offset,
 					      uint32_t in_minimum,
@@ -44,7 +45,10 @@
 NTSTATUS smbd_smb2_request_process_read(struct smbd_smb2_request *req)
 {
 	NTSTATUS status;
+	const uint8_t *inhdr;
 	const uint8_t *inbody;
+	int i = req->current_idx;
+	uint32_t in_smbpid;
 	uint32_t in_length;
 	uint64_t in_offset;
 	uint64_t in_file_id_persistent;
@@ -58,7 +62,10 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
+
+	in_smbpid = IVAL(inhdr, SMB2_HDR_PID);
 
 	in_length		= IVAL(inbody, 0x04);
 	in_offset		= BVAL(inbody, 0x08);
@@ -69,24 +76,19 @@
 
 	/* check the max read size */
 	if (in_length > req->sconn->smb2.max_read) {
-		DEBUG(2,("smbd_smb2_request_process_read: "
-			 "client ignored max read: %s: 0x%08X: 0x%08X\n",
+		DEBUG(0,("here:%s: 0x%08X: 0x%08X\n",
 			__location__, in_length, req->sconn->smb2.max_read));
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	status = smbd_smb2_request_verify_creditcharge(req, in_length);
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	in_fsp = file_fsp_smb2(req, in_file_id_persistent, in_file_id_volatile);
 	if (in_fsp == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_read_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_read_send(req, req->sconn->smb2.event_ctx,
 				     req, in_fsp,
+				     in_smbpid,
 				     in_length,
 				     in_offset,
 				     in_minimum_count,
@@ -96,13 +98,15 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_read_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_read_done(struct tevent_req *subreq)
 {
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
+	int i = req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint8_t out_data_offset;
@@ -128,6 +132,8 @@
 
 	out_data_offset = SMB2_HDR_BODY + 0x10;
 
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x10);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -161,12 +167,10 @@
 
 struct smbd_smb2_read_state {
 	struct smbd_smb2_request *smb2req;
-	struct smb_request *smbreq;
 	files_struct *fsp;
 	uint32_t in_length;
 	uint64_t in_offset;
 	uint32_t in_minimum;
-	DATA_BLOB out_headers;
 	DATA_BLOB out_data;
 	uint32_t out_remaining;
 };
@@ -178,33 +182,23 @@
 	uint32_t in_length = state->in_length;
 	uint64_t in_offset = state->in_offset;
 	files_struct *fsp = state->fsp;
-	const DATA_BLOB *hdr = state->smb2req->queue_entry.sendfile_header;
 	ssize_t nread;
-	ssize_t ret;
 
 	nread = SMB_VFS_SENDFILE(fsp->conn->sconn->sock,
-				 fsp,
-				 hdr,
-				 in_offset,
-				 in_length);
+					fsp,
+					NULL,
+					in_offset,
+					in_length);
 	DEBUG(10,("smb2_sendfile_send_data: SMB_VFS_SENDFILE returned %d on file %s\n",
 		(int)nread,
 		fsp_str_dbg(fsp) ));
 
 	if (nread == -1) {
-		/*
-		 * Returning ENOSYS means no data at all was sent.
-		   Do this as a normal read. */
-		if (errno == ENOSYS) {
-			goto normal_read;
-		}
-
-		if (errno == EINTR) {
+		if (errno == ENOSYS || errno == EINTR) {
 			/*
-			 * Special hack for broken Linux with no working sendfile. If we
-			 * return EINTR we sent the header but not the rest of the data.
-			 * Fake this up by doing read/write calls.
-			 */
+			 * Special hack for broken systems with no working
+			 * sendfile. Fake this up by doing read/write calls.
+			*/
 			set_use_sendfile(SNUM(fsp->conn), false);
 			nread = fake_sendfile(fsp, in_offset, in_length);
 			if (nread == -1) {
@@ -235,54 +229,27 @@
 		DEBUG(3, ("send_file_readX: sendfile sent zero bytes "
 			"falling back to the normal read: %s\n",
 			fsp_str_dbg(fsp)));
-		goto normal_read;
-	}
-
-	/*
-	 * We got a short read
-	 */
-	goto out;
 
-normal_read:
-	/* Send out the header. */
-	ret = write_data(fsp->conn->sconn->sock,
-			 (const char *)hdr->data, hdr->length);
-	if (ret != hdr->length) {
-		char addr[INET6_ADDRSTRLEN];
-		/*
-		 * Try and give an error message saying what
-		 * client failed.
-		 */
-		DEBUG(0, ("smb2_sendfile_send_data: write_data failed "
-			  "for client %s. Error %s\n",
-			  get_peer_addr(fsp->conn->sconn->sock, addr,
-					sizeof(addr)),
-			  strerror(errno)));
-
-		DEBUG(0,("smb2_sendfile_send_data: write_data failed for file "
-			 "%s (%s). Terminating\n", fsp_str_dbg(fsp),
-			 strerror(errno)));
-		exit_server_cleanly("smb2_sendfile_send_data: write_data failed");
-	}
-	nread = fake_sendfile(fsp, in_offset, in_length);
-	if (nread == -1) {
-		DEBUG(0,("smb2_sendfile_send_data: "
-			"fake_sendfile failed for file "
-			"%s (%s). Terminating\n",
-			fsp_str_dbg(fsp),
-			strerror(errno)));
-		exit_server_cleanly("smb2_sendfile_send_data: "
-			"fake_sendfile failed");
+		nread = fake_sendfile(fsp, in_offset, in_length);
+		if (nread == -1) {
+			DEBUG(0,("smb2_sendfile_send_data: "
+				"fake_sendfile failed for file "
+				"%s (%s). Terminating\n",
+				fsp_str_dbg(fsp),
+				strerror(errno)));
+			exit_server_cleanly("smb2_sendfile_send_data: "
+				"fake_sendfile failed");
+		}
 	}
 
   out:
 
 	if (nread < in_length) {
-		sendfile_short_send(fsp, nread, hdr->length, in_length);
+		sendfile_short_send(fsp, nread, 0, in_length);
 	}
 
 	init_strict_lock_struct(fsp,
-				fsp->op->global->open_persistent_id,
+				fsp->fnum,
 				in_offset,
 				in_length,
 				READ_LOCK,
@@ -312,16 +279,15 @@
 	 * reads on most normal files. JRA.
 	*/
 
-	if (!lp__use_sendfile(SNUM(fsp->conn)) ||
-	    smb2req->do_signing ||
-	    smb2req->do_encryption ||
-	    smb2req->in.vector_count >= (2*SMBD_SMB2_NUM_IOV_PER_REQ) ||
-	    (fsp->base_fsp != NULL) ||
-	    (fsp->wcp != NULL) ||
-	    (!S_ISREG(fsp->fsp_name->st.st_ex_mode)) ||
-	    (state->in_offset >= fsp->fsp_name->st.st_ex_size) ||
-	    (fsp->fsp_name->st.st_ex_size < state->in_offset + state->in_length))
-	{
+	if (!_lp_use_sendfile(SNUM(fsp->conn)) ||
+			smb2req->do_signing ||
+			smb2req->in.vector_count != 4 ||
+			(fsp->base_fsp != NULL) ||
+			(fsp->wcp != NULL) ||
+			(!S_ISREG(fsp->fsp_name->st.st_ex_mode)) ||
+			(state->in_offset >= fsp->fsp_name->st.st_ex_size) ||
+			(fsp->fsp_name->st.st_ex_size < state->in_offset +
+				state->in_length)) {
 		return NT_STATUS_RETRY;
 	}
 
@@ -333,13 +299,12 @@
 	/* Make a copy of state attached to the smb2req. Attach
 	   the destructor here as this will trigger the sendfile
 	   call when the request is destroyed. */
-	state_copy = talloc(smb2req, struct smbd_smb2_read_state);
+	state_copy = TALLOC_P(smb2req, struct smbd_smb2_read_state);
 	if (!state_copy) {
 		return NT_STATUS_NO_MEMORY;
 	}
 	*state_copy = *state;
 	talloc_set_destructor(state_copy, smb2_sendfile_send_data);
-	state->smb2req->queue_entry.sendfile_header = &state_copy->out_headers;
 	return NT_STATUS_OK;
 }
 
@@ -383,8 +348,8 @@
 		return NT_STATUS_END_OF_FILE;
 	}
 
-	DEBUG(3,("smbd_smb2_read: %s, file %s, length=%lu offset=%lu read=%lu\n",
-		fsp_fnum_dbg(fsp),
+	DEBUG(3,("smbd_smb2_read: fnum=[%d/%s] length=%lu offset=%lu read=%lu\n",
+		fsp->fnum,
 		fsp_str_dbg(fsp),
 		(unsigned long)state->in_length,
 		(unsigned long)state->in_offset,
@@ -396,19 +361,11 @@
 	return NT_STATUS_OK;
 }
 
-static bool smbd_smb2_read_cancel(struct tevent_req *req)
-{
-	struct smbd_smb2_read_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_read_state);
-
-	return cancel_smb2_aio(state->smbreq);
-}
-
 static struct tevent_req *smbd_smb2_read_send(TALLOC_CTX *mem_ctx,
 					      struct tevent_context *ev,
 					      struct smbd_smb2_request *smb2req,
 					      struct files_struct *fsp,
+					      uint32_t in_smbpid,
 					      uint32_t in_length,
 					      uint64_t in_offset,
 					      uint32_t in_minimum,
@@ -418,7 +375,7 @@
 	struct tevent_req *req = NULL;
 	struct smbd_smb2_read_state *state = NULL;
 	struct smb_request *smbreq = NULL;
-	connection_struct *conn = smb2req->tcon->compat;
+	connection_struct *conn = smb2req->tcon->compat_conn;
 	ssize_t nread = -1;
 	struct lock_struct lock;
 	int saved_errno;
@@ -435,14 +392,13 @@
 	state->out_data = data_blob_null;
 	state->out_remaining = 0;
 
-	DEBUG(10,("smbd_smb2_read: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_read: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
 		return tevent_req_post(req, ev);
 	}
-	state->smbreq = smbreq;
 
 	if (fsp->is_directory) {
 		tevent_req_nterror(req, NT_STATUS_INVALID_DEVICE_REQUEST);
@@ -464,7 +420,7 @@
 			return tevent_req_post(req, ev);
 		}
 
-		subreq = np_read_send(state, ev,
+		subreq = np_read_send(state, smbd_event_context(),
 				      fsp->fake_file_handle,
 				      state->out_data.data,
 				      state->out_data.length);
@@ -487,28 +443,32 @@
 				fsp,
 				state,
 				&state->out_data,
-				(off_t)in_offset,
+				(SMB_OFF_T)in_offset,
 				(size_t)in_length);
 
 	if (NT_STATUS_IS_OK(status)) {
 		/*
-		 * Doing an async read, allow this
-		 * request to be canceled
+		 * Doing an async read. Don't
+		 * send a "gone async" message
+		 * as we expect this to be less
+		 * than the client timeout period.
+		 * JRA. FIXME for offline files..
+		 * FIXME. Add cancel code..
 		 */
-		tevent_req_set_cancel_fn(req, smbd_smb2_read_cancel);
+		smb2req->async = true;
 		return req;
 	}
 
 	if (!NT_STATUS_EQUAL(status, NT_STATUS_RETRY)) {
 		/* Real error in setting up aio. Fail. */
-		tevent_req_nterror(req, status);
+		tevent_req_nterror(req, NT_STATUS_FILE_CLOSED);
 		return tevent_req_post(req, ev);
 	}
 
 	/* Fallback to synchronous. */
 
 	init_strict_lock_struct(fsp,
-				fsp->op->global->open_persistent_id,
+				fsp->fnum,
 				in_offset,
 				in_length,
 				READ_LOCK,
@@ -548,10 +508,10 @@
 
 	SMB_VFS_STRICT_UNLOCK(conn, fsp, &lock);
 
-	DEBUG(10,("smbd_smb2_read: file %s, %s, offset=%llu "
+	DEBUG(10,("smbd_smb2_read: file %s fnum[%d] offset=%llu "
 		"len=%llu returned %lld\n",
 		fsp_str_dbg(fsp),
-		fsp_fnum_dbg(fsp),
+		fsp->fnum,
 		(unsigned long long)in_offset,
 		(unsigned long long)in_length,
 		(long long)nread));
@@ -579,8 +539,6 @@
 	status = np_read_recv(subreq, &nread, &is_data_outstanding);
 	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
-		NTSTATUS old = status;
-		status = nt_status_np_pipe(old);
 		tevent_req_nterror(req, status);
 		return;
 	}
Only in ../../samba-3.6.24/source3/smbd: smb2_read.o
diff -ur smbd/smb2_server.c ../../samba-3.6.24/source3/smbd/smb2_server.c
--- smbd/smb2_server.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_server.c	2015-01-28 10:52:25.149068676 +0800
@@ -26,153 +26,40 @@
 #include "../lib/tsocket/tsocket.h"
 #include "../lib/util/tevent_ntstatus.h"
 #include "smbprofile.h"
-#include "../lib/util/bitmap.h"
-#include "../librpc/gen_ndr/krb5pac.h"
-#include "auth.h"
-
-static void smbd_smb2_connection_handler(struct tevent_context *ev,
-					 struct tevent_fd *fde,
-					 uint16_t flags,
-					 void *private_data);
-static NTSTATUS smbd_smb2_io_handler(struct smbd_server_connection *sconn,
-				     uint16_t fde_flags);
 
 #define OUTVEC_ALLOC_SIZE (SMB2_HDR_BODY + 9)
 
-static const struct smbd_smb2_dispatch_table {
-	uint16_t opcode;
-	const char *name;
-	bool need_session;
-	bool need_tcon;
-	bool as_root;
-	uint16_t fileid_ofs;
-	bool allow_invalid_fileid;
-} smbd_smb2_table[] = {
-#define _OP(o) .opcode = o, .name = #o
-	{
-		_OP(SMB2_OP_NEGPROT),
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_SESSSETUP),
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_LOGOFF),
-		.need_session = true,
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_TCON),
-		.need_session = true,
-		/*
-		 * This call needs to be run as root.
-		 *
-		 * smbd_smb2_request_process_tcon()
-		 * calls make_connection_snum(), which will call
-		 * change_to_user(), when needed.
-		 */
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_TDIS),
-		.need_session = true,
-		.need_tcon = true,
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_CREATE),
-		.need_session = true,
-		.need_tcon = true,
-	},{
-		_OP(SMB2_OP_CLOSE),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x08,
-	},{
-		_OP(SMB2_OP_FLUSH),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x08,
-	},{
-		_OP(SMB2_OP_READ),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x10,
-	},{
-		_OP(SMB2_OP_WRITE),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x10,
-	},{
-		_OP(SMB2_OP_LOCK),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x08,
-	},{
-		_OP(SMB2_OP_IOCTL),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x08,
-		.allow_invalid_fileid = true,
-	},{
-		_OP(SMB2_OP_CANCEL),
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_KEEPALIVE),
-		.as_root = true,
-	},{
-		_OP(SMB2_OP_FIND),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x08,
-	},{
-		_OP(SMB2_OP_NOTIFY),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x08,
-	},{
-		_OP(SMB2_OP_GETINFO),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x18,
-	},{
-		_OP(SMB2_OP_SETINFO),
-		.need_session = true,
-		.need_tcon = true,
-		.fileid_ofs = 0x10,
-	},{
-		_OP(SMB2_OP_BREAK),
-		.need_session = true,
-		.need_tcon = true,
-		/*
-		 * we do not set
-		 * .fileid_ofs here
-		 * as LEASE breaks does not
-		 * have a file id
-		 */
-	}
+static const char *smb2_names[] = {
+	"SMB2_NEGPROT",
+	"SMB2_SESSSETUP",
+	"SMB2_LOGOFF",
+	"SMB2_TCON",
+	"SMB2_TDIS",
+	"SMB2_CREATE",
+	"SMB2_CLOSE",
+	"SMB2_FLUSH",
+	"SMB2_READ",
+	"SMB2_WRITE",
+	"SMB2_LOCK",
+	"SMB2_IOCTL",
+	"SMB2_CANCEL",
+	"SMB2_KEEPALIVE",
+	"SMB2_FIND",
+	"SMB2_NOTIFY",
+	"SMB2_GETINFO",
+	"SMB2_SETINFO",
+	"SMB2_BREAK"
 };
 
 const char *smb2_opcode_name(uint16_t opcode)
 {
-	if (opcode >= ARRAY_SIZE(smbd_smb2_table)) {
+	if (opcode > 0x12) {
 		return "Bad SMB2 opcode";
 	}
-	return smbd_smb2_table[opcode].name;
-}
-
-static const struct smbd_smb2_dispatch_table *smbd_smb2_call(uint16_t opcode)
-{
-	const struct smbd_smb2_dispatch_table *ret = NULL;
-
-	if (opcode >= ARRAY_SIZE(smbd_smb2_table)) {
-		return NULL;
-	}
-
-	ret = &smbd_smb2_table[opcode];
-
-	SMB_ASSERT(ret->opcode == opcode);
-
-	return ret;
+	return smb2_names[opcode];
 }
 
-static void print_req_vectors(const struct smbd_smb2_request *req)
+static void print_req_vectors(struct smbd_smb2_request *req)
 {
 	int i;
 
@@ -203,10 +90,29 @@
 
 static NTSTATUS smbd_initialize_smb2(struct smbd_server_connection *sconn)
 {
+	NTSTATUS status;
+	int ret;
+
 	TALLOC_FREE(sconn->smb1.fde);
 
-	sconn->smb2.send_queue = NULL;
+	sconn->smb2.event_ctx = smbd_event_context();
+
+	sconn->smb2.recv_queue = tevent_queue_create(sconn, "smb2 recv queue");
+	if (sconn->smb2.recv_queue == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	sconn->smb2.send_queue = tevent_queue_create(sconn, "smb2 send queue");
+	if (sconn->smb2.send_queue == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
 
+	sconn->smb2.sessions.idtree = idr_init(sconn);
+	if (sconn->smb2.sessions.idtree == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	sconn->smb2.sessions.limit = 0x0000FFFE;
+	sconn->smb2.sessions.list = NULL;
 	sconn->smb2.seqnum_low = 0;
 	sconn->smb2.seqnum_range = 1;
 	sconn->smb2.credits_granted = 1;
@@ -217,14 +123,11 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	sconn->smb2.fde = tevent_add_fd(sconn->ev_ctx,
-					sconn,
-					sconn->sock,
-					TEVENT_FD_READ,
-					smbd_smb2_connection_handler,
-					sconn);
-	if (sconn->smb2.fde == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	ret = tstream_bsd_existing_socket(sconn, sconn->sock,
+					  &sconn->smb2.stream);
+	if (ret == -1) {
+		status = map_nt_error_from_unix(errno);
+		return status;
 	}
 
 	/* Ensure child is set to non-blocking mode */
@@ -253,253 +156,76 @@
 	_smb2_setlen(vector[0].iov_base, len);
 }
 
+static int smbd_smb2_request_parent_destructor(struct smbd_smb2_request **req)
+{
+	if (*req) {
+		(*req)->parent = NULL;
+		(*req)->mem_pool = NULL;
+	}
+
+	return 0;
+}
+
 static int smbd_smb2_request_destructor(struct smbd_smb2_request *req)
 {
-	data_blob_clear_free(&req->first_key);
-	data_blob_clear_free(&req->last_key);
+	if (req->parent) {
+		*req->parent = NULL;
+		talloc_free(req->mem_pool);
+	}
+
 	return 0;
 }
 
 static struct smbd_smb2_request *smbd_smb2_request_allocate(TALLOC_CTX *mem_ctx)
 {
 	TALLOC_CTX *mem_pool;
+	struct smbd_smb2_request **parent;
 	struct smbd_smb2_request *req;
 
 #if 0
 	/* Enable this to find subtle valgrind errors. */
 	mem_pool = talloc_init("smbd_smb2_request_allocate");
 #else
-	mem_pool = talloc_tos();
+	mem_pool = talloc_pool(mem_ctx, 8192);
 #endif
 	if (mem_pool == NULL) {
 		return NULL;
 	}
 
-	req = talloc_zero(mem_pool, struct smbd_smb2_request);
+	parent = talloc(mem_pool, struct smbd_smb2_request *);
+	if (parent == NULL) {
+		talloc_free(mem_pool);
+		return NULL;
+	}
+
+	req = talloc_zero(parent, struct smbd_smb2_request);
 	if (req == NULL) {
 		talloc_free(mem_pool);
 		return NULL;
 	}
-	talloc_reparent(mem_pool, mem_ctx, req);
-#if 0
-	TALLOC_FREE(mem_pool);
-#endif
+	*parent		= req;
+	req->mem_pool	= mem_pool;
+	req->parent	= parent;
 
 	req->last_session_id = UINT64_MAX;
 	req->last_tid = UINT32_MAX;
 
+	talloc_set_destructor(parent, smbd_smb2_request_parent_destructor);
 	talloc_set_destructor(req, smbd_smb2_request_destructor);
 
 	return req;
 }
 
-static NTSTATUS smbd_smb2_inbuf_parse_compound(struct smbXsrv_connection *conn,
-					       NTTIME now,
-					       uint8_t *buf,
-					       size_t buflen,
-					       TALLOC_CTX *mem_ctx,
-					       struct iovec **piov,
-					       int *pnum_iov)
-{
-	struct iovec *iov;
-	int num_iov = 1;
-	size_t taken = 0;
-	uint8_t *first_hdr = buf;
-	size_t verified_buflen = 0;
-	uint8_t *tf = NULL;
-	size_t tf_len = 0;
-
-	/*
-	 * Note: index '0' is reserved for the transport protocol
-	 */
-	iov = talloc_zero_array(mem_ctx, struct iovec, num_iov);
-	if (iov == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	while (taken < buflen) {
-		size_t len = buflen - taken;
-		uint8_t *hdr = first_hdr + taken;
-		struct iovec *cur;
-		size_t full_size;
-		size_t next_command_ofs;
-		uint16_t body_size;
-		uint8_t *body = NULL;
-		uint32_t dyn_size;
-		uint8_t *dyn = NULL;
-		struct iovec *iov_tmp;
-
-		if (verified_buflen > taken) {
-			len = verified_buflen - taken;
-		} else {
-			tf = NULL;
-			tf_len = 0;
-		}
-
-		if (len < 4) {
-			DEBUG(10, ("%d bytes left, expected at least %d\n",
-				   (int)len, 4));
-			goto inval;
-		}
-		if (IVAL(hdr, 0) == SMB2_TF_MAGIC) {
-			struct smbXsrv_session *s = NULL;
-			uint64_t uid;
-			struct iovec tf_iov[2];
-			NTSTATUS status;
-			size_t enc_len;
-
-			if (conn->protocol < PROTOCOL_SMB2_24) {
-				DEBUG(10, ("Got SMB2_TRANSFORM header, "
-					   "but dialect[0x%04X] is used\n",
-					   conn->smb2.server.dialect));
-				goto inval;
-			}
-
-			if (!(conn->smb2.server.capabilities & SMB2_CAP_ENCRYPTION)) {
-				DEBUG(10, ("Got SMB2_TRANSFORM header, "
-					   "but not negotiated "
-					   "client[0x%08X] server[0x%08X]\n",
-					   conn->smb2.client.capabilities,
-					   conn->smb2.server.capabilities));
-				goto inval;
-			}
-
-			if (len < SMB2_TF_HDR_SIZE) {
-				DEBUG(1, ("%d bytes left, expected at least %d\n",
-					   (int)len, SMB2_TF_HDR_SIZE));
-				goto inval;
-			}
-			tf = hdr;
-			tf_len = SMB2_TF_HDR_SIZE;
-			taken += tf_len;
-
-			hdr = first_hdr + taken;
-			enc_len = IVAL(tf, SMB2_TF_MSG_SIZE);
-			uid = BVAL(tf, SMB2_TF_SESSION_ID);
-
-			if (len < SMB2_TF_HDR_SIZE + enc_len) {
-				DEBUG(1, ("%d bytes left, expected at least %d\n",
-					   (int)len,
-					   (int)(SMB2_TF_HDR_SIZE + enc_len)));
-				goto inval;
-			}
-
-			status = smb2srv_session_lookup(conn, uid, now, &s);
-			if (s == NULL) {
-				DEBUG(1, ("invalid session[%llu] in "
-					  "SMB2_TRANSFORM header\n",
-					   (unsigned long long)uid));
-				TALLOC_FREE(iov);
-				return NT_STATUS_USER_SESSION_DELETED;
-			}
-
-			tf_iov[0].iov_base = (void *)tf;
-			tf_iov[0].iov_len = tf_len;
-			tf_iov[1].iov_base = (void *)hdr;
-			tf_iov[1].iov_len = enc_len;
-
-			status = smb2_signing_decrypt_pdu(s->global->decryption_key,
-							  conn->protocol,
-							  tf_iov, 2);
-			if (!NT_STATUS_IS_OK(status)) {
-				TALLOC_FREE(iov);
-				return status;
-			}
-
-			verified_buflen = taken + enc_len;
-			len = enc_len;
-		}
-
-		/*
-		 * We need the header plus the body length field
-		 */
-
-		if (len < SMB2_HDR_BODY + 2) {
-			DEBUG(10, ("%d bytes left, expected at least %d\n",
-				   (int)len, SMB2_HDR_BODY));
-			goto inval;
-		}
-		if (IVAL(hdr, 0) != SMB2_MAGIC) {
-			DEBUG(10, ("Got non-SMB2 PDU: %x\n",
-				   IVAL(hdr, 0)));
-			goto inval;
-		}
-		if (SVAL(hdr, 4) != SMB2_HDR_BODY) {
-			DEBUG(10, ("Got HDR len %d, expected %d\n",
-				   SVAL(hdr, 4), SMB2_HDR_BODY));
-			goto inval;
-		}
-
-		full_size = len;
-		next_command_ofs = IVAL(hdr, SMB2_HDR_NEXT_COMMAND);
-		body_size = SVAL(hdr, SMB2_HDR_BODY);
-
-		if (next_command_ofs != 0) {
-			if (next_command_ofs < (SMB2_HDR_BODY + 2)) {
-				goto inval;
-			}
-			if (next_command_ofs > full_size) {
-				goto inval;
-			}
-			full_size = next_command_ofs;
-		}
-		if (body_size < 2) {
-			goto inval;
-		}
-		body_size &= 0xfffe;
-
-		if (body_size > (full_size - SMB2_HDR_BODY)) {
-			/*
-			 * let the caller handle the error
-			 */
-			body_size = full_size - SMB2_HDR_BODY;
-		}
-		body = hdr + SMB2_HDR_BODY;
-		dyn = body + body_size;
-		dyn_size = full_size - (SMB2_HDR_BODY + body_size);
-
-		iov_tmp = talloc_realloc(mem_ctx, iov, struct iovec,
-					 num_iov + SMBD_SMB2_NUM_IOV_PER_REQ);
-		if (iov_tmp == NULL) {
-			TALLOC_FREE(iov);
-			return NT_STATUS_NO_MEMORY;
-		}
-		iov = iov_tmp;
-		cur = &iov[num_iov];
-		num_iov += SMBD_SMB2_NUM_IOV_PER_REQ;
-
-		cur[SMBD_SMB2_TF_IOV_OFS].iov_base   = tf;
-		cur[SMBD_SMB2_TF_IOV_OFS].iov_len    = tf_len;
-		cur[SMBD_SMB2_HDR_IOV_OFS].iov_base  = hdr;
-		cur[SMBD_SMB2_HDR_IOV_OFS].iov_len   = SMB2_HDR_BODY;
-		cur[SMBD_SMB2_BODY_IOV_OFS].iov_base = body;
-		cur[SMBD_SMB2_BODY_IOV_OFS].iov_len  = body_size;
-		cur[SMBD_SMB2_DYN_IOV_OFS].iov_base  = dyn;
-		cur[SMBD_SMB2_DYN_IOV_OFS].iov_len   = dyn_size;
-
-		taken += full_size;
-	}
-
-	*piov = iov;
-	*pnum_iov = num_iov;
-	return NT_STATUS_OK;
-
-inval:
-	TALLOC_FREE(iov);
-	return NT_STATUS_INVALID_PARAMETER;
-}
-
 static NTSTATUS smbd_smb2_request_create(struct smbd_server_connection *sconn,
-					 uint8_t *inbuf, size_t size,
+					 const uint8_t *inbuf, size_t size,
 					 struct smbd_smb2_request **_req)
 {
 	struct smbd_smb2_request *req;
 	uint32_t protocol_version;
 	const uint8_t *inhdr = NULL;
+	off_t ofs = 0;
 	uint16_t cmd;
 	uint32_t next_command_ofs;
-	NTSTATUS status;
-	NTTIME now;
 
 	if (size < (4 + SMB2_HDR_BODY + 2)) {
 		DEBUG(0,("Invalid SMB2 packet length count %ld\n", (long)size));
@@ -537,19 +263,35 @@
 
 	talloc_steal(req, inbuf);
 
-	req->request_time = timeval_current();
-	now = timeval_to_nttime(&req->request_time);
-
-	status = smbd_smb2_inbuf_parse_compound(sconn->conn,
-						now,
-						inbuf + NBT_HDR_SIZE,
-						size - NBT_HDR_SIZE,
-						req, &req->in.vector,
-						&req->in.vector_count);
-	if (!NT_STATUS_IS_OK(status)) {
+	req->in.vector = talloc_array(req, struct iovec, 4);
+	if (req->in.vector == NULL) {
 		TALLOC_FREE(req);
-		return status;
+		return NT_STATUS_NO_MEMORY;
 	}
+	req->in.vector_count = 4;
+
+	memcpy(req->in.nbt_hdr, inbuf, 4);
+
+	ofs = 0;
+	req->in.vector[0].iov_base	= (void *)req->in.nbt_hdr;
+	req->in.vector[0].iov_len	= 4;
+	ofs += req->in.vector[0].iov_len;
+
+	req->in.vector[1].iov_base	= (void *)(inbuf + ofs);
+	req->in.vector[1].iov_len	= SMB2_HDR_BODY;
+	ofs += req->in.vector[1].iov_len;
+
+	req->in.vector[2].iov_base	= (void *)(inbuf + ofs);
+	req->in.vector[2].iov_len	= SVAL(inbuf, ofs) & 0xFFFE;
+	ofs += req->in.vector[2].iov_len;
+
+	if (ofs > size) {
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+
+	req->in.vector[3].iov_base	= (void *)(inbuf + ofs);
+	req->in.vector[3].iov_len	= size - ofs;
+	ofs += req->in.vector[3].iov_len;
 
 	req->current_idx = 1;
 
@@ -633,67 +375,39 @@
 				const uint8_t *inhdr)
 {
 	uint64_t message_id = BVAL(inhdr, SMB2_HDR_MESSAGE_ID);
-	uint16_t opcode = SVAL(inhdr, SMB2_HDR_OPCODE);
-	uint16_t credit_charge = 1;
-	uint64_t i;
+	uint16_t opcode = IVAL(inhdr, SMB2_HDR_OPCODE);
+	bool ok;
 
 	if (opcode == SMB2_OP_CANCEL) {
 		/* SMB2_CANCEL requests by definition resend messageids. */
 		return true;
 	}
 
-	if (sconn->smb2.supports_multicredit) {
-		credit_charge = SVAL(inhdr, SMB2_HDR_CREDIT_CHARGE);
-		credit_charge = MAX(credit_charge, 1);
-	}
-
-	DEBUG(11, ("smb2_validate_message_id: mid %llu (charge %llu), "
-		   "credits_granted %llu, "
+	DEBUG(11, ("smb2_validate_message_id: mid %llu, credits_granted %llu, "
 		   "seqnum low/range: %llu/%llu\n",
 		   (unsigned long long) message_id,
-		   (unsigned long long) credit_charge,
 		   (unsigned long long) sconn->smb2.credits_granted,
 		   (unsigned long long) sconn->smb2.seqnum_low,
 		   (unsigned long long) sconn->smb2.seqnum_range));
 
-	if (sconn->smb2.credits_granted < credit_charge) {
+	if (sconn->smb2.credits_granted < 1) {
 		DEBUG(0, ("smb2_validate_message_id: client used more "
-			  "credits than granted, mid %llu, charge %llu, "
-			  "credits_granted %llu, "
+			  "credits than granted, mid %llu, credits_granted %llu, "
 			  "seqnum low/range: %llu/%llu\n",
 			  (unsigned long long) message_id,
-			  (unsigned long long) credit_charge,
 			  (unsigned long long) sconn->smb2.credits_granted,
 			  (unsigned long long) sconn->smb2.seqnum_low,
 			  (unsigned long long) sconn->smb2.seqnum_range));
 		return false;
 	}
 
-	/*
-	 * now check the message ids
-	 *
-	 * for multi-credit requests we need to check all current mid plus
-	 * the implicit mids caused by the credit charge
-	 * e.g. current mid = 15, charge 5 => mark 15-19 as used
-	 */
-
-	for (i = 0; i <= (credit_charge-1); i++) {
-		uint64_t id = message_id + i;
-		bool ok;
-
-		DEBUG(11, ("Iterating mid %llu charge %u (sequence %llu)\n",
-			   (unsigned long long)message_id,
-			   credit_charge,
-			   (unsigned long long)id));
-
-		ok = smb2_validate_sequence_number(sconn, message_id, id);
-		if (!ok) {
-			return false;
-		}
+	ok = smb2_validate_sequence_number(sconn, message_id, message_id);
+	if (!ok) {
+		return false;
 	}
 
 	/* substract used credits */
-	sconn->smb2.credits_granted -= credit_charge;
+	sconn->smb2.credits_granted -= 1;
 
 	return true;
 }
@@ -705,25 +419,23 @@
 
 	count = req->in.vector_count;
 
-	if (count < 1 + SMBD_SMB2_NUM_IOV_PER_REQ) {
+	if (count < 4) {
 		/* It's not a SMB2 request */
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	for (idx=1; idx < count; idx += SMBD_SMB2_NUM_IOV_PER_REQ) {
-		struct iovec *hdr = SMBD_SMB2_IDX_HDR_IOV(req,in,idx);
-		struct iovec *body = SMBD_SMB2_IDX_BODY_IOV(req,in,idx);
+	for (idx=1; idx < count; idx += 3) {
 		const uint8_t *inhdr = NULL;
 
-		if (hdr->iov_len != SMB2_HDR_BODY) {
+		if (req->in.vector[idx].iov_len != SMB2_HDR_BODY) {
 			return NT_STATUS_INVALID_PARAMETER;
 		}
 
-		if (body->iov_len < 2) {
+		if (req->in.vector[idx+1].iov_len < 2) {
 			return NT_STATUS_INVALID_PARAMETER;
 		}
 
-		inhdr = (const uint8_t *)hdr->iov_base;
+		inhdr = (const uint8_t *)req->in.vector[idx].iov_base;
 
 		/* Check the SMB2 header */
 		if (IVAL(inhdr, SMB2_HDR_PROTOCOL_ID) != SMB2_MAGIC) {
@@ -744,7 +456,6 @@
 {
 	const uint8_t *inhdr = (const uint8_t *)in_vector->iov_base;
 	uint8_t *outhdr = (uint8_t *)out_vector->iov_base;
-	uint16_t credit_charge = 1;
 	uint16_t credits_requested;
 	uint32_t out_flags;
 	uint16_t cmd;
@@ -770,11 +481,6 @@
 	current_max_credits = sconn->smb2.max_credits / 16;
 	current_max_credits = MAX(current_max_credits, 1);
 
-	if (sconn->smb2.supports_multicredit) {
-		credit_charge = SVAL(inhdr, SMB2_HDR_CREDIT_CHARGE);
-		credit_charge = MAX(credit_charge, 1);
-	}
-
 	cmd = SVAL(inhdr, SMB2_HDR_OPCODE);
 	credits_requested = SVAL(inhdr, SMB2_HDR_CREDIT);
 	out_flags = IVAL(outhdr, SMB2_HDR_FLAGS);
@@ -782,12 +488,6 @@
 
 	SMB_ASSERT(sconn->smb2.max_credits >= sconn->smb2.credits_granted);
 
-	if (sconn->smb2.max_credits < credit_charge) {
-		smbd_server_connection_terminate(sconn,
-			"client error: credit charge > max credits\n");
-		return;
-	}
-
 	if (out_flags & SMB2_HDR_FLAG_ASYNC) {
 		/*
 		 * In case we already send an async interim
@@ -823,7 +523,7 @@
 
 		additional_credits = MIN(additional_credits, additional_max);
 
-		credits_granted = credit_charge + additional_credits;
+		credits_granted = 1 + additional_credits;
 	} else if (sconn->smb2.credits_granted == 0) {
 		/*
 		 * Make sure the client has always at least one credit
@@ -860,11 +560,10 @@
 	sconn->smb2.credits_granted += credits_granted;
 	sconn->smb2.seqnum_range += credits_granted;
 
-	DEBUG(10,("smb2_set_operation_credit: requested %u, charge %u, "
+	DEBUG(10,("smb2_set_operation_credit: requested %u, "
 		"granted %u, current possible/max %u/%u, "
 		"total granted/max/low/range %u/%u/%llu/%u\n",
 		(unsigned int)credits_requested,
-		(unsigned int)credit_charge,
 		(unsigned int)credits_granted,
 		(unsigned int)credits_possible,
 		(unsigned int)current_max_credits,
@@ -882,18 +581,16 @@
 
 	count = outreq->out.vector_count;
 
-	for (idx=1; idx < count; idx += SMBD_SMB2_NUM_IOV_PER_REQ) {
-		struct iovec *inhdr_v = SMBD_SMB2_IDX_HDR_IOV(inreq,in,idx);
-		struct iovec *outhdr_v = SMBD_SMB2_IDX_HDR_IOV(outreq,out,idx);
-		uint8_t *outhdr = (uint8_t *)outhdr_v->iov_base;
-
-		smb2_set_operation_credit(outreq->sconn, inhdr_v, outhdr_v);
-
+	for (idx=1; idx < count; idx += 3) {
+		uint8_t *outhdr = (uint8_t *)outreq->out.vector[idx].iov_base;
+		smb2_set_operation_credit(outreq->sconn,
+			&inreq->in.vector[idx],
+			&outreq->out.vector[idx]);
 		/* To match Windows, count up what we
 		   just granted. */
 		total_credits += SVAL(outhdr, SMB2_HDR_CREDIT);
 		/* Set to zero in all but the last reply. */
-		if (idx + SMBD_SMB2_NUM_IOV_PER_REQ < count) {
+		if (idx + 3 < count) {
 			SSVAL(outhdr, SMB2_HDR_CREDIT, 0);
 		} else {
 			SSVAL(outhdr, SMB2_HDR_CREDIT, total_credits);
@@ -917,20 +614,23 @@
 	vector[0].iov_len	= 4;
 	SIVAL(req->out.nbt_hdr, 0, 0);
 
-	for (idx=1; idx < count; idx += SMBD_SMB2_NUM_IOV_PER_REQ) {
-		struct iovec *inhdr_v = SMBD_SMB2_IDX_HDR_IOV(req,in,idx);
-		const uint8_t *inhdr = (const uint8_t *)inhdr_v->iov_base;
+	for (idx=1; idx < count; idx += 3) {
+		const uint8_t *inhdr = NULL;
+		uint32_t in_flags;
 		uint8_t *outhdr = NULL;
 		uint8_t *outbody = NULL;
 		uint32_t next_command_ofs = 0;
 		struct iovec *current = &vector[idx];
 
-		if ((idx + SMBD_SMB2_NUM_IOV_PER_REQ) < count) {
+		if ((idx + 3) < count) {
 			/* we have a next command -
 			 * setup for the error case. */
 			next_command_ofs = SMB2_HDR_BODY + 9;
 		}
 
+		inhdr = (const uint8_t *)req->in.vector[idx].iov_base;
+		in_flags = IVAL(inhdr, SMB2_HDR_FLAGS);
+
 		outhdr = talloc_zero_array(vector, uint8_t,
 				      OUTVEC_ALLOC_SIZE);
 		if (outhdr == NULL) {
@@ -939,20 +639,14 @@
 
 		outbody = outhdr + SMB2_HDR_BODY;
 
-		/*
-		 * SMBD_SMB2_TF_IOV_OFS might be used later
-		 */
-		current[SMBD_SMB2_TF_IOV_OFS].iov_base   = NULL;
-		current[SMBD_SMB2_TF_IOV_OFS].iov_len    = 0;
-
-		current[SMBD_SMB2_HDR_IOV_OFS].iov_base  = (void *)outhdr;
-		current[SMBD_SMB2_HDR_IOV_OFS].iov_len   = SMB2_HDR_BODY;
+		current[0].iov_base	= (void *)outhdr;
+		current[0].iov_len	= SMB2_HDR_BODY;
 
-		current[SMBD_SMB2_BODY_IOV_OFS].iov_base = (void *)outbody;
-		current[SMBD_SMB2_BODY_IOV_OFS].iov_len  = 8;
+		current[1].iov_base	= (void *)outbody;
+		current[1].iov_len	= 8;
 
-		current[SMBD_SMB2_DYN_IOV_OFS].iov_base  = NULL;
-		current[SMBD_SMB2_DYN_IOV_OFS].iov_len   = 0;
+		current[2].iov_base	= NULL;
+		current[2].iov_len	= 0;
 
 		/* setup the SMB2 header */
 		SIVAL(outhdr, SMB2_HDR_PROTOCOL_ID,	SMB2_MAGIC);
@@ -1003,102 +697,72 @@
 	exit_server_cleanly(reason);
 }
 
-static bool dup_smb2_vec4(TALLOC_CTX *ctx,
+static bool dup_smb2_vec3(TALLOC_CTX *ctx,
 			struct iovec *outvec,
 			const struct iovec *srcvec)
 {
-	const uint8_t *srctf;
-	size_t srctf_len;
-	const uint8_t *srchdr;
-	size_t srchdr_len;
-	const uint8_t *srcbody;
-	size_t srcbody_len;
-	const uint8_t *expected_srcbody;
-	const uint8_t *srcdyn;
-	size_t srcdyn_len;
-	const uint8_t *expected_srcdyn;
-	uint8_t *dsttf;
-	uint8_t *dsthdr;
-	uint8_t *dstbody;
-	uint8_t *dstdyn;
-
-	srctf  = (const uint8_t *)srcvec[SMBD_SMB2_TF_IOV_OFS].iov_base;
-	srctf_len = srcvec[SMBD_SMB2_TF_IOV_OFS].iov_len;
-	srchdr  = (const uint8_t *)srcvec[SMBD_SMB2_HDR_IOV_OFS].iov_base;
-	srchdr_len = srcvec[SMBD_SMB2_HDR_IOV_OFS].iov_len;
-	srcbody = (const uint8_t *)srcvec[SMBD_SMB2_BODY_IOV_OFS].iov_base;
-	srcbody_len = srcvec[SMBD_SMB2_BODY_IOV_OFS].iov_len;
-	expected_srcbody = srchdr + SMB2_HDR_BODY;
-	srcdyn  = (const uint8_t *)srcvec[SMBD_SMB2_DYN_IOV_OFS].iov_base;
-	srcdyn_len = srcvec[SMBD_SMB2_DYN_IOV_OFS].iov_len;
-	expected_srcdyn = srcbody + 8;
-
-	if ((srctf_len != SMB2_TF_HDR_SIZE) && (srctf_len != 0)) {
-		return false;
-	}
-
-	if (srchdr_len != SMB2_HDR_BODY) {
-		return false;
-	}
-
-	if (srctf_len == SMB2_TF_HDR_SIZE) {
-		dsttf = talloc_memdup(ctx, srctf, SMB2_TF_HDR_SIZE);
-		if (dsttf == NULL) {
-			return false;
-		}
-	} else {
-		dsttf = NULL;
-	}
-	outvec[SMBD_SMB2_TF_IOV_OFS].iov_base = (void *)dsttf;
-	outvec[SMBD_SMB2_TF_IOV_OFS].iov_len = srctf_len;
-
-	/* vec[SMBD_SMB2_HDR_IOV_OFS] is always boilerplate and must
+	/* vec[0] is always boilerplate and must
 	 * be allocated with size OUTVEC_ALLOC_SIZE. */
 
-	dsthdr = talloc_memdup(ctx, srchdr, OUTVEC_ALLOC_SIZE);
-	if (dsthdr == NULL) {
+	outvec[0].iov_base = talloc_memdup(ctx,
+				srcvec[0].iov_base,
+				OUTVEC_ALLOC_SIZE);
+	if (!outvec[0].iov_base) {
 		return false;
 	}
-	outvec[SMBD_SMB2_HDR_IOV_OFS].iov_base = (void *)dsthdr;
-	outvec[SMBD_SMB2_HDR_IOV_OFS].iov_len = SMB2_HDR_BODY;
+	outvec[0].iov_len = SMB2_HDR_BODY;
 
 	/*
-	 * If this is a "standard" vec[SMBD_SMB2_BOFY_IOV_OFS] of length 8,
-	 * pointing to srcvec[SMBD_SMB2_HDR_IOV_OFS].iov_base + SMB2_HDR_BODY,
+	 * If this is a "standard" vec[1] of length 8,
+	 * pointing to srcvec[0].iov_base + SMB2_HDR_BODY,
 	 * then duplicate this. Else use talloc_memdup().
 	 */
 
-	if ((srcbody == expected_srcbody) && (srcbody_len == 8)) {
-		dstbody = dsthdr + SMB2_HDR_BODY;
+	if (srcvec[1].iov_len == 8 &&
+			srcvec[1].iov_base ==
+				((uint8_t *)srcvec[0].iov_base) +
+					SMB2_HDR_BODY) {
+		outvec[1].iov_base = ((uint8_t *)outvec[0].iov_base) +
+					SMB2_HDR_BODY;
+		outvec[1].iov_len = 8;
 	} else {
-		dstbody = talloc_memdup(ctx, srcbody, srcbody_len);
-		if (dstbody == NULL) {
+		outvec[1].iov_base = talloc_memdup(ctx,
+				srcvec[1].iov_base,
+				srcvec[1].iov_len);
+		if (!outvec[1].iov_base) {
 			return false;
 		}
+		outvec[1].iov_len = srcvec[1].iov_len;
 	}
-	outvec[SMBD_SMB2_BODY_IOV_OFS].iov_base = (void *)dstbody;
-	outvec[SMBD_SMB2_BODY_IOV_OFS].iov_len = srcbody_len;
 
 	/*
-	 * If this is a "standard" vec[SMBD_SMB2_DYN_IOV_OFS] of length 1,
-	 * pointing to
-	 * srcvec[SMBD_SMB2_HDR_IOV_OFS].iov_base + 8
+	 * If this is a "standard" vec[2] of length 1,
+	 * pointing to srcvec[0].iov_base + (OUTVEC_ALLOC_SIZE - 1)
 	 * then duplicate this. Else use talloc_memdup().
 	 */
 
-	if ((srcdyn == expected_srcdyn) && (srcdyn_len == 1)) {
-		dstdyn = dsthdr + SMB2_HDR_BODY + 8;
-	} else if (srcdyn == NULL) {
-		dstdyn = NULL;
-	} else {
-		dstdyn = talloc_memdup(ctx, srcdyn, srcdyn_len);
-		if (dstdyn == NULL) {
-			return false;
+	if (srcvec[2].iov_base &&
+			srcvec[2].iov_len) {
+		if (srcvec[2].iov_base ==
+				((uint8_t *)srcvec[0].iov_base) +
+					(OUTVEC_ALLOC_SIZE - 1) &&
+				srcvec[2].iov_len == 1) {
+			/* Common SMB2 error packet case. */
+			outvec[2].iov_base = ((uint8_t *)outvec[0].iov_base) +
+				(OUTVEC_ALLOC_SIZE - 1);
+		} else {
+			outvec[2].iov_base = talloc_memdup(ctx,
+					srcvec[2].iov_base,
+					srcvec[2].iov_len);
+			if (!outvec[2].iov_base) {
+				return false;
+			}
 		}
+		outvec[2].iov_len = srcvec[2].iov_len;
+	} else {
+		outvec[2].iov_base = NULL;
+		outvec[2].iov_len = 0;
 	}
-	outvec[SMBD_SMB2_DYN_IOV_OFS].iov_base = (void *)dstdyn;
-	outvec[SMBD_SMB2_DYN_IOV_OFS].iov_len = srcdyn_len;
-
 	return true;
 }
 
@@ -1116,9 +780,17 @@
 
 	newreq->sconn = req->sconn;
 	newreq->session = req->session;
-	newreq->do_encryption = req->do_encryption;
 	newreq->do_signing = req->do_signing;
 	newreq->current_idx = req->current_idx;
+	newreq->async = false;
+	newreq->cancelled = false;
+	/* Note we are leaving:
+		->tcon
+		->smb1req
+		->compat_chain_fsp
+	   uninitialized as NULL here as
+	   they're not used in the interim
+	   response code. JRA. */
 
 	outvec = talloc_zero_array(newreq, struct iovec, count);
 	if (!outvec) {
@@ -1134,8 +806,8 @@
 	memcpy(newreq->out.nbt_hdr, req->out.nbt_hdr, 4);
 
 	/* Setup the vectors identically to the ones in req. */
-	for (i = 1; i < count; i += SMBD_SMB2_NUM_IOV_PER_REQ) {
-		if (!dup_smb2_vec4(outvec, &outvec[i], &req->out.vector[i])) {
+	for (i = 1; i < count; i += 3) {
+		if (!dup_smb2_vec3(outvec, &outvec[i], &req->out.vector[i])) {
 			break;
 		}
 	}
@@ -1152,16 +824,13 @@
 	return newreq;
 }
 
+static void smbd_smb2_request_writev_done(struct tevent_req *subreq);
+
 static NTSTATUS smb2_send_async_interim_response(const struct smbd_smb2_request *req)
 {
-	struct smbd_server_connection *sconn = req->sconn;
-	struct smbXsrv_connection *conn = req->sconn->conn;
-	int first_idx = 1;
-	struct iovec *firsttf = NULL;
-	struct iovec *outhdr_v = NULL;
+	int i = 0;
 	uint8_t *outhdr = NULL;
 	struct smbd_smb2_request *nreq = NULL;
-	NTSTATUS status;
 
 	/* Create a new smb2 request we'll use
 	   for the interim return. */
@@ -1170,24 +839,31 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	/* Lose the last X out vectors. They're the
+	/* Lose the last 3 out vectors. They're the
 	   ones we'll be using for the async reply. */
-	nreq->out.vector_count -= SMBD_SMB2_NUM_IOV_PER_REQ;
+	nreq->out.vector_count -= 3;
 
 	smb2_setup_nbt_length(nreq->out.vector,
 		nreq->out.vector_count);
 
 	/* Step back to the previous reply. */
-	nreq->current_idx -= SMBD_SMB2_NUM_IOV_PER_REQ;
-	firsttf = SMBD_SMB2_IDX_TF_IOV(nreq,out,first_idx);
-	outhdr_v = SMBD_SMB2_OUT_HDR_IOV(nreq);
-	outhdr = SMBD_SMB2_OUT_HDR_PTR(nreq);
+	i = nreq->current_idx - 3;
+	outhdr = (uint8_t *)nreq->out.vector[i].iov_base;
 	/* And end the chain. */
 	SIVAL(outhdr, SMB2_HDR_NEXT_COMMAND, 0);
 
 	/* Calculate outgoing credits */
 	smb2_calculate_credits(req, nreq);
 
+	/* Re-sign if needed. */
+	if (nreq->do_signing) {
+		NTSTATUS status;
+		status = smb2_signing_sign_pdu(nreq->session->session_key,
+					&nreq->out.vector[i], 3);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
+		}
+	}
 	if (DEBUGLEVEL >= 10) {
 		dbgtext("smb2_send_async_interim_response: nreq->current_idx = %u\n",
 			(unsigned int)nreq->current_idx );
@@ -1195,91 +871,76 @@
 			(unsigned int)nreq->out.vector_count );
 		print_req_vectors(nreq);
 	}
+	nreq->subreq = tstream_writev_queue_send(nreq,
+					nreq->sconn->smb2.event_ctx,
+					nreq->sconn->smb2.stream,
+					nreq->sconn->smb2.send_queue,
+					nreq->out.vector,
+					nreq->out.vector_count);
 
-	/*
-	 * As we have changed the header (SMB2_HDR_NEXT_COMMAND),
-	 * we need to sign/encrypt here with the last/first key we remembered
-	 */
-	if (firsttf->iov_len == SMB2_TF_HDR_SIZE) {
-		status = smb2_signing_encrypt_pdu(req->first_key,
-					conn->protocol,
-					firsttf,
-					nreq->out.vector_count - first_idx);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	} else if (req->last_key.length > 0) {
-		status = smb2_signing_sign_pdu(req->last_key,
-					       conn->protocol,
-					       outhdr_v,
-					       SMBD_SMB2_NUM_IOV_PER_REQ - 1);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
+	if (nreq->subreq == NULL) {
+		return NT_STATUS_NO_MEMORY;
 	}
 
-	nreq->queue_entry.mem_ctx = nreq;
-	nreq->queue_entry.vector = nreq->out.vector;
-	nreq->queue_entry.count = nreq->out.vector_count;
-	DLIST_ADD_END(nreq->sconn->smb2.send_queue, &nreq->queue_entry, NULL);
-	nreq->sconn->smb2.send_queue_len++;
-
-	status = smbd_smb2_io_handler(sconn, TEVENT_FD_WRITE);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
+	tevent_req_set_callback(nreq->subreq,
+			smbd_smb2_request_writev_done,
+			nreq);
 
 	return NT_STATUS_OK;
 }
 
 struct smbd_smb2_request_pending_state {
         struct smbd_server_connection *sconn;
-	struct smbd_smb2_send_queue queue_entry;
-        uint8_t buf[NBT_HDR_SIZE + SMB2_TF_HDR_SIZE + SMB2_HDR_BODY + 0x08 + 1];
-        struct iovec vector[1 + SMBD_SMB2_NUM_IOV_PER_REQ];
+        uint8_t buf[4 + SMB2_HDR_BODY + 0x08 + 1];
+        struct iovec vector[3];
 };
 
-static void smbd_smb2_request_pending_timer(struct tevent_context *ev,
-					    struct tevent_timer *te,
-					    struct timeval current_time,
-					    void *private_data);
+static void smbd_smb2_request_pending_writev_done(struct tevent_req *subreq)
+{
+	struct smbd_smb2_request_pending_state *state =
+		tevent_req_callback_data(subreq,
+			struct smbd_smb2_request_pending_state);
+	struct smbd_server_connection *sconn = state->sconn;
+	int ret;
+	int sys_errno;
+
+	ret = tstream_writev_queue_recv(subreq, &sys_errno);
+	TALLOC_FREE(subreq);
+	if (ret == -1) {
+		NTSTATUS status = map_nt_error_from_unix(sys_errno);
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
+	}
+
+	TALLOC_FREE(state);
+}
 
 NTSTATUS smbd_smb2_request_pending_queue(struct smbd_smb2_request *req,
-					 struct tevent_req *subreq,
-					 uint32_t defer_time)
+					 struct tevent_req *subreq)
 {
 	NTSTATUS status;
-	struct timeval defer_endtime;
-	uint8_t *outhdr = NULL;
-	uint32_t flags;
+	struct smbd_smb2_request_pending_state *state = NULL;
+	int i = req->current_idx;
+	uint8_t *reqhdr = NULL;
+	uint8_t *hdr = NULL;
+	uint8_t *body = NULL;
+	uint32_t flags = 0;
+	uint64_t message_id = 0;
+	uint64_t async_id = 0;
 
 	if (!tevent_req_is_in_progress(subreq)) {
-		/*
-		 * This is a performance optimization,
-		 * it avoids one tevent_loop iteration,
-		 * which means we avoid one
-		 * talloc_stackframe_pool/talloc_free pair.
-		 */
-		tevent_req_notify_callback(subreq);
 		return NT_STATUS_OK;
 	}
 
 	req->subreq = subreq;
 	subreq = NULL;
 
-	if (req->async_te) {
-		/* We're already async. */
-		return NT_STATUS_OK;
-	}
-
-	outhdr = SMBD_SMB2_OUT_HDR_PTR(req);
-	flags = IVAL(outhdr, SMB2_HDR_FLAGS);
-	if (flags & SMB2_HDR_FLAG_ASYNC) {
+	if (req->async) {
 		/* We're already async. */
 		return NT_STATUS_OK;
 	}
 
-	if (req->in.vector_count > req->current_idx + SMBD_SMB2_NUM_IOV_PER_REQ) {
+	if (req->in.vector_count > i + 3) {
 		/*
 		 * We're trying to go async in a compound
 		 * request chain.
@@ -1288,7 +949,8 @@
 		 * is not allowed. See [MS-SMB2].pdf
 		 * note <194> on Section 3.3.5.2.7.
 		 */
-		const uint8_t *inhdr = SMBD_SMB2_IN_HDR_PTR(req);
+		const uint8_t *inhdr =
+			(const uint8_t *)req->in.vector[i].iov_base;
 
 		if (SVAL(inhdr, SMB2_HDR_OPCODE) != SMB2_OP_CREATE) {
 			/*
@@ -1301,7 +963,7 @@
 			TALLOC_FREE(req->subreq);
 			return smbd_smb2_request_error(req,
 				NT_STATUS_INTERNAL_ERROR);
-		}
+                }
 	}
 
 	if (DEBUGLEVEL >= 10) {
@@ -1310,7 +972,7 @@
 		print_req_vectors(req);
 	}
 
-	if (req->current_idx > 1) {
+	if (i > 1) {
 		/*
 		 * We're going async in a compound
 		 * chain after the first request has
@@ -1318,13 +980,10 @@
 		 * interim response containing the
 		 * set of replies already generated.
 		 */
-		int idx = req->current_idx;
-
 		status = smb2_send_async_interim_response(req);
 		if (!NT_STATUS_IS_OK(status)) {
 			return status;
 		}
-		data_blob_clear_free(&req->first_key);
 
 		req->current_idx = 1;
 
@@ -1333,86 +992,41 @@
 		 * we just sent.
 		 */
 		memmove(&req->in.vector[1],
-			&req->in.vector[idx],
-			sizeof(req->in.vector[0])*(req->in.vector_count - idx));
-		req->in.vector_count = 1 + (req->in.vector_count - idx);
+			&req->in.vector[i],
+			sizeof(req->in.vector[0])*(req->in.vector_count - i));
+		req->in.vector_count = 1 + (req->in.vector_count - i);
+
+		smb2_setup_nbt_length(req->in.vector, req->in.vector_count);
 
 		/* Re-arrange the out.vectors to match. */
 		memmove(&req->out.vector[1],
-			&req->out.vector[idx],
-			sizeof(req->out.vector[0])*(req->out.vector_count - idx));
-		req->out.vector_count = 1 + (req->out.vector_count - idx);
+			&req->out.vector[i],
+			sizeof(req->out.vector[0])*(req->out.vector_count - i));
+		req->out.vector_count = 1 + (req->out.vector_count - i);
 
-		if (req->in.vector_count == 1 + SMBD_SMB2_NUM_IOV_PER_REQ) {
+		if (req->in.vector_count == 4) {
+			uint8_t *outhdr = (uint8_t *)req->out.vector[i].iov_base;
 			/*
 			 * We only have one remaining request as
 			 * we've processed everything else.
 			 * This is no longer a compound request.
 			 */
 			req->compound_related = false;
-			outhdr = SMBD_SMB2_OUT_HDR_PTR(req);
 			flags = (IVAL(outhdr, SMB2_HDR_FLAGS) & ~SMB2_HDR_FLAG_CHAINED);
 			SIVAL(outhdr, SMB2_HDR_FLAGS, flags);
 		}
 	}
-	data_blob_clear_free(&req->last_key);
 
-	defer_endtime = timeval_current_ofs_usec(defer_time);
-	req->async_te = tevent_add_timer(req->sconn->ev_ctx,
-					 req, defer_endtime,
-					 smbd_smb2_request_pending_timer,
-					 req);
-	if (req->async_te == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	/* Don't return an intermediate packet on a pipe read/write. */
+	if (req->tcon && req->tcon->compat_conn && IS_IPC(req->tcon->compat_conn)) {
+		goto out;
 	}
 
-	return NT_STATUS_OK;
-}
-
-static void smbd_smb2_request_pending_timer(struct tevent_context *ev,
-					    struct tevent_timer *te,
-					    struct timeval current_time,
-					    void *private_data)
-{
-	struct smbd_smb2_request *req =
-		talloc_get_type_abort(private_data,
-		struct smbd_smb2_request);
-	struct smbd_server_connection *sconn = req->sconn;
-	struct smbd_smb2_request_pending_state *state = NULL;
-	uint8_t *outhdr = NULL;
-	const uint8_t *inhdr = NULL;
-	uint8_t *tf = NULL;
-	size_t tf_len = 0;
-	uint8_t *hdr = NULL;
-	uint8_t *body = NULL;
-	uint8_t *dyn = NULL;
-	uint32_t flags = 0;
-	uint64_t session_id = 0;
-	uint64_t message_id = 0;
-	uint64_t nonce_high = 0;
-	uint64_t nonce_low = 0;
-	uint64_t async_id = 0;
-	NTSTATUS status;
-
-	TALLOC_FREE(req->async_te);
-
-	/* Ensure our final reply matches the interim one. */
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
-	outhdr = SMBD_SMB2_OUT_HDR_PTR(req);
-	flags = IVAL(outhdr, SMB2_HDR_FLAGS);
-	message_id = BVAL(outhdr, SMB2_HDR_MESSAGE_ID);
-	session_id = BVAL(outhdr, SMB2_HDR_SESSION_ID);
-
+	reqhdr = (uint8_t *)req->out.vector[i].iov_base;
+	flags = (IVAL(reqhdr, SMB2_HDR_FLAGS) & ~SMB2_HDR_FLAG_CHAINED);
+	message_id = BVAL(reqhdr, SMB2_HDR_MESSAGE_ID);
 	async_id = message_id; /* keep it simple for now... */
 
-	SIVAL(outhdr, SMB2_HDR_FLAGS, flags | SMB2_HDR_FLAG_ASYNC);
-	SBVAL(outhdr, SMB2_HDR_ASYNC_ID, async_id);
-
-	DEBUG(10,("smbd_smb2_request_pending_queue: opcode[%s] mid %llu "
-		"going async\n",
-		smb2_opcode_name(SVAL(inhdr, SMB2_HDR_OPCODE)),
-		(unsigned long long)async_id ));
-
 	/*
 	 * What we send is identical to a smbd_smb2_request_error
 	 * packet with an error status of STATUS_PENDING. Make use
@@ -1421,51 +1035,37 @@
 
 	state = talloc_zero(req->sconn, struct smbd_smb2_request_pending_state);
 	if (state == NULL) {
-		smbd_server_connection_terminate(req->sconn,
-						 nt_errstr(NT_STATUS_NO_MEMORY));
-		return;
+		return NT_STATUS_NO_MEMORY;
 	}
 	state->sconn = req->sconn;
 
-	tf = state->buf + NBT_HDR_SIZE;
-	tf_len = SMB2_TF_HDR_SIZE;
-
-	hdr = tf + SMB2_TF_HDR_SIZE;
-	body = hdr + SMB2_HDR_BODY;
-	dyn = body + 8;
+	state->vector[0].iov_base = (void *)state->buf;
+	state->vector[0].iov_len = 4;
 
-	if (req->do_encryption) {
-		struct smbXsrv_session *x = req->session;
+	state->vector[1].iov_base = state->buf + 4;
+	state->vector[1].iov_len = SMB2_HDR_BODY;
 
-		nonce_high = x->nonce_high;
-		nonce_low = x->nonce_low;
+	state->vector[2].iov_base = state->buf + 4 + SMB2_HDR_BODY;
+	state->vector[2].iov_len = 9;
 
-		x->nonce_low += 1;
-		if (x->nonce_low == 0) {
-			x->nonce_low += 1;
-			x->nonce_high += 1;
-		}
-	}
+	smb2_setup_nbt_length(state->vector, 3);
 
-	SIVAL(tf, SMB2_TF_PROTOCOL_ID, SMB2_TF_MAGIC);
-	SBVAL(tf, SMB2_TF_NONCE+0, nonce_low);
-	SBVAL(tf, SMB2_TF_NONCE+8, nonce_high);
-	SBVAL(tf, SMB2_TF_SESSION_ID, session_id);
+	hdr = (uint8_t *)state->vector[1].iov_base;
+	body = (uint8_t *)state->vector[2].iov_base;
 
 	SIVAL(hdr, SMB2_HDR_PROTOCOL_ID, SMB2_MAGIC);
 	SSVAL(hdr, SMB2_HDR_LENGTH, SMB2_HDR_BODY);
 	SSVAL(hdr, SMB2_HDR_EPOCH, 0);
 	SIVAL(hdr, SMB2_HDR_STATUS, NT_STATUS_V(STATUS_PENDING));
-	SSVAL(hdr, SMB2_HDR_OPCODE, SVAL(outhdr, SMB2_HDR_OPCODE));
+	SSVAL(hdr, SMB2_HDR_OPCODE, SVAL(reqhdr, SMB2_HDR_OPCODE));
 
 	SIVAL(hdr, SMB2_HDR_FLAGS, flags);
 	SIVAL(hdr, SMB2_HDR_NEXT_COMMAND, 0);
 	SBVAL(hdr, SMB2_HDR_MESSAGE_ID, message_id);
 	SBVAL(hdr, SMB2_HDR_PID, async_id);
 	SBVAL(hdr, SMB2_HDR_SESSION_ID,
-		BVAL(outhdr, SMB2_HDR_SESSION_ID));
-	memcpy(hdr+SMB2_HDR_SIGNATURE,
-	       outhdr+SMB2_HDR_SIGNATURE, 16);
+		BVAL(reqhdr, SMB2_HDR_SESSION_ID));
+	memset(hdr+SMB2_HDR_SIGNATURE, 0, 16);
 
 	SSVAL(body, 0x00, 0x08 + 1);
 
@@ -1473,105 +1073,79 @@
 	SCVAL(body, 0x03, 0);
 	SIVAL(body, 0x04, 0);
 	/* Match W2K8R2... */
-	SCVAL(dyn,  0x00, 0x21);
-
-	state->vector[0].iov_base = (void *)state->buf;
-	state->vector[0].iov_len = NBT_HDR_SIZE;
-
-	if (req->do_encryption) {
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_base   = tf;
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_len    = tf_len;
-	} else {
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_base   = NULL;
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_len    = 0;
-	}
-
-	state->vector[1+SMBD_SMB2_HDR_IOV_OFS].iov_base  = hdr;
-	state->vector[1+SMBD_SMB2_HDR_IOV_OFS].iov_len   = SMB2_HDR_BODY;
-
-	state->vector[1+SMBD_SMB2_BODY_IOV_OFS].iov_base = body;
-	state->vector[1+SMBD_SMB2_BODY_IOV_OFS].iov_len  = 8;
-
-	state->vector[1+SMBD_SMB2_DYN_IOV_OFS].iov_base  = dyn;
-	state->vector[1+SMBD_SMB2_DYN_IOV_OFS].iov_len   = 1;
-
-	smb2_setup_nbt_length(state->vector, 1 + SMBD_SMB2_NUM_IOV_PER_REQ);
+	SCVAL(body, 0x08, 0x21);
 
 	/* Ensure we correctly go through crediting. Grant
 	   the credits now, and zero credits on the final
 	   response. */
 	smb2_set_operation_credit(req->sconn,
-			SMBD_SMB2_IN_HDR_IOV(req),
-			&state->vector[1+SMBD_SMB2_HDR_IOV_OFS]);
+			&req->in.vector[i],
+			&state->vector[1]);
 
 	SIVAL(hdr, SMB2_HDR_FLAGS, flags | SMB2_HDR_FLAG_ASYNC);
 
-	if (DEBUGLVL(10)) {
-		int i;
-
-		for (i = 0; i < ARRAY_SIZE(state->vector); i++) {
-			dbgtext("\tstate->vector[%u/%u].iov_len = %u\n",
-				(unsigned int)i,
-				(unsigned int)ARRAY_SIZE(state->vector),
-				(unsigned int)state->vector[i].iov_len);
+	if (req->do_signing) {
+		status = smb2_signing_sign_pdu(req->session->session_key,
+					&state->vector[1], 2);
+		if (!NT_STATUS_IS_OK(status)) {
+			return status;
 		}
 	}
 
-	if (req->do_encryption) {
-		struct smbXsrv_session *x = req->session;
-		struct smbXsrv_connection *conn = x->connection;
-		DATA_BLOB encryption_key = x->global->encryption_key;
-
-		status = smb2_signing_encrypt_pdu(encryption_key,
-					conn->protocol,
-					&state->vector[1+SMBD_SMB2_TF_IOV_OFS],
-					SMBD_SMB2_NUM_IOV_PER_REQ);
-		if (!NT_STATUS_IS_OK(status)) {
-			smbd_server_connection_terminate(req->sconn,
-						nt_errstr(status));
-			return;
-		}
-	} else if (req->do_signing) {
-		struct smbXsrv_session *x = req->session;
-		struct smbXsrv_connection *conn = x->connection;
-		DATA_BLOB signing_key = x->global->channels[0].signing_key;
-
-		status = smb2_signing_sign_pdu(signing_key,
-					conn->protocol,
-					&state->vector[1+SMBD_SMB2_HDR_IOV_OFS],
-					SMBD_SMB2_NUM_IOV_PER_REQ - 1);
-		if (!NT_STATUS_IS_OK(status)) {
-			smbd_server_connection_terminate(req->sconn,
-						nt_errstr(status));
-			return;
-		}
+	subreq = tstream_writev_queue_send(state,
+					req->sconn->smb2.event_ctx,
+					req->sconn->smb2.stream,
+					req->sconn->smb2.send_queue,
+					state->vector,
+					3);
+
+	if (subreq == NULL) {
+		return NT_STATUS_NO_MEMORY;
 	}
 
-	state->queue_entry.mem_ctx = state;
-	state->queue_entry.vector = state->vector;
-	state->queue_entry.count = ARRAY_SIZE(state->vector);
-	DLIST_ADD_END(sconn->smb2.send_queue, &state->queue_entry, NULL);
-	sconn->smb2.send_queue_len++;
+	tevent_req_set_callback(subreq,
+			smbd_smb2_request_pending_writev_done,
+			state);
+
+	/* Note we're going async with this request. */
+	req->async = true;
+
+  out:
+
+	smb2_setup_nbt_length(req->out.vector,
+		req->out.vector_count);
+
+	if (req->async) {
+		/* Ensure our final reply matches the interim one. */
+		reqhdr = (uint8_t *)req->out.vector[1].iov_base;
+		SIVAL(reqhdr, SMB2_HDR_FLAGS, flags | SMB2_HDR_FLAG_ASYNC);
+		SBVAL(reqhdr, SMB2_HDR_PID, async_id);
 
-	status = smbd_smb2_io_handler(sconn, TEVENT_FD_WRITE);
-	if (!NT_STATUS_IS_OK(status)) {
-		smbd_server_connection_terminate(sconn,
-						 nt_errstr(status));
-		return;
+		{
+			const uint8_t *inhdr =
+				(const uint8_t *)req->in.vector[1].iov_base;
+			DEBUG(10,("smbd_smb2_request_pending_queue: opcode[%s] mid %llu "
+				"going async\n",
+				smb2_opcode_name((uint16_t)IVAL(inhdr, SMB2_HDR_OPCODE)),
+				(unsigned long long)async_id ));
+		}
 	}
-}
+
+	return NT_STATUS_OK;
+}
 
 static NTSTATUS smbd_smb2_request_process_cancel(struct smbd_smb2_request *req)
 {
 	struct smbd_server_connection *sconn = req->sconn;
 	struct smbd_smb2_request *cur;
 	const uint8_t *inhdr;
+	int i = req->current_idx;
 	uint32_t flags;
 	uint64_t search_message_id;
 	uint64_t search_async_id;
 	uint64_t found_id;
 
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
+	inhdr = (const uint8_t *)req->in.vector[i].iov_base;
 
 	flags = IVAL(inhdr, SMB2_HDR_FLAGS);
 	search_message_id = BVAL(inhdr, SMB2_HDR_MESSAGE_ID);
@@ -1597,7 +1171,9 @@
 			continue;
 		}
 
-		outhdr = SMBD_SMB2_OUT_HDR_PTR(cur);
+		i = cur->current_idx;
+
+		outhdr = (const uint8_t *)cur->out.vector[i].iov_base;
 
 		message_id = BVAL(outhdr, SMB2_HDR_MESSAGE_ID);
 		async_id = BVAL(outhdr, SMB2_HDR_PID);
@@ -1616,10 +1192,10 @@
 	}
 
 	if (cur && cur->subreq) {
-		inhdr = SMBD_SMB2_IN_HDR_PTR(cur);
+		inhdr = (const uint8_t *)cur->in.vector[i].iov_base;
 		DEBUG(10,("smbd_smb2_request_process_cancel: attempting to "
 			"cancel opcode[%s] mid %llu\n",
-			smb2_opcode_name(SVAL(inhdr, SMB2_HDR_OPCODE)),
+			smb2_opcode_name((uint16_t)IVAL(inhdr, SMB2_HDR_OPCODE)),
                         (unsigned long long)found_id ));
 		tevent_req_cancel(cur->subreq);
 	}
@@ -1627,197 +1203,30 @@
 	return NT_STATUS_OK;
 }
 
-/*************************************************************
- Ensure an incoming tid is a valid one for us to access.
- Change to the associated uid credentials and chdir to the
- valid tid directory.
-*************************************************************/
-
-static NTSTATUS smbd_smb2_request_check_tcon(struct smbd_smb2_request *req)
-{
-	const uint8_t *inhdr;
-	uint32_t in_flags;
-	uint32_t in_tid;
-	struct smbXsrv_tcon *tcon;
-	NTSTATUS status;
-	NTTIME now = timeval_to_nttime(&req->request_time);
-
-	req->tcon = NULL;
-
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
-
-	in_flags = IVAL(inhdr, SMB2_HDR_FLAGS);
-	in_tid = IVAL(inhdr, SMB2_HDR_TID);
-
-	if (in_flags & SMB2_HDR_FLAG_CHAINED) {
-		in_tid = req->last_tid;
-	}
-
-	req->last_tid = 0;
-
-	status = smb2srv_tcon_lookup(req->session,
-				     in_tid, now, &tcon);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
-	if (!change_to_user(tcon->compat, req->session->compat->vuid)) {
-		return NT_STATUS_ACCESS_DENIED;
-	}
-
-	/* should we pass FLAG_CASELESS_PATHNAMES here? */
-	if (!set_current_service(tcon->compat, 0, true)) {
-		return NT_STATUS_ACCESS_DENIED;
-	}
-
-	req->tcon = tcon;
-	req->last_tid = in_tid;
-
-	return NT_STATUS_OK;
-}
-
-/*************************************************************
- Ensure an incoming session_id is a valid one for us to access.
-*************************************************************/
-
-static NTSTATUS smbd_smb2_request_check_session(struct smbd_smb2_request *req)
-{
-	const uint8_t *inhdr;
-	uint32_t in_flags;
-	uint16_t in_opcode;
-	uint64_t in_session_id;
-	struct smbXsrv_session *session = NULL;
-	struct auth_session_info *session_info;
-	NTSTATUS status;
-	NTTIME now = timeval_to_nttime(&req->request_time);
-
-	req->session = NULL;
-	req->tcon = NULL;
-
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
-
-	in_flags = IVAL(inhdr, SMB2_HDR_FLAGS);
-	in_opcode = SVAL(inhdr, SMB2_HDR_OPCODE);
-	in_session_id = BVAL(inhdr, SMB2_HDR_SESSION_ID);
-
-	if (in_flags & SMB2_HDR_FLAG_CHAINED) {
-		in_session_id = req->last_session_id;
-	}
-
-	req->last_session_id = 0;
-
-	/* lookup an existing session */
-	status = smb2srv_session_lookup(req->sconn->conn,
-					in_session_id, now,
-					&session);
-	if (session) {
-		req->session = session;
-		req->last_session_id = in_session_id;
-	}
-	if (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {
-		switch (in_opcode) {
-		case SMB2_OP_SESSSETUP:
-			status = NT_STATUS_OK;
-			break;
-		default:
-			break;
-		}
-	}
-	if (NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-		switch (in_opcode) {
-		case SMB2_OP_TCON:
-		case SMB2_OP_CREATE:
-		case SMB2_OP_GETINFO:
-		case SMB2_OP_SETINFO:
-			return NT_STATUS_INVALID_HANDLE;
-		default:
-			/*
-			 * Notice the check for
-			 * (session_info == NULL)
-			 * below.
-			 */
-			status = NT_STATUS_OK;
-			break;
-		}
-	}
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
-	session_info = session->global->auth_session_info;
-	if (session_info == NULL) {
-		return NT_STATUS_INVALID_HANDLE;
-	}
-
-	if (in_session_id != req->sconn->conn->last_session_id) {
-		req->sconn->conn->last_session_id = in_session_id;
-		set_current_user_info(session_info->unix_info->sanitized_username,
-				      session_info->unix_info->unix_name,
-				      session_info->info->domain_name);
-	}
-
-	return NT_STATUS_OK;
-}
-
-NTSTATUS smbd_smb2_request_verify_creditcharge(struct smbd_smb2_request *req,
-						uint32_t data_length)
-{
-	uint16_t needed_charge;
-	uint16_t credit_charge = 1;
-	const uint8_t *inhdr;
-
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
-
-	if (req->sconn->smb2.supports_multicredit) {
-		credit_charge = SVAL(inhdr, SMB2_HDR_CREDIT_CHARGE);
-		credit_charge = MAX(credit_charge, 1);
-	}
-
-	needed_charge = (data_length - 1)/ 65536 + 1;
-
-	DEBUG(10, ("mid %llu, CreditCharge: %d, NeededCharge: %d\n",
-		   (unsigned long long) BVAL(inhdr, SMB2_HDR_MESSAGE_ID),
-		   credit_charge, needed_charge));
-
-	if (needed_charge > credit_charge) {
-		DEBUG(2, ("CreditCharge too low, given %d, needed %d\n",
-			  credit_charge, needed_charge));
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	return NT_STATUS_OK;
-}
-
 NTSTATUS smbd_smb2_request_verify_sizes(struct smbd_smb2_request *req,
 					size_t expected_body_size)
 {
-	struct iovec *inhdr_v;
 	const uint8_t *inhdr;
 	uint16_t opcode;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	size_t body_size;
 	size_t min_dyn_size = expected_body_size & 0x00000001;
-	int max_idx = req->in.vector_count - SMBD_SMB2_NUM_IOV_PER_REQ;
 
 	/*
 	 * The following should be checked already.
 	 */
-	if (req->in.vector_count < SMBD_SMB2_NUM_IOV_PER_REQ) {
+	if ((i+2) > req->in.vector_count) {
 		return NT_STATUS_INTERNAL_ERROR;
 	}
-	if (req->current_idx > max_idx) {
+	if (req->in.vector[i+0].iov_len != SMB2_HDR_BODY) {
 		return NT_STATUS_INTERNAL_ERROR;
 	}
-
-	inhdr_v = SMBD_SMB2_IN_HDR_IOV(req);
-	if (inhdr_v->iov_len != SMB2_HDR_BODY) {
-		return NT_STATUS_INTERNAL_ERROR;
-	}
-	if (SMBD_SMB2_IN_BODY_LEN(req) < 2) {
+	if (req->in.vector[i+1].iov_len < 2) {
 		return NT_STATUS_INTERNAL_ERROR;
 	}
 
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
 	opcode = SVAL(inhdr, SMB2_HDR_OPCODE);
 
 	switch (opcode) {
@@ -1830,16 +1239,16 @@
 	/*
 	 * Now check the expected body size,
 	 * where the last byte might be in the
-	 * dynamic section..
+	 * dynnamic section..
 	 */
-	if (SMBD_SMB2_IN_BODY_LEN(req) != (expected_body_size & 0xFFFFFFFE)) {
+	if (req->in.vector[i+1].iov_len != (expected_body_size & 0xFFFFFFFE)) {
 		return NT_STATUS_INVALID_PARAMETER;
 	}
-	if (SMBD_SMB2_IN_DYN_LEN(req) < min_dyn_size) {
+	if (req->in.vector[i+2].iov_len < min_dyn_size) {
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	body_size = SVAL(inbody, 0x00);
 	if (body_size != expected_body_size) {
@@ -1851,10 +1260,8 @@
 
 NTSTATUS smbd_smb2_request_dispatch(struct smbd_smb2_request *req)
 {
-	struct smbXsrv_connection *conn = req->sconn->conn;
-	const struct smbd_smb2_dispatch_table *call = NULL;
-	const struct iovec *intf_v = SMBD_SMB2_IN_TF_IOV(req);
 	const uint8_t *inhdr;
+	int i = req->current_idx;
 	uint16_t opcode;
 	uint32_t flags;
 	uint64_t mid;
@@ -1862,22 +1269,19 @@
 	NTSTATUS session_status;
 	uint32_t allowed_flags;
 	NTSTATUS return_value;
-	struct smbXsrv_session *x = NULL;
-	bool signing_required = false;
-	bool encryption_required = false;
 
-	inhdr = SMBD_SMB2_IN_HDR_PTR(req);
+	inhdr = (const uint8_t *)req->in.vector[i].iov_base;
 
 	/* TODO: verify more things */
 
 	flags = IVAL(inhdr, SMB2_HDR_FLAGS);
-	opcode = SVAL(inhdr, SMB2_HDR_OPCODE);
+	opcode = IVAL(inhdr, SMB2_HDR_OPCODE);
 	mid = BVAL(inhdr, SMB2_HDR_MESSAGE_ID);
 	DEBUG(10,("smbd_smb2_request_dispatch: opcode[%s] mid = %llu\n",
 		smb2_opcode_name(opcode),
 		(unsigned long long)mid));
 
-	if (conn->protocol >= PROTOCOL_SMB2_02) {
+	if (get_Protocol() >= PROTOCOL_SMB2) {
 		/*
 		 * once the protocol is negotiated
 		 * SMB2_OP_NEGPROT is not allowed anymore
@@ -1897,62 +1301,6 @@
 		}
 	}
 
-	/*
-	 * Check if the client provided a valid session id,
-	 * if so smbd_smb2_request_check_session() calls
-	 * set_current_user_info().
-	 *
-	 * As some command don't require a valid session id
-	 * we defer the check of the session_status
-	 */
-	session_status = smbd_smb2_request_check_session(req);
-	x = req->session;
-	if (x != NULL) {
-		signing_required = x->global->signing_required;
-		encryption_required = x->global->encryption_required;
-
-		if (opcode == SMB2_OP_SESSSETUP &&
-		    x->global->channels[0].signing_key.length) {
-			signing_required = true;
-		}
-	}
-
-	req->do_signing = false;
-	req->do_encryption = false;
-	if (intf_v->iov_len == SMB2_TF_HDR_SIZE) {
-		const uint8_t *intf = SMBD_SMB2_IN_TF_PTR(req);
-		uint64_t tf_session_id = BVAL(intf, SMB2_TF_SESSION_ID);
-
-		if (x != NULL && x->global->session_wire_id != tf_session_id) {
-			DEBUG(0,("smbd_smb2_request_dispatch: invalid session_id"
-				 "in SMB2_HDR[%llu], SMB2_TF[%llu]\n",
-				 (unsigned long long)x->global->session_wire_id,
-				 (unsigned long long)tf_session_id));
-			/*
-			 * TODO: windows allows this...
-			 * should we drop the connection?
-			 *
-			 * For now we just return ACCESS_DENIED
-			 * (Windows clients never trigger this)
-			 * and wait for an update of [MS-SMB2].
-			 */
-			return smbd_smb2_request_error(req,
-					NT_STATUS_ACCESS_DENIED);
-		}
-
-		req->do_encryption = true;
-	}
-
-	if (encryption_required && !req->do_encryption) {
-		return smbd_smb2_request_error(req,
-				NT_STATUS_ACCESS_DENIED);
-	}
-
-	call = smbd_smb2_call(opcode);
-	if (call == NULL) {
-		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
-	}
-
 	allowed_flags = SMB2_HDR_FLAG_CHAINED |
 			SMB2_HDR_FLAG_SIGNED |
 			SMB2_HDR_FLAG_DFS;
@@ -1963,6 +1311,16 @@
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
+	/*
+	 * Check if the client provided a valid session id,
+	 * if so smbd_smb2_request_check_session() calls
+	 * set_current_user_info().
+	 *
+	 * As some command don't require a valid session id
+	 * we defer the check of the session_status
+	 */
+	session_status = smbd_smb2_request_check_session(req);
+
 	if (flags & SMB2_HDR_FLAG_CHAINED) {
 		/*
 		 * This check is mostly for giving the correct error code
@@ -1975,51 +1333,21 @@
 		req->compat_chain_fsp = NULL;
 	}
 
-	if (req->do_encryption) {
-		signing_required = false;
-	} else if (flags & SMB2_HDR_FLAG_SIGNED) {
-		DATA_BLOB signing_key;
-
-		if (x == NULL) {
-			return smbd_smb2_request_error(
-				req, NT_STATUS_ACCESS_DENIED);
-		}
-
-		signing_key = x->global->channels[0].signing_key;
-
-		/*
-		 * If we have a signing key, we should
-		 * sign the response
-		 */
-		if (signing_key.length > 0) {
-			req->do_signing = true;
+	req->do_signing = false;
+	if (flags & SMB2_HDR_FLAG_SIGNED) {
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return smbd_smb2_request_error(req, session_status);
 		}
 
-		status = smb2_signing_check_pdu(signing_key,
-						conn->protocol,
-						SMBD_SMB2_IN_HDR_IOV(req),
-						SMBD_SMB2_NUM_IOV_PER_REQ - 1);
+		req->do_signing = true;
+		status = smb2_signing_check_pdu(req->session->session_key,
+						&req->in.vector[i], 3);
 		if (!NT_STATUS_IS_OK(status)) {
 			return smbd_smb2_request_error(req, status);
 		}
-
-		/*
-		 * Now that we know the request was correctly signed
-		 * we have to sign the response too.
-		 */
-		req->do_signing = true;
-
-		if (!NT_STATUS_IS_OK(session_status)) {
-			return smbd_smb2_request_error(req, session_status);
-		}
 	} else if (opcode == SMB2_OP_CANCEL) {
 		/* Cancel requests are allowed to skip the signing */
-	} else if (signing_required) {
-		/*
-		 * If signing is required we try to sign
-		 * a possible error response
-		 */
-		req->do_signing = true;
+	} else if (req->session && req->session->do_signing) {
 		return smbd_smb2_request_error(req, NT_STATUS_ACCESS_DENIED);
 	}
 
@@ -2027,80 +1355,11 @@
 		req->compound_related = true;
 	}
 
-	if (call->need_session) {
-		if (!NT_STATUS_IS_OK(session_status)) {
-			return smbd_smb2_request_error(req, session_status);
-		}
-	}
-
-	if (call->need_tcon) {
-		SMB_ASSERT(call->need_session);
-
-		/*
-		 * This call needs to be run as user.
-		 *
-		 * smbd_smb2_request_check_tcon()
-		 * calls change_to_user() on success.
-		 */
-		status = smbd_smb2_request_check_tcon(req);
-		if (!NT_STATUS_IS_OK(status)) {
-			return smbd_smb2_request_error(req, status);
-		}
-		if (req->tcon->global->encryption_required) {
-			encryption_required = true;
-		}
-		if (encryption_required && !req->do_encryption) {
-			return smbd_smb2_request_error(req,
-				NT_STATUS_ACCESS_DENIED);
-		}
-	}
-
-	if (call->fileid_ofs != 0) {
-		size_t needed = call->fileid_ofs + 16;
-		const uint8_t *body = SMBD_SMB2_IN_BODY_PTR(req);
-		size_t body_size = SMBD_SMB2_IN_BODY_LEN(req);
-		uint64_t file_id_persistent;
-		uint64_t file_id_volatile;
-		struct files_struct *fsp;
-
-		SMB_ASSERT(call->need_tcon);
-
-		if (needed > body_size) {
-			return smbd_smb2_request_error(req,
-					NT_STATUS_INVALID_PARAMETER);
-		}
-
-		file_id_persistent	= BVAL(body, call->fileid_ofs + 0);
-		file_id_volatile	= BVAL(body, call->fileid_ofs + 8);
-
-		fsp = file_fsp_smb2(req, file_id_persistent, file_id_volatile);
-		if (fsp == NULL) {
-			if (!call->allow_invalid_fileid) {
-				return smbd_smb2_request_error(req,
-						NT_STATUS_FILE_CLOSED);
-			}
-
-			if (file_id_persistent != UINT64_MAX) {
-				return smbd_smb2_request_error(req,
-						NT_STATUS_FILE_CLOSED);
-			}
-			if (file_id_volatile != UINT64_MAX) {
-				return smbd_smb2_request_error(req,
-						NT_STATUS_FILE_CLOSED);
-			}
-		}
-	}
-
-	if (call->as_root) {
-		SMB_ASSERT(call->fileid_ofs == 0);
+	switch (opcode) {
+	case SMB2_OP_NEGPROT:
 		/* This call needs to be run as root */
 		change_to_root_user();
-	} else {
-		SMB_ASSERT(call->need_tcon);
-	}
 
-	switch (opcode) {
-	case SMB2_OP_NEGPROT:
 		{
 			START_PROFILE(smb2_negprot);
 			return_value = smbd_smb2_request_process_negprot(req);
@@ -2109,6 +1368,9 @@
 		break;
 
 	case SMB2_OP_SESSSETUP:
+		/* This call needs to be run as root */
+		change_to_root_user();
+
 		{
 			START_PROFILE(smb2_sesssetup);
 			return_value = smbd_smb2_request_process_sesssetup(req);
@@ -2117,6 +1379,14 @@
 		break;
 
 	case SMB2_OP_LOGOFF:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+
+		/* This call needs to be run as root */
+		change_to_root_user();
+
 		{
 			START_PROFILE(smb2_logoff);
 			return_value = smbd_smb2_request_process_logoff(req);
@@ -2125,6 +1395,20 @@
 		break;
 
 	case SMB2_OP_TCON:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+
+		/*
+		 * This call needs to be run as root.
+		 *
+		 * smbd_smb2_request_process_tcon()
+		 * calls make_connection_snum(), which will call
+		 * change_to_user(), when needed.
+		 */
+		change_to_root_user();
+
 		{
 			START_PROFILE(smb2_tcon);
 			return_value = smbd_smb2_request_process_tcon(req);
@@ -2133,6 +1417,25 @@
 		break;
 
 	case SMB2_OP_TDIS:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+		/* This call needs to be run as root */
+		change_to_root_user();
+
+
 		{
 			START_PROFILE(smb2_tdis);
 			return_value = smbd_smb2_request_process_tdis(req);
@@ -2141,6 +1444,22 @@
 		break;
 
 	case SMB2_OP_CREATE:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_create);
 			return_value = smbd_smb2_request_process_create(req);
@@ -2149,6 +1468,22 @@
 		break;
 
 	case SMB2_OP_CLOSE:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_close);
 			return_value = smbd_smb2_request_process_close(req);
@@ -2157,14 +1492,46 @@
 		break;
 
 	case SMB2_OP_FLUSH:
-		{
-			START_PROFILE(smb2_flush);
-			return_value = smbd_smb2_request_process_flush(req);
-			END_PROFILE(smb2_flush);
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
 		}
-		break;
-
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
+		{
+			START_PROFILE(smb2_flush);
+			return_value = smbd_smb2_request_process_flush(req);
+			END_PROFILE(smb2_flush);
+		}
+		break;
+
 	case SMB2_OP_READ:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_read);
 			return_value = smbd_smb2_request_process_read(req);
@@ -2173,6 +1540,22 @@
 		break;
 
 	case SMB2_OP_WRITE:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_write);
 			return_value = smbd_smb2_request_process_write(req);
@@ -2181,6 +1564,30 @@
 		break;
 
 	case SMB2_OP_LOCK:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			/* Too ugly to live ? JRA. */
+			if (NT_STATUS_EQUAL(session_status,NT_STATUS_USER_SESSION_DELETED)) {
+				session_status = NT_STATUS_FILE_CLOSED;
+			}
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			/* Too ugly to live ? JRA. */
+			if (NT_STATUS_EQUAL(status,NT_STATUS_NETWORK_NAME_DELETED)) {
+				status = NT_STATUS_FILE_CLOSED;
+			}
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_lock);
 			return_value = smbd_smb2_request_process_lock(req);
@@ -2189,6 +1596,22 @@
 		break;
 
 	case SMB2_OP_IOCTL:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_ioctl);
 			return_value = smbd_smb2_request_process_ioctl(req);
@@ -2197,6 +1620,13 @@
 		break;
 
 	case SMB2_OP_CANCEL:
+		/*
+		 * This call needs to be run as root
+		 *
+		 * That is what we also do in the SMB1 case.
+		 */
+		change_to_root_user();
+
 		{
 			START_PROFILE(smb2_cancel);
 			return_value = smbd_smb2_request_process_cancel(req);
@@ -2205,6 +1635,9 @@
 		break;
 
 	case SMB2_OP_KEEPALIVE:
+		/* This call needs to be run as root */
+		change_to_root_user();
+
 		{
 			START_PROFILE(smb2_keepalive);
 			return_value = smbd_smb2_request_process_keepalive(req);
@@ -2213,6 +1646,22 @@
 		break;
 
 	case SMB2_OP_FIND:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_find);
 			return_value = smbd_smb2_request_process_find(req);
@@ -2221,6 +1670,22 @@
 		break;
 
 	case SMB2_OP_NOTIFY:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_notify);
 			return_value = smbd_smb2_request_process_notify(req);
@@ -2229,6 +1694,22 @@
 		break;
 
 	case SMB2_OP_GETINFO:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_getinfo);
 			return_value = smbd_smb2_request_process_getinfo(req);
@@ -2237,6 +1718,22 @@
 		break;
 
 	case SMB2_OP_SETINFO:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_setinfo);
 			return_value = smbd_smb2_request_process_setinfo(req);
@@ -2245,6 +1742,22 @@
 		break;
 
 	case SMB2_OP_BREAK:
+		if (!NT_STATUS_IS_OK(session_status)) {
+			return_value = smbd_smb2_request_error(req, session_status);
+			break;
+		}
+		/*
+		 * This call needs to be run as user.
+		 *
+		 * smbd_smb2_request_check_tcon()
+		 * calls change_to_user() on success.
+		 */
+		status = smbd_smb2_request_check_tcon(req);
+		if (!NT_STATUS_IS_OK(status)) {
+			return_value = smbd_smb2_request_error(req, status);
+			break;
+		}
+
 		{
 			START_PROFILE(smb2_break);
 			return_value = smbd_smb2_request_process_break(req);
@@ -2261,93 +1774,12 @@
 
 static NTSTATUS smbd_smb2_request_reply(struct smbd_smb2_request *req)
 {
-	struct smbd_server_connection *sconn = req->sconn;
-	struct smbXsrv_connection *conn = req->sconn->conn;
-	int first_idx = 1;
-	struct iovec *firsttf = SMBD_SMB2_IDX_TF_IOV(req,out,first_idx);
-	struct iovec *outhdr = SMBD_SMB2_OUT_HDR_IOV(req);
-	struct iovec *outdyn = SMBD_SMB2_OUT_DYN_IOV(req);
-	NTSTATUS status;
+	struct tevent_req *subreq;
+	int i = req->current_idx;
 
 	req->subreq = NULL;
-	TALLOC_FREE(req->async_te);
-
-	if (req->do_encryption &&
-	    (firsttf->iov_len == 0) &&
-	    (req->first_key.length == 0) &&
-	    (req->session != NULL) &&
-	    (req->session->global->encryption_key.length != 0))
-	{
-		DATA_BLOB encryption_key = req->session->global->encryption_key;
-		uint8_t *tf;
-		uint64_t session_id = req->session->global->session_wire_id;
-		struct smbXsrv_session *x = req->session;
-		uint64_t nonce_high;
-		uint64_t nonce_low;
-
-		nonce_high = x->nonce_high;
-		nonce_low = x->nonce_low;
-
-		x->nonce_low += 1;
-		if (x->nonce_low == 0) {
-			x->nonce_low += 1;
-			x->nonce_high += 1;
-		}
 
-		/*
-		 * We need to place the SMB2_TRANSFORM header before the
-		 * first SMB2 header
-		 */
-
-		/*
-		 * we need to remember the encryption key
-		 * and defer the signing/encryption until
-		 * we are sure that we do not change
-		 * the header again.
-		 */
-		req->first_key = data_blob_dup_talloc(req, encryption_key);
-		if (req->first_key.data == NULL) {
-			return NT_STATUS_NO_MEMORY;
-		}
-
-		tf = talloc_zero_array(req->out.vector, uint8_t,
-				       SMB2_TF_HDR_SIZE);
-		if (tf == NULL) {
-			return NT_STATUS_NO_MEMORY;
-		}
-
-		SIVAL(tf, SMB2_TF_PROTOCOL_ID, SMB2_TF_MAGIC);
-		SBVAL(tf, SMB2_TF_NONCE+0, nonce_low);
-		SBVAL(tf, SMB2_TF_NONCE+8, nonce_high);
-		SBVAL(tf, SMB2_TF_SESSION_ID, session_id);
-
-		firsttf->iov_base = (void *)tf;
-		firsttf->iov_len = SMB2_TF_HDR_SIZE;
-	}
-
-	if ((req->current_idx > SMBD_SMB2_NUM_IOV_PER_REQ) &&
-	    (req->last_key.length > 0) &&
-	    (firsttf->iov_len == 0))
-	{
-		int last_idx = req->current_idx - SMBD_SMB2_NUM_IOV_PER_REQ;
-		struct iovec *lasthdr = SMBD_SMB2_IDX_HDR_IOV(req,out,last_idx);
-
-		/*
-		 * As we are sure the header of the last request in the
-		 * compound chain will not change, we can to sign here
-		 * with the last signing key we remembered.
-		 */
-		status = smb2_signing_sign_pdu(req->last_key,
-					       conn->protocol,
-					       lasthdr,
-					       SMBD_SMB2_NUM_IOV_PER_REQ - 1);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	}
-	data_blob_clear_free(&req->last_key);
-
-	req->current_idx += SMBD_SMB2_NUM_IOV_PER_REQ;
+	req->current_idx += 3;
 
 	if (req->current_idx < req->out.vector_count) {
 		/*
@@ -2363,24 +1795,26 @@
 			return NT_STATUS_NO_MEMORY;
 		}
 
-		if (req->do_signing && firsttf->iov_len == 0) {
-			struct smbXsrv_session *x = req->session;
-			DATA_BLOB signing_key = x->global->channels[0].signing_key;
-
+		if (req->do_signing) {
 			/*
-			 * we need to remember the signing key
-			 * and defer the signing until
-			 * we are sure that we do not change
-			 * the header again.
+			 * We sign each reply as we go along.
+			 * We can do this as smb2_calculate_credits()
+			 * grants zero credits on every part of a
+			 * compound reply except the last one,
+			 * which is signed just before calling
+			 * tstream_writev_queue_send().
 			 */
-			req->last_key = data_blob_dup_talloc(req, signing_key);
-			if (req->last_key.data == NULL) {
-				return NT_STATUS_NO_MEMORY;
+			NTSTATUS status;
+			status = smb2_signing_sign_pdu(req->session->session_key,
+					       &req->out.vector[i], 3);
+			if (!NT_STATUS_IS_OK(status)) {
+				TALLOC_FREE(im);
+				return status;
 			}
 		}
 
 		tevent_schedule_immediate(im,
-					req->sconn->ev_ctx,
+					req->sconn->smb2.event_ctx,
 					smbd_smb2_request_dispatch_immediate,
 					req);
 		return NT_STATUS_OK;
@@ -2396,56 +1830,45 @@
 	   is a final reply for an async operation). */
 	smb2_calculate_credits(req, req);
 
-	/*
-	 * now check if we need to sign the current response
-	 */
-	if (firsttf->iov_len == SMB2_TF_HDR_SIZE) {
-		status = smb2_signing_encrypt_pdu(req->first_key,
-					conn->protocol,
-					firsttf,
-					req->out.vector_count - first_idx);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	} else if (req->do_signing) {
-		struct smbXsrv_session *x = req->session;
-		DATA_BLOB signing_key = x->global->channels[0].signing_key;
-
-		status = smb2_signing_sign_pdu(signing_key,
-					       conn->protocol,
-					       outhdr,
-					       SMBD_SMB2_NUM_IOV_PER_REQ - 1);
+	if (req->do_signing) {
+		NTSTATUS status;
+		status = smb2_signing_sign_pdu(req->session->session_key,
+					       &req->out.vector[i], 3);
 		if (!NT_STATUS_IS_OK(status)) {
 			return status;
 		}
 	}
-	data_blob_clear_free(&req->first_key);
+
+	if (DEBUGLEVEL >= 10) {
+		dbgtext("smbd_smb2_request_reply: sending...\n");
+		print_req_vectors(req);
+	}
 
 	/* I am a sick, sick man... :-). Sendfile hack ... JRA. */
-	if (req->out.vector_count < (2*SMBD_SMB2_NUM_IOV_PER_REQ) &&
-	    outdyn->iov_base == NULL && outdyn->iov_len != 0) {
+	if (req->out.vector_count == 4 &&
+			req->out.vector[3].iov_base == NULL &&
+			req->out.vector[3].iov_len != 0) {
 		/* Dynamic part is NULL. Chop it off,
 		   We're going to send it via sendfile. */
 		req->out.vector_count -= 1;
 	}
 
+	subreq = tstream_writev_queue_send(req,
+					   req->sconn->smb2.event_ctx,
+					   req->sconn->smb2.stream,
+					   req->sconn->smb2.send_queue,
+					   req->out.vector,
+					   req->out.vector_count);
+	if (subreq == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	tevent_req_set_callback(subreq, smbd_smb2_request_writev_done, req);
 	/*
 	 * We're done with this request -
 	 * move it off the "being processed" queue.
 	 */
 	DLIST_REMOVE(req->sconn->smb2.requests, req);
 
-	req->queue_entry.mem_ctx = req;
-	req->queue_entry.vector = req->out.vector;
-	req->queue_entry.count = req->out.vector_count;
-	DLIST_ADD_END(req->sconn->smb2.send_queue, &req->queue_entry, NULL);
-	req->sconn->smb2.send_queue_len++;
-
-	status = smbd_smb2_io_handler(sconn, TEVENT_FD_WRITE);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
 	return NT_STATUS_OK;
 }
 
@@ -2481,19 +1904,45 @@
 	}
 }
 
+static void smbd_smb2_request_writev_done(struct tevent_req *subreq)
+{
+	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
+					struct smbd_smb2_request);
+	struct smbd_server_connection *sconn = req->sconn;
+	int ret;
+	int sys_errno;
+	NTSTATUS status;
+
+	ret = tstream_writev_queue_recv(subreq, &sys_errno);
+	TALLOC_FREE(subreq);
+	TALLOC_FREE(req);
+	if (ret == -1) {
+		status = map_nt_error_from_unix(sys_errno);
+		DEBUG(2,("smbd_smb2_request_writev_done: client write error %s\n",
+			nt_errstr(status)));
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
+	}
+
+	status = smbd_smb2_request_next_incoming(sconn);
+	if (!NT_STATUS_IS_OK(status)) {
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
+	}
+}
+
 NTSTATUS smbd_smb2_request_done_ex(struct smbd_smb2_request *req,
 				   NTSTATUS status,
 				   DATA_BLOB body, DATA_BLOB *dyn,
 				   const char *location)
 {
 	uint8_t *outhdr;
-	struct iovec *outbody_v;
-	struct iovec *outdyn_v;
+	int i = req->current_idx;
 	uint32_t next_command_ofs;
 
 	DEBUG(10,("smbd_smb2_request_done_ex: "
 		  "idx[%d] status[%s] body[%u] dyn[%s:%u] at %s\n",
-		  req->current_idx, nt_errstr(status), (unsigned int)body.length,
+		  i, nt_errstr(status), (unsigned int)body.length,
 		  dyn ? "yes": "no",
 		  (unsigned int)(dyn ? dyn->length : 0),
 		  location));
@@ -2506,34 +1955,32 @@
 		return smbd_smb2_request_error(req, NT_STATUS_INTERNAL_ERROR);
 	}
 
-	outhdr = SMBD_SMB2_OUT_HDR_PTR(req);
-	outbody_v = SMBD_SMB2_OUT_BODY_IOV(req);
-	outdyn_v = SMBD_SMB2_OUT_DYN_IOV(req);
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
 
 	next_command_ofs = IVAL(outhdr, SMB2_HDR_NEXT_COMMAND);
 	SIVAL(outhdr, SMB2_HDR_STATUS, NT_STATUS_V(status));
 
-	outbody_v->iov_base = (void *)body.data;
-	outbody_v->iov_len = body.length;
+	req->out.vector[i+1].iov_base = (void *)body.data;
+	req->out.vector[i+1].iov_len = body.length;
 
 	if (dyn) {
-		outdyn_v->iov_base = (void *)dyn->data;
-		outdyn_v->iov_len = dyn->length;
+		req->out.vector[i+2].iov_base	= (void *)dyn->data;
+		req->out.vector[i+2].iov_len	= dyn->length;
 	} else {
-		outdyn_v->iov_base = NULL;
-		outdyn_v->iov_len = 0;
+		req->out.vector[i+2].iov_base = NULL;
+		req->out.vector[i+2].iov_len = 0;
 	}
 
 	/* see if we need to recalculate the offset to the next response */
 	if (next_command_ofs > 0) {
 		next_command_ofs  = SMB2_HDR_BODY;
-		next_command_ofs += SMBD_SMB2_OUT_BODY_LEN(req);
-		next_command_ofs += SMBD_SMB2_OUT_DYN_LEN(req);
+		next_command_ofs += req->out.vector[i+1].iov_len;
+		next_command_ofs += req->out.vector[i+2].iov_len;
 	}
 
 	if ((next_command_ofs % 8) != 0) {
 		size_t pad_size = 8 - (next_command_ofs % 8);
-		if (SMBD_SMB2_OUT_DYN_LEN(req) == 0) {
+		if (req->out.vector[i+2].iov_len == 0) {
 			/*
 			 * if the dyn buffer is empty
 			 * we can use it to add padding
@@ -2547,8 +1994,8 @@
 						NT_STATUS_NO_MEMORY);
 			}
 
-			outdyn_v->iov_base = (void *)pad;
-			outdyn_v->iov_len = pad_size;
+			req->out.vector[i+2].iov_base = (void *)pad;
+			req->out.vector[i+2].iov_len = pad_size;
 		} else {
 			/*
 			 * For now we copy the dynamic buffer
@@ -2559,8 +2006,8 @@
 			size_t new_size;
 			uint8_t *new_dyn;
 
-			old_size = SMBD_SMB2_OUT_DYN_LEN(req);
-			old_dyn = SMBD_SMB2_OUT_DYN_PTR(req);
+			old_size = req->out.vector[i+2].iov_len;
+			old_dyn = (uint8_t *)req->out.vector[i+2].iov_base;
 
 			new_size = old_size + pad_size;
 			new_dyn = talloc_zero_array(req->out.vector,
@@ -2573,8 +2020,8 @@
 			memcpy(new_dyn, old_dyn, old_size);
 			memset(new_dyn + old_size, 0, pad_size);
 
-			outdyn_v->iov_base = (void *)new_dyn;
-			outdyn_v->iov_len = new_size;
+			req->out.vector[i+2].iov_base = (void *)new_dyn;
+			req->out.vector[i+2].iov_len = new_size;
 		}
 		next_command_ofs += pad_size;
 	}
@@ -2590,36 +2037,13 @@
 				    const char *location)
 {
 	DATA_BLOB body;
-	uint8_t *outhdr = SMBD_SMB2_OUT_HDR_PTR(req);
-	size_t unread_bytes = smbd_smb2_unread_bytes(req);
+	int i = req->current_idx;
+	uint8_t *outhdr = (uint8_t *)req->out.vector[i].iov_base;
 
 	DEBUG(10,("smbd_smb2_request_error_ex: idx[%d] status[%s] |%s| at %s\n",
-		  req->current_idx, nt_errstr(status), info ? " +info" : "",
+		  i, nt_errstr(status), info ? " +info" : "",
 		  location));
 
-	if (unread_bytes) {
-		/* Recvfile error. Drain incoming socket. */
-		size_t ret;
-
-		errno = 0;
-		ret = drain_socket(req->sconn->sock, unread_bytes);
-		if (ret != unread_bytes) {
-			NTSTATUS error;
-
-			if (errno == 0) {
-				error = NT_STATUS_IO_DEVICE_ERROR;
-			} else {
-				error = map_nt_error_from_unix_common(errno);
-			}
-
-			DEBUG(2, ("Failed to drain %u bytes from SMB2 socket: "
-				  "ret[%u] errno[%d] => %s\n",
-				  (unsigned)unread_bytes,
-				  (unsigned)ret, errno, nt_errstr(error)));
-			return error;
-		}
-	}
-
 	body.data = outhdr + SMB2_HDR_BODY;
 	body.length = 8;
 	SSVAL(body.data, 0, 9);
@@ -2654,64 +2078,34 @@
 
 struct smbd_smb2_send_oplock_break_state {
 	struct smbd_server_connection *sconn;
-	struct smbd_smb2_send_queue queue_entry;
-	uint8_t buf[NBT_HDR_SIZE + SMB2_TF_HDR_SIZE + SMB2_HDR_BODY + 0x18];
-	struct iovec vector[1+SMBD_SMB2_NUM_IOV_PER_REQ];
+	uint8_t buf[4 + SMB2_HDR_BODY + 0x18];
+	struct iovec vector;
 };
 
+static void smbd_smb2_oplock_break_writev_done(struct tevent_req *subreq);
+
 NTSTATUS smbd_smb2_send_oplock_break(struct smbd_server_connection *sconn,
-				     struct smbXsrv_session *session,
-				     struct smbXsrv_tcon *tcon,
-				     struct smbXsrv_open *op,
+				     uint64_t file_id_persistent,
+				     uint64_t file_id_volatile,
 				     uint8_t oplock_level)
 {
 	struct smbd_smb2_send_oplock_break_state *state;
-	struct smbXsrv_connection *conn = sconn->conn;
-	uint8_t *tf;
-	size_t tf_len;
+	struct tevent_req *subreq;
 	uint8_t *hdr;
 	uint8_t *body;
-	size_t body_len;
-	uint8_t *dyn;
-	size_t dyn_len;
-	bool do_encryption = session->global->encryption_required;
-	uint64_t nonce_high = 0;
-	uint64_t nonce_low = 0;
-	NTSTATUS status;
-
-	if (tcon->global->encryption_required) {
-		do_encryption = true;
-	}
 
-	state = talloc_zero(sconn, struct smbd_smb2_send_oplock_break_state);
+	state = talloc(sconn, struct smbd_smb2_send_oplock_break_state);
 	if (state == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
 	state->sconn = sconn;
 
-	tf = state->buf + NBT_HDR_SIZE;
-	tf_len = SMB2_TF_HDR_SIZE;
-	hdr = tf + tf_len;
-	body = hdr + SMB2_HDR_BODY;
-	body_len = 0x18;
-	dyn = body + body_len;
-	dyn_len = 0;
-
-	if (do_encryption) {
-		nonce_high = session->nonce_high;
-		nonce_low = session->nonce_low;
-
-		session->nonce_low += 1;
-		if (session->nonce_low == 0) {
-			session->nonce_low += 1;
-			session->nonce_high += 1;
-		}
-	}
+	state->vector.iov_base = (void *)state->buf;
+	state->vector.iov_len = sizeof(state->buf);
 
-	SIVAL(tf, SMB2_TF_PROTOCOL_ID, SMB2_TF_MAGIC);
-	SBVAL(tf, SMB2_TF_NONCE+0, nonce_low);
-	SBVAL(tf, SMB2_TF_NONCE+8, nonce_high);
-	SBVAL(tf, SMB2_TF_SESSION_ID, session->global->session_wire_id);
+	_smb2_setlen(state->buf, sizeof(state->buf) - 4);
+	hdr = state->buf + 4;
+	body = hdr + SMB2_HDR_BODY;
 
 	SIVAL(hdr, 0,				SMB2_MAGIC);
 	SSVAL(hdr, SMB2_HDR_LENGTH,		SMB2_HDR_BODY);
@@ -2727,137 +2121,433 @@
 	SBVAL(hdr, SMB2_HDR_SESSION_ID,		0);
 	memset(hdr+SMB2_HDR_SIGNATURE, 0, 16);
 
-	SSVAL(body, 0x00, body_len);
+	SSVAL(body, 0x00, 0x18);
 
 	SCVAL(body, 0x02, oplock_level);
 	SCVAL(body, 0x03, 0);		/* reserved */
 	SIVAL(body, 0x04, 0);		/* reserved */
-	SBVAL(body, 0x08, op->global->open_persistent_id);
-	SBVAL(body, 0x10, op->global->open_volatile_id);
-
-	state->vector[0].iov_base = (void *)state->buf;
-	state->vector[0].iov_len = NBT_HDR_SIZE;
+	SBVAL(body, 0x08, file_id_persistent);
+	SBVAL(body, 0x10, file_id_volatile);
 
-	if (do_encryption) {
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_base   = tf;
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_len    = tf_len;
-	} else {
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_base   = NULL;
-		state->vector[1+SMBD_SMB2_TF_IOV_OFS].iov_len    = 0;
+	subreq = tstream_writev_queue_send(state,
+					   sconn->smb2.event_ctx,
+					   sconn->smb2.stream,
+					   sconn->smb2.send_queue,
+					   &state->vector, 1);
+	if (subreq == NULL) {
+		return NT_STATUS_NO_MEMORY;
 	}
+	tevent_req_set_callback(subreq,
+				smbd_smb2_oplock_break_writev_done,
+				state);
+
+	return NT_STATUS_OK;
+}
 
-	state->vector[1+SMBD_SMB2_HDR_IOV_OFS].iov_base  = hdr;
-	state->vector[1+SMBD_SMB2_HDR_IOV_OFS].iov_len   = SMB2_HDR_BODY;
+static void smbd_smb2_oplock_break_writev_done(struct tevent_req *subreq)
+{
+	struct smbd_smb2_send_oplock_break_state *state =
+		tevent_req_callback_data(subreq,
+		struct smbd_smb2_send_oplock_break_state);
+	struct smbd_server_connection *sconn = state->sconn;
+	int ret;
+	int sys_errno;
 
-	state->vector[1+SMBD_SMB2_BODY_IOV_OFS].iov_base = body;
-	state->vector[1+SMBD_SMB2_BODY_IOV_OFS].iov_len  = body_len;
+	ret = tstream_writev_queue_recv(subreq, &sys_errno);
+	TALLOC_FREE(subreq);
+	if (ret == -1) {
+		NTSTATUS status = map_nt_error_from_unix(sys_errno);
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
+	}
 
-	state->vector[1+SMBD_SMB2_DYN_IOV_OFS].iov_base  = dyn;
-	state->vector[1+SMBD_SMB2_DYN_IOV_OFS].iov_len   = dyn_len;
+	TALLOC_FREE(state);
+}
 
-	smb2_setup_nbt_length(state->vector, 1 + SMBD_SMB2_NUM_IOV_PER_REQ);
+struct smbd_smb2_request_read_state {
+	size_t missing;
+	bool asked_for_header;
+	struct smbd_smb2_request *smb2_req;
+};
 
-	if (do_encryption) {
-		DATA_BLOB encryption_key = session->global->encryption_key;
+static int smbd_smb2_request_next_vector(struct tstream_context *stream,
+					 void *private_data,
+					 TALLOC_CTX *mem_ctx,
+					 struct iovec **_vector,
+					 size_t *_count);
+static void smbd_smb2_request_read_done(struct tevent_req *subreq);
+
+static struct tevent_req *smbd_smb2_request_read_send(TALLOC_CTX *mem_ctx,
+					struct tevent_context *ev,
+					struct smbd_server_connection *sconn)
+{
+	struct tevent_req *req;
+	struct smbd_smb2_request_read_state *state;
+	struct tevent_req *subreq;
 
-		status = smb2_signing_encrypt_pdu(encryption_key,
-					conn->protocol,
-					&state->vector[1+SMBD_SMB2_TF_IOV_OFS],
-					SMBD_SMB2_NUM_IOV_PER_REQ);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
+	req = tevent_req_create(mem_ctx, &state,
+				struct smbd_smb2_request_read_state);
+	if (req == NULL) {
+		return NULL;
 	}
+	state->missing = 0;
+	state->asked_for_header = false;
 
-	state->queue_entry.mem_ctx = state;
-	state->queue_entry.vector = state->vector;
-	state->queue_entry.count = ARRAY_SIZE(state->vector);
-	DLIST_ADD_END(state->sconn->smb2.send_queue, &state->queue_entry, NULL);
-	state->sconn->smb2.send_queue_len++;
-
-	status = smbd_smb2_io_handler(sconn, TEVENT_FD_WRITE);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+	state->smb2_req = smbd_smb2_request_allocate(state);
+	if (tevent_req_nomem(state->smb2_req, req)) {
+		return tevent_req_post(req, ev);
+	}
+	state->smb2_req->sconn = sconn;
+
+	subreq = tstream_readv_pdu_queue_send(state, ev, sconn->smb2.stream,
+					      sconn->smb2.recv_queue,
+					      smbd_smb2_request_next_vector,
+					      state);
+	if (tevent_req_nomem(subreq, req)) {
+		return tevent_req_post(req, ev);
 	}
+	tevent_req_set_callback(subreq, smbd_smb2_request_read_done, req);
 
-	return NT_STATUS_OK;
+	return req;
 }
 
-static size_t get_min_receive_file_size(struct smbd_smb2_request *smb2_req)
+static int smbd_smb2_request_next_vector(struct tstream_context *stream,
+					 void *private_data,
+					 TALLOC_CTX *mem_ctx,
+					 struct iovec **_vector,
+					 size_t *_count)
 {
-	if (smb2_req->do_signing) {
-		return 0;
-	}
-	if (smb2_req->do_encryption) {
+	struct smbd_smb2_request_read_state *state =
+		talloc_get_type_abort(private_data,
+		struct smbd_smb2_request_read_state);
+	struct smbd_smb2_request *req = state->smb2_req;
+	struct iovec *vector;
+	int idx = req->in.vector_count;
+	size_t len = 0;
+	uint8_t *buf = NULL;
+
+	if (req->in.vector_count == 0) {
+		/*
+		 * first we need to get the NBT header
+		 */
+		req->in.vector = talloc_array(req, struct iovec,
+					      req->in.vector_count + 1);
+		if (req->in.vector == NULL) {
+			return -1;
+		}
+		req->in.vector_count += 1;
+
+		req->in.vector[idx].iov_base	= (void *)req->in.nbt_hdr;
+		req->in.vector[idx].iov_len	= 4;
+
+		vector = talloc_array(mem_ctx, struct iovec, 1);
+		if (vector == NULL) {
+			return -1;
+		}
+
+		vector[0] = req->in.vector[idx];
+
+		*_vector = vector;
+		*_count = 1;
 		return 0;
 	}
-	return (size_t)lp_min_receive_file_size();
-}
 
-static bool is_smb2_recvfile_write(struct smbd_smb2_request_read_state *state)
-{
-	uint32_t flags;
+	if (req->in.vector_count == 1) {
+		/*
+		 * Now we analyze the NBT header
+		 */
+		state->missing = smb2_len(req->in.vector[0].iov_base);
 
-	if (IVAL(state->pktbuf, 0) == SMB2_TF_MAGIC) {
-		/* Transform header. Cannot recvfile. */
-		return false;
+		if (state->missing == 0) {
+			/* if there're no remaining bytes, we're done */
+			*_vector = NULL;
+			*_count = 0;
+			return 0;
+		}
+
+		req->in.vector = talloc_realloc(req, req->in.vector,
+						struct iovec,
+						req->in.vector_count + 1);
+		if (req->in.vector == NULL) {
+			return -1;
+		}
+		req->in.vector_count += 1;
+
+		if (CVAL(req->in.vector[0].iov_base, 0) != 0) {
+			/*
+			 * it's a special NBT message,
+			 * so get all remaining bytes
+			 */
+			len = state->missing;
+		} else if (state->missing < (SMB2_HDR_BODY + 2)) {
+			/*
+			 * it's an invalid message, just read what we can get
+			 * and let the caller handle the error
+			 */
+			len = state->missing;
+		} else {
+			/*
+			 * We assume it's a SMB2 request,
+			 * and we first get the header and the
+			 * first 2 bytes (the struct size) of the body
+			 */
+			len = SMB2_HDR_BODY + 2;
+
+			state->asked_for_header = true;
+		}
+
+		state->missing -= len;
+
+		buf = talloc_array(req->in.vector, uint8_t, len);
+		if (buf == NULL) {
+			return -1;
+		}
+
+		req->in.vector[idx].iov_base	= (void *)buf;
+		req->in.vector[idx].iov_len	= len;
+
+		vector = talloc_array(mem_ctx, struct iovec, 1);
+		if (vector == NULL) {
+			return -1;
+		}
+
+		vector[0] = req->in.vector[idx];
+
+		*_vector = vector;
+		*_count = 1;
+		return 0;
 	}
-	if (IVAL(state->pktbuf, 0) != SMB2_MAGIC) {
-		/* Not SMB2. Normal error path will cope. */
-		return false;
+
+	if (state->missing == 0) {
+		/* if there're no remaining bytes, we're done */
+		*_vector = NULL;
+		*_count = 0;
+		return 0;
 	}
-	if (SVAL(state->pktbuf, 4) != SMB2_HDR_BODY) {
-		/* Not SMB2. Normal error path will cope. */
-		return false;
+
+	if (state->asked_for_header) {
+		const uint8_t *hdr;
+		size_t full_size;
+		size_t next_command_ofs;
+		size_t body_size;
+		uint8_t *body;
+		size_t dyn_size;
+		uint8_t *dyn;
+		bool invalid = false;
+
+		state->asked_for_header = false;
+
+		/*
+		 * We got the SMB2 header and the first 2 bytes
+		 * of the body. We fix the size to just the header
+		 * and manually copy the 2 first bytes to the body section
+		 */
+		req->in.vector[idx-1].iov_len = SMB2_HDR_BODY;
+		hdr = (const uint8_t *)req->in.vector[idx-1].iov_base;
+
+		/* allocate vectors for body and dynamic areas */
+		req->in.vector = talloc_realloc(req, req->in.vector,
+						struct iovec,
+						req->in.vector_count + 2);
+		if (req->in.vector == NULL) {
+			return -1;
+		}
+		req->in.vector_count += 2;
+
+		full_size = state->missing + SMB2_HDR_BODY + 2;
+		next_command_ofs = IVAL(hdr, SMB2_HDR_NEXT_COMMAND);
+		body_size = SVAL(hdr, SMB2_HDR_BODY);
+
+		if (next_command_ofs != 0) {
+			if (next_command_ofs < (SMB2_HDR_BODY + 2)) {
+				/*
+				 * this is invalid, just return a zero
+				 * body and let the caller deal with the error
+				 */
+				invalid = true;
+			} else if (next_command_ofs > full_size) {
+				/*
+				 * this is invalid, just return a zero
+				 * body and let the caller deal with the error
+				 */
+				invalid = true;
+			} else {
+				full_size = next_command_ofs;
+			}
+		}
+
+		if (!invalid) {
+			if (body_size < 2) {
+				/*
+				 * this is invalid, just return a zero
+				 * body and let the caller deal with the error
+				 */
+				invalid = true;
+			}
+
+			if ((body_size % 2) != 0) {
+				body_size -= 1;
+			}
+
+			if (body_size > (full_size - SMB2_HDR_BODY)) {
+				/*
+				 * this is invalid, just return a zero
+				 * body and let the caller deal with the error
+				 */
+				invalid = true;
+			}
+		}
+
+		if (invalid) {
+			/* the caller should check this */
+			body_size = 2;
+		}
+
+		dyn_size = full_size - (SMB2_HDR_BODY + body_size);
+
+		state->missing -= (body_size - 2) + dyn_size;
+
+		body = talloc_array(req->in.vector, uint8_t, body_size);
+		if (body == NULL) {
+			return -1;
+		}
+
+		dyn = talloc_array(req->in.vector, uint8_t, dyn_size);
+		if (dyn == NULL) {
+			return -1;
+		}
+
+		req->in.vector[idx].iov_base	= (void *)body;
+		req->in.vector[idx].iov_len	= body_size;
+		req->in.vector[idx+1].iov_base	= (void *)dyn;
+		req->in.vector[idx+1].iov_len	= dyn_size;
+
+		vector = talloc_array(mem_ctx, struct iovec, 2);
+		if (vector == NULL) {
+			return -1;
+		}
+
+		/*
+		 * the first 2 bytes of the body were already fetched
+		 * together with the header
+		 */
+		memcpy(body, hdr + SMB2_HDR_BODY, 2);
+		vector[0].iov_base = body + 2;
+		vector[0].iov_len = body_size - 2;
+
+		vector[1] = req->in.vector[idx+1];
+
+		*_vector = vector;
+		*_count = 2;
+		return 0;
 	}
-	if (SVAL(state->pktbuf, SMB2_HDR_OPCODE) != SMB2_OP_WRITE) {
-		/* Needs to be a WRITE. */
-		return false;
+
+	/*
+	 * when we endup here, we're looking for a new SMB2 request
+	 * next. And we ask for its header and the first 2 bytes of
+	 * the body (like we did for the first SMB2 request).
+	 */
+
+	req->in.vector = talloc_realloc(req, req->in.vector,
+					struct iovec,
+					req->in.vector_count + 1);
+	if (req->in.vector == NULL) {
+		return -1;
 	}
-	if (IVAL(state->pktbuf, SMB2_HDR_NEXT_COMMAND) != 0) {
-		/* Chained. Cannot recvfile. */
-		return false;
+	req->in.vector_count += 1;
+
+	/*
+	 * We assume it's a SMB2 request,
+	 * and we first get the header and the
+	 * first 2 bytes (the struct size) of the body
+	 */
+	len = SMB2_HDR_BODY + 2;
+
+	if (len > state->missing) {
+		/* let the caller handle the error */
+		len = state->missing;
 	}
-	flags = IVAL(state->pktbuf, SMB2_HDR_FLAGS);
-	if (flags & SMB2_HDR_FLAG_CHAINED) {
-		/* Chained. Cannot recvfile. */
-		return false;
+
+	state->missing -= len;
+	state->asked_for_header = true;
+
+	buf = talloc_array(req->in.vector, uint8_t, len);
+	if (buf == NULL) {
+		return -1;
 	}
-	if (flags & SMB2_HDR_FLAG_SIGNED) {
-		/* Signed. Cannot recvfile. */
-		return false;
+
+	req->in.vector[idx].iov_base	= (void *)buf;
+	req->in.vector[idx].iov_len	= len;
+
+	vector = talloc_array(mem_ctx, struct iovec, 1);
+	if (vector == NULL) {
+		return -1;
 	}
 
-	DEBUG(10,("Doing recvfile write len = %u\n",
-		(unsigned int)(state->pktlen -
-		SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN)));
+	vector[0] = req->in.vector[idx];
 
-	return true;
+	*_vector = vector;
+	*_count = 1;
+	return 0;
+}
+
+static void smbd_smb2_request_read_done(struct tevent_req *subreq)
+{
+	struct tevent_req *req =
+		tevent_req_callback_data(subreq,
+		struct tevent_req);
+	int ret;
+	int sys_errno;
+	NTSTATUS status;
+
+	ret = tstream_readv_pdu_queue_recv(subreq, &sys_errno);
+	if (ret == -1) {
+		status = map_nt_error_from_unix(sys_errno);
+		tevent_req_nterror(req, status);
+		return;
+	}
+
+	tevent_req_done(req);
 }
 
+static NTSTATUS smbd_smb2_request_read_recv(struct tevent_req *req,
+					    TALLOC_CTX *mem_ctx,
+					    struct smbd_smb2_request **_smb2_req)
+{
+	struct smbd_smb2_request_read_state *state =
+		tevent_req_data(req,
+		struct smbd_smb2_request_read_state);
+	NTSTATUS status;
+
+	if (tevent_req_is_nterror(req, &status)) {
+		tevent_req_received(req);
+		return status;
+	}
+
+	talloc_steal(mem_ctx, state->smb2_req->mem_pool);
+	*_smb2_req = state->smb2_req;
+	tevent_req_received(req);
+	return NT_STATUS_OK;
+}
+
+static void smbd_smb2_request_incoming(struct tevent_req *subreq);
+
 static NTSTATUS smbd_smb2_request_next_incoming(struct smbd_server_connection *sconn)
 {
-	struct smbd_smb2_request_read_state *state = &sconn->smb2.request_read_state;
 	size_t max_send_queue_len;
 	size_t cur_send_queue_len;
+	struct tevent_req *subreq;
 
-	if (!NT_STATUS_IS_OK(sconn->status)) {
+	if (tevent_queue_length(sconn->smb2.recv_queue) > 0) {
 		/*
-		 * we're not supposed to do any io
-		 */
-		return NT_STATUS_OK;
-	}
-
-	if (state->req != NULL) {
-		/*
-		 * if there is already a tstream_readv_pdu
+		 * if there is already a smbd_smb2_request_read
 		 * pending, we are done.
 		 */
 		return NT_STATUS_OK;
 	}
 
 	max_send_queue_len = MAX(1, sconn->smb2.max_credits/16);
-	cur_send_queue_len = sconn->smb2.send_queue_len;
+	cur_send_queue_len = tevent_queue_length(sconn->smb2.send_queue);
 
 	if (cur_send_queue_len > max_send_queue_len) {
 		/*
@@ -2869,21 +2559,17 @@
 	}
 
 	/* ask for the next request */
-	ZERO_STRUCTP(state);
-	state->req = smbd_smb2_request_allocate(sconn);
-	if (state->req == NULL) {
+	subreq = smbd_smb2_request_read_send(sconn, sconn->smb2.event_ctx, sconn);
+	if (subreq == NULL) {
 		return NT_STATUS_NO_MEMORY;
 	}
-	state->req->sconn = sconn;
-	state->min_recv_size = get_min_receive_file_size(state->req);
-
-	TEVENT_FD_READABLE(sconn->smb2.fde);
+	tevent_req_set_callback(subreq, smbd_smb2_request_incoming, sconn);
 
 	return NT_STATUS_OK;
 }
 
 void smbd_smb2_first_negprot(struct smbd_server_connection *sconn,
-			     uint8_t *inbuf, size_t size)
+			     const uint8_t *inbuf, size_t size)
 {
 	NTSTATUS status;
 	struct smbd_smb2_request *req = NULL;
@@ -2930,345 +2616,57 @@
 	sconn->num_requests++;
 }
 
-static int socket_error_from_errno(int ret,
-				   int sys_errno,
-				   bool *retry)
-{
-	*retry = false;
-
-	if (ret >= 0) {
-		return 0;
-	}
-
-	if (ret != -1) {
-		return EIO;
-	}
-
-	if (sys_errno == 0) {
-		return EIO;
-	}
-
-	if (sys_errno == EINTR) {
-		*retry = true;
-		return sys_errno;
-	}
-
-	if (sys_errno == EINPROGRESS) {
-		*retry = true;
-		return sys_errno;
-	}
-
-	if (sys_errno == EAGAIN) {
-		*retry = true;
-		return sys_errno;
-	}
-
-	/* ENOMEM is retryable on Solaris/illumos, and possibly other systems. */
-	if (sys_errno == ENOMEM) {
-		*retry = true;
-		return sys_errno;
-	}
-
-#ifdef EWOULDBLOCK
-	if (sys_errno == EWOULDBLOCK) {
-		*retry = true;
-		return sys_errno;
-	}
-#endif
-
-	return sys_errno;
-}
-
-static NTSTATUS smbd_smb2_flush_send_queue(struct smbd_server_connection *sconn)
-{
-	int ret;
-	int err;
-	bool retry;
-
-	if (sconn->smb2.send_queue == NULL) {
-		TEVENT_FD_NOT_WRITEABLE(sconn->smb2.fde);
-		return NT_STATUS_OK;
-	}
-
-	while (sconn->smb2.send_queue != NULL) {
-		struct smbd_smb2_send_queue *e = sconn->smb2.send_queue;
-
-		if (e->sendfile_header != NULL) {
-			size_t size = 0;
-			size_t i = 0;
-			uint8_t *buf;
-
-			for (i=0; i < e->count; i++) {
-				size += e->vector[i].iov_len;
-			}
-
-			buf = talloc_array(e->mem_ctx, uint8_t, size);
-			if (buf == NULL) {
-				return NT_STATUS_NO_MEMORY;
-			}
-
-			size = 0;
-			for (i=0; i < e->count; i++) {
-				memcpy(buf+size,
-				       e->vector[i].iov_base,
-				       e->vector[i].iov_len);
-				size += e->vector[i].iov_len;
-			}
-
-			e->sendfile_header->data = buf;
-			e->sendfile_header->length = size;
-			e->count = 0;
-
-			sconn->smb2.send_queue_len--;
-			DLIST_REMOVE(sconn->smb2.send_queue, e);
-			talloc_free(e->mem_ctx);
-			continue;
-		}
-
-		ret = writev(sconn->sock, e->vector, e->count);
-		if (ret == 0) {
-			/* propagate end of file */
-			return NT_STATUS_INTERNAL_ERROR;
-		}
-		err = socket_error_from_errno(ret, errno, &retry);
-		if (retry) {
-			/* retry later */
-			TEVENT_FD_WRITEABLE(sconn->smb2.fde);
-			return NT_STATUS_OK;
-		}
-		if (err != 0) {
-			return map_nt_error_from_unix_common(err);
-		}
-		while (ret > 0) {
-			if (ret < e->vector[0].iov_len) {
-				uint8_t *base;
-				base = (uint8_t *)e->vector[0].iov_base;
-				base += ret;
-				e->vector[0].iov_base = (void *)base;
-				e->vector[0].iov_len -= ret;
-				break;
-			}
-			ret -= e->vector[0].iov_len;
-			e->vector += 1;
-			e->count -= 1;
-		}
-
-		/*
-		 * there're maybe some empty vectors at the end
-		 * which we need to skip, otherwise we would get
-		 * ret == 0 from the readv() call and return EPIPE
-		 */
-		while (e->count > 0) {
-			if (e->vector[0].iov_len > 0) {
-				break;
-			}
-			e->vector += 1;
-			e->count -= 1;
-		}
-
-		if (e->count > 0) {
-			/* we have more to write */
-			TEVENT_FD_WRITEABLE(sconn->smb2.fde);
-			return NT_STATUS_OK;
-		}
-
-		sconn->smb2.send_queue_len--;
-		DLIST_REMOVE(sconn->smb2.send_queue, e);
-		talloc_free(e->mem_ctx);
-	}
-
-	return NT_STATUS_OK;
-}
-
-static NTSTATUS smbd_smb2_io_handler(struct smbd_server_connection *sconn,
-				     uint16_t fde_flags)
+static void smbd_smb2_request_incoming(struct tevent_req *subreq)
 {
-	struct smbd_smb2_request_read_state *state = &sconn->smb2.request_read_state;
-	struct smbd_smb2_request *req = NULL;
-	size_t min_recvfile_size = UINT32_MAX;
-	int ret;
-	int err;
-	bool retry;
+	struct smbd_server_connection *sconn = tevent_req_callback_data(subreq,
+					       struct smbd_server_connection);
 	NTSTATUS status;
-	NTTIME now;
-
-	if (!NT_STATUS_IS_OK(sconn->status)) {
-		/*
-		 * we're not supposed to do any io
-		 */
-		TEVENT_FD_NOT_READABLE(sconn->smb2.fde);
-		TEVENT_FD_NOT_WRITEABLE(sconn->smb2.fde);
-		return NT_STATUS_OK;
-	}
-
-	if (fde_flags & TEVENT_FD_WRITE) {
-		status = smbd_smb2_flush_send_queue(sconn);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	}
-
-	if (!(fde_flags & TEVENT_FD_READ)) {
-		return NT_STATUS_OK;
-	}
-
-	if (state->req == NULL) {
-		TEVENT_FD_NOT_READABLE(sconn->smb2.fde);
-		return NT_STATUS_OK;
-	}
-
-again:
-	if (!state->hdr.done) {
-		state->hdr.done = true;
-
-		state->vector.iov_base = (void *)state->hdr.nbt;
-		state->vector.iov_len = NBT_HDR_SIZE;
-	}
-
-	ret = readv(sconn->sock, &state->vector, 1);
-	if (ret == 0) {
-		/* propagate end of file */
-		return NT_STATUS_END_OF_FILE;
-	}
-	err = socket_error_from_errno(ret, errno, &retry);
-	if (retry) {
-		/* retry later */
-		TEVENT_FD_READABLE(sconn->smb2.fde);
-		return NT_STATUS_OK;
-	}
-	if (err != 0) {
-		return map_nt_error_from_unix_common(err);
-	}
-
-	if (ret < state->vector.iov_len) {
-		uint8_t *base;
-		base = (uint8_t *)state->vector.iov_base;
-		base += ret;
-		state->vector.iov_base = (void *)base;
-		state->vector.iov_len -= ret;
-		/* we have more to read */
-		TEVENT_FD_READABLE(sconn->smb2.fde);
-		return NT_STATUS_OK;
-	}
-
-	if (state->pktlen > 0) {
-		if (state->doing_receivefile && !is_smb2_recvfile_write(state)) {
-			/*
-			 * Not a possible receivefile write.
-			 * Read the rest of the data.
-			 */
-			state->doing_receivefile = false;
-			state->vector.iov_base = (void *)(state->pktbuf +
-				SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN);
-			state->vector.iov_len = (state->pktlen -
-				SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN);
-			goto again;
-		}
-
-		/*
-		 * Either this is a receivefile write so we've
-		 * done a short read, or if not we have all the data.
-		 */
-		goto got_full;
-	}
-
-	/*
-	 * Now we analyze the NBT header
-	 */
-	state->pktlen = smb2_len(state->hdr.nbt);
-	if (state->pktlen == 0) {
-		goto got_full;
-	}
-
-	state->pktbuf = talloc_array(state->req, uint8_t, state->pktlen);
-	if (state->pktbuf == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-
-	state->vector.iov_base = (void *)state->pktbuf;
-
-	if (state->min_recv_size != 0) {
-		min_recvfile_size = SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN;
-		min_recvfile_size += state->min_recv_size;
-	}
-
-	if (state->pktlen > min_recvfile_size) {
-		/*
-		 * Might be a receivefile write. Read the SMB2 HEADER +
-		 * SMB2_WRITE header first. Set 'doing_receivefile'
-		 * as we're *attempting* receivefile write. If this
-		 * turns out not to be a SMB2_WRITE request or otherwise
-		 * not suitable then we'll just read the rest of the data
-		 * the next time this function is called.
-		 */
-		state->vector.iov_len = SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN;
-		state->doing_receivefile = true;
-	} else {
-		state->vector.iov_len = state->pktlen;
-	}
-
-	goto again;
-
-got_full:
-
-	if (state->hdr.nbt[0] != 0x00) {
-		DEBUG(1,("ignore NBT[0x%02X] msg\n",
-			 state->hdr.nbt[0]));
-
-		req = state->req;
-		ZERO_STRUCTP(state);
-		state->req = req;
-		state->min_recv_size = get_min_receive_file_size(state->req);
-		req = NULL;
-		goto again;
-	}
-
-	req = state->req;
-	state->req = NULL;
-
-	req->request_time = timeval_current();
-	now = timeval_to_nttime(&req->request_time);
+	struct smbd_smb2_request *req = NULL;
 
-	status = smbd_smb2_inbuf_parse_compound(req->sconn->conn,
-						now,
-						state->pktbuf,
-						state->pktlen,
-						req,
-						&req->in.vector,
-						&req->in.vector_count);
+	status = smbd_smb2_request_read_recv(subreq, sconn, &req);
+	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+		DEBUG(2,("smbd_smb2_request_incoming: client read error %s\n",
+			nt_errstr(status)));
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
 	}
 
-	if (state->doing_receivefile) {
-		req->smb1req = talloc_zero(req, struct smb_request);
-		if (req->smb1req == NULL) {
-			return NT_STATUS_NO_MEMORY;
-		}
-		req->smb1req->unread_bytes =
-			state->pktlen - SMBD_SMB2_SHORT_RECEIVEFILE_WRITE_LEN;
+	if (req->in.nbt_hdr[0] != 0x00) {
+		DEBUG(1,("smbd_smb2_request_incoming: ignore NBT[0x%02X] msg\n",
+			 req->in.nbt_hdr[0]));
+		TALLOC_FREE(req);
+		goto next;
 	}
 
-	ZERO_STRUCTP(state);
-
 	req->current_idx = 1;
 
-	DEBUG(10,("smbd_smb2_request idx[%d] of %d vectors\n",
+	DEBUG(10,("smbd_smb2_request_incoming: idx[%d] of %d vectors\n",
 		 req->current_idx, req->in.vector_count));
 
 	status = smbd_smb2_request_validate(req);
 	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
 	}
 
 	status = smbd_smb2_request_setup_out(req);
 	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
 	}
 
 	status = smbd_smb2_request_dispatch(req);
 	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
+	}
+
+next:
+	status = smbd_smb2_request_next_incoming(sconn);
+	if (!NT_STATUS_IS_OK(status)) {
+		smbd_server_connection_terminate(sconn, nt_errstr(status));
+		return;
 	}
 
 	sconn->num_requests++;
@@ -3285,28 +2683,4 @@
 		change_to_root_user();
 		check_log_size();
 	}
-
-	status = smbd_smb2_request_next_incoming(sconn);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
-	return NT_STATUS_OK;
-}
-
-static void smbd_smb2_connection_handler(struct tevent_context *ev,
-					 struct tevent_fd *fde,
-					 uint16_t flags,
-					 void *private_data)
-{
-	struct smbd_server_connection *sconn =
-		talloc_get_type_abort(private_data,
-		struct smbd_server_connection);
-	NTSTATUS status;
-
-	status = smbd_smb2_io_handler(sconn, flags);
-	if (!NT_STATUS_IS_OK(status)) {
-		smbd_server_connection_terminate(sconn, nt_errstr(status));
-		return;
-	}
 }
Only in ../../samba-3.6.24/source3/smbd: smb2_server.o
diff -ur smbd/smb2_sesssetup.c ../../samba-3.6.24/source3/smbd/smb2_sesssetup.c
--- smbd/smb2_sesssetup.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_sesssetup.c	2015-01-28 10:52:25.149068676 +0800
@@ -23,133 +23,84 @@
 #include "smbd/smbd.h"
 #include "smbd/globals.h"
 #include "../libcli/smb/smb_common.h"
-#include "../auth/gensec/gensec.h"
+#include "../libcli/auth/spnego.h"
+#include "../libcli/auth/ntlmssp.h"
+#include "ntlmssp_wrap.h"
+#include "../librpc/gen_ndr/krb5pac.h"
+#include "libads/kerberos_proto.h"
+#include "../lib/util/asn1.h"
 #include "auth.h"
-#include "../lib/tsocket/tsocket.h"
-#include "../libcli/security/security.h"
-#include "../lib/util/tevent_ntstatus.h"
-#include "lib/smbd_tevent_queue.h"
 
-static struct tevent_req *smbd_smb2_session_setup_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req,
+static NTSTATUS smbd_smb2_session_setup(struct smbd_smb2_request *smb2req,
 					uint64_t in_session_id,
-					uint8_t in_flags,
 					uint8_t in_security_mode,
-					uint64_t in_previous_session_id,
-					DATA_BLOB in_security_buffer);
-static NTSTATUS smbd_smb2_session_setup_recv(struct tevent_req *req,
+					DATA_BLOB in_security_buffer,
 					uint16_t *out_session_flags,
-					TALLOC_CTX *mem_ctx,
 					DATA_BLOB *out_security_buffer,
 					uint64_t *out_session_id);
 
-static void smbd_smb2_request_sesssetup_done(struct tevent_req *subreq);
-
 NTSTATUS smbd_smb2_request_process_sesssetup(struct smbd_smb2_request *smb2req)
 {
 	const uint8_t *inhdr;
 	const uint8_t *inbody;
+	int i = smb2req->current_idx;
+	uint8_t *outhdr;
+	DATA_BLOB outbody;
+	DATA_BLOB outdyn;
 	uint64_t in_session_id;
-	uint8_t in_flags;
 	uint8_t in_security_mode;
-	uint64_t in_previous_session_id;
 	uint16_t in_security_offset;
 	uint16_t in_security_length;
 	DATA_BLOB in_security_buffer;
+	uint16_t out_session_flags;
+	uint64_t out_session_id;
+	uint16_t out_security_offset;
+	DATA_BLOB out_security_buffer = data_blob_null;
 	NTSTATUS status;
-	struct tevent_req *subreq;
 
 	status = smbd_smb2_request_verify_sizes(smb2req, 0x19);
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(smb2req, status);
 	}
-	inhdr = SMBD_SMB2_IN_HDR_PTR(smb2req);
-	inbody = SMBD_SMB2_IN_BODY_PTR(smb2req);
+	inhdr = (const uint8_t *)smb2req->in.vector[i+0].iov_base;
+	inbody = (const uint8_t *)smb2req->in.vector[i+1].iov_base;
 
-	in_session_id = BVAL(inhdr, SMB2_HDR_SESSION_ID);
-
-	in_flags = CVAL(inbody, 0x02);
-	in_security_mode = CVAL(inbody, 0x03);
-	/* Capabilities = IVAL(inbody, 0x04) */
-	/* Channel = IVAL(inbody, 0x08) */
 	in_security_offset = SVAL(inbody, 0x0C);
 	in_security_length = SVAL(inbody, 0x0E);
-	in_previous_session_id = BVAL(inbody, 0x10);
 
-	if (in_security_offset != (SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(smb2req))) {
+	if (in_security_offset != (SMB2_HDR_BODY + smb2req->in.vector[i+1].iov_len)) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (in_security_length > SMBD_SMB2_IN_DYN_LEN(smb2req)) {
+	if (in_security_length > smb2req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(smb2req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_security_buffer.data = SMBD_SMB2_IN_DYN_PTR(smb2req);
+	in_session_id = BVAL(inhdr, SMB2_HDR_SESSION_ID);
+	in_security_mode = CVAL(inbody, 0x03);
+	in_security_buffer.data = (uint8_t *)smb2req->in.vector[i+2].iov_base;
 	in_security_buffer.length = in_security_length;
 
-	subreq = smbd_smb2_session_setup_send(smb2req,
-					      smb2req->sconn->ev_ctx,
-					      smb2req,
-					      in_session_id,
-					      in_flags,
-					      in_security_mode,
-					      in_previous_session_id,
-					      in_security_buffer);
-	if (subreq == NULL) {
-		return smbd_smb2_request_error(smb2req, NT_STATUS_NO_MEMORY);
-	}
-	tevent_req_set_callback(subreq, smbd_smb2_request_sesssetup_done, smb2req);
-
-	return smbd_smb2_request_pending_queue(smb2req, subreq, 500);
-}
-
-static void smbd_smb2_request_sesssetup_done(struct tevent_req *subreq)
-{
-	struct smbd_smb2_request *smb2req =
-		tevent_req_callback_data(subreq,
-		struct smbd_smb2_request);
-	uint8_t *outhdr;
-	DATA_BLOB outbody;
-	DATA_BLOB outdyn;
-	uint16_t out_session_flags;
-	uint64_t out_session_id;
-	uint16_t out_security_offset;
-	DATA_BLOB out_security_buffer = data_blob_null;
-	NTSTATUS status;
-	NTSTATUS error; /* transport error */
-
-	status = smbd_smb2_session_setup_recv(subreq,
-					      &out_session_flags,
-					      smb2req,
-					      &out_security_buffer,
-					      &out_session_id);
-	TALLOC_FREE(subreq);
+	status = smbd_smb2_session_setup(smb2req,
+					 in_session_id,
+					 in_security_mode,
+					 in_security_buffer,
+					 &out_session_flags,
+					 &out_security_buffer,
+					 &out_session_id);
 	if (!NT_STATUS_IS_OK(status) &&
 	    !NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
 		status = nt_status_squash(status);
-		error = smbd_smb2_request_error(smb2req, status);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(smb2req->sconn,
-							 nt_errstr(error));
-			return;
-		}
-		return;
+		return smbd_smb2_request_error(smb2req, status);
 	}
 
 	out_security_offset = SMB2_HDR_BODY + 0x08;
 
-	outhdr = SMBD_SMB2_OUT_HDR_PTR(smb2req);
+	outhdr = (uint8_t *)smb2req->out.vector[i].iov_base;
 
 	outbody = data_blob_talloc(smb2req->out.vector, NULL, 0x08);
 	if (outbody.data == NULL) {
-		error = smbd_smb2_request_error(smb2req, NT_STATUS_NO_MEMORY);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(smb2req->sconn,
-							 nt_errstr(error));
-			return;
-		}
-		return;
+		return smbd_smb2_request_error(smb2req, NT_STATUS_NO_MEMORY);
 	}
 
 	SBVAL(outhdr, SMB2_HDR_SESSION_ID, out_session_id);
@@ -164,200 +115,202 @@
 
 	outdyn = out_security_buffer;
 
-	error = smbd_smb2_request_done_ex(smb2req, status, outbody, &outdyn,
-					   __location__);
-	if (!NT_STATUS_IS_OK(error)) {
-		smbd_server_connection_terminate(smb2req->sconn,
-						 nt_errstr(error));
-		return;
+	return smbd_smb2_request_done_ex(smb2req, status, outbody, &outdyn,
+					 __location__);
+}
+
+static int smbd_smb2_session_destructor(struct smbd_smb2_session *session)
+{
+	if (session->sconn == NULL) {
+		return 0;
+	}
+
+	/* first free all tcons */
+	while (session->tcons.list) {
+		talloc_free(session->tcons.list);
+	}
+
+	idr_remove(session->sconn->smb2.sessions.idtree, session->vuid);
+	DLIST_REMOVE(session->sconn->smb2.sessions.list, session);
+	invalidate_vuid(session->sconn, session->vuid);
+
+	session->vuid = 0;
+	session->status = NT_STATUS_USER_SESSION_DELETED;
+	session->sconn = NULL;
+
+	return 0;
+}
+
+static NTSTATUS setup_ntlmssp_session_info(struct smbd_smb2_session *session,
+				NTSTATUS status)
+{
+	if (NT_STATUS_IS_OK(status)) {
+		status = auth_ntlmssp_steal_session_info(session,
+				session->auth_ntlmssp_state,
+				&session->session_info);
+	} else {
+		/* Note that this session_info won't have a session
+		 * key.  But for map to guest, that's exactly the right
+		 * thing - we can't reasonably guess the key the
+		 * client wants, as the password was wrong */
+		status = do_map_to_guest(status,
+			&session->session_info,
+			auth_ntlmssp_get_username(session->auth_ntlmssp_state),
+			auth_ntlmssp_get_domain(session->auth_ntlmssp_state));
 	}
+	return status;
 }
 
-static NTSTATUS smbd_smb2_auth_generic_return(struct smbXsrv_session *session,
+#ifdef HAVE_KRB5
+static NTSTATUS smbd_smb2_session_setup_krb5(struct smbd_smb2_session *session,
 					struct smbd_smb2_request *smb2req,
 					uint8_t in_security_mode,
-					struct auth_session_info *session_info,
+					const DATA_BLOB *secblob,
+					const char *mechOID,
 					uint16_t *out_session_flags,
+					DATA_BLOB *out_security_buffer,
 					uint64_t *out_session_id)
 {
-	NTSTATUS status;
+	DATA_BLOB ap_rep = data_blob_null;
+	DATA_BLOB ap_rep_wrapped = data_blob_null;
+	DATA_BLOB ticket = data_blob_null;
+	DATA_BLOB session_key = data_blob_null;
+	DATA_BLOB secblob_out = data_blob_null;
+	uint8 tok_id[2];
+	struct PAC_LOGON_INFO *logon_info = NULL;
+	char *principal = NULL;
+	char *user = NULL;
+	char *domain = NULL;
+	struct passwd *pw = NULL;
+	NTSTATUS status;
+	char *real_username;
+	fstring tmp;
+	bool username_was_mapped = false;
+	bool map_domainuser_to_guest = false;
 	bool guest = false;
-	uint8_t session_key[16];
-	struct smbXsrv_session *x = session;
-	struct smbXsrv_connection *conn = session->connection;
 
-	if ((in_security_mode & SMB2_NEGOTIATE_SIGNING_REQUIRED) ||
-	    lp_server_signing() == SMB_SIGNING_REQUIRED) {
-		x->global->signing_required = true;
+	if (!spnego_parse_krb5_wrap(talloc_tos(), *secblob, &ticket, tok_id)) {
+		status = NT_STATUS_LOGON_FAILURE;
+		goto fail;
 	}
 
-	if (lp_smb_encrypt(-1) == SMB_SIGNING_REQUIRED) {
-		x->global->encryption_required = true;
-	}
+	status = ads_verify_ticket(smb2req, lp_realm(), 0, &ticket,
+				   &principal, &logon_info, &ap_rep,
+				   &session_key, true);
 
-	if (security_session_user_level(session_info, NULL) < SECURITY_USER) {
-		/* we map anonymous to guest internally */
-		*out_session_flags |= SMB2_SESSION_FLAG_IS_GUEST;
-		*out_session_flags |= SMB2_SESSION_FLAG_IS_NULL;
-		/* force no signing */
-		x->global->signing_required = false;
-		guest = true;
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(1,("smb2: Failed to verify incoming ticket with error %s!\n",
+			nt_errstr(status)));
+		if (!NT_STATUS_EQUAL(status, NT_STATUS_TIME_DIFFERENCE_AT_DC)) {
+			status = NT_STATUS_LOGON_FAILURE;
+		}
+		goto fail;
 	}
 
-	if (guest && x->global->encryption_required) {
-		DEBUG(1,("reject guest session as encryption is required\n"));
-		return NT_STATUS_ACCESS_DENIED;
+	status = get_user_from_kerberos_info(talloc_tos(),
+					     smb2req->sconn->client_id.name,
+					     principal, logon_info,
+					     &username_was_mapped,
+					     &map_domainuser_to_guest,
+					     &user, &domain,
+					     &real_username, &pw);
+	if (!NT_STATUS_IS_OK(status)) {
+		goto fail;
 	}
 
-	if (!(conn->smb2.server.capabilities & SMB2_CAP_ENCRYPTION)) {
-		if (x->global->encryption_required) {
-			DEBUG(1,("reject session with dialect[0x%04X] "
-				 "as encryption is required\n",
-				 conn->smb2.server.dialect));
-			return NT_STATUS_ACCESS_DENIED;
-		}
+	/* save the PAC data if we have it */
+	if (logon_info) {
+		netsamlogon_cache_store(user, &logon_info->info3);
 	}
 
-	if (x->global->encryption_required) {
-		*out_session_flags |= SMB2_SESSION_FLAG_ENCRYPT_DATA;
-	}
+	/* setup the string used by %U */
+	sub_set_smb_name(real_username);
 
-	ZERO_STRUCT(session_key);
-	memcpy(session_key, session_info->session_key.data,
-	       MIN(session_info->session_key.length, sizeof(session_key)));
+	/* reload services so that the new %U is taken into account */
+	reload_services(smb2req->sconn->msg_ctx, smb2req->sconn->sock, true);
 
-	x->global->signing_key = data_blob_talloc(x->global,
-						  session_key,
-						  sizeof(session_key));
-	if (x->global->signing_key.data == NULL) {
-		ZERO_STRUCT(session_key);
-		return NT_STATUS_NO_MEMORY;
+	status = make_server_info_krb5(session,
+					user, domain, real_username, pw,
+					logon_info, map_domainuser_to_guest,
+					&session->session_info);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(1, ("smb2: make_server_info_krb5 failed\n"));
+		goto fail;
 	}
 
-	if (conn->protocol >= PROTOCOL_SMB2_24) {
-		const DATA_BLOB label = data_blob_string_const_null("SMB2AESCMAC");
-		const DATA_BLOB context = data_blob_string_const_null("SmbSign");
-
-		smb2_key_derivation(session_key, sizeof(session_key),
-				    label.data, label.length,
-				    context.data, context.length,
-				    x->global->signing_key.data);
-	}
-
-	if (conn->protocol >= PROTOCOL_SMB2_24) {
-		const DATA_BLOB label = data_blob_string_const_null("SMB2AESCCM");
-		const DATA_BLOB context = data_blob_string_const_null("ServerIn ");
-
-		x->global->decryption_key = data_blob_talloc(x->global,
-							     session_key,
-							     sizeof(session_key));
-		if (x->global->decryption_key.data == NULL) {
-			ZERO_STRUCT(session_key);
-			return NT_STATUS_NO_MEMORY;
-		}
-
-		smb2_key_derivation(session_key, sizeof(session_key),
-				    label.data, label.length,
-				    context.data, context.length,
-				    x->global->decryption_key.data);
-	}
 
-	if (conn->protocol >= PROTOCOL_SMB2_24) {
-		const DATA_BLOB label = data_blob_string_const_null("SMB2AESCCM");
-		const DATA_BLOB context = data_blob_string_const_null("ServerOut");
-
-		x->global->encryption_key = data_blob_talloc(x->global,
-							     session_key,
-							     sizeof(session_key));
-		if (x->global->encryption_key.data == NULL) {
-			ZERO_STRUCT(session_key);
-			return NT_STATUS_NO_MEMORY;
-		}
+	session->session_info->nss_token |= username_was_mapped;
 
-		smb2_key_derivation(session_key, sizeof(session_key),
-				    label.data, label.length,
-				    context.data, context.length,
-				    x->global->encryption_key.data);
-
-		generate_random_buffer((uint8_t *)&x->nonce_high, sizeof(x->nonce_high));
-		x->nonce_low = 1;
-	}
+	/* we need to build the token for the user. make_session_info_guest()
+	   already does this */
 
-	x->global->application_key = data_blob_dup_talloc(x->global,
-						x->global->signing_key);
-	if (x->global->application_key.data == NULL) {
-		ZERO_STRUCT(session_key);
-		return NT_STATUS_NO_MEMORY;
+	if (!session->session_info->security_token ) {
+		status = create_local_token(session->session_info);
+		if (!NT_STATUS_IS_OK(status)) {
+			DEBUG(10,("smb2: failed to create local token: %s\n",
+				nt_errstr(status)));
+			goto fail;
+		}
 	}
 
-	if (conn->protocol >= PROTOCOL_SMB2_24) {
-		const DATA_BLOB label = data_blob_string_const_null("SMB2APP");
-		const DATA_BLOB context = data_blob_string_const_null("SmbRpc");
-
-		smb2_key_derivation(session_key, sizeof(session_key),
-				    label.data, label.length,
-				    context.data, context.length,
-				    x->global->application_key.data);
-	}
-	ZERO_STRUCT(session_key);
-
-	x->global->channels[0].signing_key = data_blob_dup_talloc(x->global->channels,
-						x->global->signing_key);
-	if (x->global->channels[0].signing_key.data == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	if ((in_security_mode & SMB2_NEGOTIATE_SIGNING_REQUIRED) ||
+	     lp_server_signing() == Required) {
+		session->do_signing = true;
 	}
 
-	data_blob_clear_free(&session_info->session_key);
-	session_info->session_key = data_blob_dup_talloc(session_info,
-						x->global->application_key);
-	if (session_info->session_key.data == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	if (session->session_info->guest) {
+		/* we map anonymous to guest internally */
+		*out_session_flags |= SMB2_SESSION_FLAG_IS_GUEST;
+		*out_session_flags |= SMB2_SESSION_FLAG_IS_NULL;
+		/* force no signing */
+		session->do_signing = false;
+		guest = true;
 	}
 
-	session->compat = talloc_zero(session, struct user_struct);
-	if (session->compat == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	data_blob_free(&session->session_info->user_session_key);
+	session->session_info->user_session_key =
+			data_blob_talloc(
+				session->session_info,
+				session_key.data,
+				session_key.length);
+        if (session_key.length > 0) {
+		if (session->session_info->user_session_key.data == NULL) {
+			status = NT_STATUS_NO_MEMORY;
+			goto fail;
+		}
+	}
+	session->session_key = session->session_info->user_session_key;
+
+	session->compat_vuser = talloc_zero(session, user_struct);
+	if (session->compat_vuser == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto fail;
+	}
+	session->compat_vuser->auth_ntlmssp_state = NULL;
+	session->compat_vuser->homes_snum = -1;
+	session->compat_vuser->session_info = session->session_info;
+	session->compat_vuser->session_keystr = NULL;
+	session->compat_vuser->vuid = session->vuid;
+	DLIST_ADD(session->sconn->smb1.sessions.validated_users, session->compat_vuser);
+
+	/* This is a potentially untrusted username */
+	alpha_strcpy(tmp, user, ". _-$", sizeof(tmp));
+	session->session_info->sanitized_username =
+				talloc_strdup(session->session_info, tmp);
+
+	if (!session->session_info->guest) {
+		session->compat_vuser->homes_snum =
+			register_homes_share(session->session_info->unix_name);
 	}
-	session->compat->session = session;
-	session->compat->homes_snum = -1;
-	session->compat->session_info = session_info;
-	session->compat->session_keystr = NULL;
-	session->compat->vuid = session->global->session_wire_id;
-	DLIST_ADD(smb2req->sconn->users, session->compat);
-	smb2req->sconn->num_users++;
-
-	if (security_session_user_level(session_info, NULL) >= SECURITY_USER) {
-		session->compat->homes_snum =
-			register_homes_share(session_info->unix_info->unix_name);
-	}
-
-	set_current_user_info(session_info->unix_info->sanitized_username,
-			      session_info->unix_info->unix_name,
-			      session_info->info->domain_name);
-
-	reload_services(smb2req->sconn, conn_snum_used, true);
-
-	session->status = NT_STATUS_OK;
-	session->global->auth_session_info = session_info;
-	session->global->auth_session_info_seqnum += 1;
-	session->global->channels[0].auth_session_info_seqnum =
-		session->global->auth_session_info_seqnum;
-	session->global->expiration_time = gensec_expire_time(session->gensec);
 
-	if (!session_claim(session)) {
+	if (!session_claim(session->sconn, session->compat_vuser)) {
 		DEBUG(1, ("smb2: Failed to claim session "
-			"for vuid=%llu\n",
-			(unsigned long long)session->compat->vuid));
-		return NT_STATUS_LOGON_FAILURE;
+			"for vuid=%d\n",
+			session->compat_vuser->vuid));
+		goto fail;
 	}
 
-	status = smbXsrv_session_update(session);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(0, ("smb2: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
-			  nt_errstr(status)));
-		return NT_STATUS_LOGON_FAILURE;
-	}
+	session->status = NT_STATUS_OK;
 
 	/*
 	 * we attach the session to the request
@@ -369,573 +322,570 @@
 	}
 
 	global_client_caps |= (CAP_LEVEL_II_OPLOCKS|CAP_STATUS32);
+        status = NT_STATUS_OK;
+
+	/* wrap that up in a nice GSS-API wrapping */
+	ap_rep_wrapped = spnego_gen_krb5_wrap(talloc_tos(), ap_rep,
+				TOK_ID_KRB_AP_REP);
+
+	secblob_out = spnego_gen_auth_response(
+					talloc_tos(),
+					&ap_rep_wrapped,
+					status,
+					mechOID);
+
+	*out_security_buffer = data_blob_talloc(smb2req,
+						secblob_out.data,
+						secblob_out.length);
+	if (secblob_out.data && out_security_buffer->data == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto fail;
+	}
+
+	data_blob_free(&ap_rep);
+	data_blob_free(&ap_rep_wrapped);
+	data_blob_free(&ticket);
+	data_blob_free(&session_key);
+	data_blob_free(&secblob_out);
 
-	*out_session_id = session->global->session_wire_id;
+	*out_session_id = session->vuid;
 
 	return NT_STATUS_OK;
+
+  fail:
+
+	data_blob_free(&ap_rep);
+	data_blob_free(&ap_rep_wrapped);
+	data_blob_free(&ticket);
+	data_blob_free(&session_key);
+	data_blob_free(&secblob_out);
+
+	ap_rep_wrapped = data_blob_null;
+	secblob_out = spnego_gen_auth_response(
+					talloc_tos(),
+					&ap_rep_wrapped,
+					status,
+					mechOID);
+
+	*out_security_buffer = data_blob_talloc(smb2req,
+						secblob_out.data,
+						secblob_out.length);
+	data_blob_free(&secblob_out);
+	return status;
 }
+#endif
 
-static NTSTATUS smbd_smb2_reauth_generic_return(struct smbXsrv_session *session,
+static NTSTATUS smbd_smb2_spnego_negotiate(struct smbd_smb2_session *session,
 					struct smbd_smb2_request *smb2req,
-					struct auth_session_info *session_info,
+					uint8_t in_security_mode,
+					DATA_BLOB in_security_buffer,
 					uint16_t *out_session_flags,
+					DATA_BLOB *out_security_buffer,
 					uint64_t *out_session_id)
 {
+	DATA_BLOB secblob_in = data_blob_null;
+	DATA_BLOB chal_out = data_blob_null;
+	char *kerb_mech = NULL;
 	NTSTATUS status;
-	struct smbXsrv_session *x = session;
-	struct smbXsrv_connection *conn = session->connection;
 
-	data_blob_clear_free(&session_info->session_key);
-	session_info->session_key = data_blob_dup_talloc(session_info,
-						x->global->application_key);
-	if (session_info->session_key.data == NULL) {
-		return NT_STATUS_NO_MEMORY;
+	/* Ensure we have no old NTLM state around. */
+	TALLOC_FREE(session->auth_ntlmssp_state);
+
+	status = parse_spnego_mechanisms(talloc_tos(), in_security_buffer,
+			&secblob_in, &kerb_mech);
+	if (!NT_STATUS_IS_OK(status)) {
+		goto out;
 	}
 
-	session->compat->session_info = session_info;
-	session->compat->vuid = session->global->session_wire_id;
+#ifdef HAVE_KRB5
+	if (kerb_mech && ((lp_security()==SEC_ADS) ||
+				USE_KERBEROS_KEYTAB) ) {
+		status = smbd_smb2_session_setup_krb5(session,
+				smb2req,
+				in_security_mode,
+				&secblob_in,
+				kerb_mech,
+				out_session_flags,
+				out_security_buffer,
+				out_session_id);
 
-	session->compat->homes_snum =
-			register_homes_share(session_info->unix_info->unix_name);
+		goto out;
+	}
+#endif
 
-	set_current_user_info(session_info->unix_info->sanitized_username,
-			      session_info->unix_info->unix_name,
-			      session_info->info->domain_name);
+	if (kerb_mech) {
+		/* The mechtoken is a krb5 ticket, but
+		 * we need to fall back to NTLM. */
 
-	reload_services(smb2req->sconn, conn_snum_used, true);
+		DEBUG(3,("smb2: Got krb5 ticket in SPNEGO "
+			"but set to downgrade to NTLMSSP\n"));
 
-	session->status = NT_STATUS_OK;
-	TALLOC_FREE(session->global->auth_session_info);
-	session->global->auth_session_info = session_info;
-	session->global->auth_session_info_seqnum += 1;
-	session->global->channels[0].auth_session_info_seqnum =
-		session->global->auth_session_info_seqnum;
-	session->global->expiration_time = gensec_expire_time(session->gensec);
+		status = NT_STATUS_MORE_PROCESSING_REQUIRED;
+	} else {
+		/* Fall back to NTLMSSP. */
+		status = auth_ntlmssp_start(&session->auth_ntlmssp_state);
+		if (!NT_STATUS_IS_OK(status)) {
+			goto out;
+		}
 
-	status = smbXsrv_session_update(session);
-	if (!NT_STATUS_IS_OK(status)) {
-		DEBUG(0, ("smb2: Failed to update session for vuid=%llu - %s\n",
-			  (unsigned long long)session->compat->vuid,
-			  nt_errstr(status)));
-		return NT_STATUS_LOGON_FAILURE;
+		status = auth_ntlmssp_update(session->auth_ntlmssp_state,
+					     secblob_in,
+					     &chal_out);
 	}
 
-	conn_clear_vuid_caches(conn->sconn, session->compat->vuid);
+	if (!NT_STATUS_IS_OK(status) &&
+			!NT_STATUS_EQUAL(status,
+				NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		goto out;
+	}
+
+	*out_security_buffer = spnego_gen_auth_response(smb2req,
+						&chal_out,
+						status,
+						OID_NTLMSSP);
+	if (out_security_buffer->data == NULL) {
+		status = NT_STATUS_NO_MEMORY;
+		goto out;
+	}
+	*out_session_id = session->vuid;
+
+  out:
+
+	data_blob_free(&secblob_in);
+	data_blob_free(&chal_out);
+	TALLOC_FREE(kerb_mech);
+	if (!NT_STATUS_IS_OK(status) &&
+			!NT_STATUS_EQUAL(status,
+				NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		TALLOC_FREE(session->auth_ntlmssp_state);
+		TALLOC_FREE(session);
+	}
+	return status;
+}
 
-	*out_session_id = session->global->session_wire_id;
+static NTSTATUS smbd_smb2_common_ntlmssp_auth_return(struct smbd_smb2_session *session,
+					struct smbd_smb2_request *smb2req,
+					uint8_t in_security_mode,
+					DATA_BLOB in_security_buffer,
+					uint16_t *out_session_flags,
+					uint64_t *out_session_id)
+{
+	fstring tmp;
+	bool guest = false;
 
-	return NT_STATUS_OK;
-}
+	if ((in_security_mode & SMB2_NEGOTIATE_SIGNING_REQUIRED) ||
+	    lp_server_signing() == Required) {
+		session->do_signing = true;
+	}
 
-struct smbd_smb2_session_setup_state {
-	struct tevent_context *ev;
-	struct smbd_smb2_request *smb2req;
-	uint64_t in_session_id;
-	uint8_t in_flags;
-	uint8_t in_security_mode;
-	uint64_t in_previous_session_id;
-	DATA_BLOB in_security_buffer;
-	struct smbXsrv_session *session;
-	struct auth_session_info *session_info;
-	uint16_t out_session_flags;
-	DATA_BLOB out_security_buffer;
-	uint64_t out_session_id;
-	/* The following pointer is owned by state->session. */
-	struct smbd_smb2_session_setup_state **pp_self_ref;
-};
+	if (session->session_info->guest) {
+		/* we map anonymous to guest internally */
+		*out_session_flags |= SMB2_SESSION_FLAG_IS_GUEST;
+		*out_session_flags |= SMB2_SESSION_FLAG_IS_NULL;
+		/* force no signing */
+		session->do_signing = false;
+		guest = true;
+	}
 
-static int pp_self_ref_destructor(struct smbd_smb2_session_setup_state **pp_state)
-{
-	(*pp_state)->session = NULL;
-	/*
-	 * To make things clearer, ensure the pp_self_ref
-	 * pointer is nulled out. We're never going to
-	 * access this again.
-	 */
-	(*pp_state)->pp_self_ref = NULL;
-	return 0;
-}
+	session->session_key = session->session_info->user_session_key;
+
+	session->compat_vuser = talloc_zero(session, user_struct);
+	if (session->compat_vuser == NULL) {
+		TALLOC_FREE(session->auth_ntlmssp_state);
+		TALLOC_FREE(session);
+		return NT_STATUS_NO_MEMORY;
+	}
+	session->compat_vuser->auth_ntlmssp_state = session->auth_ntlmssp_state;
+	session->compat_vuser->homes_snum = -1;
+	session->compat_vuser->session_info = session->session_info;
+	session->compat_vuser->session_keystr = NULL;
+	session->compat_vuser->vuid = session->vuid;
+	DLIST_ADD(session->sconn->smb1.sessions.validated_users, session->compat_vuser);
+
+	/* This is a potentially untrusted username */
+	alpha_strcpy(tmp,
+		     auth_ntlmssp_get_username(session->auth_ntlmssp_state),
+		     ". _-$",
+		     sizeof(tmp));
+	session->session_info->sanitized_username = talloc_strdup(
+		session->session_info, tmp);
+
+	if (!session->compat_vuser->session_info->guest) {
+		session->compat_vuser->homes_snum =
+			register_homes_share(session->session_info->unix_name);
+	}
+
+	if (!session_claim(session->sconn, session->compat_vuser)) {
+		DEBUG(1, ("smb2: Failed to claim session "
+			"for vuid=%d\n",
+			session->compat_vuser->vuid));
+		TALLOC_FREE(session->auth_ntlmssp_state);
+		TALLOC_FREE(session);
+		return NT_STATUS_LOGON_FAILURE;
+	}
+
+
+	session->status = NT_STATUS_OK;
 
-static int smbd_smb2_session_setup_state_destructor(struct smbd_smb2_session_setup_state *state)
-{
 	/*
-	 * if state->session is not NULL,
-	 * we remove the session on failure
+	 * we attach the session to the request
+	 * so that the response can be signed
 	 */
-	TALLOC_FREE(state->session);
-	return 0;
-}
+	smb2req->session = session;
+	if (!guest) {
+		smb2req->do_signing = true;
+	}
+
+	global_client_caps |= (CAP_LEVEL_II_OPLOCKS|CAP_STATUS32);
 
-static void smbd_smb2_session_setup_gensec_done(struct tevent_req *subreq);
-static void smbd_smb2_session_setup_previous_done(struct tevent_req *subreq);
+	*out_session_id = session->vuid;
 
-/************************************************************************
- We have to tag the state->session pointer with memory talloc'ed
- on it to ensure it gets NULL'ed out if the underlying struct smbXsrv_session
- is deleted by shutdown whilst this request is in flight.
-************************************************************************/
-
-static NTSTATUS tag_state_session_ptr(struct smbd_smb2_session_setup_state *state)
-{
-	state->pp_self_ref = talloc_zero(state->session,
-			struct smbd_smb2_session_setup_state *);
-	if (state->pp_self_ref == NULL) {
-		return NT_STATUS_NO_MEMORY;
-	}
-	*state->pp_self_ref = state;
-	talloc_set_destructor(state->pp_self_ref, pp_self_ref_destructor);
 	return NT_STATUS_OK;
 }
 
-static struct tevent_req *smbd_smb2_session_setup_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
+static NTSTATUS smbd_smb2_spnego_auth(struct smbd_smb2_session *session,
 					struct smbd_smb2_request *smb2req,
-					uint64_t in_session_id,
-					uint8_t in_flags,
 					uint8_t in_security_mode,
-					uint64_t in_previous_session_id,
-					DATA_BLOB in_security_buffer)
+					DATA_BLOB in_security_buffer,
+					uint16_t *out_session_flags,
+					DATA_BLOB *out_security_buffer,
+					uint64_t *out_session_id)
 {
-	struct tevent_req *req;
-	struct smbd_smb2_session_setup_state *state;
+	DATA_BLOB auth = data_blob_null;
+	DATA_BLOB auth_out = data_blob_null;
 	NTSTATUS status;
-	NTTIME now = timeval_to_nttime(&smb2req->request_time);
-	struct tevent_req *subreq;
 
-	req = tevent_req_create(mem_ctx, &state,
-				struct smbd_smb2_session_setup_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->ev = ev;
-	state->smb2req = smb2req;
-	state->in_session_id = in_session_id;
-	state->in_flags = in_flags;
-	state->in_security_mode = in_security_mode;
-	state->in_previous_session_id = in_previous_session_id;
-	state->in_security_buffer = in_security_buffer;
-
-	if (in_flags & SMB2_SESSION_FLAG_BINDING) {
-		if (smb2req->sconn->conn->protocol < PROTOCOL_SMB2_22) {
-			tevent_req_nterror(req, NT_STATUS_REQUEST_NOT_ACCEPTED);
-			return tevent_req_post(req, ev);
-		}
-
-		/*
-		 * We do not support multi channel.
-		 */
-		tevent_req_nterror(req, NT_STATUS_NOT_SUPPORTED);
-		return tevent_req_post(req, ev);
+	if (!spnego_parse_auth(talloc_tos(), in_security_buffer, &auth)) {
+		TALLOC_FREE(session);
+		return NT_STATUS_LOGON_FAILURE;
 	}
 
-	talloc_set_destructor(state, smbd_smb2_session_setup_state_destructor);
-
-	if (state->in_session_id == 0) {
-		/* create a new session */
-		status = smbXsrv_session_create(state->smb2req->sconn->conn,
-					        now, &state->session);
-		if (tevent_req_nterror(req, status)) {
-			return tevent_req_post(req, ev);
-		}
-	} else {
-		status = smb2srv_session_lookup(state->smb2req->sconn->conn,
-						state->in_session_id, now,
-						&state->session);
-		if (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {
-			status = NT_STATUS_OK;
-		}
-		if (NT_STATUS_IS_OK(status)) {
-			state->session->status = NT_STATUS_MORE_PROCESSING_REQUIRED;
-			status = NT_STATUS_MORE_PROCESSING_REQUIRED;
-			TALLOC_FREE(state->session->gensec);
-		}
-		if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-			tevent_req_nterror(req, status);
-			return tevent_req_post(req, ev);
-		}
+	if (auth.length > 0 && auth.data[0] == ASN1_APPLICATION(0)) {
+		/* Might be a second negTokenTarg packet */
+		DATA_BLOB secblob_in = data_blob_null;
+		char *kerb_mech = NULL;
+
+		status = parse_spnego_mechanisms(talloc_tos(),
+				in_security_buffer,
+				&secblob_in, &kerb_mech);
+		if (!NT_STATUS_IS_OK(status)) {
+			TALLOC_FREE(session);
+			return status;
+		}
+
+#ifdef HAVE_KRB5
+		if (kerb_mech && ((lp_security()==SEC_ADS) ||
+					USE_KERBEROS_KEYTAB) ) {
+			status = smbd_smb2_session_setup_krb5(session,
+					smb2req,
+					in_security_mode,
+					&secblob_in,
+					kerb_mech,
+					out_session_flags,
+					out_security_buffer,
+					out_session_id);
+
+			data_blob_free(&secblob_in);
+			TALLOC_FREE(kerb_mech);
+			if (!NT_STATUS_IS_OK(status)) {
+				TALLOC_FREE(session);
+			}
+			return status;
+		}
+#endif
+
+		/* Can't blunder into NTLMSSP auth if we have
+		 * a krb5 ticket. */
+
+		if (kerb_mech) {
+			DEBUG(3,("smb2: network "
+				"misconfiguration, client sent us a "
+				"krb5 ticket and kerberos security "
+				"not enabled\n"));
+			TALLOC_FREE(session);
+			data_blob_free(&secblob_in);
+			TALLOC_FREE(kerb_mech);
+			return NT_STATUS_LOGON_FAILURE;
+		}
+
+		data_blob_free(&secblob_in);
+	}
+
+	if (session->auth_ntlmssp_state == NULL) {
+		status = auth_ntlmssp_start(&session->auth_ntlmssp_state);
+		if (!NT_STATUS_IS_OK(status)) {
+			data_blob_free(&auth);
+			TALLOC_FREE(session);
+			return status;
+		}
+	}
+
+	status = auth_ntlmssp_update(session->auth_ntlmssp_state,
+				     auth,
+				     &auth_out);
+	/* We need to call setup_ntlmssp_session_info() if status==NT_STATUS_OK,
+	   or if status is anything except NT_STATUS_MORE_PROCESSING_REQUIRED,
+	   as this can trigger map to guest. */
+	if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		status = setup_ntlmssp_session_info(session, status);
 	}
 
-	status = tag_state_session_ptr(state);
-	if (tevent_req_nterror(req, status)) {
-		return tevent_req_post(req, ev);
+	if (!NT_STATUS_IS_OK(status) &&
+			!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		TALLOC_FREE(session->auth_ntlmssp_state);
+		data_blob_free(&auth);
+		TALLOC_FREE(session);
+		return status;
 	}
 
-	if (state->session->gensec == NULL) {
-		status = auth_generic_prepare(state->session,
-					      state->session->connection->remote_address,
-					      &state->session->gensec);
-		if (tevent_req_nterror(req, status)) {
-			return tevent_req_post(req, ev);
-		}
-
-		gensec_want_feature(state->session->gensec, GENSEC_FEATURE_SESSION_KEY);
-		gensec_want_feature(state->session->gensec, GENSEC_FEATURE_UNIX_TOKEN);
+	data_blob_free(&auth);
 
-		status = gensec_start_mech_by_oid(state->session->gensec,
-						  GENSEC_OID_SPNEGO);
-		if (tevent_req_nterror(req, status)) {
-			return tevent_req_post(req, ev);
-		}
-	}
+	*out_security_buffer = spnego_gen_auth_response(smb2req,
+				&auth_out, status, NULL);
 
-	become_root();
-	subreq = gensec_update_send(state, state->ev,
-				    state->session->gensec,
-				    state->in_security_buffer);
-	unbecome_root();
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
+	if (out_security_buffer->data == NULL) {
+		TALLOC_FREE(session->auth_ntlmssp_state);
+		TALLOC_FREE(session);
+		return NT_STATUS_NO_MEMORY;
 	}
-	tevent_req_set_callback(subreq, smbd_smb2_session_setup_gensec_done, req);
-
-	return req;
-}
-
-static void smbd_smb2_session_setup_gensec_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req =
-		tevent_req_callback_data(subreq,
-		struct tevent_req);
-	struct smbd_smb2_session_setup_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_session_setup_state);
-	NTSTATUS status;
 
-	become_root();
-	status = gensec_update_recv(subreq, state,
-				    &state->out_security_buffer);
-	unbecome_root();
-	TALLOC_FREE(subreq);
-	if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED) &&
-	    !NT_STATUS_IS_OK(status)) {
-		tevent_req_nterror(req, status);
-		return;
-	}
+	*out_session_id = session->vuid;
 
 	if (NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-		state->out_session_id = state->session->global->session_wire_id;
-		/* we want to keep the session */
-		TALLOC_FREE(state->pp_self_ref);
-		tevent_req_nterror(req, status);
-		return;
-	}
-
-	status = gensec_session_info(state->session->gensec,
-				     state->session->global,
-				     &state->session_info);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-
-	if ((state->in_previous_session_id != 0) &&
-	     (state->session->global->session_wire_id !=
-	      state->in_previous_session_id))
-	{
-		subreq = smb2srv_session_close_previous_send(state, state->ev,
-						state->session->connection,
-						state->session_info,
-						state->in_previous_session_id,
-						state->session->global->session_wire_id);
-		if (tevent_req_nomem(subreq, req)) {
-			return;
-		}
-		tevent_req_set_callback(subreq,
-					smbd_smb2_session_setup_previous_done,
-					req);
-		return;
-	}
-
-	if (state->session->global->auth_session_info != NULL) {
-		status = smbd_smb2_reauth_generic_return(state->session,
-							 state->smb2req,
-							 state->session_info,
-							 &state->out_session_flags,
-							 &state->out_session_id);
-		if (tevent_req_nterror(req, status)) {
-			return;
-		}
-		/* we want to keep the session */
-		TALLOC_FREE(state->pp_self_ref);
-		tevent_req_done(req);
-		return;
-	}
-
-	status = smbd_smb2_auth_generic_return(state->session,
-					       state->smb2req,
-					       state->in_security_mode,
-					       state->session_info,
-					       &state->out_session_flags,
-					       &state->out_session_id);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-
-	/* we want to keep the session */
-	TALLOC_FREE(state->pp_self_ref);
-	tevent_req_done(req);
-	return;
-}
-
-static void smbd_smb2_session_setup_previous_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req =
-		tevent_req_callback_data(subreq,
-		struct tevent_req);
-	struct smbd_smb2_session_setup_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_session_setup_state);
-	NTSTATUS status;
+		return NT_STATUS_MORE_PROCESSING_REQUIRED;
+	}
 
-	status = smb2srv_session_close_previous_recv(subreq);
-	TALLOC_FREE(subreq);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-
-	if (state->session->global->auth_session_info != NULL) {
-		status = smbd_smb2_reauth_generic_return(state->session,
-							 state->smb2req,
-							 state->session_info,
-							 &state->out_session_flags,
-							 &state->out_session_id);
-		if (tevent_req_nterror(req, status)) {
-			return;
-		}
-		/* we want to keep the session */
-		TALLOC_FREE(state->pp_self_ref);
-		tevent_req_done(req);
-		return;
-	}
-
-	status = smbd_smb2_auth_generic_return(state->session,
-					       state->smb2req,
-					       state->in_security_mode,
-					       state->session_info,
-					       &state->out_session_flags,
-					       &state->out_session_id);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-
-	/* we want to keep the session */
-	TALLOC_FREE(state->pp_self_ref);
-	tevent_req_done(req);
-	return;
+	/* We're done - claim the session. */
+	return smbd_smb2_common_ntlmssp_auth_return(session,
+						smb2req,
+						in_security_mode,
+						in_security_buffer,
+						out_session_flags,
+						out_session_id);
 }
 
-static NTSTATUS smbd_smb2_session_setup_recv(struct tevent_req *req,
+static NTSTATUS smbd_smb2_raw_ntlmssp_auth(struct smbd_smb2_session *session,
+					struct smbd_smb2_request *smb2req,
+					uint8_t in_security_mode,
+					DATA_BLOB in_security_buffer,
 					uint16_t *out_session_flags,
-					TALLOC_CTX *mem_ctx,
 					DATA_BLOB *out_security_buffer,
 					uint64_t *out_session_id)
 {
-	struct smbd_smb2_session_setup_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_session_setup_state);
 	NTSTATUS status;
+	DATA_BLOB secblob_out = data_blob_null;
+
+	*out_security_buffer = data_blob_null;
 
-	if (tevent_req_is_nterror(req, &status)) {
-		if (!NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
-			tevent_req_received(req);
-			return nt_status_squash(status);
+	if (session->auth_ntlmssp_state == NULL) {
+		status = auth_ntlmssp_start(&session->auth_ntlmssp_state);
+		if (!NT_STATUS_IS_OK(status)) {
+			TALLOC_FREE(session);
+			return status;
 		}
-	} else {
-		status = NT_STATUS_OK;
 	}
 
-	*out_session_flags = state->out_session_flags;
-	*out_security_buffer = state->out_security_buffer;
-	*out_session_id = state->out_session_id;
-
-	talloc_steal(mem_ctx, out_security_buffer->data);
-	tevent_req_received(req);
-	return status;
-}
+	/* RAW NTLMSSP */
+	status = auth_ntlmssp_update(session->auth_ntlmssp_state,
+				     in_security_buffer,
+				     &secblob_out);
+
+	if (NT_STATUS_IS_OK(status) ||
+			NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		*out_security_buffer = data_blob_talloc(smb2req,
+						secblob_out.data,
+						secblob_out.length);
+		if (secblob_out.data && out_security_buffer->data == NULL) {
+			TALLOC_FREE(session->auth_ntlmssp_state);
+			TALLOC_FREE(session);
+			return NT_STATUS_NO_MEMORY;
+		}
+	}
 
-static struct tevent_req *smbd_smb2_logoff_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req);
-static NTSTATUS smbd_smb2_logoff_recv(struct tevent_req *req);
-static void smbd_smb2_request_logoff_done(struct tevent_req *subreq);
+	if (NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {
+		*out_session_id = session->vuid;
+		return status;
+	}
 
-NTSTATUS smbd_smb2_request_process_logoff(struct smbd_smb2_request *req)
-{
-	NTSTATUS status;
-	struct tevent_req *subreq = NULL;
+	status = setup_ntlmssp_session_info(session, status);
 
-	status = smbd_smb2_request_verify_sizes(req, 0x04);
 	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
-	subreq = smbd_smb2_logoff_send(req, req->sconn->ev_ctx, req);
-	if (subreq == NULL) {
-		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
+		TALLOC_FREE(session->auth_ntlmssp_state);
+		TALLOC_FREE(session);
+		return status;
 	}
-	tevent_req_set_callback(subreq, smbd_smb2_request_logoff_done, req);
+	*out_session_id = session->vuid;
 
-	/*
-	 * Wait a long time before going async on this to allow
-	 * requests we're waiting on to finish. Set timeout to 10 secs.
-	 */
-	return smbd_smb2_request_pending_queue(req, subreq, 10000000);
+	return smbd_smb2_common_ntlmssp_auth_return(session,
+						smb2req,
+						in_security_mode,
+						in_security_buffer,
+						out_session_flags,
+						out_session_id);
 }
 
-static void smbd_smb2_request_logoff_done(struct tevent_req *subreq)
+static NTSTATUS smbd_smb2_session_setup(struct smbd_smb2_request *smb2req,
+					uint64_t in_session_id,
+					uint8_t in_security_mode,
+					DATA_BLOB in_security_buffer,
+					uint16_t *out_session_flags,
+					DATA_BLOB *out_security_buffer,
+					uint64_t *out_session_id)
 {
-	struct smbd_smb2_request *smb2req =
-		tevent_req_callback_data(subreq,
-		struct smbd_smb2_request);
-	DATA_BLOB outbody;
-	NTSTATUS status;
-	NTSTATUS error;
+	struct smbd_smb2_session *session;
 
-	status = smbd_smb2_logoff_recv(subreq);
-	TALLOC_FREE(subreq);
-	if (!NT_STATUS_IS_OK(status)) {
-		error = smbd_smb2_request_error(smb2req, status);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(smb2req->sconn,
-							nt_errstr(error));
-			return;
+	*out_session_flags = 0;
+	*out_session_id = 0;
+
+	if (in_session_id == 0) {
+		int id;
+
+		/* create a new session */
+		session = talloc_zero(smb2req->sconn, struct smbd_smb2_session);
+		if (session == NULL) {
+			return NT_STATUS_NO_MEMORY;
 		}
-		return;
-	}
+		session->status = NT_STATUS_MORE_PROCESSING_REQUIRED;
+		id = idr_get_new_random(smb2req->sconn->smb2.sessions.idtree,
+					session,
+					smb2req->sconn->smb2.sessions.limit);
+		if (id == -1) {
+			return NT_STATUS_INSUFFICIENT_RESOURCES;
+		}
+		session->vuid = id;
 
-	outbody = data_blob_talloc(smb2req->out.vector, NULL, 0x04);
-	if (outbody.data == NULL) {
-		error = smbd_smb2_request_error(smb2req, NT_STATUS_NO_MEMORY);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(smb2req->sconn,
-							nt_errstr(error));
-			return;
+		session->tcons.idtree = idr_init(session);
+		if (session->tcons.idtree == NULL) {
+			return NT_STATUS_NO_MEMORY;
 		}
-		return;
-	}
+		session->tcons.limit = 0x0000FFFE;
+		session->tcons.list = NULL;
 
-	SSVAL(outbody.data, 0x00, 0x04);        /* struct size */
-	SSVAL(outbody.data, 0x02, 0);           /* reserved */
+		DLIST_ADD_END(smb2req->sconn->smb2.sessions.list, session,
+			      struct smbd_smb2_session *);
+		session->sconn = smb2req->sconn;
+		talloc_set_destructor(session, smbd_smb2_session_destructor);
+	} else {
+		void *p;
 
-	error = smbd_smb2_request_done(smb2req, outbody, NULL);
-	if (!NT_STATUS_IS_OK(error)) {
-		smbd_server_connection_terminate(smb2req->sconn,
-						nt_errstr(error));
-		return;
-	}
+		/* lookup an existing session */
+		p = idr_find(smb2req->sconn->smb2.sessions.idtree, in_session_id);
+		if (p == NULL) {
+			return NT_STATUS_USER_SESSION_DELETED;
+		}
+		session = talloc_get_type_abort(p, struct smbd_smb2_session);
+	}
+
+	if (NT_STATUS_IS_OK(session->status)) {
+		return NT_STATUS_REQUEST_NOT_ACCEPTED;
+	}
+
+	if (in_security_buffer.data[0] == ASN1_APPLICATION(0)) {
+		return smbd_smb2_spnego_negotiate(session,
+						smb2req,
+						in_security_mode,
+						in_security_buffer,
+						out_session_flags,
+						out_security_buffer,
+						out_session_id);
+	} else if (in_security_buffer.data[0] == ASN1_CONTEXT(1)) {
+		return smbd_smb2_spnego_auth(session,
+						smb2req,
+						in_security_mode,
+						in_security_buffer,
+						out_session_flags,
+						out_security_buffer,
+						out_session_id);
+	} else if (strncmp((char *)(in_security_buffer.data), "NTLMSSP", 7) == 0) {
+		return smbd_smb2_raw_ntlmssp_auth(session,
+						smb2req,
+						in_security_mode,
+						in_security_buffer,
+						out_session_flags,
+						out_security_buffer,
+						out_session_id);
+	}
+
+	/* Unknown packet type. */
+	DEBUG(1,("Unknown packet type %u in smb2 sessionsetup\n",
+		(unsigned int)in_security_buffer.data[0] ));
+	TALLOC_FREE(session->auth_ntlmssp_state);
+	TALLOC_FREE(session);
+	return NT_STATUS_LOGON_FAILURE;
 }
 
-struct smbd_smb2_logout_state {
-	struct smbd_smb2_request *smb2req;
-	struct tevent_queue *wait_queue;
-};
+NTSTATUS smbd_smb2_request_check_session(struct smbd_smb2_request *req)
+{
+	const uint8_t *inhdr;
+	int i = req->current_idx;
+	uint32_t in_flags;
+	uint64_t in_session_id;
+	void *p;
+	struct smbd_smb2_session *session;
 
-static void smbd_smb2_logoff_wait_done(struct tevent_req *subreq);
+	req->session = NULL;
+	req->tcon = NULL;
 
-static struct tevent_req *smbd_smb2_logoff_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req)
-{
-	struct tevent_req *req;
-	struct smbd_smb2_logout_state *state;
-	struct tevent_req *subreq;
-	struct smbd_smb2_request *preq;
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
 
-	req = tevent_req_create(mem_ctx, &state,
-			struct smbd_smb2_logout_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->smb2req = smb2req;
+	in_flags = IVAL(inhdr, SMB2_HDR_FLAGS);
+	in_session_id = BVAL(inhdr, SMB2_HDR_SESSION_ID);
 
-	state->wait_queue = tevent_queue_create(state, "logoff_wait_queue");
-	if (tevent_req_nomem(state->wait_queue, req)) {
-		return tevent_req_post(req, ev);
+	if (in_flags & SMB2_HDR_FLAG_CHAINED) {
+		in_session_id = req->last_session_id;
 	}
 
-	/*
-	 * Make sure that no new request will be able to use this session.
-	 */
-	smb2req->session->status = NT_STATUS_USER_SESSION_DELETED;
+	req->last_session_id = UINT64_MAX;
 
-	for (preq = smb2req->sconn->smb2.requests; preq != NULL; preq = preq->next) {
-		if (preq == smb2req) {
-			/* Can't cancel current request. */
-			continue;
-		}
-		if (preq->session != smb2req->session) {
-			/* Request on different session. */
-			continue;
-		}
-
-		/*
-		 * Never cancel anything in a compound
-		 * request. Way too hard to deal with
-		 * the result.
-		 */
-		if (!preq->compound_related && preq->subreq != NULL) {
-			tevent_req_cancel(preq->subreq);
-		}
-
-		/*
-		 * Now wait until the request is finished.
-		 *
-		 * We don't set a callback, as we just want to block the
-		 * wait queue and the talloc_free() of the request will
-		 * remove the item from the wait queue.
-		 */
-		subreq = smbd_tevent_queue_wait_send(preq, ev, state->wait_queue);
-		if (tevent_req_nomem(subreq, req)) {
-			return tevent_req_post(req, ev);
-		}
+	/* lookup an existing session */
+	p = idr_find(req->sconn->smb2.sessions.idtree, in_session_id);
+	if (p == NULL) {
+		return NT_STATUS_USER_SESSION_DELETED;
 	}
+	session = talloc_get_type_abort(p, struct smbd_smb2_session);
 
-	/*
-	 * Now we add our own waiter to the end of the queue,
-	 * this way we get notified when all pending requests are finished
-	 * and send to the socket.
-	 */
-	subreq = smbd_tevent_queue_wait_send(state, ev, state->wait_queue);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
+	if (!NT_STATUS_IS_OK(session->status)) {
+		return NT_STATUS_ACCESS_DENIED;
 	}
-	tevent_req_set_callback(subreq, smbd_smb2_logoff_wait_done, req);
 
-	return req;
+	set_current_user_info(session->session_info->sanitized_username,
+			      session->session_info->unix_name,
+			      session->session_info->info3->base.domain.string);
+
+	req->session = session;
+	req->last_session_id = in_session_id;
+
+	return NT_STATUS_OK;
 }
 
-static void smbd_smb2_logoff_wait_done(struct tevent_req *subreq)
+NTSTATUS smbd_smb2_request_process_logoff(struct smbd_smb2_request *req)
 {
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smbd_smb2_logout_state *state = tevent_req_data(
-		req, struct smbd_smb2_logout_state);
 	NTSTATUS status;
+	DATA_BLOB outbody;
 
-	smbd_tevent_queue_wait_recv(subreq);
-	TALLOC_FREE(subreq);
+	status = smbd_smb2_request_verify_sizes(req, 0x04);
+	if (!NT_STATUS_IS_OK(status)) {
+		return smbd_smb2_request_error(req, status);
+	}
 
 	/*
-	 * As we've been awoken, we may have changed
-	 * uid in the meantime. Ensure we're still
-	 * root (SMB2_OP_LOGOFF has .as_root = true).
+	 * TODO: cancel all outstanding requests on the session
+	 *       and delete all tree connections.
 	 */
-	change_to_root_user();
-
-	status = smbXsrv_session_logoff(state->smb2req->session);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-
+	smbd_smb2_session_destructor(req->session);
 	/*
 	 * we may need to sign the response, so we need to keep
 	 * the session until the response is sent to the wire.
 	 */
-	talloc_steal(state->smb2req, state->smb2req->session);
+	talloc_steal(req, req->session);
 
-	tevent_req_done(req);
-}
+	outbody = data_blob_talloc(req->out.vector, NULL, 0x04);
+	if (outbody.data == NULL) {
+		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
+	}
 
-static NTSTATUS smbd_smb2_logoff_recv(struct tevent_req *req)
-{
-	return tevent_req_simple_recv_ntstatus(req);
+	SSVAL(outbody.data, 0x00, 0x04);	/* struct size */
+	SSVAL(outbody.data, 0x02, 0);		/* reserved */
+
+	return smbd_smb2_request_done(req, outbody, NULL);
 }
Only in ../../samba-3.6.24/source3/smbd: smb2_sesssetup.o
diff -ur smbd/smb2_setinfo.c ../../samba-3.6.24/source3/smbd/smb2_setinfo.c
--- smbd/smb2_setinfo.c	2014-09-15 16:37:50.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_setinfo.c	2015-01-28 10:52:25.149068676 +0800
@@ -41,6 +41,7 @@
 {
 	NTSTATUS status;
 	const uint8_t *inbody;
+	int i = req->current_idx;
 	uint8_t in_info_type;
 	uint8_t in_file_info_class;
 	uint16_t in_input_buffer_offset;
@@ -56,7 +57,7 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_info_type			= CVAL(inbody, 0x02);
 	in_file_info_class		= CVAL(inbody, 0x03);
@@ -70,37 +71,27 @@
 	if (in_input_buffer_offset == 0 && in_input_buffer_length == 0) {
 		/* This is ok */
 	} else if (in_input_buffer_offset !=
-		   (SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(req))) {
+		   (SMB2_HDR_BODY + req->in.vector[i+1].iov_len)) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (in_input_buffer_length > SMBD_SMB2_IN_DYN_LEN(req)) {
+	if (in_input_buffer_length > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_input_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
+	in_input_buffer.data = (uint8_t *)req->in.vector[i+2].iov_base;
 	in_input_buffer.length = in_input_buffer_length;
 
 	if (in_input_buffer.length > req->sconn->smb2.max_trans) {
-		DEBUG(2,("smbd_smb2_request_process_setinfo: "
-			 "client ignored max trans: %s: 0x%08X: 0x%08X\n",
-			 __location__, (unsigned)in_input_buffer.length,
-			 (unsigned)req->sconn->smb2.max_trans));
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	status = smbd_smb2_request_verify_creditcharge(req,
-						in_input_buffer.length);
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	in_fsp = file_fsp_smb2(req, in_file_id_persistent, in_file_id_volatile);
 	if (in_fsp == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_setinfo_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_setinfo_send(req, req->sconn->smb2.event_ctx,
 					req, in_fsp,
 					in_info_type,
 					in_file_info_class,
@@ -111,7 +102,7 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_setinfo_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_setinfo_done(struct tevent_req *subreq)
@@ -171,7 +162,7 @@
 	struct tevent_req *req = NULL;
 	struct smbd_smb2_setinfo_state *state = NULL;
 	struct smb_request *smbreq = NULL;
-	connection_struct *conn = smb2req->tcon->compat;
+	connection_struct *conn = smb2req->tcon->compat_conn;
 	NTSTATUS status;
 
 	req = tevent_req_create(mem_ctx, &state,
@@ -181,8 +172,8 @@
 	}
 	state->smb2req = smb2req;
 
-	DEBUG(10,("smbd_smb2_setinfo_send: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_setinfo_send: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
@@ -264,8 +255,7 @@
 
 			if (SMB_VFS_FSTAT(fsp, &fsp->fsp_name->st) != 0) {
 				DEBUG(3,("smbd_smb2_setinfo_send: fstat "
-					 "of %s failed (%s)\n",
-					 fsp_fnum_dbg(fsp),
+					 "of fnum %d failed (%s)\n", fsp->fnum,
 					 strerror(errno)));
 				status = map_nt_error_from_unix(errno);
 				tevent_req_nterror(req, status);
@@ -311,8 +301,7 @@
 		status = set_sd_blob(fsp,
 				in_input_buffer.data,
 				in_input_buffer.length,
-				in_additional_information &
-				SMB_SUPPORTED_SECINFO_FLAGS);
+				in_additional_information);
 		if (!NT_STATUS_IS_OK(status)) {
 			tevent_req_nterror(req, status);
 			return tevent_req_post(req, ev);
Only in ../../samba-3.6.24/source3/smbd: smb2_setinfo.o
Only in ../../samba-3.6.24/source3/smbd: smb2_signing.c
Only in ../../samba-3.6.24/source3/smbd: smb2_signing.o
diff -ur smbd/smb2_tcon.c ../../samba-3.6.24/source3/smbd/smb2_tcon.c
--- smbd/smb2_tcon.c	2014-04-15 14:59:09.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_tcon.c	2015-01-28 10:52:25.149068676 +0800
@@ -24,60 +24,59 @@
 #include "../libcli/smb/smb_common.h"
 #include "../libcli/security/security.h"
 #include "auth.h"
-#include "lib/param/loadparm.h"
-#include "../lib/util/tevent_ntstatus.h"
-#include "lib/smbd_tevent_queue.h"
-
-static struct tevent_req *smbd_smb2_tree_connect_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req,
-					const char *in_path);
-static NTSTATUS smbd_smb2_tree_connect_recv(struct tevent_req *req,
-					    uint8_t *out_share_type,
-					    uint32_t *out_share_flags,
-					    uint32_t *out_capabilities,
-					    uint32_t *out_maximal_access,
-					    uint32_t *out_tree_id);
 
-static void smbd_smb2_request_tcon_done(struct tevent_req *subreq);
+static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
+				       const char *in_path,
+				       uint8_t *out_share_type,
+				       uint32_t *out_share_flags,
+				       uint32_t *out_capabilities,
+				       uint32_t *out_maximal_access,
+				       uint32_t *out_tree_id);
 
 NTSTATUS smbd_smb2_request_process_tcon(struct smbd_smb2_request *req)
 {
 	const uint8_t *inbody;
+	int i = req->current_idx;
+	uint8_t *outhdr;
+	DATA_BLOB outbody;
 	uint16_t in_path_offset;
 	uint16_t in_path_length;
 	DATA_BLOB in_path_buffer;
 	char *in_path_string;
 	size_t in_path_string_size;
+	uint8_t out_share_type = 0;
+	uint32_t out_share_flags = 0;
+	uint32_t out_capabilities = 0;
+	uint32_t out_maximal_access = 0;
+	uint32_t out_tree_id = 0;
 	NTSTATUS status;
 	bool ok;
-	struct tevent_req *subreq;
 
 	status = smbd_smb2_request_verify_sizes(req, 0x09);
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
 
 	in_path_offset = SVAL(inbody, 0x04);
 	in_path_length = SVAL(inbody, 0x06);
 
-	if (in_path_offset != (SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(req))) {
+	if (in_path_offset != (SMB2_HDR_BODY + req->in.vector[i+1].iov_len)) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (in_path_length > SMBD_SMB2_IN_DYN_LEN(req)) {
+	if (in_path_length > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_path_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
+	in_path_buffer.data = (uint8_t *)req->in.vector[i+2].iov_base;
 	in_path_buffer.length = in_path_length;
 
 	ok = convert_string_talloc(req, CH_UTF16, CH_UNIX,
 				   in_path_buffer.data,
 				   in_path_buffer.length,
 				   &in_path_string,
-				   &in_path_string_size);
+				   &in_path_string_size, false);
 	if (!ok) {
 		return smbd_smb2_request_error(req, NT_STATUS_ILLEGAL_CHARACTER);
 	}
@@ -90,61 +89,21 @@
 		return smbd_smb2_request_error(req, NT_STATUS_BAD_NETWORK_NAME);
 	}
 
-	subreq = smbd_smb2_tree_connect_send(req,
-					     req->sconn->ev_ctx,
-					     req,
-					     in_path_string);
-	if (subreq == NULL) {
-		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
-	}
-	tevent_req_set_callback(subreq, smbd_smb2_request_tcon_done, req);
-
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
-}
-
-static void smbd_smb2_request_tcon_done(struct tevent_req *subreq)
-{
-	struct smbd_smb2_request *req =
-		tevent_req_callback_data(subreq,
-		struct smbd_smb2_request);
-	uint8_t *outhdr;
-	DATA_BLOB outbody;
-	uint8_t out_share_type = 0;
-	uint32_t out_share_flags = 0;
-	uint32_t out_capabilities = 0;
-	uint32_t out_maximal_access = 0;
-	uint32_t out_tree_id = 0;
-	NTSTATUS status;
-	NTSTATUS error;
-
-	status = smbd_smb2_tree_connect_recv(subreq,
-					     &out_share_type,
-					     &out_share_flags,
-					     &out_capabilities,
-					     &out_maximal_access,
-					     &out_tree_id);
-	TALLOC_FREE(subreq);
+	status = smbd_smb2_tree_connect(req, in_path_string,
+					&out_share_type,
+					&out_share_flags,
+					&out_capabilities,
+					&out_maximal_access,
+					&out_tree_id);
 	if (!NT_STATUS_IS_OK(status)) {
-		error = smbd_smb2_request_error(req, status);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(req->sconn,
-							 nt_errstr(error));
-			return;
-		}
-		return;
+		return smbd_smb2_request_error(req, status);
 	}
 
-	outhdr = SMBD_SMB2_OUT_HDR_PTR(req);
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
 
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x10);
 	if (outbody.data == NULL) {
-		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(req->sconn,
-							 nt_errstr(error));
-			return;
-		}
-		return;
+		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
 	}
 
 	SIVAL(outhdr, SMB2_HDR_TID, out_tree_id);
@@ -160,12 +119,30 @@
 	SIVAL(outbody.data, 0x0C,
 	      out_maximal_access);		/* maximal access */
 
-	error = smbd_smb2_request_done(req, outbody, NULL);
-	if (!NT_STATUS_IS_OK(error)) {
-		smbd_server_connection_terminate(req->sconn,
-						 nt_errstr(error));
-		return;
+	return smbd_smb2_request_done(req, outbody, NULL);
+}
+
+static int smbd_smb2_tcon_destructor(struct smbd_smb2_tcon *tcon)
+{
+	if (tcon->session == NULL) {
+		return 0;
 	}
+
+	idr_remove(tcon->session->tcons.idtree, tcon->tid);
+	DLIST_REMOVE(tcon->session->tcons.list, tcon);
+	SMB_ASSERT(tcon->session->sconn->num_tcons_open > 0);
+	tcon->session->sconn->num_tcons_open--;
+
+	if (tcon->compat_conn) {
+		set_current_service(tcon->compat_conn, 0, true);
+		close_cnum(tcon->compat_conn, tcon->session->vuid);
+	}
+
+	tcon->compat_conn = NULL;
+	tcon->tid = 0;
+	tcon->session = NULL;
+
+	return 0;
 }
 
 static NTSTATUS smbd_smb2_tree_connect(struct smbd_smb2_request *req,
@@ -176,17 +153,14 @@
 				       uint32_t *out_maximal_access,
 				       uint32_t *out_tree_id)
 {
-	struct smbXsrv_connection *conn = req->sconn->conn;
 	const char *share = in_path;
 	char *service = NULL;
 	int snum = -1;
-	struct smbXsrv_tcon *tcon;
-	NTTIME now = timeval_to_nttime(&req->request_time);
+	struct smbd_smb2_tcon *tcon;
 	connection_struct *compat_conn = NULL;
-	struct user_struct *compat_vuser = req->session->compat;
+	user_struct *compat_vuser = req->session->compat_vuser;
+	int id;
 	NTSTATUS status;
-	bool encryption_required = req->session->global->encryption_required;
-	bool guest_session = false;
 
 	if (strncmp(share, "\\\\", 2) == 0) {
 		const char *p = strchr(share+2, '\\');
@@ -203,10 +177,7 @@
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	if (!strlower_m(service)) {
-		DEBUG(2, ("strlower_m %s failed\n", service));
-		return NT_STATUS_INVALID_PARAMETER;
-	}
+	strlower_m(service);
 
 	/* TODO: do more things... */
 	if (strequal(service,HOMES_NAME)) {
@@ -215,13 +186,13 @@
 				"user %s because it was not found "
 				"or created at session setup "
 				"time\n",
-				compat_vuser->session_info->unix_info->unix_name));
+				compat_vuser->session_info->unix_name));
 			return NT_STATUS_BAD_NETWORK_NAME;
 		}
 		snum = compat_vuser->homes_snum;
 	} else if ((compat_vuser->homes_snum != -1)
                    && strequal(service,
-			lp_servicename(talloc_tos(), compat_vuser->homes_snum))) {
+			lp_servicename(compat_vuser->homes_snum))) {
 		snum = compat_vuser->homes_snum;
 	} else {
 		snum = find_service(talloc_tos(), service, &service);
@@ -236,85 +207,65 @@
 		return NT_STATUS_BAD_NETWORK_NAME;
 	}
 
-	if (lp_smb_encrypt(snum) == SMB_SIGNING_REQUIRED) {
-		encryption_required = true;
-	}
-
-	if (security_session_user_level(compat_vuser->session_info, NULL) < SECURITY_USER) {
-		guest_session = true;
-	}
-
-	if (guest_session && encryption_required) {
-		DEBUG(1,("reject guest as encryption is required for service %s\n",
-			 service));
+	/* Don't allow connection if encryption is required. */
+	if (lp_smb_encrypt(snum) == Required) {
+		DEBUG(0,("Connection refused on share %s as encryption is"
+			" required on this share and SMB2 does not support"
+			" this.\n",
+			lp_servicename(snum)));
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
-	if (!(conn->smb2.server.capabilities & SMB2_CAP_ENCRYPTION)) {
-		if (encryption_required) {
-			DEBUG(1,("reject tcon with dialect[0x%04X] "
-				 "as encryption is required for service %s\n",
-				 conn->smb2.server.dialect, service));
-			return NT_STATUS_ACCESS_DENIED;
-		}
-	}
-
 	/* create a new tcon as child of the session */
-	status = smb2srv_tcon_create(req->session, now, &tcon);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+	tcon = talloc_zero(req->session, struct smbd_smb2_tcon);
+	if (tcon == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	id = idr_get_new_random(req->session->tcons.idtree,
+				tcon,
+				req->session->tcons.limit);
+	if (id == -1) {
+		TALLOC_FREE(tcon);
+		return NT_STATUS_INSUFFICIENT_RESOURCES;
 	}
+	tcon->tid = id;
+	tcon->snum = snum;
 
-	tcon->global->encryption_required = encryption_required;
+	DLIST_ADD_END(req->session->tcons.list, tcon,
+		      struct smbd_smb2_tcon *);
+	tcon->session = req->session;
+	tcon->session->sconn->num_tcons_open++;
+	talloc_set_destructor(tcon, smbd_smb2_tcon_destructor);
 
 	compat_conn = make_connection_smb2(req->sconn,
-					tcon, snum,
-					req->session->compat,
-					"???",
+					tcon,
+					req->session->compat_vuser,
+					data_blob_null, "???",
 					&status);
 	if (compat_conn == NULL) {
 		TALLOC_FREE(tcon);
 		return status;
 	}
+	tcon->compat_conn = talloc_move(tcon, &compat_conn);
 
-	tcon->global->share_name = lp_servicename(tcon->global,
-						  SNUM(compat_conn));
-	if (tcon->global->share_name == NULL) {
-		conn_free(compat_conn);
-		TALLOC_FREE(tcon);
-		return NT_STATUS_NO_MEMORY;
-	}
-	tcon->global->session_global_id =
-		req->session->global->session_global_id;
-
-	tcon->compat = talloc_move(tcon, &compat_conn);
-
-	tcon->status = NT_STATUS_OK;
-
-	status = smbXsrv_tcon_update(tcon);
-	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(tcon);
-		return status;
-	}
-
-	if (IS_PRINT(tcon->compat)) {
+	if (IS_PRINT(tcon->compat_conn)) {
 		*out_share_type = SMB2_SHARE_TYPE_PRINT;
-	} else if (IS_IPC(tcon->compat)) {
+	} else if (IS_IPC(tcon->compat_conn)) {
 		*out_share_type = SMB2_SHARE_TYPE_PIPE;
 	} else {
 		*out_share_type = SMB2_SHARE_TYPE_DISK;
 	}
 
-	*out_share_flags = 0;
+	*out_share_flags = SMB2_SHAREFLAG_ALLOW_NAMESPACE_CACHING;
 
-	if (lp_msdfs_root(SNUM(tcon->compat)) && lp_host_msdfs()) {
+	if (lp_msdfs_root(SNUM(tcon->compat_conn)) && lp_host_msdfs()) {
 		*out_share_flags |= (SMB2_SHAREFLAG_DFS|SMB2_SHAREFLAG_DFS_ROOT);
 		*out_capabilities = SMB2_SHARE_CAP_DFS;
 	} else {
 		*out_capabilities = 0;
 	}
 
-	switch(lp_csc_policy(SNUM(tcon->compat))) {
+	switch(lp_csc_policy(SNUM(tcon->compat_conn))) {
 	case CSC_POLICY_MANUAL:
 		break;
 	case CSC_POLICY_DOCUMENTS:
@@ -330,269 +281,79 @@
 		break;
 	}
 
-	if (lp_hideunreadable(SNUM(tcon->compat)) ||
-	    lp_hideunwriteable_files(SNUM(tcon->compat))) {
-		*out_share_flags |= SMB2_SHAREFLAG_ACCESS_BASED_DIRECTORY_ENUM;
-	}
+	*out_maximal_access = tcon->compat_conn->share_access;
 
-	if (encryption_required) {
-		*out_share_flags |= SMB2_SHAREFLAG_ENCRYPT_DATA;
-	}
-
-	*out_maximal_access = tcon->compat->share_access;
-
-	*out_tree_id = tcon->global->tcon_wire_id;
+	*out_tree_id = tcon->tid;
 	return NT_STATUS_OK;
 }
 
-struct smbd_smb2_tree_connect_state {
-	const char *in_path;
-	uint8_t out_share_type;
-	uint32_t out_share_flags;
-	uint32_t out_capabilities;
-	uint32_t out_maximal_access;
-	uint32_t out_tree_id;
-};
-
-static struct tevent_req *smbd_smb2_tree_connect_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req,
-					const char *in_path)
+NTSTATUS smbd_smb2_request_check_tcon(struct smbd_smb2_request *req)
 {
-	struct tevent_req *req;
-	struct smbd_smb2_tree_connect_state *state;
-	NTSTATUS status;
+	const uint8_t *inhdr;
+	int i = req->current_idx;
+	uint32_t in_flags;
+	uint32_t in_tid;
+	void *p;
+	struct smbd_smb2_tcon *tcon;
+
+	req->tcon = NULL;
+
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
 
-	req = tevent_req_create(mem_ctx, &state,
-				struct smbd_smb2_tree_connect_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->in_path = in_path;
-
-	status = smbd_smb2_tree_connect(smb2req,
-					state->in_path,
-					&state->out_share_type,
-					&state->out_share_flags,
-					&state->out_capabilities,
-					&state->out_maximal_access,
-					&state->out_tree_id);
-	if (tevent_req_nterror(req, status)) {
-		return tevent_req_post(req, ev);
+	in_flags = IVAL(inhdr, SMB2_HDR_FLAGS);
+	in_tid = IVAL(inhdr, SMB2_HDR_TID);
+
+	if (in_flags & SMB2_HDR_FLAG_CHAINED) {
+		in_tid = req->last_tid;
 	}
 
-	tevent_req_done(req);
-	return tevent_req_post(req, ev);
-}
+	req->last_tid = UINT32_MAX;
 
-static NTSTATUS smbd_smb2_tree_connect_recv(struct tevent_req *req,
-					    uint8_t *out_share_type,
-					    uint32_t *out_share_flags,
-					    uint32_t *out_capabilities,
-					    uint32_t *out_maximal_access,
-					    uint32_t *out_tree_id)
-{
-	struct smbd_smb2_tree_connect_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_tree_connect_state);
-	NTSTATUS status;
+	/* lookup an existing session */
+	p = idr_find(req->session->tcons.idtree, in_tid);
+	if (p == NULL) {
+		return NT_STATUS_NETWORK_NAME_DELETED;
+	}
+	tcon = talloc_get_type_abort(p, struct smbd_smb2_tcon);
 
-	if (tevent_req_is_nterror(req, &status)) {
-		tevent_req_received(req);
-		return status;
+	if (!change_to_user(tcon->compat_conn,req->session->vuid)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
+	/* should we pass FLAG_CASELESS_PATHNAMES here? */
+	if (!set_current_service(tcon->compat_conn, 0, true)) {
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
-	*out_share_type = state->out_share_type;
-	*out_share_flags = state->out_share_flags;
-	*out_capabilities = state->out_capabilities;
-	*out_maximal_access = state->out_maximal_access;
-	*out_tree_id = state->out_tree_id;
+	req->tcon = tcon;
+	req->last_tid = in_tid;
 
-	tevent_req_received(req);
 	return NT_STATUS_OK;
 }
 
-static struct tevent_req *smbd_smb2_tdis_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req);
-static NTSTATUS smbd_smb2_tdis_recv(struct tevent_req *req);
-static void smbd_smb2_request_tdis_done(struct tevent_req *subreq);
-
 NTSTATUS smbd_smb2_request_process_tdis(struct smbd_smb2_request *req)
 {
 	NTSTATUS status;
-	struct tevent_req *subreq = NULL;
+	DATA_BLOB outbody;
 
 	status = smbd_smb2_request_verify_sizes(req, 0x04);
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
 
-	subreq = smbd_smb2_tdis_send(req, req->sconn->ev_ctx, req);
-	if (subreq == NULL) {
-		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
-	}
-	tevent_req_set_callback(subreq, smbd_smb2_request_tdis_done, req);
-
 	/*
-	 * Wait a long time before going async on this to allow
-	 * requests we're waiting on to finish. Set timeout to 10 secs.
+	 * TODO: cancel all outstanding requests on the tcon
+	 *       and delete all file handles.
 	 */
-	return smbd_smb2_request_pending_queue(req, subreq, 10000000);
-}
-
-static void smbd_smb2_request_tdis_done(struct tevent_req *subreq)
-{
-	struct smbd_smb2_request *smb2req =
-		tevent_req_callback_data(subreq,
-		struct smbd_smb2_request);
-	DATA_BLOB outbody;
-	NTSTATUS status;
-	NTSTATUS error;
+	TALLOC_FREE(req->tcon);
 
-	status = smbd_smb2_tdis_recv(subreq);
-	TALLOC_FREE(subreq);
-	if (!NT_STATUS_IS_OK(status)) {
-		error = smbd_smb2_request_error(smb2req, status);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(smb2req->sconn,
-							nt_errstr(error));
-			return;
-		}
-		return;
-	}
-
-	outbody = data_blob_talloc(smb2req->out.vector, NULL, 0x04);
+	outbody = data_blob_talloc(req->out.vector, NULL, 0x04);
 	if (outbody.data == NULL) {
-		error = smbd_smb2_request_error(smb2req, NT_STATUS_NO_MEMORY);
-		if (!NT_STATUS_IS_OK(error)) {
-			smbd_server_connection_terminate(smb2req->sconn,
-							nt_errstr(error));
-			return;
-		}
-		return;
+		return smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
 	}
 
 	SSVAL(outbody.data, 0x00, 0x04);	/* struct size */
 	SSVAL(outbody.data, 0x02, 0);		/* reserved */
 
-	error = smbd_smb2_request_done(smb2req, outbody, NULL);
-	if (!NT_STATUS_IS_OK(error)) {
-		smbd_server_connection_terminate(smb2req->sconn,
-						nt_errstr(error));
-		return;
-	}
-}
-
-struct smbd_smb2_tdis_state {
-	struct smbd_smb2_request *smb2req;
-	struct tevent_queue *wait_queue;
-};
-
-static void smbd_smb2_tdis_wait_done(struct tevent_req *subreq);
-
-static struct tevent_req *smbd_smb2_tdis_send(TALLOC_CTX *mem_ctx,
-					struct tevent_context *ev,
-					struct smbd_smb2_request *smb2req)
-{
-	struct tevent_req *req;
-	struct smbd_smb2_tdis_state *state;
-	struct tevent_req *subreq;
-	struct smbd_smb2_request *preq;
-
-	req = tevent_req_create(mem_ctx, &state,
-			struct smbd_smb2_tdis_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	state->smb2req = smb2req;
-
-	state->wait_queue = tevent_queue_create(state, "tdis_wait_queue");
-	if (tevent_req_nomem(state->wait_queue, req)) {
-		return tevent_req_post(req, ev);
-	}
-
-	/*
-	 * Make sure that no new request will be able to use this tcon.
-	 */
-	smb2req->tcon->status = NT_STATUS_NETWORK_NAME_DELETED;
-
-	for (preq = smb2req->sconn->smb2.requests; preq != NULL; preq = preq->next) {
-		if (preq == smb2req) {
-			/* Can't cancel current request. */
-			continue;
-		}
-		if (preq->tcon != smb2req->tcon) {
-			/* Request on different tcon. */
-			continue;
-		}
-
-		/*
-		 * Never cancel anything in a compound
-		 * request. Way too hard to deal with
-		 * the result.
-		 */
-		if (!preq->compound_related && preq->subreq != NULL) {
-			tevent_req_cancel(preq->subreq);
-		}
-
-		/*
-		 * Now wait until the request is finished.
-		 *
-		 * We don't set a callback, as we just want to block the
-		 * wait queue and the talloc_free() of the request will
-		 * remove the item from the wait queue.
-		 */
-		subreq = smbd_tevent_queue_wait_send(preq, ev, state->wait_queue);
-		if (tevent_req_nomem(subreq, req)) {
-			return tevent_req_post(req, ev);
-		}
-	}
-
-	/*
-	 * Now we add our own waiter to the end of the queue,
-	 * this way we get notified when all pending requests are finished
-	 * and send to the socket.
-	 */
-	subreq = smbd_tevent_queue_wait_send(state, ev, state->wait_queue);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
-	}
-	tevent_req_set_callback(subreq, smbd_smb2_tdis_wait_done, req);
-
-	return req;
-}
-
-static void smbd_smb2_tdis_wait_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smbd_smb2_tdis_state *state = tevent_req_data(
-		req, struct smbd_smb2_tdis_state);
-	NTSTATUS status;
-
-	smbd_tevent_queue_wait_recv(subreq);
-	TALLOC_FREE(subreq);
-
-	/*
-	 * As we've been awoken, we may have changed
-	 * uid in the meantime. Ensure we're still
-	 * root (SMB2_OP_TDIS has .as_root = true).
-	 */
-	change_to_root_user();
-
-	status = smbXsrv_tcon_disconnect(state->smb2req->tcon,
-					 state->smb2req->tcon->compat->vuid);
-	if (tevent_req_nterror(req, status)) {
-		return;
-	}
-
-	/* We did tear down the tcon. */
-	TALLOC_FREE(state->smb2req->tcon);
-	tevent_req_done(req);
-}
-
-static NTSTATUS smbd_smb2_tdis_recv(struct tevent_req *req)
-{
-	return tevent_req_simple_recv_ntstatus(req);
+	return smbd_smb2_request_done(req, outbody, NULL);
 }
Only in ../../samba-3.6.24/source3/smbd: smb2_tcon.o
diff -ur smbd/smb2_write.c ../../samba-3.6.24/source3/smbd/smb2_write.c
--- smbd/smb2_write.c	2012-10-02 16:38:44.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smb2_write.c	2015-01-28 10:52:25.149068676 +0800
@@ -29,6 +29,7 @@
 					       struct tevent_context *ev,
 					       struct smbd_smb2_request *smb2req,
 					       struct files_struct *in_fsp,
+					       uint32_t in_smbpid,
 					       DATA_BLOB in_data,
 					       uint64_t in_offset,
 					       uint32_t in_flags);
@@ -39,7 +40,10 @@
 NTSTATUS smbd_smb2_request_process_write(struct smbd_smb2_request *req)
 {
 	NTSTATUS status;
+	const uint8_t *inhdr;
 	const uint8_t *inbody;
+	int i = req->current_idx;
+	uint32_t in_smbpid;
 	uint16_t in_data_offset;
 	uint32_t in_data_length;
 	DATA_BLOB in_data_buffer;
@@ -54,7 +58,10 @@
 	if (!NT_STATUS_IS_OK(status)) {
 		return smbd_smb2_request_error(req, status);
 	}
-	inbody = SMBD_SMB2_IN_BODY_PTR(req);
+	inhdr = (const uint8_t *)req->in.vector[i+0].iov_base;
+	inbody = (const uint8_t *)req->in.vector[i+1].iov_base;
+
+	in_smbpid = IVAL(inhdr, SMB2_HDR_PID);
 
 	in_data_offset		= SVAL(inbody, 0x02);
 	in_data_length		= IVAL(inbody, 0x04);
@@ -63,11 +70,11 @@
 	in_file_id_volatile	= BVAL(inbody, 0x18);
 	in_flags		= IVAL(inbody, 0x2C);
 
-	if (in_data_offset != (SMB2_HDR_BODY + SMBD_SMB2_IN_BODY_LEN(req))) {
+	if (in_data_offset != (SMB2_HDR_BODY + req->in.vector[i+1].iov_len)) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	if (in_data_length > SMBD_SMB2_IN_DYN_LEN(req)) {
+	if (in_data_length > req->in.vector[i+2].iov_len) {
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
@@ -79,21 +86,17 @@
 		return smbd_smb2_request_error(req, NT_STATUS_INVALID_PARAMETER);
 	}
 
-	in_data_buffer.data = SMBD_SMB2_IN_DYN_PTR(req);
+	in_data_buffer.data = (uint8_t *)req->in.vector[i+2].iov_base;
 	in_data_buffer.length = in_data_length;
 
-	status = smbd_smb2_request_verify_creditcharge(req, in_data_length);
-	if (!NT_STATUS_IS_OK(status)) {
-		return smbd_smb2_request_error(req, status);
-	}
-
 	in_fsp = file_fsp_smb2(req, in_file_id_persistent, in_file_id_volatile);
 	if (in_fsp == NULL) {
 		return smbd_smb2_request_error(req, NT_STATUS_FILE_CLOSED);
 	}
 
-	subreq = smbd_smb2_write_send(req, req->sconn->ev_ctx,
+	subreq = smbd_smb2_write_send(req, req->sconn->smb2.event_ctx,
 				      req, in_fsp,
+				      in_smbpid,
 				      in_data_buffer,
 				      in_offset,
 				      in_flags);
@@ -102,13 +105,15 @@
 	}
 	tevent_req_set_callback(subreq, smbd_smb2_request_write_done, req);
 
-	return smbd_smb2_request_pending_queue(req, subreq, 500);
+	return smbd_smb2_request_pending_queue(req, subreq);
 }
 
 static void smbd_smb2_request_write_done(struct tevent_req *subreq)
 {
 	struct smbd_smb2_request *req = tevent_req_callback_data(subreq,
 					struct smbd_smb2_request);
+	int i = req->current_idx;
+	uint8_t *outhdr;
 	DATA_BLOB outbody;
 	DATA_BLOB outdyn;
 	uint32_t out_count = 0;
@@ -127,6 +132,8 @@
 		return;
 	}
 
+	outhdr = (uint8_t *)req->out.vector[i].iov_base;
+
 	outbody = data_blob_talloc(req->out.vector, NULL, 0x10);
 	if (outbody.data == NULL) {
 		error = smbd_smb2_request_error(req, NT_STATUS_NO_MEMORY);
@@ -156,7 +163,6 @@
 
 struct smbd_smb2_write_state {
 	struct smbd_smb2_request *smb2req;
-	struct smb_request *smbreq;
 	files_struct *fsp;
 	bool write_through;
 	uint32_t in_length;
@@ -166,51 +172,37 @@
 
 static void smbd_smb2_write_pipe_done(struct tevent_req *subreq);
 
-static NTSTATUS smb2_write_complete_internal(struct tevent_req *req,
-					     ssize_t nwritten, int err,
-					     bool do_sync)
+NTSTATUS smb2_write_complete(struct tevent_req *req, ssize_t nwritten, int err)
 {
 	NTSTATUS status;
 	struct smbd_smb2_write_state *state = tevent_req_data(req,
 					struct smbd_smb2_write_state);
 	files_struct *fsp = state->fsp;
 
-	if (nwritten == -1) {
-		status = map_nt_error_from_unix(err);
-
-		DEBUG(2, ("smb2_write failed: %s, file %s, "
-			  "length=%lu offset=%lu nwritten=-1: %s\n",
-			  fsp_fnum_dbg(fsp),
-			  fsp_str_dbg(fsp),
-			  (unsigned long)state->in_length,
-			  (unsigned long)state->in_offset,
-			  nt_errstr(status)));
-
-		return status;
-	}
-
-	DEBUG(3,("smb2: %s, file %s, "
+	DEBUG(3,("smb2: fnum=[%d/%s] "
 		"length=%lu offset=%lu wrote=%lu\n",
-		fsp_fnum_dbg(fsp),
+		fsp->fnum,
 		fsp_str_dbg(fsp),
 		(unsigned long)state->in_length,
 		(unsigned long)state->in_offset,
 		(unsigned long)nwritten));
 
+	if (nwritten == -1) {
+		return map_nt_error_from_unix(err);
+	}
+
 	if ((nwritten == 0) && (state->in_length != 0)) {
 		DEBUG(5,("smb2: write [%s] disk full\n",
 			fsp_str_dbg(fsp)));
 		return NT_STATUS_DISK_FULL;
 	}
 
-	if (do_sync) {
-		status = sync_file(fsp->conn, fsp, state->write_through);
-		if (!NT_STATUS_IS_OK(status)) {
-			DEBUG(5,("smb2: sync_file for %s returned %s\n",
-				 fsp_str_dbg(fsp),
-				 nt_errstr(status)));
-			return status;
-		}
+	status = sync_file(fsp->conn, fsp, state->write_through);
+	if (!NT_STATUS_IS_OK(status)) {
+		DEBUG(5,("smb2: sync_file for %s returned %s\n",
+			fsp_str_dbg(fsp),
+			nt_errstr(status)));
+		return status;
 	}
 
 	state->out_count = nwritten;
@@ -218,31 +210,11 @@
 	return NT_STATUS_OK;
 }
 
-NTSTATUS smb2_write_complete(struct tevent_req *req, ssize_t nwritten, int err)
-{
-	return smb2_write_complete_internal(req, nwritten, err, true);
-}
-
-NTSTATUS smb2_write_complete_nosync(struct tevent_req *req, ssize_t nwritten,
-				    int err)
-{
-	return smb2_write_complete_internal(req, nwritten, err, false);
-}
-
-
-static bool smbd_smb2_write_cancel(struct tevent_req *req)
-{
-	struct smbd_smb2_write_state *state =
-		tevent_req_data(req,
-		struct smbd_smb2_write_state);
-
-	return cancel_smb2_aio(state->smbreq);
-}
-
 static struct tevent_req *smbd_smb2_write_send(TALLOC_CTX *mem_ctx,
 					       struct tevent_context *ev,
 					       struct smbd_smb2_request *smb2req,
 					       struct files_struct *fsp,
+					       uint32_t in_smbpid,
 					       DATA_BLOB in_data,
 					       uint64_t in_offset,
 					       uint32_t in_flags)
@@ -251,7 +223,7 @@
 	struct tevent_req *req = NULL;
 	struct smbd_smb2_write_state *state = NULL;
 	struct smb_request *smbreq = NULL;
-	connection_struct *conn = smb2req->tcon->compat;
+	connection_struct *conn = smb2req->tcon->compat_conn;
 	ssize_t nwritten;
 	struct lock_struct lock;
 
@@ -261,20 +233,19 @@
 		return NULL;
 	}
 	state->smb2req = smb2req;
-	if (in_flags & SMB2_WRITEFLAG_WRITE_THROUGH) {
+	if (in_flags & 0x00000001) {
 		state->write_through = true;
 	}
 	state->in_length = in_data.length;
 	state->out_count = 0;
 
-	DEBUG(10,("smbd_smb2_write: %s - %s\n",
-		  fsp_str_dbg(fsp), fsp_fnum_dbg(fsp)));
+	DEBUG(10,("smbd_smb2_write: %s - fnum[%d]\n",
+		  fsp_str_dbg(fsp), fsp->fnum));
 
 	smbreq = smbd_smb2_fake_smb_request(smb2req);
 	if (tevent_req_nomem(smbreq, req)) {
 		return tevent_req_post(req, ev);
 	}
-	state->smbreq = smbreq;
 
 	state->fsp = fsp;
 
@@ -286,7 +257,7 @@
 			return tevent_req_post(req, ev);
 		}
 
-		subreq = np_write_send(state, ev,
+		subreq = np_write_send(state, smbd_event_context(),
 				       fsp->fake_file_handle,
 				       in_data.data,
 				       in_data.length);
@@ -314,10 +285,14 @@
 
 	if (NT_STATUS_IS_OK(status)) {
 		/*
-		 * Doing an async write, allow this
-		 * request to be canceled
+		 * Doing an async write. Don't
+		 * send a "gone async" message
+		 * as we expect this to be less
+		 * than the client timeout period.
+		 * JRA. FIXME for offline files..
+		 * FIXME - add cancel code..
 		 */
-		tevent_req_set_cancel_fn(req, smbd_smb2_write_cancel);
+		smb2req->async = true;
 		return req;
 	}
 
@@ -329,7 +304,7 @@
 
 	/* Fallback to synchronous. */
 	init_strict_lock_struct(fsp,
-				fsp->op->global->open_persistent_id,
+				fsp->fnum,
 				in_offset,
 				in_data.length,
 				WRITE_LOCK,
@@ -378,8 +353,6 @@
 	status = np_write_recv(subreq, &nwritten);
 	TALLOC_FREE(subreq);
 	if (!NT_STATUS_IS_OK(status)) {
-		NTSTATUS old = status;
-		status = nt_status_np_pipe(old);
 		tevent_req_nterror(req, status);
 		return;
 	}
Only in ../../samba-3.6.24/source3/smbd: smb2_write.o
diff -ur smbd/smbd.h ../../samba-3.6.24/source3/smbd/smbd.h
--- smbd/smbd.h	2014-01-07 16:02:57.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/smbd.h	2015-01-28 10:52:25.149068676 +0800
@@ -19,60 +19,9 @@
 #ifndef _SMBD_SMBD_H
 #define _SMBD_SMBD_H
 
-struct dptr_struct;
-
 #include "smb_acls.h"
 #include "vfs.h"
 #include "smbd/proto.h"
 #include "locking/proto.h"
 
-/*
- * Pathnames used if request done
- * under privilege.
- */
-struct privilege_paths {
-	struct smb_filename parent_name;
-	struct smb_filename file_name;
-};
-
-struct trans_state {
-	struct trans_state *next, *prev;
-	uint64_t vuid; /* SMB2 compat */
-	uint64_t mid;
-
-	uint32 max_param_return;
-	uint32 max_data_return;
-	uint32 max_setup_return;
-
-	uint8 cmd;		/* SMBtrans or SMBtrans2 */
-
-	char *name;		/* for trans requests */
-	uint16 call;		/* for trans2 and nttrans requests */
-
-	bool close_on_completion;
-	bool one_way;
-
-	unsigned int setup_count;
-	uint16 *setup;
-
-	size_t received_data;
-	size_t received_param;
-
-	size_t total_param;
-	char *param;
-
-	size_t total_data;
-	char *data;
-};
-
-/*
- * unix_convert_flags
- */
-#define UCF_SAVE_LCOMP			0x00000001
-#define UCF_ALWAYS_ALLOW_WCARD_LCOMP	0x00000002
-#define UCF_COND_ALLOW_WCARD_LCOMP	0x00000004
-#define UCF_POSIX_PATHNAMES		0x00000008
-#define UCF_UNIX_NAME_LOOKUP		0x00000010
-#define UCF_PREP_CREATEFILE		0x00000020
-
 #endif /* _SMBD_SMBD_H */
Only in smbd: smbXsrv_open.c
Only in smbd: smbXsrv_session.c
Only in smbd: smbXsrv_tcon.c
Only in smbd: smbXsrv_version.c
diff -ur smbd/srvstr.c ../../samba-3.6.24/source3/smbd/srvstr.c
--- smbd/srvstr.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/srvstr.c	2015-01-28 10:52:25.149068676 +0800
@@ -24,7 +24,8 @@
 
 /* Make sure we can't write a string past the end of the buffer */
 
-size_t srvstr_push_fn(const char *base_ptr, uint16 smb_flags2, void *dest,
+size_t srvstr_push_fn(const char *function, unsigned int line,
+		      const char *base_ptr, uint16 smb_flags2, void *dest,
 		      const char *src, int dest_len, int flags)
 {
 	if (dest_len < 0) {
@@ -32,7 +33,7 @@
 	}
 
 	/* 'normal' push into size-specified buffer */
-	return push_string_base(base_ptr, smb_flags2, dest, src,
+	return push_string_base(function, line, base_ptr, smb_flags2, dest, src,
 				dest_len, flags);
 }
 
@@ -56,7 +57,7 @@
 	 */
 	grow_size = (strlen(str) + 2) * 4;
 
-	if (!(tmp = talloc_realloc(NULL, *outbuf, uint8,
+	if (!(tmp = TALLOC_REALLOC_ARRAY(NULL, *outbuf, uint8,
 					 buf_size + grow_size))) {
 		DEBUG(0, ("talloc failed\n"));
 		return -1;
Only in ../../samba-3.6.24/source3/smbd: srvstr.o
diff -ur smbd/statcache.c ../../samba-3.6.24/source3/smbd/statcache.c
--- smbd/statcache.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/statcache.c	2015-01-28 10:52:25.149068676 +0800
@@ -25,7 +25,7 @@
 #include "smbd/smbd.h"
 #include "messages.h"
 #include "smbprofile.h"
-#include "tdb_compat.h"
+#include <tdb.h>
 
 /****************************************************************************
  Stat cache code used in unix_convert.
@@ -349,8 +349,8 @@
  Tell all smbd's to delete an entry.
 **************************************************************************/
 
-void smbd_send_stat_cache_delete_message(struct messaging_context *msg_ctx,
-					 const char *name)
+void send_stat_cache_delete_message(struct messaging_context *msg_ctx,
+				    const char *name)
 {
 #ifdef DEVELOPER
 	message_send_all(msg_ctx,
@@ -386,7 +386,7 @@
  JRA. Use a djb-algorithm hash for speed.
 ***************************************************************/
 
-unsigned int fast_string_hash(TDB_DATA *key)
+unsigned int fast_string_hash(struct TDB_DATA *key)
 {
         unsigned int n = 0;
         const char *p;
Only in ../../samba-3.6.24/source3/smbd: statcache.o
diff -ur smbd/statvfs.c ../../samba-3.6.24/source3/smbd/statvfs.c
--- smbd/statvfs.c	2012-10-02 16:24:45.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/statvfs.c	2015-01-28 10:52:25.149068676 +0800
@@ -23,7 +23,36 @@
 #include "system/filesys.h"
 #include "smbd/smbd.h"
 
+#if defined(LINUX) && defined(HAVE_FSID_INT)
+static int linux_statvfs(const char *path, vfs_statvfs_struct *statbuf)
+{
+	struct statvfs statvfs_buf;
+	int result;
+
+	result = statvfs(path, &statvfs_buf);
+
+	if (!result) {
+		statbuf->OptimalTransferSize = statvfs_buf.f_frsize;
+		statbuf->BlockSize = statvfs_buf.f_bsize;
+		statbuf->TotalBlocks = statvfs_buf.f_blocks;
+		statbuf->BlocksAvail = statvfs_buf.f_bfree;
+		statbuf->UserBlocksAvail = statvfs_buf.f_bavail;
+		statbuf->TotalFileNodes = statvfs_buf.f_files;
+		statbuf->FreeFileNodes = statvfs_buf.f_ffree;
+		statbuf->FsIdentifier = statvfs_buf.f_fsid;
+
+		/* Good defaults for Linux filesystems are case sensitive
+		 * and case preserving.
+		 */
+		statbuf->FsCapabilities =
+		    FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES;
+	}
+	return result;
+}
+#endif
+
 #if defined(DARWINOS)
+
 #include <sys/attr.h>
 
 static int darwin_fs_capabilities(const char * path)
@@ -73,77 +102,28 @@
 
 	return caps;
 }
-#endif /* DARWINOS */
 
-#if defined(BSD_STYLE_STATVFS)
-static int bsd_statvfs(const char *path, vfs_statvfs_struct *statbuf)
+static int darwin_statvfs(const char *path, vfs_statvfs_struct *statbuf)
 {
 	struct statfs sbuf;
 	int ret;
 
 	ret = statfs(path, &sbuf);
-	if (ret == 0) {
-		statbuf->OptimalTransferSize = sbuf.f_iosize;
-		statbuf->BlockSize = sbuf.f_bsize;
-		statbuf->TotalBlocks = sbuf.f_blocks;
-		statbuf->BlocksAvail = sbuf.f_bfree;
-		statbuf->UserBlocksAvail = sbuf.f_bavail;
-		statbuf->TotalFileNodes = sbuf.f_files;
-		statbuf->FreeFileNodes = sbuf.f_ffree;
-		statbuf->FsIdentifier =
-			(((uint64_t) sbuf.f_fsid.val[0] << 32) & 0xffffffff00000000LL) |
-			    (uint64_t) sbuf.f_fsid.val[1];
-#ifdef DARWINOS
-		statbuf->FsCapabilities = darwin_fs_capabilities(sbuf.f_mntonname);
-#else
-		/* Try to extrapolate some of the fs flags into the
-		 * capabilities
-		 */
-		statbuf->FsCapabilities =
-		    FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES;
-#ifdef MNT_ACLS
-		if (sbuf.f_flags & MNT_ACLS)
-			statbuf->FsCapabilities |= FILE_PERSISTENT_ACLS;
-#endif
-#endif
-		if (sbuf.f_flags & MNT_QUOTA)
-			statbuf->FsCapabilities |= FILE_VOLUME_QUOTAS;
-		if (sbuf.f_flags & MNT_RDONLY)
-			statbuf->FsCapabilities |= FILE_READ_ONLY_VOLUME;
+	if (ret != 0) {
+		return ret;
 	}
 
-	return ret;
-}
-#elif defined(STAT_STATVFS) && defined(HAVE_FSID_INT)
-static int linux_statvfs(const char *path, vfs_statvfs_struct *statbuf)
-{
-	struct statvfs statvfs_buf;
-	int result;
-
-	result = statvfs(path, &statvfs_buf);
+	statbuf->OptimalTransferSize = sbuf.f_iosize;
+	statbuf->BlockSize = sbuf.f_bsize;
+	statbuf->TotalBlocks = sbuf.f_blocks;
+	statbuf->BlocksAvail = sbuf.f_bfree;
+	statbuf->UserBlocksAvail = sbuf.f_bavail;
+	statbuf->TotalFileNodes = sbuf.f_files;
+	statbuf->FreeFileNodes = sbuf.f_ffree;
+	statbuf->FsIdentifier = *(uint64_t *)(&sbuf.f_fsid); /* Ick. */
+	statbuf->FsCapabilities = darwin_fs_capabilities(sbuf.f_mntonname);
 
-	if (!result) {
-		statbuf->OptimalTransferSize = statvfs_buf.f_frsize;
-		statbuf->BlockSize = statvfs_buf.f_bsize;
-		statbuf->TotalBlocks = statvfs_buf.f_blocks;
-		statbuf->BlocksAvail = statvfs_buf.f_bfree;
-		statbuf->UserBlocksAvail = statvfs_buf.f_bavail;
-		statbuf->TotalFileNodes = statvfs_buf.f_files;
-		statbuf->FreeFileNodes = statvfs_buf.f_ffree;
-		statbuf->FsIdentifier = statvfs_buf.f_fsid;
-		/* Try to extrapolate some of the fs flags into the
-		 * capabilities
-		 */
-		statbuf->FsCapabilities =
-		    FILE_CASE_SENSITIVE_SEARCH | FILE_CASE_PRESERVED_NAMES;
-#ifdef ST_QUOTA
-		if (statvfs_buf.f_flag & ST_QUOTA)
-			statbuf->FsCapabilities |= FILE_VOLUME_QUOTAS;
-#endif
-		if (statvfs_buf.f_flag & ST_RDONLY)
-			statbuf->FsCapabilities |= FILE_READ_ONLY_VOLUME;
-	}
-	return result;
+	return 0;
 }
 #endif
 
@@ -151,14 +131,14 @@
  sys_statvfs() is an abstraction layer over system-dependent statvfs()/statfs()
  for particular POSIX systems. Due to controversy of what is considered more important
  between LSB and FreeBSD/POSIX.1 (IEEE Std 1003.1-2001) we need to abstract the interface
- so that particular OS would use its prefered interface.
+ so that particular OS would use its preffered interface.
 */
 int sys_statvfs(const char *path, vfs_statvfs_struct *statbuf)
 {
-#if defined(BSD_STYLE_STATVFS)
-	return bsd_statvfs(path, statbuf);
-#elif defined(STAT_STATVFS) && defined(HAVE_FSID_INT)
+#if defined(LINUX) && defined(HAVE_FSID_INT)
 	return linux_statvfs(path, statbuf);
+#elif defined(DARWINOS)
+	return darwin_statvfs(path, statbuf);
 #else
 	/* BB change this to return invalid level */
 #ifdef EOPNOTSUPP
Only in ../../samba-3.6.24/source3/smbd: statvfs.o
diff -ur smbd/trans2.c ../../samba-3.6.24/source3/smbd/trans2.c
--- smbd/trans2.c	2013-10-07 16:49:10.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/trans2.c	2015-01-28 10:52:25.149068676 +0800
@@ -32,13 +32,12 @@
 #include "../libcli/auth/libcli_auth.h"
 #include "../librpc/gen_ndr/xattr.h"
 #include "../librpc/gen_ndr/ndr_security.h"
-#include "../librpc/gen_ndr/open_files.h"
 #include "libcli/security/security.h"
 #include "trans2.h"
 #include "auth.h"
 #include "smbprofile.h"
 #include "rpc_server/srv_pipe_hnd.h"
-#include "printing.h"
+#include "libsmb/libsmb.h"
 
 #define DIR_ENTRY_SAFETY_MARGIN 4096
 
@@ -53,30 +52,6 @@
 				const SMB_STRUCT_STAT *psbuf);
 
 /********************************************************************
- The canonical "check access" based on object handle or path function.
-********************************************************************/
-
-NTSTATUS check_access(connection_struct *conn,
-				files_struct *fsp,
-				const struct smb_filename *smb_fname,
-				uint32_t access_mask)
-{
-	if (fsp) {
-		if (!(fsp->access_mask & access_mask)) {
-			return NT_STATUS_ACCESS_DENIED;
-		}
-	} else {
-		NTSTATUS status = smbd_check_access_rights(conn,
-					smb_fname,
-					access_mask);
-		if (!NT_STATUS_IS_OK(status)) {
-			return status;
-		}
-	}
-	return NT_STATUS_OK;
-}
-
-/********************************************************************
  Roundup a value to the nearest allocation roundup size boundary.
  Only do this for Windows clients.
 ********************************************************************/
@@ -134,7 +109,7 @@
 		if (strequal( prohibited_ea_names[i], unix_ea_name))
 			return true;
 	}
-	if (strncasecmp_m(unix_ea_name, SAMBA_XATTR_DOSSTREAM_PREFIX,
+	if (StrnCaseCmp(unix_ea_name, SAMBA_XATTR_DOSSTREAM_PREFIX,
 			strlen(SAMBA_XATTR_DOSSTREAM_PREFIX)) == 0) {
 		return true;
 	}
@@ -156,7 +131,7 @@
 
  again:
 
-	val = talloc_realloc(mem_ctx, val, char, attr_size);
+	val = TALLOC_REALLOC_ARRAY(mem_ctx, val, char, attr_size);
 	if (!val) {
 		return NT_STATUS_NO_MEMORY;
 	}
@@ -219,7 +194,7 @@
 	 * TALLOC the result early to get the talloc hierarchy right.
 	 */
 
-	names = talloc_array(mem_ctx, char *, 1);
+	names = TALLOC_ARRAY(mem_ctx, char *, 1);
 	if (names == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		return NT_STATUS_NO_MEMORY;
@@ -227,7 +202,7 @@
 
 	while (ea_namelist_size <= 65536) {
 
-		ea_namelist = talloc_realloc(
+		ea_namelist = TALLOC_REALLOC_ARRAY(
 			names, ea_namelist, char, ea_namelist_size);
 		if (ea_namelist == NULL) {
 			DEBUG(0, ("talloc failed\n"));
@@ -286,7 +261,7 @@
 		num_names += 1;
 	}
 
-	tmp = talloc_realloc(mem_ctx, names, char *, num_names);
+	tmp = TALLOC_REALLOC_ARRAY(mem_ctx, names, char *, num_names);
 	if (tmp == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		TALLOC_FREE(names);
@@ -313,8 +288,8 @@
  Return a linked list of the total EA's. Plus the total size
 ****************************************************************************/
 
-static NTSTATUS get_ea_list_from_file_path(TALLOC_CTX *mem_ctx, connection_struct *conn, files_struct *fsp,
-				      const char *fname, size_t *pea_total_len, struct ea_list **ea_list)
+static struct ea_list *get_ea_list_from_file(TALLOC_CTX *mem_ctx, connection_struct *conn, files_struct *fsp,
+					const char *fname, size_t *pea_total_len)
 {
 	/* Get a list of all xattrs. Max namesize is 64k. */
 	size_t i, num_names;
@@ -323,18 +298,16 @@
 	NTSTATUS status;
 
 	*pea_total_len = 0;
-	*ea_list = NULL;
+
+	if (!lp_ea_support(SNUM(conn))) {
+		return NULL;
+	}
 
 	status = get_ea_names_from_file(talloc_tos(), conn, fsp, fname,
 					&names, &num_names);
 
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
-	if (num_names == 0) {
-		*ea_list = NULL;
-		return NT_STATUS_OK;
+	if (!NT_STATUS_IS_OK(status) || (num_names == 0)) {
+		return NULL;
 	}
 
 	for (i=0; i<num_names; i++) {
@@ -345,27 +318,15 @@
 		    || samba_private_attr_name(names[i]))
 			continue;
 
-		/*
-		 * Filter out any underlying POSIX EA names
-		 * that a Windows client can't handle.
-		 */
-		if (!lp_posix_pathnames() &&
-				is_invalid_windows_ea_name(names[i])) {
-			continue;
-		}
-
-		listp = talloc(mem_ctx, struct ea_list);
+		listp = TALLOC_P(mem_ctx, struct ea_list);
 		if (listp == NULL) {
-			return NT_STATUS_NO_MEMORY;
+			return NULL;
 		}
 
-		status = get_ea_value(listp, conn, fsp,
-				      fname, names[i],
-				      &listp->ea);
-
-		if (!NT_STATUS_IS_OK(status)) {
-			TALLOC_FREE(listp);
-			return status;
+		if (!NT_STATUS_IS_OK(get_ea_value(mem_ctx, conn, fsp,
+						  fname, names[i],
+						  &listp->ea))) {
+			return NULL;
 		}
 
 		if (listp->ea.value.length == 0) {
@@ -398,25 +359,7 @@
 	DEBUG(10, ("get_ea_list_from_file: total_len = %u\n",
 		   (unsigned int)*pea_total_len));
 
-	*ea_list = ea_list_head;
-	return NT_STATUS_OK;
-}
-
-static NTSTATUS get_ea_list_from_file(TALLOC_CTX *mem_ctx, connection_struct *conn, files_struct *fsp,
-				      const struct smb_filename *smb_fname, size_t *pea_total_len, struct ea_list **ea_list)
-{
-	*pea_total_len = 0;
-	*ea_list = NULL;
-
-	if (!lp_ea_support(SNUM(conn))) {
-		return NT_STATUS_OK;
-	}
-
-	if (is_ntfs_stream_smb_fname(smb_fname)) {
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	return get_ea_list_from_file_path(mem_ctx, conn, fsp, smb_fname->base_name, pea_total_len, ea_list);
+	return ea_list_head;
 }
 
 /****************************************************************************
@@ -456,7 +399,7 @@
 		SCVAL(p,0,ea_list->ea.flags);
 		SCVAL(p,1,dos_namelen);
 		SSVAL(p,2,ea_list->ea.value.length);
-		strlcpy(p+4, dos_ea_name, dos_namelen+1);
+		fstrcpy(p+4, dos_ea_name);
 		memcpy( p + 4 + dos_namelen + 1, ea_list->ea.value.data, ea_list->ea.value.length);
 
 		total_data_size -= 4 + dos_namelen + 1 + ea_list->ea.value.length;
@@ -478,7 +421,7 @@
 {
 	uint8_t *p = (uint8_t *)pdata;
 	uint8_t *last_start = NULL;
-	bool do_store_data = (pdata != NULL);
+	bool store_data = (pdata != NULL);
 
 	*ret_data_size = 0;
 
@@ -492,7 +435,7 @@
 		size_t this_size;
 		size_t pad = 0;
 
-		if (last_start != NULL && do_store_data) {
+		if (last_start && store_data) {
 			SIVAL(last_start, 0, PTR_DIFF(p, last_start));
 		}
 		last_start = p;
@@ -513,26 +456,26 @@
 			this_size += pad;
 		}
 
-		if (do_store_data) {
-			if (this_size > total_data_size) {
-				return NT_STATUS_INFO_LENGTH_MISMATCH;
-			}
+		if (this_size > total_data_size) {
+			return NT_STATUS_INFO_LENGTH_MISMATCH;
+		}
 
-			/* We know we have room. */
+		/* We know we have room. */
+		if (store_data) {
 			SIVAL(p, 0x00, 0); /* next offset */
 			SCVAL(p, 0x04, ea_list->ea.flags);
 			SCVAL(p, 0x05, dos_namelen);
 			SSVAL(p, 0x06, ea_list->ea.value.length);
-			strlcpy((char *)(p+0x08), dos_ea_name, dos_namelen+1);
+			fstrcpy((char *)(p+0x08), dos_ea_name);
 			memcpy(p + 0x08 + dos_namelen + 1, ea_list->ea.value.data, ea_list->ea.value.length);
 			if (pad) {
 				memset(p + 0x08 + dos_namelen + 1 + ea_list->ea.value.length,
 					'\0',
 					pad);
 			}
-			total_data_size -= this_size;
 		}
 
+		total_data_size -= this_size;
 		p += this_size;
 	}
 
@@ -541,25 +484,20 @@
 	return NT_STATUS_OK;
 }
 
-static unsigned int estimate_ea_size(connection_struct *conn, files_struct *fsp, const struct smb_filename *smb_fname)
+static unsigned int estimate_ea_size(connection_struct *conn, files_struct *fsp, const char *fname)
 {
 	size_t total_ea_len = 0;
-	TALLOC_CTX *mem_ctx;
 	struct ea_list *ea_list = NULL;
+	TALLOC_CTX *mem_ctx = NULL;
 
 	if (!lp_ea_support(SNUM(conn))) {
 		return 0;
 	}
-	mem_ctx = talloc_stackframe();
-
-	/* If this is a stream fsp, then we need to instead find the
-	 * estimated ea len from the main file, not the stream
-	 * (streams cannot have EAs), but the estimate isn't just 0 in
-	 * this case! */
-	if (is_ntfs_stream_smb_fname(smb_fname)) {
-		fsp = NULL;
+	mem_ctx = talloc_tos();
+	ea_list = get_ea_list_from_file(mem_ctx, conn, fsp, fname, &total_ea_len);
+	if (ea_list == NULL) {
+		return 0;
 	}
-	(void)get_ea_list_from_file_path(mem_ctx, conn, fsp, smb_fname->base_name, &total_ea_len, &ea_list);
 	if(conn->sconn->using_smb2) {
 		NTSTATUS status;
 		unsigned int ret_data_size;
@@ -571,7 +509,7 @@
 		 */
 		status = fill_ea_chained_buffer(mem_ctx,
 						NULL,
-						0,
+						65535,
 						&ret_data_size,
 						conn,
 						ea_list);
@@ -580,7 +518,7 @@
 		}
 		total_ea_len = ret_data_size;
 	}
-	TALLOC_FREE(mem_ctx);
+
 	return total_ea_len;
 }
 
@@ -592,17 +530,13 @@
 {
 	size_t total_ea_len;
 	TALLOC_CTX *mem_ctx = talloc_tos();
-	struct ea_list *ea_list;
-	NTSTATUS status = get_ea_list_from_file_path(mem_ctx, conn, fsp, fname, &total_ea_len, &ea_list);
-	if (!NT_STATUS_IS_OK(status)) {
-		return;
-	}
+	struct ea_list *ea_list = get_ea_list_from_file(mem_ctx, conn, fsp, fname, &total_ea_len);
 
 	for (; ea_list; ea_list = ea_list->next) {
 		if (strequal(&unix_ea_name[5], ea_list->ea.name)) {
 			DEBUG(10,("canonicalize_ea_name: %s -> %s\n",
 				&unix_ea_name[5], ea_list->ea.name));
-			strlcpy(&unix_ea_name[5], ea_list->ea.name, sizeof(fstring)-5);
+			safe_strcpy(&unix_ea_name[5], ea_list->ea.name, sizeof(fstring)-6);
 			break;
 		}
 	}
@@ -615,32 +549,17 @@
 NTSTATUS set_ea(connection_struct *conn, files_struct *fsp,
 		const struct smb_filename *smb_fname, struct ea_list *ea_list)
 {
-	NTSTATUS status;
 	char *fname = NULL;
 
 	if (!lp_ea_support(SNUM(conn))) {
 		return NT_STATUS_EAS_NOT_SUPPORTED;
 	}
 
-	status = check_access(conn, fsp, smb_fname, FILE_WRITE_EA);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
-	/* Setting EAs on streams isn't supported. */
-	if (is_ntfs_stream_smb_fname(smb_fname)) {
-		return NT_STATUS_INVALID_PARAMETER;
-	}
-
-	/*
-	 * Filter out invalid Windows EA names - before
-	 * we set *any* of them.
-	 */
-
-	if (ea_list_has_invalid_name(ea_list)) {
-		return STATUS_INVALID_EA_NAME;
+	if (fsp && !(fsp->access_mask & FILE_WRITE_EA)) {
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
+	/* For now setting EAs on streams isn't supported. */
 	fname = smb_fname->base_name;
 
 	for (;ea_list; ea_list = ea_list->next) {
@@ -716,7 +635,7 @@
 	size_t converted_size, offset = 0;
 
 	while (offset + 2 < data_size) {
-		struct ea_list *eal = talloc_zero(ctx, struct ea_list);
+		struct ea_list *eal = TALLOC_ZERO_P(ctx, struct ea_list);
 		unsigned int namelen = CVAL(pdata,offset);
 
 		offset++; /* Go past the namelen byte. */
@@ -754,7 +673,7 @@
 
 struct ea_list *read_ea_list_entry(TALLOC_CTX *ctx, const char *pdata, size_t data_size, size_t *pbytes_used)
 {
-	struct ea_list *eal = talloc_zero(ctx, struct ea_list);
+	struct ea_list *eal = TALLOC_ZERO_P(ctx, struct ea_list);
 	uint16 val_len;
 	unsigned int namelen;
 	size_t converted_size;
@@ -896,7 +815,6 @@
 
 void send_trans2_replies(connection_struct *conn,
 			struct smb_request *req,
-			NTSTATUS status,
 			 const char *params,
 			 int paramsize,
 			 const char *pdata,
@@ -937,14 +855,6 @@
 
 	if(params_to_send == 0 && data_to_send == 0) {
 		reply_outbuf(req, 10, 0);
-		if (NT_STATUS_V(status)) {
-			uint8_t eclass;
-			uint32_t ecode;
-			ntstatus_to_dos(status, &eclass, &ecode);
-			error_packet_set((char *)req->outbuf,
-					eclass, ecode, status,
-					__LINE__,__FILE__);
-		}
 		show_msg((char *)req->outbuf);
 		if (!srv_send_smb(sconn,
 				(char *)req->outbuf,
@@ -1075,13 +985,6 @@
 					 ERRDOS,ERRbufferoverflow,
 					 STATUS_BUFFER_OVERFLOW,
 					 __LINE__,__FILE__);
-		} else if (NT_STATUS_V(status)) {
-			uint8_t eclass;
-			uint32_t ecode;
-			ntstatus_to_dos(status, &eclass, &ecode);
-			error_packet_set((char *)req->outbuf,
-					eclass, ecode, status,
-					__LINE__,__FILE__);
 		}
 
 		/* Send the packet */
@@ -1137,7 +1040,7 @@
 	uint32 open_size;
 	char *pname;
 	char *fname = NULL;
-	off_t size=0;
+	SMB_OFF_T size=0;
 	int fattr=0,mtime=0;
 	SMB_INO_T inode = 0;
 	int smb_action = 0;
@@ -1253,20 +1156,6 @@
 			reply_nterror(req, NT_STATUS_EAS_NOT_SUPPORTED);
 			goto out;
 		}
-
-		if (ea_list_has_invalid_name(ea_list)) {
-			int param_len = 30;
-			*pparams = (char *)SMB_REALLOC(*pparams, param_len);
-			if(*pparams == NULL ) {
-				reply_nterror(req, NT_STATUS_NO_MEMORY);
-				goto out;
-			}
-			params = *pparams;
-			memset(params, '\0', param_len);
-			send_trans2_replies(conn, req, STATUS_INVALID_EA_NAME,
-				params, param_len, NULL, 0, max_data_bytes);
-			goto out;
-		}
 	}
 
 	status = SMB_VFS_CREATE_FILE(
@@ -1288,7 +1177,7 @@
 		&smb_action);				/* psbuf */
 
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			goto out;
 		}
@@ -1335,14 +1224,14 @@
 	SSVAL(params,24,0); /* Padding. */
 	if (flags & 8) {
 		uint32 ea_size = estimate_ea_size(conn, fsp,
-						  smb_fname);
+						  fsp->fsp_name->base_name);
 		SIVAL(params, 26, ea_size);
 	} else {
 		SIVAL(params, 26, 0);
 	}
 
 	/* Send the required number of replies */
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 30, *ppdata, 0, max_data_bytes);
+	send_trans2_replies(conn, req, params, 30, *ppdata, 0, max_data_bytes);
  out:
 	TALLOC_FREE(smb_fname);
 }
@@ -1370,7 +1259,7 @@
 	if (case_sensitive) {
 		return strcmp(str,mask)==0;
 	} else {
-		return strcasecmp_m(str,mask) == 0;
+		return StrCaseCmp(str,mask) == 0;
 	}
 }
 
@@ -1451,22 +1340,30 @@
 	ret |= ((perms & UNIX_SET_UID ) ? S_ISUID : 0);
 #endif
 
-	if (ptype == PERM_NEW_FILE) {
-		/*
-		 * "create mask"/"force create mode" are
-		 * only applied to new files, not existing ones.
-		 */
+	switch (ptype) {
+	case PERM_NEW_FILE:
+		/* Apply mode mask */
 		ret &= lp_create_mask(SNUM(conn));
 		/* Add in force bits */
 		ret |= lp_force_create_mode(SNUM(conn));
-	} else if (ptype == PERM_NEW_DIR) {
-		/*
-		 * "directory mask"/"force directory mode" are
-		 * only applied to new directories, not existing ones.
-		 */
+		break;
+	case PERM_NEW_DIR:
 		ret &= lp_dir_mask(SNUM(conn));
 		/* Add in force bits */
 		ret |= lp_force_dir_mode(SNUM(conn));
+		break;
+	case PERM_EXISTING_FILE:
+		/* Apply mode mask */
+		ret &= lp_security_mask(SNUM(conn));
+		/* Add in force bits */
+		ret |= lp_force_security_mode(SNUM(conn));
+		break;
+	case PERM_EXISTING_DIR:
+		/* Apply mode mask */
+		ret &= lp_dir_security_mask(SNUM(conn));
+		/* Add in force bits */
+		ret |= lp_force_dir_security_mode(SNUM(conn));
+		break;
 	}
 
 	*ret_perms = ret;
@@ -1654,6 +1551,7 @@
 	uint32_t len;
 	struct timespec mdate_ts, adate_ts, cdate_ts, create_date_ts;
 	time_t mdate = (time_t)0, adate = (time_t)0, create_date = (time_t)0;
+	time_t c_date = (time_t)0;
 	char *nameptr;
 	char *last_entry_ptr;
 	bool was_8_3;
@@ -1689,6 +1587,7 @@
 	create_date = convert_timespec_to_time_t(create_date_ts);
 	mdate = convert_timespec_to_time_t(mdate_ts);
 	adate = convert_timespec_to_time_t(adate_ts);
+	c_date = convert_timespec_to_time_t(cdate_ts);
 
 	/* align the record */
 	SMB_ASSERT(align >= 1);
@@ -1774,7 +1673,7 @@
 		SSVAL(p,20,mode);
 		{
 			unsigned int ea_size = estimate_ea_size(conn, NULL,
-								smb_fname);
+								smb_fname->base_name);
 			SIVAL(p,22,ea_size); /* Extended attributes */
 		}
 		p += 27;
@@ -1804,7 +1703,6 @@
 	{
 		struct ea_list *file_list = NULL;
 		size_t ea_len = 0;
-		NTSTATUS status;
 
 		DEBUG(10,("smbd_marshall_dir_entry: SMB_FIND_EA_LIST\n"));
 		if (!name_list) {
@@ -1822,12 +1720,9 @@
 		SSVAL(p,20,mode);
 		p += 22; /* p now points to the EA area. */
 
-		status = get_ea_list_from_file(ctx, conn, NULL,
-					       smb_fname,
-					       &ea_len, &file_list);
-		if (!NT_STATUS_IS_OK(status)) {
-			file_list = NULL;
-		}
+		file_list = get_ea_list_from_file(ctx, conn, NULL,
+						  smb_fname->base_name,
+						  &ea_len);
 		name_list = ea_list_union(name_list, file_list, &ea_len);
 
 		/* We need to determine if this entry will fit in the space available. */
@@ -1883,7 +1778,7 @@
 			SIVAL(p, 0, IO_REPARSE_TAG_DFS);
 		} else {
 			unsigned int ea_size = estimate_ea_size(conn, NULL,
-								smb_fname);
+								smb_fname->base_name);
 			SIVAL(p,0,ea_size); /* Extended attributes */
 		}
 		p += 4;
@@ -1985,7 +1880,7 @@
 		q = p; p += 4; /* q is placeholder for name length. */
 		{
 			unsigned int ea_size = estimate_ea_size(conn, NULL,
-								smb_fname);
+								smb_fname->base_name);
 			SIVAL(p,0,ea_size); /* Extended attributes */
 			p +=4;
 		}
@@ -2062,10 +1957,10 @@
 			SIVAL(p, 0, IO_REPARSE_TAG_DFS);
 		} else {
 			unsigned int ea_size = estimate_ea_size(conn, NULL,
-								smb_fname);
+								smb_fname->base_name);
 			SIVAL(p,0,ea_size); /* Extended attributes */
 		}
-		p += 4;
+		p +=4;
 		SIVAL(p,0,0); p += 4; /* Unknown - reserved ? */
 		SBVAL(p,0,file_index); p += 8;
 		len = srvstr_push(base_data, flags2, p,
@@ -2110,10 +2005,10 @@
 			SIVAL(p, 0, IO_REPARSE_TAG_DFS);
 		} else {
 			unsigned int ea_size = estimate_ea_size(conn, NULL,
-								smb_fname);
+								smb_fname->base_name);
 			SIVAL(p,0,ea_size); /* Extended attributes */
 		}
-		p += 4;
+		p +=4;
 		/* Clear the short name buffer. This is
 		 * IMPORTANT as not doing so will trigger
 		 * a Win2k client bug. JRA.
@@ -2421,7 +2316,6 @@
 	struct dptr_struct *dirptr = NULL;
 	struct smbd_server_connection *sconn = req->sconn;
 	uint32_t ucf_flags = (UCF_SAVE_LCOMP | UCF_ALWAYS_ALLOW_WCARD_LCOMP);
-	bool backup_priv = false;
 
 	if (total_params < 13) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
@@ -2434,16 +2328,11 @@
 	close_after_first = (findfirst_flags & FLAG_TRANS2_FIND_CLOSE);
 	close_if_end = (findfirst_flags & FLAG_TRANS2_FIND_CLOSE_IF_END);
 	requires_resume_key = (findfirst_flags & FLAG_TRANS2_FIND_REQUIRE_RESUME);
-	backup_priv = ((findfirst_flags & FLAG_TRANS2_FIND_BACKUP_INTENT) &&
-				security_token_has_privilege(get_current_nttok(conn),
-						SEC_PRIV_BACKUP));
-
 	info_level = SVAL(params,6);
 
 	DEBUG(3,("call_trans2findfirst: dirtype = %x, maxentries = %d, close_after_first=%d, \
-close_if_end = %d requires_resume_key = %d backup_priv = %d level = 0x%x, max_data_bytes = %d\n",
+close_if_end = %d requires_resume_key = %d level = 0x%x, max_data_bytes = %d\n",
 		(unsigned int)dirtype, maxentries, close_after_first, close_if_end, requires_resume_key,
-		(int)backup_priv,
 		info_level, max_data_bytes));
 
 	if (!maxentries) {
@@ -2485,24 +2374,12 @@
 		goto out;
 	}
 
-	if (backup_priv) {
-		become_root();
-		ntstatus = filename_convert_with_privilege(ctx,
-				conn,
-				req,
-				directory,
-				ucf_flags,
-				&mask_contains_wcard,
-				&smb_dname);
-	} else {
-		ntstatus = filename_convert(ctx, conn,
+	ntstatus = filename_convert(ctx, conn,
 				    req->flags2 & FLAGS2_DFS_PATHNAMES,
 				    directory,
 				    ucf_flags,
 				    &mask_contains_wcard,
 				    &smb_dname);
-	}
-
 	if (!NT_STATUS_IS_OK(ntstatus)) {
 		if (NT_STATUS_EQUAL(ntstatus,NT_STATUS_PATH_NOT_COVERED)) {
 			reply_botherror(req, NT_STATUS_PATH_NOT_COVERED,
@@ -2593,7 +2470,6 @@
 		needed as lanman2 assumes these are being saved between calls */
 
 	ntstatus = dptr_create(conn,
-				req,
 				NULL, /* fsp */
 				directory,
 				False,
@@ -2609,12 +2485,6 @@
 		goto out;
 	}
 
-	if (backup_priv) {
-		/* Remember this in case we have
-		   to do a findnext. */
-		dptr_set_priv(dirptr);
-	}
-
 	dptr_num = dptr_dnum(dirptr);
 	DEBUG(4,("dptr_num is %d, wcard = %s, attr = %d\n", dptr_num, mask, dirtype));
 
@@ -2625,8 +2495,8 @@
 		a different TRANS2 call. */
 
 	DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-		 directory,lp_dontdescend(ctx, SNUM(conn))));
-	if (in_list(directory,lp_dontdescend(ctx, SNUM(conn)),conn->case_sensitive))
+		directory,lp_dontdescend(SNUM(conn))));
+	if (in_list(directory,lp_dontdescend(SNUM(conn)),conn->case_sensitive))
 		dont_descend = True;
 
 	p = pdata;
@@ -2714,7 +2584,7 @@
 	SSVAL(params,6,0); /* Never an EA error */
 	SSVAL(params,8,last_entry_off);
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 10, pdata, PTR_DIFF(p,pdata),
+	send_trans2_replies(conn, req, params, 10, pdata, PTR_DIFF(p,pdata),
 			    max_data_bytes);
 
 	if ((! *directory) && dptr_path(sconn, dptr_num)) {
@@ -2741,11 +2611,6 @@
 		name_to_8_3(mask, mangled_name, True, conn->params);
 	}
  out:
-
-	if (backup_priv) {
-		unbecome_root();
-	}
-
 	TALLOC_FREE(smb_dname);
 	return;
 }
@@ -2795,7 +2660,6 @@
 	TALLOC_CTX *ctx = talloc_tos();
 	struct dptr_struct *dirptr;
 	struct smbd_server_connection *sconn = req->sconn;
-	bool backup_priv = false; 
 
 	if (total_params < 13) {
 		reply_nterror(req, NT_STATUS_INVALID_PARAMETER);
@@ -2929,23 +2793,21 @@
 	directory = dptr_path(sconn, dptr_num);
 
 	/* Get the wildcard mask from the dptr */
-	if((mask = dptr_wcard(sconn, dptr_num))== NULL) {
+	if((p = dptr_wcard(sconn, dptr_num))== NULL) {
 		DEBUG(2,("dptr_num %d has no wildcard\n", dptr_num));
 		reply_nterror(req, STATUS_NO_MORE_FILES);
 		return;
 	}
 
+	mask = p;
+
 	/* Get the attr mask from the dptr */
 	dirtype = dptr_attr(sconn, dptr_num);
 
-	backup_priv = dptr_get_priv(dirptr);
-
-	DEBUG(3,("dptr_num is %d, mask = %s, attr = %x, dirptr=(0x%lX,%ld) "
-		"backup_priv = %d\n",
+	DEBUG(3,("dptr_num is %d, mask = %s, attr = %x, dirptr=(0x%lX,%ld)\n",
 		dptr_num, mask, dirtype,
 		(long)dirptr,
-		dptr_TellDir(dirptr),
-		(int)backup_priv));
+		dptr_TellDir(dirptr)));
 
 	/* Initialize per TRANS2_FIND_NEXT operation data */
 	dptr_init_search_op(dirptr);
@@ -2954,18 +2816,14 @@
 		a different TRANS2 call. */
 
 	DEBUG(8,("dirpath=<%s> dontdescend=<%s>\n",
-		 directory,lp_dontdescend(ctx, SNUM(conn))));
-	if (in_list(directory,lp_dontdescend(ctx, SNUM(conn)),conn->case_sensitive))
+		 directory,lp_dontdescend(SNUM(conn))));
+	if (in_list(directory,lp_dontdescend(SNUM(conn)),conn->case_sensitive))
 		dont_descend = True;
 
 	p = pdata;
 	space_remaining = max_data_bytes;
 	out_of_space = False;
 
-	if (backup_priv) {
-		become_root();
-	}
-
 	/*
 	 * Seek to the correct position. We no longer use the resume key but
 	 * depend on the last file name instead.
@@ -3055,17 +2913,13 @@
 		dptr_close(sconn, &dptr_num); /* This frees up the saved mask */
 	}
 
-	if (backup_priv) {
-		unbecome_root();
-	}
-
 	/* Set up the return parameter block */
 	SSVAL(params,0,numentries);
 	SSVAL(params,2,finished);
 	SSVAL(params,4,0); /* Never an EA error */
 	SSVAL(params,6,last_entry_off);
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 8, pdata, PTR_DIFF(p,pdata),
+	send_trans2_replies(conn, req, params, 8, pdata, PTR_DIFF(p,pdata),
 			    max_data_bytes);
 
 	return;
@@ -3073,7 +2927,7 @@
 
 unsigned char *create_volume_objectid(connection_struct *conn, unsigned char objid[16])
 {
-	E_md4hash(lp_servicename(talloc_tos(), SNUM(conn)),objid);
+	E_md4hash(lp_servicename(SNUM(conn)),objid);
 	return objid;
 }
 
@@ -3124,10 +2978,10 @@
 {
 	char *pdata, *end_data;
 	int data_len = 0, len;
-	const char *vname = volume_label(talloc_tos(), SNUM(conn));
+	const char *vname = volume_label(SNUM(conn));
 	int snum = SNUM(conn);
-	char *fstype = lp_fstype(talloc_tos(), SNUM(conn));
-	char *filename = NULL;
+	char *fstype = lp_fstype(SNUM(conn));
+	const char *filename = NULL;
 	uint32 additional_flags = 0;
 	struct smb_filename smb_fname;
 	SMB_STRUCT_STAT st;
@@ -3215,7 +3069,7 @@
 			 * Add volume serial number - hash of a combination of
 			 * the called hostname and the service name.
 			 */
-			SIVAL(pdata,0,str_checksum(lp_servicename(talloc_tos(), snum)) ^ (str_checksum(get_local_machine_name())<<16) );
+			SIVAL(pdata,0,str_checksum(lp_servicename(snum)) ^ (str_checksum(get_local_machine_name())<<16) );
 			/*
 			 * Win2k3 and previous mess this up by sending a name length
 			 * one byte short. I believe only older clients (OS/2 Win9x) use
@@ -3288,7 +3142,7 @@
 			 * Add volume serial number - hash of a combination of
 			 * the called hostname and the service name.
 			 */
-			SIVAL(pdata,8,str_checksum(lp_servicename(talloc_tos(), snum)) ^
+			SIVAL(pdata,8,str_checksum(lp_servicename(snum)) ^ 
 				(str_checksum(get_local_machine_name())<<16));
 
 			/* Max label len is 32 characters. */
@@ -3299,15 +3153,14 @@
 			data_len = 18+len;
 
 			DEBUG(5,("smbd_do_qfsinfo : SMB_QUERY_FS_VOLUME_INFO namelen = %d, vol=%s serv=%s\n",
-				(int)strlen(vname),vname,
-				lp_servicename(talloc_tos(), snum)));
+				(int)strlen(vname),vname, lp_servicename(snum)));
 			if (max_data_bytes >= 24 && data_len > max_data_bytes) {
 				/* the client only requested a portion of the
 				   volume label */
 				data_len = max_data_bytes;
 				status = STATUS_BUFFER_OVERFLOW;
 			}
-			*fixed_portion = 24;
+
 			break;
 
 		case SMB_QUERY_FS_SIZE_INFO:
@@ -3425,26 +3278,26 @@
 			ZERO_STRUCT(quotas);
 
 			fsp.conn = conn;
-			fsp.fnum = FNUM_FIELD_INVALID;
+			fsp.fnum = -1;
 
 			/* access check */
 			if (get_current_uid(conn) != 0) {
 				DEBUG(0,("set_user_quota: access_denied "
 					 "service [%s] user [%s]\n",
-					 lp_servicename(talloc_tos(), SNUM(conn)),
-					 conn->session_info->unix_info->unix_name));
+					 lp_servicename(SNUM(conn)),
+					 conn->session_info->unix_name));
 				return NT_STATUS_ACCESS_DENIED;
 			}
 
 			if (vfs_get_ntquota(&fsp, SMB_USER_FS_QUOTA_TYPE, NULL, &quotas)!=0) {
-				DEBUG(0,("vfs_get_ntquota() failed for service [%s]\n",lp_servicename(talloc_tos(), SNUM(conn))));
+				DEBUG(0,("vfs_get_ntquota() failed for service [%s]\n",lp_servicename(SNUM(conn))));
 				return map_nt_error_from_unix(errno);
 			}
 
 			data_len = 48;
 
 			DEBUG(10,("SMB_FS_QUOTA_INFORMATION: for service [%s]\n",
-				  lp_servicename(talloc_tos(), SNUM(conn))));
+				  lp_servicename(SNUM(conn))));
 
 			/* Unknown1 24 NULL bytes*/
 			SBIG_UINT(pdata,0,(uint64_t)0);
@@ -3499,14 +3352,14 @@
 			}
 
 			switch (conn->encrypt_level) {
-			case SMB_SIGNING_OFF:
+			case 0:
 				encrypt_caps = 0;
 				break;
-			case SMB_SIGNING_IF_REQUIRED:
-			case SMB_SIGNING_DEFAULT:
+			case 1:
+			case Auto:
 				encrypt_caps = CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP;
 				break;
-			case SMB_SIGNING_REQUIRED:
+			case Required:
 				encrypt_caps = CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP|
 						CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP;
 				large_write = false;
@@ -3561,9 +3414,10 @@
 				return NT_STATUS_INVALID_LEVEL;
 #endif /* EOPNOTSUPP */
 			} else {
-				DEBUG(0,("vfs_statvfs() failed for service [%s]\n",lp_servicename(talloc_tos(), SNUM(conn))));
+				DEBUG(0,("vfs_statvfs() failed for service [%s]\n",lp_servicename(SNUM(conn))));
 				return NT_STATUS_DOS(ERRSRV, ERRerror);
 			}
+			*fixed_portion = 24;
 			break;
 		}
 
@@ -3581,10 +3435,22 @@
 				return NT_STATUS_BUFFER_TOO_SMALL;
 			}
 
-			if (security_session_user_level(conn->session_info, NULL) < SECURITY_USER) {
+			/* We ARE guest if global_sid_Builtin_Guests is
+			 * in our list of SIDs.
+			 */
+			if (nt_token_check_sid(&global_sid_Builtin_Guests,
+					       conn->session_info->security_token)) {
 				flags |= SMB_WHOAMI_GUEST;
 			}
 
+			/* We are NOT guest if global_sid_Authenticated_Users
+			 * is in our list of SIDs.
+			 */
+			if (nt_token_check_sid(&global_sid_Authenticated_Users,
+					       conn->session_info->security_token)) {
+				flags &= ~SMB_WHOAMI_GUEST;
+			}
+
 			/* NOTE: 8 bytes for UID/GID, irrespective of native
 			 * platform size. This matches
 			 * SMB_QUERY_FILE_UNIX_BASIC and friends.
@@ -3597,7 +3463,7 @@
 			    + 4 /* num_sids */
 			    + 4 /* SID bytes */
 			    + 4 /* pad/reserved */
-			    + (conn->session_info->unix_token->ngroups * 8)
+			    + (conn->session_info->utok.ngroups * 8)
 				/* groups list */
 			    + (conn->session_info->security_token->num_sids *
 				    SID_MAX_SIZE)
@@ -3606,9 +3472,9 @@
 			SIVAL(pdata, 0, flags);
 			SIVAL(pdata, 4, SMB_WHOAMI_MASK);
 			SBIG_UINT(pdata, 8,
-				  (uint64_t)conn->session_info->unix_token->uid);
+				  (uint64_t)conn->session_info->utok.uid);
 			SBIG_UINT(pdata, 16,
-				  (uint64_t)conn->session_info->unix_token->gid);
+				  (uint64_t)conn->session_info->utok.gid);
 
 
 			if (data_len >= max_data_bytes) {
@@ -3623,7 +3489,7 @@
 				break;
 			}
 
-			SIVAL(pdata, 24, conn->session_info->unix_token->ngroups);
+			SIVAL(pdata, 24, conn->session_info->utok.ngroups);
 			SIVAL(pdata, 28, conn->session_info->security_token->num_sids);
 
 			/* We walk the SID list twice, but this call is fairly
@@ -3645,9 +3511,9 @@
 			data_len = 40;
 
 			/* GID list */
-			for (i = 0; i < conn->session_info->unix_token->ngroups; ++i) {
+			for (i = 0; i < conn->session_info->utok.ngroups; ++i) {
 				SBIG_UINT(pdata, data_len,
-					  (uint64_t)conn->session_info->unix_token->groups[i]);
+					  (uint64_t)conn->session_info->utok.groups[i]);
 				data_len += 8;
 			}
 
@@ -3671,7 +3537,7 @@
 			 * Thursby MAC extension... ONLY on NTFS filesystems
 			 * once we do streams then we don't need this
 			 */
-			if (strequal(lp_fstype(talloc_tos(), SNUM(conn)),"NTFS")) {
+			if (strequal(lp_fstype(SNUM(conn)),"NTFS")) {
 				data_len = 88;
 				SIVAL(pdata,84,0x100); /* Don't support mac... */
 				break;
@@ -3713,7 +3579,8 @@
 			DEBUG(0,("call_trans2qfsinfo: encryption required "
 				"and info level 0x%x sent.\n",
 				(unsigned int)info_level));
-			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+			exit_server_cleanly("encryption required "
+				"on connection");
 			return;
 		}
 	}
@@ -3732,7 +3599,7 @@
 		return;
 	}
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 0, *ppdata, data_len,
+	send_trans2_replies(conn, req, params, 0, *ppdata, data_len,
 			    max_data_bytes);
 
 	DEBUG( 4, ( "%s info_level = %d\n",
@@ -3751,13 +3618,11 @@
 				 char **ppdata, int total_data,
 				 unsigned int max_data_bytes)
 {
-	struct smbd_server_connection *sconn = req->sconn;
 	char *pdata = *ppdata;
 	char *params = *pparams;
 	uint16 info_level;
 
-	DEBUG(10,("call_trans2setfsinfo: for service [%s]\n",
-		  lp_servicename(talloc_tos(), SNUM(conn))));
+	DEBUG(10,("call_trans2setfsinfo: for service [%s]\n",lp_servicename(SNUM(conn))));
 
 	/*  */
 	if (total_params < 4) {
@@ -3785,62 +3650,62 @@
 			DEBUG(0,("call_trans2setfsinfo: encryption required "
 				"and info level 0x%x sent.\n",
 				(unsigned int)info_level));
-			reply_nterror(req, NT_STATUS_ACCESS_DENIED);
+			exit_server_cleanly("encryption required "
+				"on connection");
 			return;
 		}
 	}
 
 	switch(info_level) {
 		case SMB_SET_CIFS_UNIX_INFO:
-			if (!lp_unix_extensions()) {
-				DEBUG(2,("call_trans2setfsinfo: "
-					"SMB_SET_CIFS_UNIX_INFO is invalid with "
-					"unix extensions off\n"));
-				reply_nterror(req,
-					      NT_STATUS_INVALID_LEVEL);
-				return;
-			}
+			{
+				uint16 client_unix_major;
+				uint16 client_unix_minor;
+				uint32 client_unix_cap_low;
+				uint32 client_unix_cap_high;
 
-			/* There should be 12 bytes of capabilities set. */
-			if (total_data < 12) {
-				reply_nterror(
-					req,
-					NT_STATUS_INVALID_PARAMETER);
-				return;
-			}
-			sconn->smb1.unix_info.client_major = SVAL(pdata,0);
-			sconn->smb1.unix_info.client_minor = SVAL(pdata,2);
-			sconn->smb1.unix_info.client_cap_low = IVAL(pdata,4);
-			sconn->smb1.unix_info.client_cap_high = IVAL(pdata,8);
-			/* Just print these values for now. */
-			DEBUG(10, ("call_trans2setfsinfo: set unix_info info. "
-				   "major = %u, minor = %u cap_low = 0x%x, "
-				   "cap_high = 0x%xn",
-				   (unsigned int)sconn->
-				   smb1.unix_info.client_major,
-				   (unsigned int)sconn->
-				   smb1.unix_info.client_minor,
-				   (unsigned int)sconn->
-				   smb1.unix_info.client_cap_low,
-				   (unsigned int)sconn->
-				   smb1.unix_info.client_cap_high));
-
-			/* Here is where we must switch to posix pathname processing... */
-			if (sconn->smb1.unix_info.client_cap_low & CIFS_UNIX_POSIX_PATHNAMES_CAP) {
-				lp_set_posix_pathnames();
-				mangle_change_to_posix();
-			}
-
-			if ((sconn->smb1.unix_info.client_cap_low & CIFS_UNIX_FCNTL_LOCKS_CAP) &&
-			    !(sconn->smb1.unix_info.client_cap_low & CIFS_UNIX_POSIX_PATH_OPERATIONS_CAP)) {
-				/* Client that knows how to do posix locks,
-				 * but not posix open/mkdir operations. Set a
-				 * default type for read/write checks. */
+				if (!lp_unix_extensions()) {
+					reply_nterror(req,
+						      NT_STATUS_INVALID_LEVEL);
+					return;
+				}
+
+				/* There should be 12 bytes of capabilities set. */
+				if (total_data < 8) {
+					reply_nterror(
+						req,
+						NT_STATUS_INVALID_PARAMETER);
+					return;
+				}
+				client_unix_major = SVAL(pdata,0);
+				client_unix_minor = SVAL(pdata,2);
+				client_unix_cap_low = IVAL(pdata,4);
+				client_unix_cap_high = IVAL(pdata,8);
+				/* Just print these values for now. */
+				DEBUG(10,("call_trans2setfsinfo: set unix info. major = %u, minor = %u \
+cap_low = 0x%x, cap_high = 0x%x\n",
+					(unsigned int)client_unix_major,
+					(unsigned int)client_unix_minor,
+					(unsigned int)client_unix_cap_low,
+					(unsigned int)client_unix_cap_high ));
+
+				/* Here is where we must switch to posix pathname processing... */
+				if (client_unix_cap_low & CIFS_UNIX_POSIX_PATHNAMES_CAP) {
+					lp_set_posix_pathnames();
+					mangle_change_to_posix();
+				}
 
-				lp_set_posix_default_cifsx_readwrite_locktype(POSIX_LOCK);
+				if ((client_unix_cap_low & CIFS_UNIX_FCNTL_LOCKS_CAP) &&
+				    !(client_unix_cap_low & CIFS_UNIX_POSIX_PATH_OPERATIONS_CAP)) {
+					/* Client that knows how to do posix locks,
+					 * but not posix open/mkdir operations. Set a
+					 * default type for read/write checks. */
 
+					lp_set_posix_default_cifsx_readwrite_locktype(POSIX_LOCK);
+
+				}
+				break;
 			}
-			break;
 
 		case SMB_REQUEST_TRANSPORT_ENCRYPTION:
 			{
@@ -3855,7 +3720,7 @@
 					return;
 				}
 
-				if (lp_smb_encrypt(SNUM(conn)) == SMB_SIGNING_OFF) {
+				if (lp_smb_encrypt(SNUM(conn)) == false) {
 					reply_nterror(
 						req,
 						NT_STATUS_NOT_SUPPORTED);
@@ -3888,7 +3753,6 @@
 				}
 
 				send_trans2_replies(conn, req,
-						NT_STATUS_OK,
 						*pparams,
 						param_len,
 						*ppdata,
@@ -3900,11 +3764,9 @@
 					 * encryption is now *on*. */
 					status = srv_encryption_start(conn);
 					if (!NT_STATUS_IS_OK(status)) {
-						char *reason = talloc_asprintf(talloc_tos(),
-									       "Failure in setting "
-									       "up encrypted transport: %s",
-									       nt_errstr(status));
-						exit_server_cleanly(reason);
+						exit_server_cleanly(
+							"Failure in setting "
+							"up encrypted transport");
 					}
 				}
 				return;
@@ -3920,8 +3782,8 @@
 				/* access check */
 				if ((get_current_uid(conn) != 0) || !CAN_WRITE(conn)) {
 					DEBUG(0,("set_user_quota: access_denied service [%s] user [%s]\n",
-						 lp_servicename(talloc_tos(), SNUM(conn)),
-						 conn->session_info->unix_info->unix_name));
+						 lp_servicename(SNUM(conn)),
+						 conn->session_info->unix_name));
 					reply_nterror(req, NT_STATUS_ACCESS_DENIED);
 					return;
 				}
@@ -3964,7 +3826,7 @@
 
 				/* now set the quotas */
 				if (vfs_set_ntquota(fsp, SMB_USER_FS_QUOTA_TYPE, NULL, &quotas)!=0) {
-					DEBUG(0,("vfs_set_ntquota() failed for service [%s]\n",lp_servicename(talloc_tos(), SNUM(conn))));
+					DEBUG(0,("vfs_set_ntquota() failed for service [%s]\n",lp_servicename(SNUM(conn))));
 					reply_nterror(req, map_nt_error_from_unix(errno));
 					return;
 				}
@@ -3999,7 +3861,7 @@
 	int entry_id = SMB_ACL_FIRST_ENTRY;
 	SMB_ACL_ENTRY_T entry;
 
-	while ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {
+	while ( posix_acl && (SMB_VFS_SYS_ACL_GET_ENTRY(conn, posix_acl, entry_id, &entry) == 1)) {
 		/* get_next... */
 		if (entry_id == SMB_ACL_FIRST_ENTRY) {
 			entry_id = SMB_ACL_NEXT_ENTRY;
@@ -4018,7 +3880,7 @@
 	int entry_id = SMB_ACL_FIRST_ENTRY;
 	SMB_ACL_ENTRY_T entry;
 
-	while ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {
+	while ( posix_acl && (SMB_VFS_SYS_ACL_GET_ENTRY(conn, posix_acl, entry_id, &entry) == 1)) {
 		SMB_ACL_TAG_T tagtype;
 		SMB_ACL_PERMSET_T permset;
 		unsigned char perms = 0;
@@ -4029,19 +3891,19 @@
 			entry_id = SMB_ACL_NEXT_ENTRY;
 		}
 
-		if (sys_acl_get_tag_type(entry, &tagtype) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_TAG_TYPE(conn, entry, &tagtype) == -1) {
 			DEBUG(0,("marshall_posix_acl: SMB_VFS_SYS_ACL_GET_TAG_TYPE failed.\n"));
 			return False;
 		}
 
-		if (sys_acl_get_permset(entry, &permset) == -1) {
+		if (SMB_VFS_SYS_ACL_GET_PERMSET(conn, entry, &permset) == -1) {
 			DEBUG(0,("marshall_posix_acl: SMB_VFS_SYS_ACL_GET_PERMSET failed.\n"));
 			return False;
 		}
 
-		perms |= (sys_acl_get_perm(permset, SMB_ACL_READ) ? SMB_POSIX_ACL_READ : 0);
-		perms |= (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? SMB_POSIX_ACL_WRITE : 0);
-		perms |= (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? SMB_POSIX_ACL_EXECUTE : 0);
+		perms |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_READ) ? SMB_POSIX_ACL_READ : 0);
+		perms |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_WRITE) ? SMB_POSIX_ACL_WRITE : 0);
+		perms |= (SMB_VFS_SYS_ACL_GET_PERM(conn, permset, SMB_ACL_EXECUTE) ? SMB_POSIX_ACL_EXECUTE : 0);
 
 		SCVAL(pdata,1,perms);
 
@@ -4054,12 +3916,13 @@
 				break;
 			case SMB_ACL_USER:
 				{
-					uid_t *puid = (uid_t *)sys_acl_get_qualifier(entry);
+					uid_t *puid = (uid_t *)SMB_VFS_SYS_ACL_GET_QUALIFIER(conn, entry);
 					if (!puid) {
 						DEBUG(0,("marshall_posix_acl: SMB_VFS_SYS_ACL_GET_QUALIFIER failed.\n"));
 						return False;
 					}
 					own_grp = (unsigned int)*puid;
+					SMB_VFS_SYS_ACL_FREE_QUALIFIER(conn, (void *)puid,tagtype);
 					SCVAL(pdata,0,SMB_POSIX_ACL_USER);
 					SIVAL(pdata,2,own_grp);
 					SIVAL(pdata,6,0);
@@ -4073,12 +3936,13 @@
 				break;
 			case SMB_ACL_GROUP:
 				{
-					gid_t *pgid= (gid_t *)sys_acl_get_qualifier(entry);
+					gid_t *pgid= (gid_t *)SMB_VFS_SYS_ACL_GET_QUALIFIER(conn, entry);
 					if (!pgid) {
 						DEBUG(0,("marshall_posix_acl: SMB_VFS_SYS_ACL_GET_QUALIFIER failed.\n"));
 						return False;
 					}
 					own_grp = (unsigned int)*pgid;
+					SMB_VFS_SYS_ACL_FREE_QUALIFIER(conn, (void *)pgid,tagtype);
 					SCVAL(pdata,0,SMB_POSIX_ACL_GROUP);
 					SIVAL(pdata,2,own_grp);
 					SIVAL(pdata,6,0);
@@ -4115,7 +3979,6 @@
 				const SMB_STRUCT_STAT *psbuf)
 {
 	uint64_t file_index = get_FileIndex(conn, psbuf);
-	dev_t devno;
 
 	DEBUG(10,("store_file_unix_basic: SMB_QUERY_FILE_UNIX_BASIC\n"));
 	DEBUG(4,("store_file_unix_basic: st_mode=%o\n",(int)psbuf->st_ex_mode));
@@ -4142,17 +4005,11 @@
 	SIVAL(pdata,0,unix_filetype(psbuf->st_ex_mode));
 	pdata += 4;
 
-	if (S_ISBLK(psbuf->st_ex_mode) || S_ISCHR(psbuf->st_ex_mode)) {
-		devno = psbuf->st_ex_rdev;
-	} else {
-		devno = psbuf->st_ex_dev;
-	}
-
-	SIVAL(pdata,0,unix_dev_major(devno));   /* Major device number if type is device */
+	SIVAL(pdata,0,unix_dev_major(psbuf->st_ex_rdev));   /* Major device number if type is device */
 	SIVAL(pdata,4,0);
 	pdata += 8;
 
-	SIVAL(pdata,0,unix_dev_minor(devno));   /* Minor device number if type is device */
+	SIVAL(pdata,0,unix_dev_minor(psbuf->st_ex_rdev));   /* Minor device number if type is device */
 	SIVAL(pdata,4,0);
 	pdata += 8;
 
@@ -4425,7 +4282,7 @@
 			return;
 	}
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, param_size, *ppdata, data_size,
+	send_trans2_replies(conn, req, params, param_size, *ppdata, data_size,
 			    max_data_bytes);
 
 	return;
@@ -4469,9 +4326,8 @@
 		return NT_STATUS_INVALID_LEVEL;
 	}
 
-	DEBUG(5,("smbd_do_qfilepathinfo: %s (%s) level=%d max_data=%u\n",
-		 smb_fname_str_dbg(smb_fname),
-		 fsp_fnum_dbg(fsp),
+	DEBUG(5,("smbd_do_qfilepathinfo: %s (fnum = %d) level=%d max_data=%u\n",
+		 smb_fname_str_dbg(smb_fname), fsp ? fsp->fnum : -1,
 		 info_level, max_data_bytes));
 
 	mode = dos_mode(conn, smb_fname);
@@ -4598,7 +4454,7 @@
 		{
 			unsigned int ea_size =
 			    estimate_ea_size(conn, fsp,
-					     smb_fname);
+					     smb_fname->base_name);
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB_INFO_QUERY_EA_SIZE\n"));
 			data_size = 26;
 			srv_put_dos_date2(pdata,0,create_time);
@@ -4625,16 +4481,13 @@
 		{
 			size_t total_ea_len = 0;
 			struct ea_list *ea_file_list = NULL;
+
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB_INFO_QUERY_EAS_FROM_LIST\n"));
 
-			status =
+			ea_file_list =
 			    get_ea_list_from_file(mem_ctx, conn, fsp,
-						  smb_fname,
-						  &total_ea_len, &ea_file_list);
-			if (!NT_STATUS_IS_OK(status)) {
-				return status;
-			}
-
+						  smb_fname->base_name,
+						  &total_ea_len);
 			ea_list = ea_list_union(ea_list, ea_file_list, &total_ea_len);
 
 			if (!ea_list || (total_ea_len > data_size)) {
@@ -4651,15 +4504,12 @@
 		{
 			/* We have data_size bytes to put EA's into. */
 			size_t total_ea_len = 0;
-			DEBUG(10,("smbd_do_qfilepathinfo: SMB_INFO_QUERY_ALL_EAS\n"));
 
-			status = get_ea_list_from_file(mem_ctx, conn, fsp,
-							smb_fname,
-							&total_ea_len, &ea_list);
-			if (!NT_STATUS_IS_OK(status)) {
-				return status;
-			}
+			DEBUG(10,("smbd_do_qfilepathinfo: SMB_INFO_QUERY_ALL_EAS\n"));
 
+			ea_list = get_ea_list_from_file(mem_ctx, conn, fsp,
+							smb_fname->base_name,
+							&total_ea_len);
 			if (!ea_list || (total_ea_len > data_size)) {
 				data_size = 4;
 				SIVAL(pdata,0,4);   /* EA List Length must be set to 4 if no EA's. */
@@ -4683,13 +4533,10 @@
 
 			/*TODO: add filtering and index handling */
 
-			status  =
-				get_ea_list_from_file(mem_ctx, conn, fsp,
-						  smb_fname,
-						  &total_ea_len, &ea_file_list);
-			if (!NT_STATUS_IS_OK(status)) {
-				return status;
-			}
+			ea_file_list =
+			    get_ea_list_from_file(mem_ctx, conn, fsp,
+						  smb_fname->base_name,
+						  &total_ea_len);
 			if (!ea_file_list) {
 				return NT_STATUS_NO_EAS_ON_FILE;
 			}
@@ -4749,7 +4596,7 @@
 		case SMB_QUERY_FILE_EA_INFO:
 		{
 			unsigned int ea_size =
-			    estimate_ea_size(conn, fsp,	smb_fname);
+			    estimate_ea_size(conn, fsp,	smb_fname->base_name);
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB_FILE_EA_INFORMATION\n"));
 			data_size = 4;
 			*fixed_portion = 4;
@@ -4813,7 +4660,7 @@
 		{
 			int len;
 			unsigned int ea_size =
-			    estimate_ea_size(conn, fsp, smb_fname);
+			    estimate_ea_size(conn, fsp, smb_fname->base_name);
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB_FILE_ALL_INFORMATION\n"));
 			put_long_date_timespec(conn->ts_res,pdata,create_time_ts);
 			put_long_date_timespec(conn->ts_res,pdata+8,atime_ts);
@@ -4846,7 +4693,7 @@
 		{
 			int len;
 			unsigned int ea_size =
-			    estimate_ea_size(conn, fsp, smb_fname);
+			    estimate_ea_size(conn, fsp, smb_fname->base_name);
 			DEBUG(10,("smbd_do_qfilepathinfo: SMB2_FILE_ALL_INFORMATION\n"));
 			put_long_date_timespec(conn->ts_res,pdata+0x00,create_time_ts);
 			put_long_date_timespec(conn->ts_res,pdata+0x08,atime_ts);
@@ -5045,7 +4892,7 @@
 		case SMB_QUERY_FILE_UNIX_LINK:
 			{
 				int len;
-				char *buffer = talloc_array(mem_ctx, char, PATH_MAX+1);
+				char *buffer = TALLOC_ARRAY(mem_ctx, char, PATH_MAX+1);
 
 				if (!buffer) {
 					return NT_STATUS_NO_MEMORY;
@@ -5085,14 +4932,12 @@
 				uint16 num_def_acls = 0;
 
 				if (fsp && fsp->fh->fd != -1) {
-					file_acl = SMB_VFS_SYS_ACL_GET_FD(fsp,
-						talloc_tos());
+					file_acl = SMB_VFS_SYS_ACL_GET_FD(fsp);
 				} else {
 					file_acl =
 					    SMB_VFS_SYS_ACL_GET_FILE(conn,
 						smb_fname->base_name,
-						SMB_ACL_TYPE_ACCESS,
-						talloc_tos());
+						SMB_ACL_TYPE_ACCESS);
 				}
 
 				if (file_acl == NULL && no_acl_syscall_error(errno)) {
@@ -5109,15 +4954,13 @@
 						    SMB_VFS_SYS_ACL_GET_FILE(
 							    conn,
 							    fsp->fsp_name->base_name,
-							    SMB_ACL_TYPE_DEFAULT,
-							    talloc_tos());
+							    SMB_ACL_TYPE_DEFAULT);
 					} else {
 						def_acl =
 						    SMB_VFS_SYS_ACL_GET_FILE(
 							    conn,
 							    smb_fname->base_name,
-							    SMB_ACL_TYPE_DEFAULT,
-							    talloc_tos());
+							    SMB_ACL_TYPE_DEFAULT);
 					}
 					def_acl = free_empty_sys_acl(conn, def_acl);
 				}
@@ -5131,10 +4974,10 @@
 						(unsigned int)((num_file_acls + num_def_acls)*SMB_POSIX_ACL_ENTRY_SIZE +
 							SMB_POSIX_ACL_HEADER_SIZE) ));
 					if (file_acl) {
-						TALLOC_FREE(file_acl);
+						SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 					}
 					if (def_acl) {
-						TALLOC_FREE(def_acl);
+						SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 					}
 					return NT_STATUS_BUFFER_TOO_SMALL;
 				}
@@ -5144,28 +4987,28 @@
 				SSVAL(pdata,4,num_def_acls);
 				if (!marshall_posix_acl(conn, pdata + SMB_POSIX_ACL_HEADER_SIZE, psbuf, file_acl)) {
 					if (file_acl) {
-						TALLOC_FREE(file_acl);
+						SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 					}
 					if (def_acl) {
-						TALLOC_FREE(def_acl);
+						SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 					}
 					return NT_STATUS_INTERNAL_ERROR;
 				}
 				if (!marshall_posix_acl(conn, pdata + SMB_POSIX_ACL_HEADER_SIZE + (num_file_acls*SMB_POSIX_ACL_ENTRY_SIZE), psbuf, def_acl)) {
 					if (file_acl) {
-						TALLOC_FREE(file_acl);
+						SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 					}
 					if (def_acl) {
-						TALLOC_FREE(def_acl);
+						SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 					}
 					return NT_STATUS_INTERNAL_ERROR;
 				}
 
 				if (file_acl) {
-					TALLOC_FREE(file_acl);
+					SMB_VFS_SYS_ACL_FREE_ACL(conn, file_acl);
 				}
 				if (def_acl) {
-					TALLOC_FREE(def_acl);
+					SMB_VFS_SYS_ACL_FREE_ACL(conn, def_acl);
 				}
 				data_size = (num_file_acls + num_def_acls)*SMB_POSIX_ACL_ENTRY_SIZE + SMB_POSIX_ACL_HEADER_SIZE;
 				break;
@@ -5371,8 +5214,8 @@
 			 * Original code - this is an open file.
 			 */
 			if (SMB_VFS_FSTAT(fsp, &smb_fname->st) != 0) {
-				DEBUG(3, ("fstat of %s failed (%s)\n",
-					  fsp_fnum_dbg(fsp), strerror(errno)));
+				DEBUG(3, ("fstat of fnum %d failed (%s)\n",
+					  fsp->fnum, strerror(errno)));
 				reply_nterror(req,
 					map_nt_error_from_unix(errno));
 				return;
@@ -5536,10 +5379,9 @@
 		}
 	}
 
-	DEBUG(3,("call_trans2qfilepathinfo %s (%s) level=%d call=%d "
+	DEBUG(3,("call_trans2qfilepathinfo %s (fnum = %d) level=%d call=%d "
 		 "total_data=%d\n", smb_fname_str_dbg(smb_fname),
-		 fsp_fnum_dbg(fsp),
-		 info_level,tran_call,total_data));
+		 fsp ? fsp->fnum : -1, info_level,tran_call,total_data));
 
 	/* Pull out any data sent here before we realloc. */
 	switch (info_level) {
@@ -5592,7 +5434,7 @@
 			}
 
 			/* Copy the lock range data. */
-			lock_data = (char *)talloc_memdup(
+			lock_data = (char *)TALLOC_MEMDUP(
 				req, pdata, total_data);
 			if (!lock_data) {
 				reply_nterror(req, NT_STATUS_NO_MEMORY);
@@ -5656,7 +5498,7 @@
 		return;
 	}
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, param_size, *ppdata, data_size,
+	send_trans2_replies(conn, req, params, param_size, *ppdata, data_size,
 			    max_data_bytes);
 
 	return;
@@ -5726,8 +5568,6 @@
 
 /****************************************************************************
  Deal with setting the time from any of the setfilepathinfo functions.
- NOTE !!!! The check for FILE_WRITE_ATTRIBUTES access must be done *before*
- calling this function.
 ****************************************************************************/
 
 NTSTATUS smb_set_file_time(connection_struct *conn,
@@ -5746,6 +5586,10 @@
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_ATTRIBUTES)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	/* get some defaults (no modifications) if any info is zero or -1. */
 	if (null_timespec(ft->create_time)) {
 		action &= ~FILE_NOTIFY_CHANGE_CREATION;
@@ -5826,8 +5670,6 @@
 
 /****************************************************************************
  Deal with setting the dosmode from any of the setfilepathinfo functions.
- NB. The check for FILE_WRITE_ATTRIBUTES access on this path must have been
- done before calling this function.
 ****************************************************************************/
 
 static NTSTATUS smb_set_file_dosmode(connection_struct *conn,
@@ -5890,7 +5732,7 @@
 				  files_struct *fsp,
 				  const struct smb_filename *smb_fname,
 				  const SMB_STRUCT_STAT *psbuf,
-				  off_t size,
+				  SMB_OFF_T size,
 				  bool fail_after_createfile)
 {
 	NTSTATUS status = NT_STATUS_OK;
@@ -5901,6 +5743,10 @@
 		return NT_STATUS_OBJECT_NAME_NOT_FOUND;
 	}
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_DATA)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	DEBUG(6,("smb_set_file_size: size: %.0f ", (double)size));
 
 	if (size == get_file_size_stat(psbuf)) {
@@ -5912,10 +5758,6 @@
 
 	if (fsp && fsp->fh->fd != -1) {
 		/* Handle based call. */
-		if (!(fsp->access_mask & FILE_WRITE_DATA)) {
-			return NT_STATUS_ACCESS_DENIED;
-		}
-
 		if (vfs_set_filelen(fsp, size) == -1) {
 			return map_nt_error_from_unix(errno);
 		}
@@ -6012,6 +5854,10 @@
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_EA)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	status = set_ea(conn, fsp, smb_fname, ea_list);
 
 	return status;
@@ -6055,6 +5901,10 @@
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_EA)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	status = set_ea(conn, fsp, fsp->fsp_name, ea_list);
 
 	DEBUG(10, ("smb_set_file_full_ea_info on file %s returned %s\n",
@@ -6106,7 +5956,7 @@
 	/* The set is across all open files on this dev/inode pair. */
 	if (!set_delete_on_close(fsp, delete_on_close,
 				 conn->session_info->security_token,
-				 conn->session_info->unix_token)) {
+				 &conn->session_info->utok)) {
 		return NT_STATUS_ACCESS_DENIED;
 	}
 	return NT_STATUS_OK;
@@ -6133,7 +5983,14 @@
 	}
 
 	position_information = (uint64_t)IVAL(pdata,0);
+#ifdef LARGE_SMB_OFF_T
 	position_information |= (((uint64_t)IVAL(pdata,4)) << 32);
+#else /* LARGE_SMB_OFF_T */
+	if (IVAL(pdata,4) != 0) {
+		/* more than 32 bits? */
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+#endif /* LARGE_SMB_OFF_T */
 
 	DEBUG(10,("smb_file_position_information: Set file position "
 		  "information for file %s to %.0f\n", fsp_str_dbg(fsp),
@@ -6329,8 +6186,8 @@
 	}
 
 	DEBUG(10,("smb2_file_rename_information: "
-		  "SMB_FILE_RENAME_INFORMATION (%s) %s -> %s\n",
-		  fsp_fnum_dbg(fsp), fsp_str_dbg(fsp),
+		  "SMB_FILE_RENAME_INFORMATION (fnum %d) %s -> %s\n",
+		  fsp->fnum, fsp_str_dbg(fsp),
 		  smb_fname_str_dbg(smb_fname_dst)));
 	status = rename_internals_fsp(conn, fsp, smb_fname_dst,
 				(FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM),
@@ -6397,8 +6254,8 @@
 	}
 
 	DEBUG(10,("smb_file_link_information: "
-		  "SMB_FILE_LINK_INFORMATION (%s) %s -> %s\n",
-		  fsp_fnum_dbg(fsp), fsp_str_dbg(fsp),
+		  "SMB_FILE_LINK_INFORMATION (fnum %d) %s -> %s\n",
+		  fsp->fnum, fsp_str_dbg(fsp),
 		  smb_fname_str_dbg(smb_fname_dst)));
 	status = hardlink_internals(ctx,
 				conn,
@@ -6458,7 +6315,6 @@
 				       req->flags2 & FLAGS2_DFS_PATHNAMES,
 				       newname,
 				       true,
-				       !conn->sconn->using_smb2,
 				       &newname,
 				       &dest_has_wcard);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -6560,8 +6416,8 @@
 
 	if (fsp) {
 		DEBUG(10,("smb_file_rename_information: "
-			  "SMB_FILE_RENAME_INFORMATION (%s) %s -> %s\n",
-			  fsp_fnum_dbg(fsp), fsp_str_dbg(fsp),
+			  "SMB_FILE_RENAME_INFORMATION (fnum %d) %s -> %s\n",
+			  fsp->fnum, fsp_str_dbg(fsp),
 			  smb_fname_str_dbg(smb_fname_dst)));
 		status = rename_internals_fsp(conn, fsp, smb_fname_dst, 0,
 					      overwrite);
@@ -6789,9 +6645,8 @@
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
-	status = check_access(conn, fsp, smb_fname, FILE_WRITE_ATTRIBUTES);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
+	if (fsp && !(fsp->access_mask & FILE_WRITE_ATTRIBUTES)) {
+		return NT_STATUS_ACCESS_DENIED;
 	}
 
 	/* Set the attributes */
@@ -6830,7 +6685,6 @@
 					files_struct *fsp,
 					const struct smb_filename *smb_fname)
 {
-	NTSTATUS status;
 	struct smb_file_time ft;
 
 	ZERO_STRUCT(ft);
@@ -6839,6 +6693,10 @@
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_ATTRIBUTES)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	/* create time */
 	ft.create_time = convert_time_t_to_timespec(srv_make_unix_date2(pdata));
 	/* access time */
@@ -6849,11 +6707,6 @@
 	DEBUG(10,("smb_set_info_standard: file %s\n",
 		smb_fname_str_dbg(smb_fname)));
 
-	status = check_access(conn, fsp, smb_fname, FILE_WRITE_ATTRIBUTES);
-	if (!NT_STATUS_IS_OK(status)) {
-		return status;
-	}
-
         return smb_set_file_time(conn,
                                 fsp,
 				smb_fname,
@@ -6885,7 +6738,15 @@
 	}
 
 	allocation_size = (uint64_t)IVAL(pdata,0);
+#ifdef LARGE_SMB_OFF_T
 	allocation_size |= (((uint64_t)IVAL(pdata,4)) << 32);
+#else /* LARGE_SMB_OFF_T */
+	if (IVAL(pdata,4) != 0) {
+		/* more than 32 bits? */
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+#endif /* LARGE_SMB_OFF_T */
+
 	DEBUG(10,("smb_set_file_allocation_info: Set file allocation info for "
 		  "file %s to %.0f\n", smb_fname_str_dbg(smb_fname),
 		  (double)allocation_size));
@@ -6894,16 +6755,16 @@
 		allocation_size = smb_roundup(conn, allocation_size);
 	}
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_DATA)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	DEBUG(10,("smb_set_file_allocation_info: file %s : setting new "
 		  "allocation size to %.0f\n", smb_fname_str_dbg(smb_fname),
 		  (double)allocation_size));
 
 	if (fsp && fsp->fh->fd != -1) {
 		/* Open file handle. */
-		if (!(fsp->access_mask & FILE_WRITE_DATA)) {
-			return NT_STATUS_ACCESS_DENIED;
-		}
-
 		/* Only change if needed. */
 		if (allocation_size != get_file_size_stat(&smb_fname->st)) {
 			if (vfs_allocate_file_space(fsp, allocation_size) == -1) {
@@ -6976,18 +6837,29 @@
 					const struct smb_filename *smb_fname,
 					bool fail_after_createfile)
 {
-	off_t size;
+	SMB_OFF_T size;
 
 	if (total_data < 8) {
 		return NT_STATUS_INVALID_PARAMETER;
 	}
 
 	size = IVAL(pdata,0);
-	size |= (((off_t)IVAL(pdata,4)) << 32);
+#ifdef LARGE_SMB_OFF_T
+	size |= (((SMB_OFF_T)IVAL(pdata,4)) << 32);
+#else /* LARGE_SMB_OFF_T */
+	if (IVAL(pdata,4) != 0)	{
+		/* more than 32 bits? */
+		return NT_STATUS_INVALID_PARAMETER;
+	}
+#endif /* LARGE_SMB_OFF_T */
 	DEBUG(10,("smb_set_file_end_of_file_info: Set end of file info for "
 		  "file %s to %.0f\n", smb_fname_str_dbg(smb_fname),
 		  (double)size));
 
+	if (fsp && !(fsp->access_mask & FILE_WRITE_DATA)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
 	return smb_set_file_size(conn, req,
 				fsp,
 				smb_fname,
@@ -7095,7 +6967,7 @@
 	struct smb_file_time ft;
 	uint32 raw_unixmode;
 	mode_t unixmode;
-	off_t size = 0;
+	SMB_OFF_T size = 0;
 	uid_t set_owner = (uid_t)SMB_UID_NO_CHANGE;
 	gid_t set_grp = (uid_t)SMB_GID_NO_CHANGE;
 	NTSTATUS status = NT_STATUS_OK;
@@ -7116,7 +6988,14 @@
 	if(IVAL(pdata, 0) != SMB_SIZE_NO_CHANGE_LO &&
 	   IVAL(pdata, 4) != SMB_SIZE_NO_CHANGE_HI) {
 		size=IVAL(pdata,0); /* first 8 Bytes are size */
-		size |= (((off_t)IVAL(pdata,4)) << 32);
+#ifdef LARGE_SMB_OFF_T
+		size |= (((SMB_OFF_T)IVAL(pdata,4)) << 32);
+#else /* LARGE_SMB_OFF_T */
+		if (IVAL(pdata,4) != 0)	{
+			/* more than 32 bits? */
+			return NT_STATUS_INVALID_PARAMETER;
+		}
+#endif /* LARGE_SMB_OFF_T */
 	}
 
 	ft.atime = interpret_long_date(pdata+24); /* access_time */
@@ -7207,18 +7086,11 @@
 	 */
 
 	if (raw_unixmode != SMB_MODE_NO_CHANGE) {
-		int ret;
-
 		DEBUG(10,("smb_set_file_unix_basic: SMB_SET_FILE_UNIX_BASIC "
 			  "setting mode 0%o for file %s\n",
 			  (unsigned int)unixmode,
 			  smb_fname_str_dbg(smb_fname)));
-		if (fsp && fsp->fh->fd != -1) {
-			ret = SMB_VFS_FCHMOD(fsp, unixmode);
-		} else {
-			ret = SMB_VFS_CHMOD(conn, smb_fname->base_name, unixmode);
-		}
-		if (ret != 0) {
+		if (SMB_VFS_CHMOD(conn, smb_fname->base_name, unixmode) != 0) {
 			return map_nt_error_from_unix(errno);
 		}
 	}
@@ -7236,15 +7108,12 @@
 			  (unsigned int)set_owner,
 			  smb_fname_str_dbg(smb_fname)));
 
-		if (fsp && fsp->fh->fd != -1) {
-			ret = SMB_VFS_FCHOWN(fsp, set_owner, (gid_t)-1);
-		} else {
-			/*
-			 * UNIX extensions calls must always operate
-			 * on symlinks.
-			 */
+		if (S_ISLNK(sbuf.st_ex_mode)) {
 			ret = SMB_VFS_LCHOWN(conn, smb_fname->base_name,
 					     set_owner, (gid_t)-1);
+		} else {
+			ret = SMB_VFS_CHOWN(conn, smb_fname->base_name,
+					    set_owner, (gid_t)-1);
 		}
 
 		if (ret != 0) {
@@ -7262,23 +7131,12 @@
 
 	if ((set_grp != (uid_t)SMB_GID_NO_CHANGE) &&
 	    (sbuf.st_ex_gid != set_grp)) {
-		int ret;
-
 		DEBUG(10,("smb_set_file_unix_basic: SMB_SET_FILE_UNIX_BASIC "
 			  "changing group %u for file %s\n",
 			  (unsigned int)set_owner,
 			  smb_fname_str_dbg(smb_fname)));
-		if (fsp && fsp->fh->fd != -1) {
-			ret = SMB_VFS_FCHOWN(fsp, set_owner, (gid_t)-1);
-		} else {
-			/*
-			 * UNIX extensions calls must always operate
-			 * on symlinks.
-			 */
-			ret = SMB_VFS_LCHOWN(conn, smb_fname->base_name, (uid_t)-1,
-				  set_grp);
-		}
-		if (ret != 0) {
+		if (SMB_VFS_CHOWN(conn, smb_fname->base_name, (uid_t)-1,
+				  set_grp) != 0) {
 			status = map_nt_error_from_unix(errno);
 			if (delete_on_fail) {
 				SMB_VFS_UNLINK(conn, smb_fname);
@@ -7827,7 +7685,8 @@
 	 * non-POSIX opens return SHARING_VIOLATION.
 	 */
 
-	lck = get_existing_share_mode_lock(talloc_tos(), fsp->file_id);
+	lck = get_share_mode_lock(talloc_tos(), fsp->file_id, NULL, NULL,
+				  NULL);
 	if (lck == NULL) {
 		DEBUG(0, ("smb_posix_unlink: Could not get share mode "
 			  "lock for file %s\n", fsp_str_dbg(fsp)));
@@ -7840,15 +7699,12 @@
 	 * don't delete. If all opens are POSIX delete we can set the delete
 	 * on close disposition.
 	 */
-	for (i=0; i<lck->data->num_share_modes; i++) {
-		struct share_mode_entry *e = &lck->data->share_modes[i];
+	for (i=0; i<lck->num_share_modes; i++) {
+		struct share_mode_entry *e = &lck->share_modes[i];
 		if (is_valid_share_mode_entry(e)) {
 			if (e->flags & SHARE_MODE_FLAG_POSIX_OPEN) {
 				continue;
 			}
-			if (share_mode_stale_pid(lck->data, i)) {
-				continue;
-			}
 			/* Fail with sharing violation. */
 			TALLOC_FREE(lck);
 			close_file(req, fsp, NORMAL_CLOSE);
@@ -7901,10 +7757,9 @@
 		}
 	}
 
-	DEBUG(3,("smbd_do_setfilepathinfo: %s (%s) info_level=%d "
+	DEBUG(3,("smbd_do_setfilepathinfo: %s (fnum %d) info_level=%d "
 		 "totdata=%d\n", smb_fname_str_dbg(smb_fname),
-		 fsp_fnum_dbg(fsp),
-		 info_level, total_data));
+		 fsp ? fsp->fnum : -1, info_level, total_data));
 
 	switch (info_level) {
 
@@ -8242,7 +8097,7 @@
 					 fsp_str_dbg(fsp)));
 
 				SSVAL(params,0,0);
-				send_trans2_replies(conn, req, NT_STATUS_OK, params, 2,
+				send_trans2_replies(conn, req, params, 2,
 						    *ppdata, 0,
 						    max_data_bytes);
 				return;
@@ -8257,7 +8112,7 @@
 			 */
 			if (SMB_VFS_FSTAT(fsp, &smb_fname->st) != 0) {
 				DEBUG(3,("call_trans2setfilepathinfo: fstat "
-					 "of %s failed (%s)\n", fsp_fnum_dbg(fsp),
+					 "of fnum %d failed (%s)\n", fsp->fnum,
 					 strerror(errno)));
 				reply_nterror(req, map_nt_error_from_unix(errno));
 				return;
@@ -8325,10 +8180,9 @@
 		}
 	}
 
-	DEBUG(3,("call_trans2setfilepathinfo(%d) %s (%s) info_level=%d "
+	DEBUG(3,("call_trans2setfilepathinfo(%d) %s (fnum %d) info_level=%d "
 		 "totdata=%d\n", tran_call, smb_fname_str_dbg(smb_fname),
-		 fsp_fnum_dbg(fsp),
-		 info_level,total_data));
+		 fsp ? fsp->fnum : -1, info_level,total_data));
 
 	/* Realloc the parameter size */
 	*pparams = (char *)SMB_REALLOC(*pparams,2);
@@ -8347,7 +8201,7 @@
 					 ppdata, total_data,
 					 &data_return_size);
 	if (!NT_STATUS_IS_OK(status)) {
-		if (open_was_deferred(req->sconn, req->mid)) {
+		if (open_was_deferred(req->mid)) {
 			/* We have re-scheduled this call. */
 			return;
 		}
@@ -8365,20 +8219,11 @@
 			return;
 		}
 
-		/*
-		 * Invalid EA name needs to return 2 param bytes,
-		 * not a zero-length error packet.
-		 */
-		if (NT_STATUS_EQUAL(status, STATUS_INVALID_EA_NAME)) {
-			send_trans2_replies(conn, req, status, params, 2, NULL, 0,
-					max_data_bytes);
-		} else {
-			reply_nterror(req, status);
-		}
+		reply_nterror(req, status);
 		return;
 	}
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 2, *ppdata, data_return_size,
+	send_trans2_replies(conn, req, params, 2, *ppdata, data_return_size,
 			    max_data_bytes);
 
 	return;
@@ -8503,7 +8348,7 @@
 
 	SSVAL(params,0,0);
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 2, *ppdata, 0, max_data_bytes);
+	send_trans2_replies(conn, req, params, 2, *ppdata, 0, max_data_bytes);
 
  out:
 	TALLOC_FREE(smb_dname);
@@ -8558,7 +8403,7 @@
 	if(fnf_handle == 0)
 		fnf_handle = 257;
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 6, *ppdata, 0, max_data_bytes);
+	send_trans2_replies(conn, req, params, 6, *ppdata, 0, max_data_bytes);
 
 	return;
 }
@@ -8589,7 +8434,7 @@
 	SSVAL(params,0,0); /* No changes */
 	SSVAL(params,2,0); /* No EA errors */
 
-	send_trans2_replies(conn, req, NT_STATUS_OK, params, 4, *ppdata, 0, max_data_bytes);
+	send_trans2_replies(conn, req, params, 4, *ppdata, 0, max_data_bytes);
 
 	return;
 }
@@ -8637,9 +8482,9 @@
 		return;
 	}
 
-	SSVAL((discard_const_p(uint8_t, req->inbuf)), smb_flg2,
+	SSVAL(req->inbuf, smb_flg2,
 	      SVAL(req->inbuf,smb_flg2) | FLAGS2_DFS_PATHNAMES);
-	send_trans2_replies(conn, req, NT_STATUS_OK, 0,0,*ppdata,reply_size, max_data_bytes);
+	send_trans2_replies(conn, req,0,0,*ppdata,reply_size, max_data_bytes);
 
 	return;
 }
@@ -8680,15 +8525,18 @@
 			CAN ACCEPT THIS IN UNICODE. JRA. */
 
 		/* Job number */
-		SSVAL(pdata, 0, print_spool_rap_jobid(fsp->print_file));
-
+		if (fsp->print_file) {
+			SSVAL(pdata, 0, fsp->print_file->rap_jobid);
+		} else {
+			SSVAL(pdata, 0, 0);
+		}
 		srvstr_push(pdata, req->flags2, pdata + 2,
-			    lp_netbios_name(), 15,
+			    global_myname(), 15,
 			    STR_ASCII|STR_TERMINATE); /* Our NetBIOS name */
 		srvstr_push(pdata, req->flags2, pdata+18,
-			    lp_servicename(talloc_tos(), SNUM(conn)), 13,
+			    lp_servicename(SNUM(conn)), 13,
 			    STR_ASCII|STR_TERMINATE); /* Service name */
-		send_trans2_replies(conn, req, NT_STATUS_OK, *pparams, 0, *ppdata, 32,
+		send_trans2_replies(conn, req, *pparams, 0, *ppdata, 32,
 				    max_data_bytes);
 		return;
 	}
@@ -8765,12 +8613,12 @@
 {
 	if (get_Protocol() >= PROTOCOL_NT1) {
 		req->flags2 |= 0x40; /* IS_LONG_NAME */
-		SSVAL((discard_const_p(uint8_t, req->inbuf)),smb_flg2,req->flags2);
+		SSVAL(req->inbuf,smb_flg2,req->flags2);
 	}
 
-	if (ENCRYPTION_REQUIRED(conn) && !req->encrypted) {
+	if (conn->encrypt_level == Required && !req->encrypted) {
 		if (state->call != TRANSACT2_QFSINFO &&
-		    state->call != TRANSACT2_SETFSINFO) {
+				state->call != TRANSACT2_SETFSINFO) {
 			DEBUG(0,("handle_trans2: encryption required "
 				"with call 0x%x\n",
 				(unsigned int)state->call));
@@ -8978,7 +8826,7 @@
 		}
 	}
 
-	if ((state = talloc(conn, struct trans_state)) == NULL) {
+	if ((state = TALLOC_P(conn, struct trans_state)) == NULL) {
 		DEBUG(0, ("talloc failed\n"));
 		reply_nterror(req, NT_STATUS_NO_MEMORY);
 		END_PROFILE(SMBtrans2);
@@ -9124,7 +8972,7 @@
 
 	START_PROFILE(SMBtranss2);
 
-	show_msg((const char *)req->inbuf);
+	show_msg((char *)req->inbuf);
 
 	/* Windows clients expect all replies to
 	   a transact secondary (SMBtranss2 0x33)
Only in ../../samba-3.6.24/source3/smbd: trans2.o
diff -ur smbd/uid.c ../../samba-3.6.24/source3/smbd/uid.c
--- smbd/uid.c	2013-02-05 20:25:26.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/uid.c	2015-01-28 10:52:25.149068676 +0800
@@ -78,86 +78,52 @@
 	TALLOC_FREE(conn->session_info);
 }
 
-/****************************************************************************
-  Setup the share access mask for a connection.
-****************************************************************************/
+/*******************************************************************
+ Check if a username is OK.
 
-static uint32_t create_share_access_mask(int snum,
-				bool readonly_share,
-				const struct security_token *token)
-{
-	uint32_t share_access = 0;
+ This sets up conn->session_info with a copy related to this vuser that
+ later code can then mess with.
+********************************************************************/
 
-	share_access_check(token,
-			lp_servicename(talloc_tos(), snum),
-			MAXIMUM_ALLOWED_ACCESS,
-			&share_access);
+static bool check_user_ok(connection_struct *conn,
+			uint16_t vuid,
+			const struct auth_serversupplied_info *session_info,
+			int snum)
+{
+	bool valid_vuid = (vuid != UID_FIELD_INVALID);
+	unsigned int i;
+	bool readonly_share;
+	bool admin_user;
 
-	if (readonly_share) {
-		share_access &=
-			~(SEC_FILE_WRITE_DATA | SEC_FILE_APPEND_DATA |
-			  SEC_FILE_WRITE_EA | SEC_FILE_WRITE_ATTRIBUTE |
-			  SEC_DIR_DELETE_CHILD );
-	}
+	if (valid_vuid) {
+		struct vuid_cache_entry *ent;
 
-	if (security_token_has_privilege(token, SEC_PRIV_SECURITY)) {
-		share_access |= SEC_FLAG_SYSTEM_SECURITY;
-	}
-	if (security_token_has_privilege(token, SEC_PRIV_RESTORE)) {
-		share_access |= (SEC_RIGHTS_PRIV_RESTORE);
-	}
-	if (security_token_has_privilege(token, SEC_PRIV_BACKUP)) {
-		share_access |= (SEC_RIGHTS_PRIV_BACKUP);
-	}
-	if (security_token_has_privilege(token, SEC_PRIV_TAKE_OWNERSHIP)) {
-		share_access |= (SEC_STD_WRITE_OWNER);
+		for (i=0; i<VUID_CACHE_SIZE; i++) {
+			ent = &conn->vuid_cache.array[i];
+			if (ent->vuid == vuid) {
+				free_conn_session_info_if_unused(conn);
+				conn->session_info = ent->session_info;
+				conn->read_only = ent->read_only;
+				return(True);
+			}
+		}
 	}
 
-	return share_access;
-}
-
-/*******************************************************************
- Calculate access mask and if this user can access this share.
-********************************************************************/
-
-NTSTATUS check_user_share_access(connection_struct *conn,
-				const struct auth_session_info *session_info,
-				uint32_t *p_share_access,
-				bool *p_readonly_share)
-{
-	int snum = SNUM(conn);
-	uint32_t share_access = 0;
-	bool readonly_share = false;
-
-	if (!user_ok_token(session_info->unix_info->unix_name,
-			   session_info->info->domain_name,
+	if (!user_ok_token(session_info->unix_name,
+			   session_info->info3->base.domain.string,
 			   session_info->security_token, snum))
-		return NT_STATUS_ACCESS_DENIED;
+		return(False);
 
 	readonly_share = is_share_read_only_for_token(
-		session_info->unix_info->unix_name,
-		session_info->info->domain_name,
+		session_info->unix_name,
+		session_info->info3->base.domain.string,
 		session_info->security_token,
 		conn);
 
-	share_access = create_share_access_mask(snum,
-					readonly_share,
-					session_info->security_token);
-
-	if ((share_access & FILE_WRITE_DATA) == 0) {
-		if ((share_access & FILE_READ_DATA) == 0) {
-			/* No access, read or write. */
-			DEBUG(0,("user %s connection to %s "
-				"denied due to share security "
-				"descriptor.\n",
-				session_info->unix_info->unix_name,
-				lp_servicename(talloc_tos(), snum)));
-			return NT_STATUS_ACCESS_DENIED;
-		}
-	}
-
 	if (!readonly_share &&
-	    !(share_access & FILE_WRITE_DATA)) {
+	    !share_access_check(session_info->security_token,
+				lp_servicename(snum), FILE_WRITE_DATA,
+				NULL)) {
 		/* smb.conf allows r/w, but the security descriptor denies
 		 * write. Fall back to looking at readonly. */
 		readonly_share = True;
@@ -165,133 +131,111 @@
 			 "security descriptor\n"));
 	}
 
-	*p_share_access = share_access;
-	*p_readonly_share = readonly_share;
-
-	return NT_STATUS_OK;
-}
-
-/*******************************************************************
- Check if a username is OK.
-
- This sets up conn->session_info with a copy related to this vuser that
- later code can then mess with.
-********************************************************************/
-
-static bool check_user_ok(connection_struct *conn,
-			uint64_t vuid,
-			const struct auth_session_info *session_info,
-			int snum)
-{
-	unsigned int i;
-	bool readonly_share = false;
-	bool admin_user = false;
-	struct vuid_cache_entry *ent = NULL;
-	uint32_t share_access = 0;
-	unsigned int share_array_index;
-	NTSTATUS status;
-
-	for (i=0; i<VUID_CACHE_SIZE; i++) {
-		ent = &conn->vuid_cache.array[i];
-		if (ent->vuid == vuid) {
-			if (vuid == UID_FIELD_INVALID) {
-				/*
-				 * Slow path, we don't care
-				 * about the array traversal.
-				 */
-				continue;
-			}
-			free_conn_session_info_if_unused(conn);
-			conn->session_info = ent->session_info;
-			conn->read_only = ent->read_only;
-			conn->share_access = get_connection_share_access_list_entry(
-							conn,
-							i);
-			return(True);
-		}
-	}
-
-	status = check_user_share_access(conn,
-					session_info,
-					&share_access,
-					&readonly_share);
-	if (!NT_STATUS_IS_OK(status)) {
-		return false;
+	if (!share_access_check(session_info->security_token,
+				lp_servicename(snum),
+				readonly_share ?
+				FILE_READ_DATA : FILE_WRITE_DATA,
+				NULL)) {
+		return False;
 	}
 
-
 	admin_user = token_contains_name_in_list(
-		session_info->unix_info->unix_name,
-		session_info->info->domain_name,
+		session_info->unix_name,
+		session_info->info3->base.domain.string,
 		NULL, session_info->security_token, lp_admin_users(snum));
 
-	share_array_index = conn->vuid_cache.next_entry;
-	ent = &conn->vuid_cache.array[conn->vuid_cache.next_entry];
+	if (valid_vuid) {
+		struct vuid_cache_entry *ent =
+			&conn->vuid_cache.array[conn->vuid_cache.next_entry];
 
-	conn->vuid_cache.next_entry =
-		(conn->vuid_cache.next_entry + 1) % VUID_CACHE_SIZE;
+		conn->vuid_cache.next_entry =
+			(conn->vuid_cache.next_entry + 1) % VUID_CACHE_SIZE;
 
-	TALLOC_FREE(ent->session_info);
+		TALLOC_FREE(ent->session_info);
 
-	/*
-	 * If force_user was set, all session_info's are based on the same
-	 * username-based faked one.
-	 */
+		/*
+		 * If force_user was set, all session_info's are based on the same
+		 * username-based faked one.
+		 */
 
-	ent->session_info = copy_session_info(
-		conn, conn->force_user ? conn->session_info : session_info);
+		ent->session_info = copy_serverinfo(
+			conn, conn->force_user ? conn->session_info : session_info);
 
-	if (ent->session_info == NULL) {
-		ent->vuid = UID_FIELD_INVALID;
-		return false;
-	}
+		if (ent->session_info == NULL) {
+			ent->vuid = UID_FIELD_INVALID;
+			return false;
+		}
 
-	/*
-	 * It's actually OK to call check_user_ok() with
-	 * vuid == UID_FIELD_INVALID as called from change_to_user_by_session().
-	 * All this will do is throw away one entry in the cache.
-	 */
-	ent->vuid = vuid;
-	ent->read_only = readonly_share;
-	set_connection_share_access_list_entry(conn,
-					share_array_index,
-					share_access);
-	free_conn_session_info_if_unused(conn);
-	conn->session_info = ent->session_info;
-	if (vuid == UID_FIELD_INVALID) {
-		/*
-		 * Not strictly needed, just make it really
-		 * clear this entry is actually an unused one.
-		 */
-		ent->read_only = false;
-		set_connection_share_access_list_entry(conn,
-					share_array_index,
-					0);
-		ent->session_info = NULL;
+		ent->vuid = vuid;
+		ent->read_only = readonly_share;
+		free_conn_session_info_if_unused(conn);
+		conn->session_info = ent->session_info;
 	}
 
 	conn->read_only = readonly_share;
-	conn->share_access = share_access;
-
 	if (admin_user) {
 		DEBUG(2,("check_user_ok: user %s is an admin user. "
 			"Setting uid as %d\n",
-			conn->session_info->unix_info->unix_name,
+			conn->session_info->unix_name,
 			sec_initial_uid() ));
-		conn->session_info->unix_token->uid = sec_initial_uid();
+		conn->session_info->utok.uid = sec_initial_uid();
 	}
 
 	return(True);
 }
 
 /****************************************************************************
+ Clear a vuid out of the connection's vuid cache
+ This is only called on SMBulogoff.
+****************************************************************************/
+
+void conn_clear_vuid_cache(connection_struct *conn, uint16_t vuid)
+{
+	int i;
+
+	for (i=0; i<VUID_CACHE_SIZE; i++) {
+		struct vuid_cache_entry *ent;
+
+		ent = &conn->vuid_cache.array[i];
+
+		if (ent->vuid == vuid) {
+			ent->vuid = UID_FIELD_INVALID;
+			/*
+			 * We need to keep conn->session_info around
+			 * if it's equal to ent->session_info as a SMBulogoff
+			 * is often followed by a SMBtdis (with an invalid
+			 * vuid). The debug code (or regular code in
+			 * vfs_full_audit) wants to refer to the
+			 * conn->session_info pointer to print debug
+			 * statements. Theoretically this is a bug,
+			 * as once the vuid is gone the session_info
+			 * on the conn struct isn't valid any more,
+			 * but there's enough code that assumes
+			 * conn->session_info is never null that
+			 * it's easier to hold onto the old pointer
+			 * until we get a new sessionsetupX.
+			 * As everything is hung off the
+			 * conn pointer as a talloc context we're not
+			 * leaking memory here. See bug #6315. JRA.
+			 */
+			if (conn->session_info == ent->session_info) {
+				ent->session_info = NULL;
+			} else {
+				TALLOC_FREE(ent->session_info);
+			}
+			ent->read_only = False;
+		}
+	}
+}
+
+/****************************************************************************
  Become the user of a connection number without changing the security context
  stack, but modify the current_user entries.
 ****************************************************************************/
 
 static bool change_to_user_internal(connection_struct *conn,
-				    const struct auth_session_info *session_info,
-				    uint64_t vuid)
+				    const struct auth_serversupplied_info *session_info,
+				    uint16_t vuid)
 {
 	int snum;
 	gid_t gid;
@@ -307,22 +251,22 @@
 	if (!ok) {
 		DEBUG(2,("SMB user %s (unix user %s) "
 			 "not permitted access to share %s.\n",
-			 session_info->unix_info->sanitized_username,
-			 session_info->unix_info->unix_name,
-			 lp_servicename(talloc_tos(), snum)));
+			 session_info->sanitized_username,
+			 session_info->unix_name,
+			 lp_servicename(snum)));
 		return false;
 	}
 
-	uid = conn->session_info->unix_token->uid;
-	gid = conn->session_info->unix_token->gid;
-	num_groups = conn->session_info->unix_token->ngroups;
-	group_list  = conn->session_info->unix_token->groups;
+	uid = conn->session_info->utok.uid;
+	gid = conn->session_info->utok.gid;
+	num_groups = conn->session_info->utok.ngroups;
+	group_list  = conn->session_info->utok.groups;
 
 	/*
 	 * See if we should force group for this service. If so this overrides
 	 * any group set in the force user code.
 	 */
-	if((group_c = *lp_force_group(talloc_tos(), snum))) {
+	if((group_c = *lp_force_group(snum))) {
 
 		SMB_ASSERT(conn->force_group_gid != (gid_t)-1);
 
@@ -337,7 +281,7 @@
 			 */
 			for (i = 0; i < num_groups; i++) {
 				if (group_list[i] == conn->force_group_gid) {
-					conn->session_info->unix_token->gid =
+					conn->session_info->utok.gid =
 						conn->force_group_gid;
 					gid = conn->force_group_gid;
 					gid_to_sid(&conn->session_info->security_token
@@ -346,7 +290,7 @@
 				}
 			}
 		} else {
-			conn->session_info->unix_token->gid = conn->force_group_gid;
+			conn->session_info->utok.gid = conn->force_group_gid;
 			gid = conn->force_group_gid;
 			gid_to_sid(&conn->session_info->security_token->sids[1],
 				   gid);
@@ -375,9 +319,10 @@
 	return true;
 }
 
-bool change_to_user(connection_struct *conn, uint64_t vuid)
+bool change_to_user(connection_struct *conn, uint16_t vuid)
 {
-	struct user_struct *vuser;
+	const struct auth_serversupplied_info *session_info = NULL;
+	user_struct *vuser;
 	int snum = SNUM(conn);
 
 	if (!conn) {
@@ -387,33 +332,53 @@
 
 	vuser = get_valid_user_struct(conn->sconn, vuid);
 
-	if ((current_user.conn == conn) &&
+	/*
+	 * We need a separate check in security=share mode due to vuid
+	 * always being UID_FIELD_INVALID. If we don't do this then
+	 * in share mode security we are *always* changing uid's between
+	 * SMB's - this hurts performance - Badly.
+	 */
+
+	if((lp_security() == SEC_SHARE) && (current_user.conn == conn) &&
+	   (current_user.ut.uid == conn->session_info->utok.uid)) {
+		DEBUG(4,("Skipping user change - already "
+			 "user\n"));
+		return(True);
+	} else if ((current_user.conn == conn) &&
 		   (vuser != NULL) && (current_user.vuid == vuid) &&
-		   (current_user.ut.uid == vuser->session_info->unix_token->uid)) {
+		   (current_user.ut.uid == vuser->session_info->utok.uid)) {
 		DEBUG(4,("Skipping user change - already "
 			 "user\n"));
 		return(True);
 	}
 
-	if (vuser == NULL) {
-		/* Invalid vuid sent */
-		DEBUG(2,("Invalid vuid %llu used on share %s.\n",
-			 (unsigned long long)vuid, lp_servicename(talloc_tos(),
-								  snum)));
+	session_info = vuser ? vuser->session_info : conn->session_info;
+
+	if (session_info == NULL) {
+		/* Invalid vuid sent - even with security = share. */
+		DEBUG(2,("Invalid vuid %d used on "
+			 "share %s.\n", vuid, lp_servicename(snum) ));
 		return false;
 	}
 
-	return change_to_user_internal(conn, vuser->session_info, vuid);
+	/* security = share sets force_user. */
+	if (!conn->force_user && vuser == NULL) {
+		DEBUG(2,("Invalid vuid used %d in accessing "
+			"share %s.\n", vuid, lp_servicename(snum) ));
+		return False;
+	}
+
+	return change_to_user_internal(conn, session_info, vuid);
 }
 
-static bool change_to_user_by_session(connection_struct *conn,
-				      const struct auth_session_info *session_info)
+bool change_to_user_by_session(connection_struct *conn,
+			       const struct auth_serversupplied_info *session_info)
 {
 	SMB_ASSERT(conn != NULL);
 	SMB_ASSERT(session_info != NULL);
 
 	if ((current_user.conn == conn) &&
-	    (current_user.ut.uid == session_info->unix_token->uid)) {
+	    (current_user.ut.uid == session_info->utok.uid)) {
 		DEBUG(7, ("Skipping user change - already user\n"));
 
 		return true;
@@ -427,7 +392,7 @@
  but modify the current_user entries.
 ****************************************************************************/
 
-bool smbd_change_to_root_user(void)
+bool change_to_root_user(void)
 {
 	set_root_sec_ctx();
 
@@ -446,13 +411,13 @@
  user. Doesn't modify current_user.
 ****************************************************************************/
 
-bool become_authenticated_pipe_user(struct auth_session_info *session_info)
+bool become_authenticated_pipe_user(struct auth_serversupplied_info *session_info)
 {
 	if (!push_sec_ctx())
 		return False;
 
-	set_sec_ctx(session_info->unix_token->uid, session_info->unix_token->gid,
-		    session_info->unix_token->ngroups, session_info->unix_token->groups,
+	set_sec_ctx(session_info->utok.uid, session_info->utok.gid,
+		    session_info->utok.ngroups, session_info->utok.groups,
 		    session_info->security_token);
 
 	return True;
@@ -491,8 +456,8 @@
 	ctx_p->conn = current_user.conn;
 	ctx_p->vuid = current_user.vuid;
 
-	DEBUG(4, ("push_conn_ctx(%llu) : conn_ctx_stack_ndx = %d\n",
-		(unsigned long long)ctx_p->vuid, conn_ctx_stack_ndx));
+	DEBUG(4, ("push_conn_ctx(%u) : conn_ctx_stack_ndx = %d\n",
+		(unsigned int)ctx_p->vuid, conn_ctx_stack_ndx ));
 
 	conn_ctx_stack_ndx++;
 }
@@ -523,7 +488,7 @@
  restores the connection context.
 ****************************************************************************/
 
-void smbd_become_root(void)
+void become_root(void)
 {
 	 /*
 	  * no good way to handle push_sec_ctx() failing without changing
@@ -538,7 +503,7 @@
 
 /* Unbecome the root user */
 
-void smbd_unbecome_root(void)
+void unbecome_root(void)
 {
 	pop_sec_ctx();
 	pop_conn_ctx();
@@ -549,7 +514,7 @@
  Saves and restores the connection context.
 ****************************************************************************/
 
-bool become_user(connection_struct *conn, uint64_t vuid)
+bool become_user(connection_struct *conn, uint16 vuid)
 {
 	if (!push_sec_ctx())
 		return False;
@@ -566,7 +531,7 @@
 }
 
 bool become_user_by_session(connection_struct *conn,
-			    const struct auth_session_info *session_info)
+			    const struct auth_serversupplied_info *session_info)
 {
 	if (!push_sec_ctx())
 		return false;
@@ -591,7 +556,7 @@
 
 /****************************************************************************
  Return the current user we are running effectively as on this connection.
- I'd like to make this return conn->session_info->unix_token->uid, but become_root()
+ I'd like to make this return conn->session_info->utok.uid, but become_root()
  doesn't alter this value.
 ****************************************************************************/
 
@@ -602,7 +567,7 @@
 
 /****************************************************************************
  Return the current group we are running effectively as on this connection.
- I'd like to make this return conn->session_info->unix_token->gid, but become_root()
+ I'd like to make this return conn->session_info->utok.gid, but become_root()
  doesn't alter this value.
 ****************************************************************************/
 
@@ -613,7 +578,7 @@
 
 /****************************************************************************
  Return the UNIX token we are running effectively as on this connection.
- I'd like to make this return &conn->session_info->unix_token-> but become_root()
+ I'd like to make this return &conn->session_info->utok, but become_root()
  doesn't alter this value.
 ****************************************************************************/
 
@@ -622,22 +587,12 @@
 	return &current_user.ut;
 }
 
-/****************************************************************************
- Return the Windows token we are running effectively as on this connection.
- If this is currently a NULL token as we're inside become_root() - a temporary
- UNIX security override, then we search up the stack for the previous active
- token.
-****************************************************************************/
-
 const struct security_token *get_current_nttok(connection_struct *conn)
 {
-	if (current_user.nt_user_token) {
-		return current_user.nt_user_token;
-	}
-	return sec_ctx_active_token();
+	return current_user.nt_user_token;
 }
 
-uint64_t get_current_vuid(connection_struct *conn)
+uint16_t get_current_vuid(connection_struct *conn)
 {
 	return current_user.vuid;
 }
Only in ../../samba-3.6.24/source3/smbd: uid.o
diff -ur smbd/utmp.c ../../samba-3.6.24/source3/smbd/utmp.c
--- smbd/utmp.c	2012-10-30 17:01:47.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/utmp.c	2015-01-28 10:52:25.149068676 +0800
@@ -115,18 +115,18 @@
  */
 
 void sys_utmp_claim(const char *username, const char *hostname,
-		    const char *id_str, int id_num)
+			const char *ip_addr_str,
+			const char *id_str, int id_num)
 {}
 
 void sys_utmp_yield(const char *username, const char *hostname,
-		    const char *id_str, int id_num)
+			const char *ip_addr_str,
+			const char *id_str, int id_num)
 {}
 
 #else /* WITH_UTMP */
 
-#ifdef HAVE_UTMP_H
 #include <utmp.h>
-#endif
 
 #ifdef HAVE_UTMPX_H
 #include <utmpx.h>
@@ -472,23 +472,22 @@
 	int nbase;
 	const char *ut_id_encstr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
+	fourbyte[0] = 'S';
+	fourbyte[1] = 'M';
+
 /*
+ * Encode remaining 2 bytes from 'i'.
  * 'ut_id_encstr' is the character set on which modulo arithmetic is done.
  * Example: digits would produce the base-10 numbers from '001'.
  */
 	nbase = strlen(ut_id_encstr);
 
-	fourbyte[0] = ut_id_encstr[i % nbase];
-	i /= nbase;
-	fourbyte[1] = ut_id_encstr[i % nbase];
-	i /= nbase;
 	fourbyte[3] = ut_id_encstr[i % nbase];
 	i /= nbase;
 	fourbyte[2] = ut_id_encstr[i % nbase];
 	i /= nbase;
 
-	/* we do not care about overflows as i is a random number */
-	return 0;
+	return(i);	/* 0: good; else overflow */
 }
 #endif /* defined(HAVE_UT_UT_ID) */
 
@@ -498,6 +497,7 @@
 */
 static bool sys_utmp_fill(struct utmp *u,
 			const char *username, const char *hostname,
+			const char *ip_addr_str,
 			const char *id_str, int id_num)
 {
 	struct timeval timeval;
@@ -518,10 +518,15 @@
 	 * ut_line:
 	 *	If size limit proves troublesome, then perhaps use "ut_id_encode()".
 	 */
+	if (strlen(id_str) > sizeof(u->ut_line)) {
+		DEBUG(1,("id_str [%s] is too long for %lu char utmp field\n",
+			 id_str, (unsigned long)sizeof(u->ut_line)));
+		return False;
+	}
 	utmp_strcpy(u->ut_line, id_str, sizeof(u->ut_line));
 
 #if defined(HAVE_UT_UT_PID)
-	u->ut_pid = getpid();
+	u->ut_pid = sys_getpid();
 #endif
 
 /*
@@ -543,6 +548,27 @@
 #if defined(HAVE_UT_UT_HOST)
 	utmp_strcpy(u->ut_host, hostname, sizeof(u->ut_host));
 #endif
+#if defined(HAVE_IPV6) && defined(HAVE_UT_UT_ADDR_V6)
+	memset(&u->ut_addr_v6, '\0', sizeof(u->ut_addr_v6));
+	if (ip_addr_str) {
+		struct in6_addr addr;
+		if (inet_pton(AF_INET6, ip_addr_str, &addr) > 0) {
+			memcpy(&u->ut_addr_v6, &addr, sizeof(addr));
+		}
+	}
+#elif defined(HAVE_UT_UT_ADDR)
+	memset(&u->ut_addr, '\0', sizeof(u->ut_addr));
+	if (ip_addr_str) {
+		struct in_addr addr;
+		if (inet_pton(AF_INET, ip_addr_str, &addr) > 0) {
+			memcpy(&u->ut_addr, &addr, sizeof(addr));
+		}
+	}
+	/*
+	 * "(unsigned long) ut_addr" apparently exists on at least HP-UX 10.20.
+	 * Volunteer to implement, please ...
+	 */
+#endif
 
 #if defined(HAVE_UT_UT_ID)
 	if (ut_id_encode(id_num, u->ut_id) != 0) {
@@ -559,7 +585,8 @@
 ****************************************************************************/
 
 void sys_utmp_yield(const char *username, const char *hostname,
-		    const char *id_str, int id_num)
+			const char *ip_addr_str,
+			const char *id_str, int id_num)
 {
 	struct utmp u;
 
@@ -574,7 +601,7 @@
 	u.ut_type = DEAD_PROCESS;
 #endif
 
-	if (!sys_utmp_fill(&u, username, hostname, id_str, id_num))
+	if (!sys_utmp_fill(&u, username, hostname, ip_addr_str, id_str, id_num))
 		return;
 
 	sys_utmp_update(&u, NULL, False);
@@ -585,7 +612,8 @@
 ****************************************************************************/
 
 void sys_utmp_claim(const char *username, const char *hostname,
-		    const char *id_str, int id_num)
+			const char *ip_addr_str,
+			const char *id_str, int id_num)
 {
 	struct utmp u;
 
@@ -595,7 +623,7 @@
 	u.ut_type = USER_PROCESS;
 #endif
 
-	if (!sys_utmp_fill(&u, username, hostname, id_str, id_num))
+	if (!sys_utmp_fill(&u, username, hostname, ip_addr_str, id_str, id_num))
 		return;
 
 	sys_utmp_update(&u, hostname, True);
Only in ../../samba-3.6.24/source3/smbd: utmp.o
diff -ur smbd/vfs.c ../../samba-3.6.24/source3/smbd/vfs.c
--- smbd/vfs.c	2013-05-21 14:48:46.000000000 +0800
+++ ../../samba-3.6.24/source3/smbd/vfs.c	2015-01-28 10:52:25.149068676 +0800
@@ -30,23 +30,12 @@
 #include "memcache.h"
 #include "transfer_file.h"
 #include "ntioctl.h"
-#include "lib/util/tevent_unix.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_VFS
 
 static_decl_vfs;
 
-struct vfs_fsp_data {
-    struct vfs_fsp_data *next;
-    struct vfs_handle_struct *owner;
-    void (*destroy)(void *p_data);
-    void *_dummy_;
-    /* NOTE: This structure contains four pointers so that we can guarantee
-     * that the end of the structure is always both 4-byte and 8-byte aligned.
-     */
-};
-
 struct vfs_init_function_entry {
 	char *name;
 	struct vfs_init_function_entry *prev, *next;
@@ -178,7 +167,7 @@
 		DEBUG(5, ("vfs module [%s] not loaded - trying to load...\n",
 			  vfs_object));
 
-		status = smb_load_module("vfs", module_path);
+		status = smb_probe_module("vfs", module_path);
 		if (!NT_STATUS_IS_OK(status)) {
 			DEBUG(0, ("error probing vfs module '%s': %s\n",
 				  module_path, nt_errstr(status)));
@@ -194,7 +183,7 @@
 
 	DEBUGADD(5,("Successfully loaded vfs module [%s] with the new modules system\n", vfs_object));
 
-	handle = talloc_zero(conn, vfs_handle_struct);
+	handle = TALLOC_ZERO_P(conn, vfs_handle_struct);
 	if (!handle) {
 		DEBUG(0,("TALLOC_ZERO() failed!\n"));
 		goto fail;
@@ -272,23 +261,6 @@
 	}
 }
 
-void vfs_remove_all_fsp_extensions(files_struct *fsp)
-{
-	struct vfs_fsp_data *curr;
-	struct vfs_fsp_data *next;
-
-	for (curr = fsp->vfs_extension; curr; curr = next) {
-
-		next = curr->next;
-		fsp->vfs_extension = next;
-
-		if (curr->destroy) {
-			curr->destroy(EXT_DATA_AREA(curr));
-		}
-		TALLOC_FREE(curr);
-	}
-}
-
 void *vfs_memctx_fsp_extension(vfs_handle_struct *handle, files_struct *fsp)
 {
 	struct vfs_fsp_data *head;
@@ -328,12 +300,6 @@
 
 	/* Normal share - initialise with disk access functions */
 	vfs_init_default(conn);
-
-	/* No need to load vfs modules for printer connections */
-	if (conn->printer) {
-		return True;
-	}
-
 	vfs_objects = lp_vfs_objects(SNUM(conn));
 
 	/* Override VFS functions if 'vfs object' was not specified*/
@@ -394,7 +360,7 @@
 }
 
 ssize_t vfs_pread_data(files_struct *fsp, char *buf,
-                size_t byte_count, off_t offset)
+                size_t byte_count, SMB_OFF_T offset)
 {
 	size_t total=0;
 
@@ -428,25 +394,14 @@
 	ssize_t ret;
 
 	if (req && req->unread_bytes) {
-		int sockfd = req->sconn->sock;
-		int old_flags;
 		SMB_ASSERT(req->unread_bytes == N);
 		/* VFS_RECVFILE must drain the socket
 		 * before returning. */
 		req->unread_bytes = 0;
-		/* Ensure the socket is blocking. */
-		old_flags = fcntl(sockfd, F_GETFL, 0);
-		if (set_blocking(sockfd, true) == -1) {
-			return (ssize_t)-1;
-		}
-		ret = SMB_VFS_RECVFILE(sockfd,
+		return SMB_VFS_RECVFILE(req->sconn->sock,
 					fsp,
-					(off_t)-1,
+					(SMB_OFF_T)-1,
 					N);
-		if (fcntl(sockfd, F_SETFL, old_flags) == -1) {
-			return (ssize_t)-1;
-		}
-		return ret;
 	}
 
 	while (total < N) {
@@ -466,31 +421,20 @@
 			files_struct *fsp,
 			const char *buffer,
 			size_t N,
-			off_t offset)
+			SMB_OFF_T offset)
 {
 	size_t total=0;
 	ssize_t ret;
 
 	if (req && req->unread_bytes) {
-		int sockfd = req->sconn->sock;
-		int old_flags;
 		SMB_ASSERT(req->unread_bytes == N);
 		/* VFS_RECVFILE must drain the socket
 		 * before returning. */
 		req->unread_bytes = 0;
-		/* Ensure the socket is blocking. */
-		old_flags = fcntl(sockfd, F_GETFL, 0);
-		if (set_blocking(sockfd, true) == -1) {
-			return (ssize_t)-1;
-		}
-		ret = SMB_VFS_RECVFILE(sockfd,
+		return SMB_VFS_RECVFILE(req->sconn->sock,
 					fsp,
 					offset,
 					N);
-		if (fcntl(sockfd, F_SETFL, old_flags) == -1) {
-			return (ssize_t)-1;
-		}
-		return ret;
 	}
 
 	while (total < N) {
@@ -527,7 +471,7 @@
 	DEBUG(10,("vfs_allocate_file_space: file %s, len %.0f\n",
 		  fsp_str_dbg(fsp), (double)len));
 
-	if (((off_t)len) < 0) {
+	if (((SMB_OFF_T)len) < 0) {
 		DEBUG(0,("vfs_allocate_file_space: %s negative len "
 			 "requested.\n", fsp_str_dbg(fsp)));
 		errno = EINVAL;
@@ -552,7 +496,7 @@
 		contend_level2_oplocks_begin(fsp, LEVEL2_CONTEND_ALLOC_SHRINK);
 
 		flush_write_cache(fsp, SIZECHANGE_FLUSH);
-		if ((ret = SMB_VFS_FTRUNCATE(fsp, (off_t)len)) != -1) {
+		if ((ret = SMB_VFS_FTRUNCATE(fsp, (SMB_OFF_T)len)) != -1) {
 			set_filelen_write_cache(fsp, len);
 		}
 
@@ -607,7 +551,7 @@
  Returns 0 on success, -1 on failure.
 ****************************************************************************/
 
-int vfs_set_filelen(files_struct *fsp, off_t len)
+int vfs_set_filelen(files_struct *fsp, SMB_OFF_T len)
 {
 	int ret;
 
@@ -639,7 +583,7 @@
 
 #define SPARSE_BUF_WRITE_SIZE (32*1024)
 
-int vfs_slow_fallocate(files_struct *fsp, off_t offset, off_t len)
+int vfs_slow_fallocate(files_struct *fsp, SMB_OFF_T offset, SMB_OFF_T len)
 {
 	ssize_t pwrite_ret;
 	size_t total = 0;
@@ -675,11 +619,11 @@
  Returns 0 on success, -1 on failure.
 ****************************************************************************/
 
-int vfs_fill_sparse(files_struct *fsp, off_t len)
+int vfs_fill_sparse(files_struct *fsp, SMB_OFF_T len)
 {
 	int ret;
 	NTSTATUS status;
-	off_t offset;
+	SMB_OFF_T offset;
 	size_t num_to_write;
 
 	status = vfs_stat_fsp(fsp);
@@ -764,7 +708,7 @@
 	return SMB_VFS_WRITE(fsp, buf, len);
 }
 
-off_t vfs_transfer_file(files_struct *in, files_struct *out, off_t n)
+SMB_OFF_T vfs_transfer_file(files_struct *in, files_struct *out, SMB_OFF_T n)
 {
 	return transfer_file_internal((void *)in, (void *)out, n,
 				      vfs_read_fn, vfs_write_fn);
@@ -777,7 +721,7 @@
 const char *vfs_readdirname(connection_struct *conn, void *p,
 			    SMB_STRUCT_STAT *sbuf, char **talloced)
 {
-	struct dirent *ptr= NULL;
+	SMB_STRUCT_DIRENT *ptr= NULL;
 	const char *dname;
 	char *translated;
 	NTSTATUS status;
@@ -821,34 +765,26 @@
 
 int vfs_ChDir(connection_struct *conn, const char *path)
 {
-	int ret;
+	int res;
 
 	if (!LastDir) {
 		LastDir = SMB_STRDUP("");
 	}
 
-	if (strcsequal(path,".")) {
-		return 0;
-	}
+	if (strcsequal(path,"."))
+		return(0);
 
-	if (*path == '/' && strcsequal(LastDir,path)) {
-		return 0;
-	}
+	if (*path == '/' && strcsequal(LastDir,path))
+		return(0);
 
 	DEBUG(4,("vfs_ChDir to %s\n",path));
 
-	ret = SMB_VFS_CHDIR(conn,path);
-	if (ret == 0) {
-		/* Global cache. */
+	res = SMB_VFS_CHDIR(conn,path);
+	if (!res) {
 		SAFE_FREE(LastDir);
 		LastDir = SMB_STRDUP(path);
-
-		/* conn cache. */
-		TALLOC_FREE(conn->cwd);
-		conn->cwd = vfs_GetWd(conn, conn);
-		DEBUG(4,("vfs_ChDir got %s\n",conn->cwd));
 	}
-	return ret;
+	return(res);
 }
 
 /*******************************************************************
@@ -859,7 +795,7 @@
 
 char *vfs_GetWd(TALLOC_CTX *ctx, connection_struct *conn)
 {
-        char *current_dir = NULL;
+        char s[PATH_MAX+1];
 	char *result = NULL;
 	DATA_BLOB cache_value;
 	struct file_id key;
@@ -867,6 +803,8 @@
 	struct smb_filename *smb_fname_full = NULL;
 	NTSTATUS status;
 
+	*s = 0;
+
 	if (!lp_getwd_cache()) {
 		goto nocache;
 	}
@@ -928,8 +866,7 @@
 	 * systems, or the not quite so bad getwd.
 	 */
 
-	current_dir = SMB_VFS_GETWD(conn);
-	if (current_dir == NULL) {
+	if (!SMB_VFS_GETWD(conn,s)) {
 		DEBUG(0, ("vfs_GetWd: SMB_VFS_GETWD call failed: %s\n",
 			  strerror(errno)));
 		goto out;
@@ -940,11 +877,10 @@
 
 		memcache_add(smbd_memcache(), GETWD_CACHE,
 			     data_blob_const(&key, sizeof(key)),
-			     data_blob_const(current_dir,
-						strlen(current_dir)+1));
+			     data_blob_const(s, strlen(s)+1));
 	}
 
-	result = talloc_strdup(ctx, current_dir);
+	result = talloc_strdup(ctx, s);
 	if (result == NULL) {
 		errno = ENOMEM;
 	}
@@ -952,183 +888,12 @@
  out:
 	TALLOC_FREE(smb_fname_dot);
 	TALLOC_FREE(smb_fname_full);
-	SAFE_FREE(current_dir);
 	return result;
 }
 
 /*******************************************************************
  Reduce a file name, removing .. elements and checking that
  it is below dir in the heirachy. This uses realpath.
- This function must run as root, and will return names
- and valid stat structs that can be checked on open.
-********************************************************************/
-
-NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
-			const char *fname,
-			struct smb_request *smbreq)
-{
-	NTSTATUS status;
-	TALLOC_CTX *ctx = talloc_tos();
-	const char *conn_rootdir;
-	size_t rootdir_len;
-	char *dir_name = NULL;
-	const char *last_component = NULL;
-	char *resolved_name = NULL;
-	char *saved_dir = NULL;
-	struct smb_filename *smb_fname_cwd = NULL;
-	struct privilege_paths *priv_paths = NULL;
-	int ret;
-
-	DEBUG(3,("check_reduced_name_with_privilege [%s] [%s]\n",
-			fname,
-			conn->connectpath));
-
-
-	priv_paths = talloc_zero(smbreq, struct privilege_paths);
-	if (!priv_paths) {
-		status = NT_STATUS_NO_MEMORY;
-		goto err;
-	}
-
-	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
-		status = NT_STATUS_NO_MEMORY;
-		goto err;
-	}
-
-	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
-	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);
-
-	if (priv_paths->parent_name.base_name == NULL ||
-			priv_paths->file_name.base_name == NULL) {
-		status = NT_STATUS_NO_MEMORY;
-		goto err;
-	}
-
-	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
-		status = map_nt_error_from_unix(errno);
-		goto err;
-	}
-	/* Remember where we were. */
-	saved_dir = vfs_GetWd(ctx, conn);
-	if (!saved_dir) {
-		status = map_nt_error_from_unix(errno);
-		goto err;
-	}
-
-	/* Go to the parent directory to lock in memory. */
-	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
-		status = map_nt_error_from_unix(errno);
-		goto err;
-	}
-
-	/* Get the absolute path of the parent directory. */
-	resolved_name = SMB_VFS_REALPATH(conn,".");
-	if (!resolved_name) {
-		status = map_nt_error_from_unix(errno);
-		goto err;
-	}
-
-	if (*resolved_name != '/') {
-		DEBUG(0,("check_reduced_name_with_privilege: realpath "
-			"doesn't return absolute paths !\n"));
-		status = NT_STATUS_OBJECT_NAME_INVALID;
-		goto err;
-	}
-
-	DEBUG(10,("check_reduced_name_with_privilege: realpath [%s] -> [%s]\n",
-		priv_paths->parent_name.base_name,
-		resolved_name));
-
-	/* Now check the stat value is the same. */
-	status = create_synthetic_smb_fname(talloc_tos(), ".",
-					NULL, NULL,
-					&smb_fname_cwd);
-	if (!NT_STATUS_IS_OK(status)) {
-		goto err;
-	}
-
-	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
-		status = map_nt_error_from_unix(errno);
-		goto err;
-	}
-
-	/* Ensure we're pointing at the same place. */
-	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
-		DEBUG(0,("check_reduced_name_with_privilege: "
-			"device/inode/uid/gid on directory %s changed. "
-			"Denying access !\n",
-			priv_paths->parent_name.base_name));
-		status = NT_STATUS_ACCESS_DENIED;
-		goto err;
-	}
-
-	/* Ensure we're below the connect path. */
-
-	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
-	if (conn_rootdir == NULL) {
-		DEBUG(2, ("check_reduced_name_with_privilege: Could not get "
-			"conn_rootdir\n"));
-		status = NT_STATUS_ACCESS_DENIED;
-		goto err;
-	}
-
-	rootdir_len = strlen(conn_rootdir);
-	if (strncmp(conn_rootdir, resolved_name, rootdir_len) != 0) {
-		DEBUG(2, ("check_reduced_name_with_privilege: Bad access "
-			"attempt: %s is a symlink outside the "
-			"share path\n",
-			dir_name));
-		DEBUGADD(2, ("conn_rootdir =%s\n", conn_rootdir));
-		DEBUGADD(2, ("resolved_name=%s\n", resolved_name));
-		status = NT_STATUS_ACCESS_DENIED;
-		goto err;
-	}
-
-	/* Now ensure that the last component either doesn't
-	   exist, or is *NOT* a symlink. */
-
-	ret = SMB_VFS_LSTAT(conn, &priv_paths->file_name);
-	if (ret == -1) {
-		/* Errno must be ENOENT for this be ok. */
-		if (errno != ENOENT) {
-			status = map_nt_error_from_unix(errno);
-			DEBUG(2, ("check_reduced_name_with_privilege: "
-				"LSTAT on %s failed with %s\n",
-				priv_paths->file_name.base_name,
-				nt_errstr(status)));
-			goto err;
-		}
-	}
-
-	if (VALID_STAT(priv_paths->file_name.st) &&
-			S_ISLNK(priv_paths->file_name.st.st_ex_mode)) {
-		DEBUG(2, ("check_reduced_name_with_privilege: "
-			"Last component %s is a symlink. Denying"
-			"access.\n",
-			priv_paths->file_name.base_name));
-		status = NT_STATUS_ACCESS_DENIED;
-		goto err;
-	}
-
-	smbreq->priv_paths = priv_paths;
-	status = NT_STATUS_OK;
-
-  err:
-
-	if (saved_dir) {
-		vfs_ChDir(conn, saved_dir);
-	}
-	SAFE_FREE(resolved_name);
-	if (!NT_STATUS_IS_OK(status)) {
-		TALLOC_FREE(priv_paths);
-	}
-	TALLOC_FREE(dir_name);
-	return status;
-}
-
-/*******************************************************************
- Reduce a file name, removing .. elements and checking that
- it is below dir in the heirachy. This uses realpath.
 ********************************************************************/
 
 NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
@@ -1154,7 +919,6 @@
 				char *dir_name = NULL;
 				const char *last_component = NULL;
 				char *new_name = NULL;
-				int ret;
 
 				/* Last component didn't exist.
 				   Remove it and try and canonicalise
@@ -1180,13 +944,18 @@
 						nt_errstr(status)));
 					return status;
 				}
-				ret = asprintf(&new_name, "%s/%s",
-					       resolved_name, last_component);
+				new_name = talloc_asprintf(ctx,
+						"%s/%s",
+						resolved_name,
+						last_component);
+				if (!new_name) {
+					return NT_STATUS_NO_MEMORY;
+				}
 				SAFE_FREE(resolved_name);
-				if (ret == -1) {
+				resolved_name = SMB_STRDUP(new_name);
+				if (!resolved_name) {
 					return NT_STATUS_NO_MEMORY;
 				}
-				resolved_name = new_name;
 				break;
 			}
 			default:
@@ -1256,8 +1025,8 @@
 			p++;
 			if (strcmp(fname, p)!=0) {
 				DEBUG(2, ("check_reduced_name: Bad access "
-					"attempt: %s is a symlink to %s\n",
-					  fname, p));
+					"attempt: %s is a symlink\n",
+					fname));
 				SAFE_FREE(resolved_name);
 				return NT_STATUS_ACCESS_DENIED;
 			}
@@ -1382,14 +1151,14 @@
 int smb_vfs_call_connect(struct vfs_handle_struct *handle,
 			 const char *service, const char *user)
 {
-	VFS_FIND(connect);
+	VFS_FIND(connect_fn);
 	return handle->fns->connect_fn(handle, service, user);
 }
 
 void smb_vfs_call_disconnect(struct vfs_handle_struct *handle)
 {
 	VFS_FIND(disconnect);
-	handle->fns->disconnect_fn(handle);
+	handle->fns->disconnect(handle);
 }
 
 uint64_t smb_vfs_call_disk_free(struct vfs_handle_struct *handle,
@@ -1398,8 +1167,8 @@
 				uint64_t *dsize)
 {
 	VFS_FIND(disk_free);
-	return handle->fns->disk_free_fn(handle, path, small_query, bsize, 
-					 dfree, dsize);
+	return handle->fns->disk_free(handle, path, small_query, bsize, dfree,
+				      dsize);
 }
 
 int smb_vfs_call_get_quota(struct vfs_handle_struct *handle,
@@ -1407,7 +1176,7 @@
 			   SMB_DISK_QUOTA *qt)
 {
 	VFS_FIND(get_quota);
-	return handle->fns->get_quota_fn(handle, qtype, id, qt);
+	return handle->fns->get_quota(handle, qtype, id, qt);
 }
 
 int smb_vfs_call_set_quota(struct vfs_handle_struct *handle,
@@ -1415,7 +1184,7 @@
 			   SMB_DISK_QUOTA *qt)
 {
 	VFS_FIND(set_quota);
-	return handle->fns->set_quota_fn(handle, qtype, id, qt);
+	return handle->fns->set_quota(handle, qtype, id, qt);
 }
 
 int smb_vfs_call_get_shadow_copy_data(struct vfs_handle_struct *handle,
@@ -1424,109 +1193,101 @@
 				      bool labels)
 {
 	VFS_FIND(get_shadow_copy_data);
-	return handle->fns->get_shadow_copy_data_fn(handle, fsp, 
-						    shadow_copy_data,
-						    labels);
+	return handle->fns->get_shadow_copy_data(handle, fsp, shadow_copy_data,
+						 labels);
 }
 int smb_vfs_call_statvfs(struct vfs_handle_struct *handle, const char *path,
 			 struct vfs_statvfs_struct *statbuf)
 {
 	VFS_FIND(statvfs);
-	return handle->fns->statvfs_fn(handle, path, statbuf);
+	return handle->fns->statvfs(handle, path, statbuf);
 }
 
 uint32_t smb_vfs_call_fs_capabilities(struct vfs_handle_struct *handle,
 			enum timestamp_set_resolution *p_ts_res)
 {
 	VFS_FIND(fs_capabilities);
-	return handle->fns->fs_capabilities_fn(handle, p_ts_res);
-}
-
-NTSTATUS smb_vfs_call_get_dfs_referrals(struct vfs_handle_struct *handle,
-					struct dfs_GetDFSReferral *r)
-{
-	VFS_FIND(get_dfs_referrals);
-	return handle->fns->get_dfs_referrals_fn(handle, r);
+	return handle->fns->fs_capabilities(handle, p_ts_res);
 }
 
-DIR *smb_vfs_call_opendir(struct vfs_handle_struct *handle,
+SMB_STRUCT_DIR *smb_vfs_call_opendir(struct vfs_handle_struct *handle,
 				     const char *fname, const char *mask,
 				     uint32 attributes)
 {
 	VFS_FIND(opendir);
-	return handle->fns->opendir_fn(handle, fname, mask, attributes);
+	return handle->fns->opendir(handle, fname, mask, attributes);
 }
 
-DIR *smb_vfs_call_fdopendir(struct vfs_handle_struct *handle,
+SMB_STRUCT_DIR *smb_vfs_call_fdopendir(struct vfs_handle_struct *handle,
 					struct files_struct *fsp,
 					const char *mask,
 					uint32 attributes)
 {
 	VFS_FIND(fdopendir);
-	return handle->fns->fdopendir_fn(handle, fsp, mask, attributes);
+	return handle->fns->fdopendir(handle, fsp, mask, attributes);
 }
 
-struct dirent *smb_vfs_call_readdir(struct vfs_handle_struct *handle,
-					      DIR *dirp,
+SMB_STRUCT_DIRENT *smb_vfs_call_readdir(struct vfs_handle_struct *handle,
+					      SMB_STRUCT_DIR *dirp,
 					      SMB_STRUCT_STAT *sbuf)
 {
 	VFS_FIND(readdir);
-	return handle->fns->readdir_fn(handle, dirp, sbuf);
+	return handle->fns->readdir(handle, dirp, sbuf);
 }
 
 void smb_vfs_call_seekdir(struct vfs_handle_struct *handle,
-			  DIR *dirp, long offset)
+			  SMB_STRUCT_DIR *dirp, long offset)
 {
 	VFS_FIND(seekdir);
-	handle->fns->seekdir_fn(handle, dirp, offset);
+	handle->fns->seekdir(handle, dirp, offset);
 }
 
 long smb_vfs_call_telldir(struct vfs_handle_struct *handle,
-			  DIR *dirp)
+			  SMB_STRUCT_DIR *dirp)
 {
 	VFS_FIND(telldir);
-	return handle->fns->telldir_fn(handle, dirp);
+	return handle->fns->telldir(handle, dirp);
 }
 
 void smb_vfs_call_rewind_dir(struct vfs_handle_struct *handle,
-			     DIR *dirp)
+			     SMB_STRUCT_DIR *dirp)
 {
 	VFS_FIND(rewind_dir);
-	handle->fns->rewind_dir_fn(handle, dirp);
+	handle->fns->rewind_dir(handle, dirp);
 }
 
 int smb_vfs_call_mkdir(struct vfs_handle_struct *handle, const char *path,
 		       mode_t mode)
 {
 	VFS_FIND(mkdir);
-	return handle->fns->mkdir_fn(handle, path, mode);
+	return handle->fns->mkdir(handle, path, mode);
 }
 
 int smb_vfs_call_rmdir(struct vfs_handle_struct *handle, const char *path)
 {
 	VFS_FIND(rmdir);
-	return handle->fns->rmdir_fn(handle, path);
+	return handle->fns->rmdir(handle, path);
 }
 
 int smb_vfs_call_closedir(struct vfs_handle_struct *handle,
-			  DIR *dir)
+			  SMB_STRUCT_DIR *dir)
 {
 	VFS_FIND(closedir);
-	return handle->fns->closedir_fn(handle, dir);
+	return handle->fns->closedir(handle, dir);
 }
 
 void smb_vfs_call_init_search_op(struct vfs_handle_struct *handle,
-				 DIR *dirp)
+				 SMB_STRUCT_DIR *dirp)
 {
 	VFS_FIND(init_search_op);
-	handle->fns->init_search_op_fn(handle, dirp);
+	handle->fns->init_search_op(handle, dirp);
 }
 
 int smb_vfs_call_open(struct vfs_handle_struct *handle,
 		      struct smb_filename *smb_fname, struct files_struct *fsp,
 		      int flags, mode_t mode)
 {
-	VFS_FIND(open);
+	VFS_FIND(open_fn);
 	return handle->fns->open_fn(handle, smb_fname, fsp, flags, mode);
 }
 
@@ -1548,7 +1309,7 @@
 				  int *pinfo)
 {
 	VFS_FIND(create_file);
-	return handle->fns->create_file_fn(
+	return handle->fns->create_file(
 		handle, req, root_dir_fid, smb_fname, access_mask,
 		share_access, create_disposition, create_options,
 		file_attributes, oplock_request, allocation_size,
@@ -1556,90 +1317,26 @@
 		result, pinfo);
 }
 
-int smb_vfs_call_close(struct vfs_handle_struct *handle,
-		       struct files_struct *fsp)
+int smb_vfs_call_close_fn(struct vfs_handle_struct *handle,
+			  struct files_struct *fsp)
 {
-	VFS_FIND(close);
+	VFS_FIND(close_fn);
 	return handle->fns->close_fn(handle, fsp);
 }
 
-ssize_t smb_vfs_call_read(struct vfs_handle_struct *handle,
-			  struct files_struct *fsp, void *data, size_t n)
+ssize_t smb_vfs_call_vfs_read(struct vfs_handle_struct *handle,
+			      struct files_struct *fsp, void *data, size_t n)
 {
-	VFS_FIND(read);
-	return handle->fns->read_fn(handle, fsp, data, n);
+	VFS_FIND(vfs_read);
+	return handle->fns->vfs_read(handle, fsp, data, n);
 }
 
 ssize_t smb_vfs_call_pread(struct vfs_handle_struct *handle,
 			   struct files_struct *fsp, void *data, size_t n,
-			   off_t offset)
+			   SMB_OFF_T offset)
 {
 	VFS_FIND(pread);
-	return handle->fns->pread_fn(handle, fsp, data, n, offset);
-}
-
-struct smb_vfs_call_pread_state {
-	ssize_t (*recv_fn)(struct tevent_req *req, int *err);
-	ssize_t retval;
-};
-
-static void smb_vfs_call_pread_done(struct tevent_req *subreq);
-
-struct tevent_req *smb_vfs_call_pread_send(struct vfs_handle_struct *handle,
-					   TALLOC_CTX *mem_ctx,
-					   struct tevent_context *ev,
-					   struct files_struct *fsp,
-					   void *data,
-					   size_t n, off_t offset)
-{
-	struct tevent_req *req, *subreq;
-	struct smb_vfs_call_pread_state *state;
-
-	req = tevent_req_create(mem_ctx, &state,
-				struct smb_vfs_call_pread_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	VFS_FIND(pread_send);
-	state->recv_fn = handle->fns->pread_recv_fn;
-
-	subreq = handle->fns->pread_send_fn(handle, state, ev, fsp, data, n,
-					    offset);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
-	}
-	tevent_req_set_callback(subreq, smb_vfs_call_pread_done, req);
-	return req;
-}
-
-static void smb_vfs_call_pread_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smb_vfs_call_pread_state *state = tevent_req_data(
-		req, struct smb_vfs_call_pread_state);
-	int err;
-
-	state->retval = state->recv_fn(subreq, &err);
-	TALLOC_FREE(subreq);
-	if (state->retval == -1) {
-		tevent_req_error(req, err);
-		return;
-	}
-	tevent_req_done(req);
-}
-
-ssize_t SMB_VFS_PREAD_RECV(struct tevent_req *req, int *perrno)
-{
-	struct smb_vfs_call_pread_state *state = tevent_req_data(
-		req, struct smb_vfs_call_pread_state);
-	int err;
-
-	if (tevent_req_is_unix_error(req, &err)) {
-		*perrno = err;
-		return -1;
-	}
-	return state->retval;
+	return handle->fns->pread(handle, fsp, data, n, offset);
 }
 
 ssize_t smb_vfs_call_write(struct vfs_handle_struct *handle,
@@ -1647,104 +1344,40 @@
 			   size_t n)
 {
 	VFS_FIND(write);
-	return handle->fns->write_fn(handle, fsp, data, n);
+	return handle->fns->write(handle, fsp, data, n);
 }
 
 ssize_t smb_vfs_call_pwrite(struct vfs_handle_struct *handle,
 			    struct files_struct *fsp, const void *data,
-			    size_t n, off_t offset)
+			    size_t n, SMB_OFF_T offset)
 {
 	VFS_FIND(pwrite);
-	return handle->fns->pwrite_fn(handle, fsp, data, n, offset);
+	return handle->fns->pwrite(handle, fsp, data, n, offset);
 }
 
-struct smb_vfs_call_pwrite_state {
-	ssize_t (*recv_fn)(struct tevent_req *req, int *err);
-	ssize_t retval;
-};
-
-static void smb_vfs_call_pwrite_done(struct tevent_req *subreq);
-
-struct tevent_req *smb_vfs_call_pwrite_send(struct vfs_handle_struct *handle,
-					    TALLOC_CTX *mem_ctx,
-					    struct tevent_context *ev,
-					    struct files_struct *fsp,
-					    const void *data,
-					    size_t n, off_t offset)
-{
-	struct tevent_req *req, *subreq;
-	struct smb_vfs_call_pwrite_state *state;
-
-	req = tevent_req_create(mem_ctx, &state,
-				struct smb_vfs_call_pwrite_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	VFS_FIND(pwrite_send);
-	state->recv_fn = handle->fns->pwrite_recv_fn;
-
-	subreq = handle->fns->pwrite_send_fn(handle, state, ev, fsp, data, n,
-					     offset);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
-	}
-	tevent_req_set_callback(subreq, smb_vfs_call_pwrite_done, req);
-	return req;
-}
-
-static void smb_vfs_call_pwrite_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smb_vfs_call_pwrite_state *state = tevent_req_data(
-		req, struct smb_vfs_call_pwrite_state);
-	int err;
-
-	state->retval = state->recv_fn(subreq, &err);
-	TALLOC_FREE(subreq);
-	if (state->retval == -1) {
-		tevent_req_error(req, err);
-		return;
-	}
-	tevent_req_done(req);
-}
-
-ssize_t SMB_VFS_PWRITE_RECV(struct tevent_req *req, int *perrno)
-{
-	struct smb_vfs_call_pwrite_state *state = tevent_req_data(
-		req, struct smb_vfs_call_pwrite_state);
-	int err;
-
-	if (tevent_req_is_unix_error(req, &err)) {
-		*perrno = err;
-		return -1;
-	}
-	return state->retval;
-}
-
-off_t smb_vfs_call_lseek(struct vfs_handle_struct *handle,
-			     struct files_struct *fsp, off_t offset,
+SMB_OFF_T smb_vfs_call_lseek(struct vfs_handle_struct *handle,
+			     struct files_struct *fsp, SMB_OFF_T offset,
 			     int whence)
 {
 	VFS_FIND(lseek);
-	return handle->fns->lseek_fn(handle, fsp, offset, whence);
+	return handle->fns->lseek(handle, fsp, offset, whence);
 }
 
 ssize_t smb_vfs_call_sendfile(struct vfs_handle_struct *handle, int tofd,
 			      files_struct *fromfsp, const DATA_BLOB *header,
-			      off_t offset, size_t count)
+			      SMB_OFF_T offset, size_t count)
 {
 	VFS_FIND(sendfile);
-	return handle->fns->sendfile_fn(handle, tofd, fromfsp, header, offset,
-					count);
+	return handle->fns->sendfile(handle, tofd, fromfsp, header, offset,
+				     count);
 }
 
 ssize_t smb_vfs_call_recvfile(struct vfs_handle_struct *handle, int fromfd,
-			      files_struct *tofsp, off_t offset,
+			      files_struct *tofsp, SMB_OFF_T offset,
 			      size_t count)
 {
 	VFS_FIND(recvfile);
-	return handle->fns->recvfile_fn(handle, fromfd, tofsp, offset, count);
+	return handle->fns->recvfile(handle, fromfd, tofsp, offset, count);
 }
 
 int smb_vfs_call_rename(struct vfs_handle_struct *handle,
@@ -1752,97 +1385,35 @@
 			const struct smb_filename *smb_fname_dst)
 {
 	VFS_FIND(rename);
-	return handle->fns->rename_fn(handle, smb_fname_src, smb_fname_dst);
+	return handle->fns->rename(handle, smb_fname_src, smb_fname_dst);
 }
 
 int smb_vfs_call_fsync(struct vfs_handle_struct *handle,
 		       struct files_struct *fsp)
 {
 	VFS_FIND(fsync);
-	return handle->fns->fsync_fn(handle, fsp);
+	return handle->fns->fsync(handle, fsp);
 }
 
-struct smb_vfs_call_fsync_state {
-	int (*recv_fn)(struct tevent_req *req, int *err);
-	int retval;
-};
-
-static void smb_vfs_call_fsync_done(struct tevent_req *subreq);
-
-struct tevent_req *smb_vfs_call_fsync_send(struct vfs_handle_struct *handle,
-					   TALLOC_CTX *mem_ctx,
-					   struct tevent_context *ev,
-					   struct files_struct *fsp)
-{
-	struct tevent_req *req, *subreq;
-	struct smb_vfs_call_fsync_state *state;
-
-	req = tevent_req_create(mem_ctx, &state,
-				struct smb_vfs_call_fsync_state);
-	if (req == NULL) {
-		return NULL;
-	}
-	VFS_FIND(fsync_send);
-	state->recv_fn = handle->fns->fsync_recv_fn;
-
-	subreq = handle->fns->fsync_send_fn(handle, state, ev, fsp);
-	if (tevent_req_nomem(subreq, req)) {
-		return tevent_req_post(req, ev);
-	}
-	tevent_req_set_callback(subreq, smb_vfs_call_fsync_done, req);
-	return req;
-}
-
-static void smb_vfs_call_fsync_done(struct tevent_req *subreq)
-{
-	struct tevent_req *req = tevent_req_callback_data(
-		subreq, struct tevent_req);
-	struct smb_vfs_call_fsync_state *state = tevent_req_data(
-		req, struct smb_vfs_call_fsync_state);
-	int err;
-
-	state->retval = state->recv_fn(subreq, &err);
-	TALLOC_FREE(subreq);
-	if (state->retval == -1) {
-		tevent_req_error(req, err);
-		return;
-	}
-	tevent_req_done(req);
-}
-
-int SMB_VFS_FSYNC_RECV(struct tevent_req *req, int *perrno)
-{
-	struct smb_vfs_call_fsync_state *state = tevent_req_data(
-		req, struct smb_vfs_call_fsync_state);
-	int err;
-
-	if (tevent_req_is_unix_error(req, &err)) {
-		*perrno = err;
-		return -1;
-	}
-	return state->retval;
-}
-
-
 int smb_vfs_call_stat(struct vfs_handle_struct *handle,
 		      struct smb_filename *smb_fname)
 {
 	VFS_FIND(stat);
-	return handle->fns->stat_fn(handle, smb_fname);
+	return handle->fns->stat(handle, smb_fname);
 }
 
 int smb_vfs_call_fstat(struct vfs_handle_struct *handle,
 		       struct files_struct *fsp, SMB_STRUCT_STAT *sbuf)
 {
 	VFS_FIND(fstat);
-	return handle->fns->fstat_fn(handle, fsp, sbuf);
+	return handle->fns->fstat(handle, fsp, sbuf);
 }
 
 int smb_vfs_call_lstat(struct vfs_handle_struct *handle,
 		       struct smb_filename *smb_filename)
 {
 	VFS_FIND(lstat);
-	return handle->fns->lstat_fn(handle, smb_filename);
+	return handle->fns->lstat(handle, smb_filename);
 }
 
 uint64_t smb_vfs_call_get_alloc_size(struct vfs_handle_struct *handle,
@@ -1850,49 +1421,49 @@
 				     const SMB_STRUCT_STAT *sbuf)
 {
 	VFS_FIND(get_alloc_size);
-	return handle->fns->get_alloc_size_fn(handle, fsp, sbuf);
+	return handle->fns->get_alloc_size(handle, fsp, sbuf);
 }
 
 int smb_vfs_call_unlink(struct vfs_handle_struct *handle,
 			const struct smb_filename *smb_fname)
 {
 	VFS_FIND(unlink);
-	return handle->fns->unlink_fn(handle, smb_fname);
+	return handle->fns->unlink(handle, smb_fname);
 }
 
 int smb_vfs_call_chmod(struct vfs_handle_struct *handle, const char *path,
 		       mode_t mode)
 {
 	VFS_FIND(chmod);
-	return handle->fns->chmod_fn(handle, path, mode);
+	return handle->fns->chmod(handle, path, mode);
 }
 
 int smb_vfs_call_fchmod(struct vfs_handle_struct *handle,
 			struct files_struct *fsp, mode_t mode)
 {
 	VFS_FIND(fchmod);
-	return handle->fns->fchmod_fn(handle, fsp, mode);
+	return handle->fns->fchmod(handle, fsp, mode);
 }
 
 int smb_vfs_call_chown(struct vfs_handle_struct *handle, const char *path,
 		       uid_t uid, gid_t gid)
 {
 	VFS_FIND(chown);
-	return handle->fns->chown_fn(handle, path, uid, gid);
+	return handle->fns->chown(handle, path, uid, gid);
 }
 
 int smb_vfs_call_fchown(struct vfs_handle_struct *handle,
 			struct files_struct *fsp, uid_t uid, gid_t gid)
 {
 	VFS_FIND(fchown);
-	return handle->fns->fchown_fn(handle, fsp, uid, gid);
+	return handle->fns->fchown(handle, fsp, uid, gid);
 }
 
 int smb_vfs_call_lchown(struct vfs_handle_struct *handle, const char *path,
 			uid_t uid, gid_t gid)
 {
 	VFS_FIND(lchown);
-	return handle->fns->lchown_fn(handle, path, uid, gid);
+	return handle->fns->lchown(handle, path, uid, gid);
 }
 
 NTSTATUS vfs_chown_fsp(files_struct *fsp, uid_t uid, gid_t gid)
@@ -1950,7 +1521,7 @@
 		}
 
 		ZERO_STRUCT(local_fname);
-		local_fname.base_name = discard_const_p(char, final_component);
+		local_fname.base_name = CONST_DISCARD(char *,final_component);
 
 		/* Must use lstat here. */
 		ret = SMB_VFS_LSTAT(fsp->conn, &local_fname);
@@ -1998,13 +1569,13 @@
 int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
 {
 	VFS_FIND(chdir);
-	return handle->fns->chdir_fn(handle, path);
+	return handle->fns->chdir(handle, path);
 }
 
-char *smb_vfs_call_getwd(struct vfs_handle_struct *handle)
+char *smb_vfs_call_getwd(struct vfs_handle_struct *handle, char *buf)
 {
 	VFS_FIND(getwd);
-	return handle->fns->getwd_fn(handle);
+	return handle->fns->getwd(handle, buf);
 }
 
 int smb_vfs_call_ntimes(struct vfs_handle_struct *handle,
@@ -2012,24 +1583,24 @@
 			struct smb_file_time *ft)
 {
 	VFS_FIND(ntimes);
-	return handle->fns->ntimes_fn(handle, smb_fname, ft);
+	return handle->fns->ntimes(handle, smb_fname, ft);
 }
 
 int smb_vfs_call_ftruncate(struct vfs_handle_struct *handle,
-			   struct files_struct *fsp, off_t offset)
+			   struct files_struct *fsp, SMB_OFF_T offset)
 {
 	VFS_FIND(ftruncate);
-	return handle->fns->ftruncate_fn(handle, fsp, offset);
+	return handle->fns->ftruncate(handle, fsp, offset);
 }
 
 int smb_vfs_call_fallocate(struct vfs_handle_struct *handle,
 				struct files_struct *fsp,
 				enum vfs_fallocate_mode mode,
-				off_t offset,
-				off_t len)
+				SMB_OFF_T offset,
+				SMB_OFF_T len)
 {
 	VFS_FIND(fallocate);
-	return handle->fns->fallocate_fn(handle, fsp, mode, offset, len);
+	return handle->fns->fallocate(handle, fsp, mode, offset, len);
 }
 
 int smb_vfs_call_kernel_flock(struct vfs_handle_struct *handle,
@@ -2037,7 +1608,7 @@
 			      uint32_t access_mask)
 {
 	VFS_FIND(kernel_flock);
-	return handle->fns->kernel_flock_fn(handle, fsp, share_mode,
+	return handle->fns->kernel_flock(handle, fsp, share_mode,
 					 access_mask);
 }
 
@@ -2045,71 +1616,68 @@
 				struct files_struct *fsp, int leasetype)
 {
 	VFS_FIND(linux_setlease);
-	return handle->fns->linux_setlease_fn(handle, fsp, leasetype);
+	return handle->fns->linux_setlease(handle, fsp, leasetype);
 }
 
 int smb_vfs_call_symlink(struct vfs_handle_struct *handle, const char *oldpath,
 			 const char *newpath)
 {
 	VFS_FIND(symlink);
-	return handle->fns->symlink_fn(handle, oldpath, newpath);
+	return handle->fns->symlink(handle, oldpath, newpath);
 }
 
-int smb_vfs_call_readlink(struct vfs_handle_struct *handle,
+int smb_vfs_call_vfs_readlink(struct vfs_handle_struct *handle,
 			      const char *path, char *buf, size_t bufsiz)
 {
-	VFS_FIND(readlink);
-	return handle->fns->readlink_fn(handle, path, buf, bufsiz);
+	VFS_FIND(vfs_readlink);
+	return handle->fns->vfs_readlink(handle, path, buf, bufsiz);
 }
 
 int smb_vfs_call_link(struct vfs_handle_struct *handle, const char *oldpath,
 		      const char *newpath)
 {
 	VFS_FIND(link);
-	return handle->fns->link_fn(handle, oldpath, newpath);
+	return handle->fns->link(handle, oldpath, newpath);
 }
 
 int smb_vfs_call_mknod(struct vfs_handle_struct *handle, const char *path,
 		       mode_t mode, SMB_DEV_T dev)
 {
 	VFS_FIND(mknod);
-	return handle->fns->mknod_fn(handle, path, mode, dev);
+	return handle->fns->mknod(handle, path, mode, dev);
 }
 
 char *smb_vfs_call_realpath(struct vfs_handle_struct *handle, const char *path)
 {
 	VFS_FIND(realpath);
-	return handle->fns->realpath_fn(handle, path);
+	return handle->fns->realpath(handle, path);
 }
 
 NTSTATUS smb_vfs_call_notify_watch(struct vfs_handle_struct *handle,
 				   struct sys_notify_context *ctx,
-				   const char *path,
-				   uint32_t *filter,
-				   uint32_t *subdir_filter,
+				   struct notify_entry *e,
 				   void (*callback)(struct sys_notify_context *ctx,
 						    void *private_data,
 						    struct notify_event *ev),
 				   void *private_data, void *handle_p)
 {
 	VFS_FIND(notify_watch);
-	return handle->fns->notify_watch_fn(handle, ctx, path,
-					    filter, subdir_filter, callback,
-					    private_data, handle_p);
+	return handle->fns->notify_watch(handle, ctx, e, callback,
+					 private_data, handle_p);
 }
 
 int smb_vfs_call_chflags(struct vfs_handle_struct *handle, const char *path,
 			 unsigned int flags)
 {
 	VFS_FIND(chflags);
-	return handle->fns->chflags_fn(handle, path, flags);
+	return handle->fns->chflags(handle, path, flags);
 }
 
 struct file_id smb_vfs_call_file_id_create(struct vfs_handle_struct *handle,
 					   const SMB_STRUCT_STAT *sbuf)
 {
 	VFS_FIND(file_id_create);
-	return handle->fns->file_id_create_fn(handle, sbuf);
+	return handle->fns->file_id_create(handle, sbuf);
 }
 
 NTSTATUS smb_vfs_call_streaminfo(struct vfs_handle_struct *handle,
@@ -2120,8 +1688,8 @@
 				 struct stream_struct **streams)
 {
 	VFS_FIND(streaminfo);
-	return handle->fns->streaminfo_fn(handle, fsp, fname, mem_ctx,
-					  num_streams, streams);
+	return handle->fns->streaminfo(handle, fsp, fname, mem_ctx,
+				       num_streams, streams);
 }
 
 int smb_vfs_call_get_real_filename(struct vfs_handle_struct *handle,
@@ -2129,15 +1697,15 @@
 				   TALLOC_CTX *mem_ctx, char **found_name)
 {
 	VFS_FIND(get_real_filename);
-	return handle->fns->get_real_filename_fn(handle, path, name, mem_ctx,
-						 found_name);
+	return handle->fns->get_real_filename(handle, path, name, mem_ctx,
+					      found_name);
 }
 
 const char *smb_vfs_call_connectpath(struct vfs_handle_struct *handle,
 				     const char *filename)
 {
 	VFS_FIND(connectpath);
-	return handle->fns->connectpath_fn(handle, filename);
+	return handle->fns->connectpath(handle, filename);
 }
 
 bool smb_vfs_call_strict_lock(struct vfs_handle_struct *handle,
@@ -2145,7 +1713,7 @@
 			      struct lock_struct *plock)
 {
 	VFS_FIND(strict_lock);
-	return handle->fns->strict_lock_fn(handle, fsp, plock);
+	return handle->fns->strict_lock(handle, fsp, plock);
 }
 
 void smb_vfs_call_strict_unlock(struct vfs_handle_struct *handle,
@@ -2153,7 +1721,7 @@
 				struct lock_struct *plock)
 {
 	VFS_FIND(strict_unlock);
-	handle->fns->strict_unlock_fn(handle, fsp, plock);
+	handle->fns->strict_unlock(handle, fsp, plock);
 }
 
 NTSTATUS smb_vfs_call_translate_name(struct vfs_handle_struct *handle,
@@ -2163,46 +1731,27 @@
 				     char **mapped_name)
 {
 	VFS_FIND(translate_name);
-	return handle->fns->translate_name_fn(handle, name, direction, mem_ctx,
-					      mapped_name);
-}
-
-NTSTATUS smb_vfs_call_fsctl(struct vfs_handle_struct *handle,
-			    struct files_struct *fsp,
-			    TALLOC_CTX *ctx,
-			    uint32_t function,
-			    uint16_t req_flags,
-			    const uint8_t *in_data,
-			    uint32_t in_len,
-			    uint8_t **out_data,
-			    uint32_t max_out_len,
-			    uint32_t *out_len)
-{
-	VFS_FIND(fsctl);
-	return handle->fns->fsctl_fn(handle, fsp, ctx, function, req_flags, 
-				     in_data, in_len, out_data, max_out_len, 
-				     out_len);
+	return handle->fns->translate_name(handle, name, direction, mem_ctx,
+					   mapped_name);
 }
 
 NTSTATUS smb_vfs_call_fget_nt_acl(struct vfs_handle_struct *handle,
 				  struct files_struct *fsp,
 				  uint32 security_info,
-				  TALLOC_CTX *mem_ctx,
 				  struct security_descriptor **ppdesc)
 {
 	VFS_FIND(fget_nt_acl);
-	return handle->fns->fget_nt_acl_fn(handle, fsp, security_info,
-					   mem_ctx, ppdesc);
+	return handle->fns->fget_nt_acl(handle, fsp, security_info,
+					ppdesc);
 }
 
 NTSTATUS smb_vfs_call_get_nt_acl(struct vfs_handle_struct *handle,
 				 const char *name,
 				 uint32 security_info,
-				 TALLOC_CTX *mem_ctx,
 				 struct security_descriptor **ppdesc)
 {
 	VFS_FIND(get_nt_acl);
-	return handle->fns->get_nt_acl_fn(handle, name, security_info, mem_ctx, ppdesc);
+	return handle->fns->get_nt_acl(handle, name, security_info, ppdesc);
 }
 
 NTSTATUS smb_vfs_call_fset_nt_acl(struct vfs_handle_struct *handle,
@@ -2211,73 +1760,134 @@
 				  const struct security_descriptor *psd)
 {
 	VFS_FIND(fset_nt_acl);
-	return handle->fns->fset_nt_acl_fn(handle, fsp, security_info_sent, 
-					   psd);
-}
-
-NTSTATUS smb_vfs_call_audit_file(struct vfs_handle_struct *handle,
-				 struct smb_filename *file,
-				 struct security_acl *sacl,
-				 uint32_t access_requested,
-				 uint32_t access_denied)
-{
-	VFS_FIND(audit_file);
-	return handle->fns->audit_file_fn(handle, 
-					  file, 
-					  sacl, 
-					  access_requested, 
-					  access_denied);
+	return handle->fns->fset_nt_acl(handle, fsp, security_info_sent, psd);
 }
 
 int smb_vfs_call_chmod_acl(struct vfs_handle_struct *handle, const char *name,
 			   mode_t mode)
 {
 	VFS_FIND(chmod_acl);
-	return handle->fns->chmod_acl_fn(handle, name, mode);
+	return handle->fns->chmod_acl(handle, name, mode);
 }
 
 int smb_vfs_call_fchmod_acl(struct vfs_handle_struct *handle,
 			    struct files_struct *fsp, mode_t mode)
 {
 	VFS_FIND(fchmod_acl);
-	return handle->fns->fchmod_acl_fn(handle, fsp, mode);
+	return handle->fns->fchmod_acl(handle, fsp, mode);
+}
+
+int smb_vfs_call_sys_acl_get_entry(struct vfs_handle_struct *handle,
+				   SMB_ACL_T theacl, int entry_id,
+				   SMB_ACL_ENTRY_T *entry_p)
+{
+	VFS_FIND(sys_acl_get_entry);
+	return handle->fns->sys_acl_get_entry(handle, theacl, entry_id,
+					      entry_p);
+}
+
+int smb_vfs_call_sys_acl_get_tag_type(struct vfs_handle_struct *handle,
+				      SMB_ACL_ENTRY_T entry_d,
+				      SMB_ACL_TAG_T *tag_type_p)
+{
+	VFS_FIND(sys_acl_get_tag_type);
+	return handle->fns->sys_acl_get_tag_type(handle, entry_d, tag_type_p);
+}
+
+int smb_vfs_call_sys_acl_get_permset(struct vfs_handle_struct *handle,
+				     SMB_ACL_ENTRY_T entry_d,
+				     SMB_ACL_PERMSET_T *permset_p)
+{
+	VFS_FIND(sys_acl_get_permset);
+	return handle->fns->sys_acl_get_permset(handle, entry_d, permset_p);
+}
+
+void * smb_vfs_call_sys_acl_get_qualifier(struct vfs_handle_struct *handle,
+					  SMB_ACL_ENTRY_T entry_d)
+{
+	VFS_FIND(sys_acl_get_qualifier);
+	return handle->fns->sys_acl_get_qualifier(handle, entry_d);
 }
 
 SMB_ACL_T smb_vfs_call_sys_acl_get_file(struct vfs_handle_struct *handle,
 					const char *path_p,
-					SMB_ACL_TYPE_T type,
-					TALLOC_CTX *mem_ctx)
+					SMB_ACL_TYPE_T type)
 {
 	VFS_FIND(sys_acl_get_file);
-	return handle->fns->sys_acl_get_file_fn(handle, path_p, type, mem_ctx);
+	return handle->fns->sys_acl_get_file(handle, path_p, type);
 }
 
 SMB_ACL_T smb_vfs_call_sys_acl_get_fd(struct vfs_handle_struct *handle,
-				      struct files_struct *fsp,
-				      TALLOC_CTX *mem_ctx)
+				      struct files_struct *fsp)
 {
 	VFS_FIND(sys_acl_get_fd);
-	return handle->fns->sys_acl_get_fd_fn(handle, fsp, mem_ctx);
+	return handle->fns->sys_acl_get_fd(handle, fsp);
 }
 
-int smb_vfs_call_sys_acl_blob_get_file(struct vfs_handle_struct *handle,
-				       const char *path_p,
-				       TALLOC_CTX *mem_ctx, 
-				       char **blob_description,
-				       DATA_BLOB *blob)
+int smb_vfs_call_sys_acl_clear_perms(struct vfs_handle_struct *handle,
+				     SMB_ACL_PERMSET_T permset)
 {
-	VFS_FIND(sys_acl_blob_get_file);
-	return handle->fns->sys_acl_blob_get_file_fn(handle, path_p, mem_ctx, blob_description, blob);
+	VFS_FIND(sys_acl_clear_perms);
+	return handle->fns->sys_acl_clear_perms(handle, permset);
 }
 
-int smb_vfs_call_sys_acl_blob_get_fd(struct vfs_handle_struct *handle,
-				     struct files_struct *fsp,
-				     TALLOC_CTX *mem_ctx, 
-				     char **blob_description,
-				     DATA_BLOB *blob)
+int smb_vfs_call_sys_acl_add_perm(struct vfs_handle_struct *handle,
+				  SMB_ACL_PERMSET_T permset,
+				  SMB_ACL_PERM_T perm)
+{
+	VFS_FIND(sys_acl_add_perm);
+	return handle->fns->sys_acl_add_perm(handle, permset, perm);
+}
+
+char * smb_vfs_call_sys_acl_to_text(struct vfs_handle_struct *handle,
+				    SMB_ACL_T theacl, ssize_t *plen)
+{
+	VFS_FIND(sys_acl_to_text);
+	return handle->fns->sys_acl_to_text(handle, theacl, plen);
+}
+
+SMB_ACL_T smb_vfs_call_sys_acl_init(struct vfs_handle_struct *handle,
+				    int count)
+{
+	VFS_FIND(sys_acl_init);
+	return handle->fns->sys_acl_init(handle, count);
+}
+
+int smb_vfs_call_sys_acl_create_entry(struct vfs_handle_struct *handle,
+				      SMB_ACL_T *pacl, SMB_ACL_ENTRY_T *pentry)
+{
+	VFS_FIND(sys_acl_create_entry);
+	return handle->fns->sys_acl_create_entry(handle, pacl, pentry);
+}
+
+int smb_vfs_call_sys_acl_set_tag_type(struct vfs_handle_struct *handle,
+				      SMB_ACL_ENTRY_T entry,
+				      SMB_ACL_TAG_T tagtype)
 {
-	VFS_FIND(sys_acl_blob_get_fd);
-	return handle->fns->sys_acl_blob_get_fd_fn(handle, fsp, mem_ctx, blob_description, blob);
+	VFS_FIND(sys_acl_set_tag_type);
+	return handle->fns->sys_acl_set_tag_type(handle, entry, tagtype);
+}
+
+int smb_vfs_call_sys_acl_set_qualifier(struct vfs_handle_struct *handle,
+				       SMB_ACL_ENTRY_T entry, void *qual)
+{
+	VFS_FIND(sys_acl_set_qualifier);
+	return handle->fns->sys_acl_set_qualifier(handle, entry, qual);
+}
+
+int smb_vfs_call_sys_acl_set_permset(struct vfs_handle_struct *handle,
+				     SMB_ACL_ENTRY_T entry,
+				     SMB_ACL_PERMSET_T permset)
+{
+	VFS_FIND(sys_acl_set_permset);
+	return handle->fns->sys_acl_set_permset(handle, entry, permset);
+}
+
+int smb_vfs_call_sys_acl_valid(struct vfs_handle_struct *handle,
+			       SMB_ACL_T theacl)
+{
+	VFS_FIND(sys_acl_valid);
+	return handle->fns->sys_acl_valid(handle, theacl);
 }
 
 int smb_vfs_call_sys_acl_set_file(struct vfs_handle_struct *handle,
@@ -2285,21 +1895,50 @@
 				  SMB_ACL_T theacl)
 {
 	VFS_FIND(sys_acl_set_file);
-	return handle->fns->sys_acl_set_file_fn(handle, name, acltype, theacl);
+	return handle->fns->sys_acl_set_file(handle, name, acltype, theacl);
 }
 
 int smb_vfs_call_sys_acl_set_fd(struct vfs_handle_struct *handle,
 				struct files_struct *fsp, SMB_ACL_T theacl)
 {
 	VFS_FIND(sys_acl_set_fd);
-	return handle->fns->sys_acl_set_fd_fn(handle, fsp, theacl);
+	return handle->fns->sys_acl_set_fd(handle, fsp, theacl);
 }
 
 int smb_vfs_call_sys_acl_delete_def_file(struct vfs_handle_struct *handle,
 					 const char *path)
 {
 	VFS_FIND(sys_acl_delete_def_file);
-	return handle->fns->sys_acl_delete_def_file_fn(handle, path);
+	return handle->fns->sys_acl_delete_def_file(handle, path);
+}
+
+int smb_vfs_call_sys_acl_get_perm(struct vfs_handle_struct *handle,
+				  SMB_ACL_PERMSET_T permset,
+				  SMB_ACL_PERM_T perm)
+{
+	VFS_FIND(sys_acl_get_perm);
+	return handle->fns->sys_acl_get_perm(handle, permset, perm);
+}
+
+int smb_vfs_call_sys_acl_free_text(struct vfs_handle_struct *handle,
+				   char *text)
+{
+	VFS_FIND(sys_acl_free_text);
+	return handle->fns->sys_acl_free_text(handle, text);
+}
+
+int smb_vfs_call_sys_acl_free_acl(struct vfs_handle_struct *handle,
+				  SMB_ACL_T posix_acl)
+{
+	VFS_FIND(sys_acl_free_acl);
+	return handle->fns->sys_acl_free_acl(handle, posix_acl);
+}
+
+int smb_vfs_call_sys_acl_free_qualifier(struct vfs_handle_struct *handle,
+					void *qualifier, SMB_ACL_TAG_T tagtype)
+{
+	VFS_FIND(sys_acl_free_qualifier);
+	return handle->fns->sys_acl_free_qualifier(handle, qualifier, tagtype);
 }
 
 ssize_t smb_vfs_call_getxattr(struct vfs_handle_struct *handle,
@@ -2307,7 +1946,15 @@
 			      size_t size)
 {
 	VFS_FIND(getxattr);
-	return handle->fns->getxattr_fn(handle, path, name, value, size);
+	return handle->fns->getxattr(handle, path, name, value, size);
+}
+
+ssize_t smb_vfs_call_lgetxattr(struct vfs_handle_struct *handle,
+			       const char *path, const char *name, void *value,
+			       size_t size)
+{
+	VFS_FIND(lgetxattr);
+	return handle->fns->lgetxattr(handle, path, name, value, size);
 }
 
 ssize_t smb_vfs_call_fgetxattr(struct vfs_handle_struct *handle,
@@ -2315,14 +1962,21 @@
 			       void *value, size_t size)
 {
 	VFS_FIND(fgetxattr);
-	return handle->fns->fgetxattr_fn(handle, fsp, name, value, size);
+	return handle->fns->fgetxattr(handle, fsp, name, value, size);
 }
 
 ssize_t smb_vfs_call_listxattr(struct vfs_handle_struct *handle,
 			       const char *path, char *list, size_t size)
 {
 	VFS_FIND(listxattr);
-	return handle->fns->listxattr_fn(handle, path, list, size);
+	return handle->fns->listxattr(handle, path, list, size);
+}
+
+ssize_t smb_vfs_call_llistxattr(struct vfs_handle_struct *handle,
+				const char *path, char *list, size_t size)
+{
+	VFS_FIND(llistxattr);
+	return handle->fns->llistxattr(handle, path, list, size);
 }
 
 ssize_t smb_vfs_call_flistxattr(struct vfs_handle_struct *handle,
@@ -2330,21 +1984,28 @@
 				size_t size)
 {
 	VFS_FIND(flistxattr);
-	return handle->fns->flistxattr_fn(handle, fsp, list, size);
+	return handle->fns->flistxattr(handle, fsp, list, size);
 }
 
 int smb_vfs_call_removexattr(struct vfs_handle_struct *handle,
 			     const char *path, const char *name)
 {
 	VFS_FIND(removexattr);
-	return handle->fns->removexattr_fn(handle, path, name);
+	return handle->fns->removexattr(handle, path, name);
+}
+
+int smb_vfs_call_lremovexattr(struct vfs_handle_struct *handle,
+			      const char *path, const char *name)
+{
+	VFS_FIND(lremovexattr);
+	return handle->fns->lremovexattr(handle, path, name);
 }
 
 int smb_vfs_call_fremovexattr(struct vfs_handle_struct *handle,
 			      struct files_struct *fsp, const char *name)
 {
 	VFS_FIND(fremovexattr);
-	return handle->fns->fremovexattr_fn(handle, fsp, name);
+	return handle->fns->fremovexattr(handle, fsp, name);
 }
 
 int smb_vfs_call_setxattr(struct vfs_handle_struct *handle, const char *path,
@@ -2352,7 +2013,15 @@
 			  int flags)
 {
 	VFS_FIND(setxattr);
-	return handle->fns->setxattr_fn(handle, path, name, value, size, flags);
+	return handle->fns->setxattr(handle, path, name, value, size, flags);
+}
+
+int smb_vfs_call_lsetxattr(struct vfs_handle_struct *handle, const char *path,
+			   const char *name, const void *value, size_t size,
+			   int flags)
+{
+	VFS_FIND(lsetxattr);
+	return handle->fns->lsetxattr(handle, path, name, value, size, flags);
 }
 
 int smb_vfs_call_fsetxattr(struct vfs_handle_struct *handle,
@@ -2360,14 +2029,68 @@
 			   const void *value, size_t size, int flags)
 {
 	VFS_FIND(fsetxattr);
-	return handle->fns->fsetxattr_fn(handle, fsp, name, value, size, flags);
+	return handle->fns->fsetxattr(handle, fsp, name, value, size, flags);
+}
+
+int smb_vfs_call_aio_read(struct vfs_handle_struct *handle,
+			  struct files_struct *fsp, SMB_STRUCT_AIOCB *aiocb)
+{
+	VFS_FIND(aio_read);
+	return handle->fns->aio_read(handle, fsp, aiocb);
+}
+
+int smb_vfs_call_aio_write(struct vfs_handle_struct *handle,
+			   struct files_struct *fsp, SMB_STRUCT_AIOCB *aiocb)
+{
+	VFS_FIND(aio_write);
+	return handle->fns->aio_write(handle, fsp, aiocb);
+}
+
+ssize_t smb_vfs_call_aio_return_fn(struct vfs_handle_struct *handle,
+				   struct files_struct *fsp,
+				   SMB_STRUCT_AIOCB *aiocb)
+{
+	VFS_FIND(aio_return_fn);
+	return handle->fns->aio_return_fn(handle, fsp, aiocb);
+}
+
+int smb_vfs_call_aio_cancel(struct vfs_handle_struct *handle,
+			    struct files_struct *fsp, SMB_STRUCT_AIOCB *aiocb)
+{
+	VFS_FIND(aio_cancel);
+	return handle->fns->aio_cancel(handle, fsp, aiocb);
+}
+
+int smb_vfs_call_aio_error_fn(struct vfs_handle_struct *handle,
+			      struct files_struct *fsp,
+			      SMB_STRUCT_AIOCB *aiocb)
+{
+	VFS_FIND(aio_error_fn);
+	return handle->fns->aio_error_fn(handle, fsp, aiocb);
+}
+
+int smb_vfs_call_aio_fsync(struct vfs_handle_struct *handle,
+			   struct files_struct *fsp, int op,
+			   SMB_STRUCT_AIOCB *aiocb)
+{
+	VFS_FIND(aio_fsync);
+	return handle->fns->aio_fsync(handle, fsp, op, aiocb);
+}
+
+int smb_vfs_call_aio_suspend(struct vfs_handle_struct *handle,
+			     struct files_struct *fsp,
+			     const SMB_STRUCT_AIOCB * const aiocb[], int n,
+			     const struct timespec *timeout)
+{
+	VFS_FIND(aio_suspend);
+	return handle->fns->aio_suspend(handle, fsp, aiocb, n, timeout);
 }
 
 bool smb_vfs_call_aio_force(struct vfs_handle_struct *handle,
 			    struct files_struct *fsp)
 {
 	VFS_FIND(aio_force);
-	return handle->fns->aio_force_fn(handle, fsp);
+	return handle->fns->aio_force(handle, fsp);
 }
 
 bool smb_vfs_call_is_offline(struct vfs_handle_struct *handle,
@@ -2375,46 +2098,12 @@
 			     SMB_STRUCT_STAT *sbuf)
 {
 	VFS_FIND(is_offline);
-	return handle->fns->is_offline_fn(handle, fname, sbuf);
+	return handle->fns->is_offline(handle, fname, sbuf);
 }
 
 int smb_vfs_call_set_offline(struct vfs_handle_struct *handle,
                              const struct smb_filename *fname)
 {
 	VFS_FIND(set_offline);
-	return handle->fns->set_offline_fn(handle, fname);
-}
-
-NTSTATUS smb_vfs_call_durable_cookie(struct vfs_handle_struct *handle,
-				     struct files_struct *fsp,
-				     TALLOC_CTX *mem_ctx,
-				     DATA_BLOB *cookie)
-{
-	VFS_FIND(durable_cookie);
-	return handle->fns->durable_cookie_fn(handle, fsp, mem_ctx, cookie);
-}
-
-NTSTATUS smb_vfs_call_durable_disconnect(struct vfs_handle_struct *handle,
-					 struct files_struct *fsp,
-					 const DATA_BLOB old_cookie,
-					 TALLOC_CTX *mem_ctx,
-					 DATA_BLOB *new_cookie)
-{
-	VFS_FIND(durable_disconnect);
-	return handle->fns->durable_disconnect_fn(handle, fsp, old_cookie,
-					          mem_ctx, new_cookie);
-}
-
-NTSTATUS smb_vfs_call_durable_reconnect(struct vfs_handle_struct *handle,
-					struct smb_request *smb1req,
-					struct smbXsrv_open *op,
-					const DATA_BLOB old_cookie,
-					TALLOC_CTX *mem_ctx,
-					struct files_struct **fsp,
-					DATA_BLOB *new_cookie)
-{
-	VFS_FIND(durable_reconnect);
-	return handle->fns->durable_reconnect_fn(handle, smb1req, op,
-					         old_cookie, mem_ctx, fsp,
-					         new_cookie);
+	return handle->fns->set_offline(handle, fname);
 }
Only in ../../samba-3.6.24/source3/smbd: vfs.o
