/* client functions auto-generated by pidl */

#include "includes.h"
#include <tevent.h>
#include "lib/util/tevent_ntstatus.h"
#include "autoconf/librpc/gen_ndr/ndr_smbXsrv.h"
#include "autoconf/librpc/gen_ndr/ndr_smbXsrv_c.h"

/* smbXsrv - client functions generated by pidl */

struct dcerpc_smbXsrv_version_global_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_version_global_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_version_global_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_version_global_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_version_global_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_version_global_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_VERSION_GLOBAL_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_version_global_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_version_global_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_version_global_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_version_global_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_version_global_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_version_global_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_version_global_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_VERSION_GLOBAL_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_version_global_decode_state {
	struct smbXsrv_version_global_decode orig;
	struct smbXsrv_version_global_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_version_global_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_version_global_decode_send(TALLOC_CTX *mem_ctx,
							     struct tevent_context *ev,
							     struct dcerpc_binding_handle *h,
							     struct smbXsrv_version_globalB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_version_global_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_version_global_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_version_global_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_version_global_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_version_global_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_version_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_version_global_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_version_global_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_version_global_decode_recv(struct tevent_req *req,
						   TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_version_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_version_global_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_version_global_decode(struct dcerpc_binding_handle *h,
					      TALLOC_CTX *mem_ctx,
					      struct smbXsrv_version_globalB _blob /* [in]  */)
{
	struct smbXsrv_version_global_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_version_global_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_session_global_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_session_global_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_session_global_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_session_global_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_session_global_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_session_global_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_SESSION_GLOBAL_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_session_global_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_session_global_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_session_global_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_session_global_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_session_global_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_session_global_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_session_global_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_SESSION_GLOBAL_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_session_global_decode_state {
	struct smbXsrv_session_global_decode orig;
	struct smbXsrv_session_global_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_session_global_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_session_global_decode_send(TALLOC_CTX *mem_ctx,
							     struct tevent_context *ev,
							     struct dcerpc_binding_handle *h,
							     struct smbXsrv_session_globalB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_session_global_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_session_global_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_session_global_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_session_global_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_session_global_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_session_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_session_global_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_session_global_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_session_global_decode_recv(struct tevent_req *req,
						   TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_session_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_session_global_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_session_global_decode(struct dcerpc_binding_handle *h,
					      TALLOC_CTX *mem_ctx,
					      struct smbXsrv_session_globalB _blob /* [in]  */)
{
	struct smbXsrv_session_global_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_session_global_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_session_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_session_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_session_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_session_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_session_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_session_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_SESSION_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_session_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_session_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_session_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_session_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_session_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_session_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_session_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_SESSION_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_session_decode_state {
	struct smbXsrv_session_decode orig;
	struct smbXsrv_session_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_session_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_session_decode_send(TALLOC_CTX *mem_ctx,
						      struct tevent_context *ev,
						      struct dcerpc_binding_handle *h,
						      struct smbXsrv_sessionB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_session_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_session_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_session_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_session_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_session_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_session_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_session_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_session_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_session_decode_recv(struct tevent_req *req,
					    TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_session_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_session_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_session_decode(struct dcerpc_binding_handle *h,
				       TALLOC_CTX *mem_ctx,
				       struct smbXsrv_sessionB _blob /* [in]  */)
{
	struct smbXsrv_session_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_session_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_session_close_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_session_close_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_session_close_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_session_close_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_session_close_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_session_close_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_SESSION_CLOSE_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_session_close_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_session_close_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_session_close_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_session_close_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_session_close_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_session_close_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_session_close_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_SESSION_CLOSE_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_session_close_decode_state {
	struct smbXsrv_session_close_decode orig;
	struct smbXsrv_session_close_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_session_close_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_session_close_decode_send(TALLOC_CTX *mem_ctx,
							    struct tevent_context *ev,
							    struct dcerpc_binding_handle *h,
							    struct smbXsrv_session_closeB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_session_close_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_session_close_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_session_close_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_session_close_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_session_close_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_session_close_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_session_close_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_session_close_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_session_close_decode_recv(struct tevent_req *req,
						  TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_session_close_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_session_close_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_session_close_decode(struct dcerpc_binding_handle *h,
					     TALLOC_CTX *mem_ctx,
					     struct smbXsrv_session_closeB _blob /* [in]  */)
{
	struct smbXsrv_session_close_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_session_close_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_tcon_global_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_tcon_global_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_tcon_global_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_tcon_global_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_tcon_global_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_tcon_global_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_TCON_GLOBAL_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_tcon_global_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_tcon_global_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_tcon_global_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_tcon_global_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_tcon_global_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_tcon_global_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_tcon_global_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_TCON_GLOBAL_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_tcon_global_decode_state {
	struct smbXsrv_tcon_global_decode orig;
	struct smbXsrv_tcon_global_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_tcon_global_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_tcon_global_decode_send(TALLOC_CTX *mem_ctx,
							  struct tevent_context *ev,
							  struct dcerpc_binding_handle *h,
							  struct smbXsrv_tcon_globalB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_tcon_global_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_tcon_global_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_tcon_global_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_tcon_global_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_tcon_global_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_tcon_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_tcon_global_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_tcon_global_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_tcon_global_decode_recv(struct tevent_req *req,
						TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_tcon_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_tcon_global_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_tcon_global_decode(struct dcerpc_binding_handle *h,
					   TALLOC_CTX *mem_ctx,
					   struct smbXsrv_tcon_globalB _blob /* [in]  */)
{
	struct smbXsrv_tcon_global_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_tcon_global_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_tcon_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_tcon_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_tcon_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_tcon_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_tcon_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_tcon_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_TCON_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_tcon_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_tcon_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_tcon_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_tcon_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_tcon_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_tcon_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_tcon_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_TCON_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_tcon_decode_state {
	struct smbXsrv_tcon_decode orig;
	struct smbXsrv_tcon_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_tcon_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_tcon_decode_send(TALLOC_CTX *mem_ctx,
						   struct tevent_context *ev,
						   struct dcerpc_binding_handle *h,
						   struct smbXsrv_tconB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_tcon_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_tcon_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_tcon_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_tcon_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_tcon_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_tcon_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_tcon_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_tcon_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_tcon_decode_recv(struct tevent_req *req,
					 TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_tcon_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_tcon_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_tcon_decode(struct dcerpc_binding_handle *h,
				    TALLOC_CTX *mem_ctx,
				    struct smbXsrv_tconB _blob /* [in]  */)
{
	struct smbXsrv_tcon_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_tcon_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_open_global_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_open_global_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_open_global_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_open_global_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_open_global_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_open_global_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_OPEN_GLOBAL_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_open_global_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_open_global_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_open_global_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_open_global_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_open_global_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_open_global_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_open_global_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_OPEN_GLOBAL_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_open_global_decode_state {
	struct smbXsrv_open_global_decode orig;
	struct smbXsrv_open_global_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_open_global_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_open_global_decode_send(TALLOC_CTX *mem_ctx,
							  struct tevent_context *ev,
							  struct dcerpc_binding_handle *h,
							  struct smbXsrv_open_globalB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_open_global_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_open_global_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_open_global_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_open_global_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_open_global_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_open_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_open_global_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_open_global_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_open_global_decode_recv(struct tevent_req *req,
						TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_open_global_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_open_global_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_open_global_decode(struct dcerpc_binding_handle *h,
					   TALLOC_CTX *mem_ctx,
					   struct smbXsrv_open_globalB _blob /* [in]  */)
{
	struct smbXsrv_open_global_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_open_global_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_smbXsrv_open_decode_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_open_decode_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_open_decode_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct smbXsrv_open_decode *r)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_open_decode_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_open_decode_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_OPEN_DECODE, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_open_decode_r_done, req);

	return req;
}

static void dcerpc_smbXsrv_open_decode_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_open_decode_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_open_decode_r_state *state =
		tevent_req_data(req,
		struct dcerpc_smbXsrv_open_decode_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_open_decode_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct smbXsrv_open_decode *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_smbXsrv,
			NDR_SMBXSRV_OPEN_DECODE, mem_ctx, r);

	return status;
}

struct dcerpc_smbXsrv_open_decode_state {
	struct smbXsrv_open_decode orig;
	struct smbXsrv_open_decode tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_smbXsrv_open_decode_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_smbXsrv_open_decode_send(TALLOC_CTX *mem_ctx,
						   struct tevent_context *ev,
						   struct dcerpc_binding_handle *h,
						   struct smbXsrv_openB _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_smbXsrv_open_decode_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_smbXsrv_open_decode_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_smbXsrv_open_decode_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_smbXsrv_open_decode_done, req);
	return req;
}

static void dcerpc_smbXsrv_open_decode_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_smbXsrv_open_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_open_decode_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_smbXsrv_open_decode_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_smbXsrv_open_decode_recv(struct tevent_req *req,
					 TALLOC_CTX *mem_ctx)
{
	struct dcerpc_smbXsrv_open_decode_state *state = tevent_req_data(
		req, struct dcerpc_smbXsrv_open_decode_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_smbXsrv_open_decode(struct dcerpc_binding_handle *h,
				    TALLOC_CTX *mem_ctx,
				    struct smbXsrv_openB _blob /* [in]  */)
{
	struct smbXsrv_open_decode r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	/* Out parameters */

	status = dcerpc_smbXsrv_open_decode_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

