<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Vstr documentation -- functions</title>
    <style type="text/css">
      A:visited { color: #ff4040; }
      A:hover { color: #20b2aa; }

      P { text-indent: 1em; }

      body     { background: #FFF; color: #000; }

      h2.ind   { background: #DDF; }

      td.title { background: #DFD; }
      td.sect  { background: #DDF; }
      td.obj   { background: #DDD; }

      ul li                       { list-style-type: lower-roman; }
      ul li:hover                 { list-style-type: square; }
      ul:hover li                 { list-style-type: decimal; }
      ul li:hover ul li.obj       { list-style-type: decimal; }
      ul li:hover ul li.obj:hover { list-style-type: square; }
    </style>

  </head>
  <body>
<table width="100%"><tr><td class="title"><h1>Vstr documentation -- functions (345)</h1>
</td></tr></table><table width="90%"><tr><td>
<h2 class="ind">Index of sections</h2>
<ul>
<li><a href="#indx-Library%20initialization%20and%20exit%20functions">Library initialization and exit functions (2)</a>
<li><a href="#indx-Exporting%20data%20functions">Exporting data functions (10)</a>
<li><a href="#indx-Memory%20reference%20functions">Memory reference functions (14)</a>
<li><a href="#indx-Creation%2fdestruction%20of%20core%20objects">Creation/destruction of core objects (18)</a>
<li><a href="#indx-Adding%20and%20deleting%20of%20data%20functions">Adding and deleting of data functions (24)</a>
<li><a href="#indx-Substitution%20of%20data%20functions">Substitution of data functions (12)</a>
<li><a href="#indx-Comparison%20of%20data%20functions">Comparison of data functions (69)</a>
<li><a href="#indx-Searching%20for%20data%20functions">Searching for data functions (32)</a>
<li><a href="#indx-Span%20of%20data%20calculation%20functions">Span of data calculation functions (20)</a>
<li><a href="#indx-Convertion%20of%20data%20functions">Convertion of data functions (6)</a>
<li><a href="#indx-Section%20of%20Vstr%20string%20functions">Section of Vstr string functions (13)</a>
<li><a href="#indx-Splitting%20data%20into%20sections%20functions">Splitting data into sections functions (6)</a>
<li><a href="#indx-Parsing%20data%20functions">Parsing data functions (13)</a>
<li><a href="#indx-Custom%20formatter%20functions">Custom formatter functions (5)</a>
<li><a href="#indx-Short%20cut%20helper%20functions">Short cut helper functions (77)</a>
<li><a href="#indx-Interator%20functions">Interator functions (7)</a>
<li><a href="#indx-Miscellaneous%20functions">Miscellaneous functions (17)</a></ul>
<h2 class="ind">Index of sections, and their contents</h2>
<ul>
<li><a id="indx-Library%20initialization%20and%20exit%20functions" href="#Library%20initialization%20and%20exit%20functions">Library initialization and exit functions</a>
<ul>
<li class="obj"><a href="#vstr_init%28%29">vstr_init()</a>
<li class="obj"><a href="#vstr_exit%28%29">vstr_exit()</a>
</ul><li><a id="indx-Exporting%20data%20functions" href="#Exporting%20data%20functions">Exporting data functions</a>
<ul>
<li class="obj"><a href="#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a>
<li class="obj"><a href="#vstr_export_cstr_malloc%28%29">vstr_export_cstr_malloc()</a>
<li class="obj"><a href="#vstr_export_cstr_buf%28%29">vstr_export_cstr_buf()</a>
<li class="obj"><a href="#vstr_export_cstr_ref%28%29">vstr_export_cstr_ref()</a>
<li class="obj"><a href="#vstr_export_iovec_ptr_all%28%29">vstr_export_iovec_ptr_all()</a>
<li class="obj"><a href="#vstr_export_iovec_cpy_buf%28%29">vstr_export_iovec_cpy_buf()</a>
<li class="obj"><a href="#vstr_export_iovec_cpy_ptr%28%29">vstr_export_iovec_cpy_ptr()</a>
<li class="obj"><a href="#vstr_export_buf%28%29">vstr_export_buf()</a>
<li class="obj"><a href="#vstr_export_chr%28%29">vstr_export_chr()</a>
<li class="obj"><a href="#vstr_export_ref%28%29">vstr_export_ref()</a>
</ul><li><a id="indx-Memory%20reference%20functions" href="#Memory%20reference%20functions">Memory reference functions</a>
<ul>
<li class="obj"><a href="#vstr_ref_add%28%29">vstr_ref_add()</a>
<li class="obj"><a href="#vstr_ref_del%28%29">vstr_ref_del()</a>
<li class="obj"><a href="#vstr_ref_cb_free_nothing%28%29">vstr_ref_cb_free_nothing()</a>
<li class="obj"><a href="#vstr_ref_cb_free_ref%28%29">vstr_ref_cb_free_ref()</a>
<li class="obj"><a href="#vstr_ref_cb_free_ptr%28%29">vstr_ref_cb_free_ptr()</a>
<li class="obj"><a href="#vstr_ref_cb_free_ptr_ref%28%29">vstr_ref_cb_free_ptr_ref()</a>
<li class="obj"><a href="#vstr_ref_make_malloc%28%29">vstr_ref_make_malloc()</a>
<li class="obj"><a href="#vstr_ref_make_ptr%28%29">vstr_ref_make_ptr()</a>
<li class="obj"><a href="#vstr_ref_make_memdup%28%29">vstr_ref_make_memdup()</a>
<li class="obj"><a href="#vstr_ref_make_strdup%28%29">vstr_ref_make_strdup()</a>
<li class="obj"><a href="#VSTR_REF_MAKE_STRDUP%28%29">VSTR_REF_MAKE_STRDUP()</a>
<li class="obj"><a href="#vstr_ref_make_vstr_base%28%29">vstr_ref_make_vstr_base()</a>
<li class="obj"><a href="#vstr_ref_make_vstr_conf%28%29">vstr_ref_make_vstr_conf()</a>
<li class="obj"><a href="#vstr_ref_make_vstr_sects%28%29">vstr_ref_make_vstr_sects()</a>
</ul><li><a id="indx-Creation%2fdestruction%20of%20core%20objects" href="#Creation%2fdestruction%20of%20core%20objects">Creation/destruction of core objects</a>
<ul>
<li class="obj"><a href="#vstr_make_conf%28%29">vstr_make_conf()</a>
<li class="obj"><a href="#vstr_free_conf%28%29">vstr_free_conf()</a>
<li class="obj"><a href="#vstr_make_base%28%29">vstr_make_base()</a>
<li class="obj"><a href="#vstr_free_base%28%29">vstr_free_base()</a>
<li class="obj"><a href="#vstr_dup_buf%28%29">vstr_dup_buf()</a>
<li class="obj"><a href="#vstr_dup_ptr%28%29">vstr_dup_ptr()</a>
<li class="obj"><a href="#vstr_dup_non%28%29">vstr_dup_non()</a>
<li class="obj"><a href="#vstr_dup_ref%28%29">vstr_dup_ref()</a>
<li class="obj"><a href="#vstr_dup_vstr%28%29">vstr_dup_vstr()</a>
<li class="obj"><a href="#vstr_dup_rep_chr%28%29">vstr_dup_rep_chr()</a>
<li class="obj"><a href="#vstr_dup_cstr_buf%28%29">vstr_dup_cstr_buf()</a>
<li class="obj"><a href="#vstr_dup_cstr_ptr%28%29">vstr_dup_cstr_ptr()</a>
<li class="obj"><a href="#vstr_dup_cstr_ref%28%29">vstr_dup_cstr_ref()</a>
<li class="obj"><a href="#VSTR_DUP_CSTR_BUF%28%29">VSTR_DUP_CSTR_BUF()</a>
<li class="obj"><a href="#VSTR_DUP_CSTR_PTR%28%29">VSTR_DUP_CSTR_PTR()</a>
<li class="obj"><a href="#VSTR_DUP_CSTR_REF%28%29">VSTR_DUP_CSTR_REF()</a>
<li class="obj"><a href="#vstr_make_spare_nodes%28%29">vstr_make_spare_nodes()</a>
<li class="obj"><a href="#vstr_free_spare_nodes%28%29">vstr_free_spare_nodes()</a>
</ul><li><a id="indx-Adding%20and%20deleting%20of%20data%20functions" href="#Adding%20and%20deleting%20of%20data%20functions">Adding and deleting of data functions</a>
<ul>
<li class="obj"><a href="#vstr_add_buf%28%29">vstr_add_buf()</a>
<li class="obj"><a href="#vstr_add_ptr%28%29">vstr_add_ptr()</a>
<li class="obj"><a href="#vstr_add_non%28%29">vstr_add_non()</a>
<li class="obj"><a href="#vstr_add_ref%28%29">vstr_add_ref()</a>
<li class="obj"><a href="#vstr_add_vstr%28%29">vstr_add_vstr()</a>
<li class="obj"><a href="#vstr_add_rep_chr%28%29">vstr_add_rep_chr()</a>
<li class="obj"><a href="#vstr_add_cstr_buf%28%29">vstr_add_cstr_buf()</a>
<li class="obj"><a href="#vstr_add_cstr_ptr%28%29">vstr_add_cstr_ptr()</a>
<li class="obj"><a href="#vstr_add_cstr_ref%28%29">vstr_add_cstr_ref()</a>
<li class="obj"><a href="#VSTR_ADD_CSTR_BUF%28%29">VSTR_ADD_CSTR_BUF()</a>
<li class="obj"><a href="#VSTR_ADD_CSTR_PTR%28%29">VSTR_ADD_CSTR_PTR()</a>
<li class="obj"><a href="#VSTR_ADD_CSTR_REF%28%29">VSTR_ADD_CSTR_REF()</a>
<li class="obj"><a href="#vstr_add_vfmt%28%29">vstr_add_vfmt()</a>
<li class="obj"><a href="#vstr_add_fmt%28%29">vstr_add_fmt()</a>
<li class="obj"><a href="#vstr_add_vsysfmt%28%29">vstr_add_vsysfmt()</a>
<li class="obj"><a href="#vstr_add_sysfmt%28%29">vstr_add_sysfmt()</a>
<li class="obj"><a href="#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>
<li class="obj"><a href="#vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a>
<li class="obj"><a href="#vstr_add_netstr_beg%28%29">vstr_add_netstr_beg()</a>
<li class="obj"><a href="#vstr_add_netstr_end%28%29">vstr_add_netstr_end()</a>
<li class="obj"><a href="#vstr_add_netstr2_beg%28%29">vstr_add_netstr2_beg()</a>
<li class="obj"><a href="#vstr_add_netstr2_end%28%29">vstr_add_netstr2_end()</a>
<li class="obj"><a href="#vstr_del%28%29">vstr_del()</a>
<li class="obj"><a href="#vstr_mov%28%29">vstr_mov()</a>
</ul><li><a id="indx-Substitution%20of%20data%20functions" href="#Substitution%20of%20data%20functions">Substitution of data functions</a>
<ul>
<li class="obj"><a href="#vstr_sub_buf%28%29">vstr_sub_buf()</a>
<li class="obj"><a href="#vstr_sub_ptr%28%29">vstr_sub_ptr()</a>
<li class="obj"><a href="#vstr_sub_non%28%29">vstr_sub_non()</a>
<li class="obj"><a href="#vstr_sub_ref%28%29">vstr_sub_ref()</a>
<li class="obj"><a href="#vstr_sub_vstr%28%29">vstr_sub_vstr()</a>
<li class="obj"><a href="#vstr_sub_rep_chr%28%29">vstr_sub_rep_chr()</a>
<li class="obj"><a href="#vstr_sub_cstr_buf%28%29">vstr_sub_cstr_buf()</a>
<li class="obj"><a href="#vstr_sub_cstr_ptr%28%29">vstr_sub_cstr_ptr()</a>
<li class="obj"><a href="#vstr_sub_cstr_ref%28%29">vstr_sub_cstr_ref()</a>
<li class="obj"><a href="#VSTR_SUB_CSTR_BUF%28%29">VSTR_SUB_CSTR_BUF()</a>
<li class="obj"><a href="#VSTR_SUB_CSTR_PTR%28%29">VSTR_SUB_CSTR_PTR()</a>
<li class="obj"><a href="#VSTR_SUB_CSTR_REF%28%29">VSTR_SUB_CSTR_REF()</a>
</ul><li><a id="indx-Comparison%20of%20data%20functions" href="#Comparison%20of%20data%20functions">Comparison of data functions</a>
<ul>
<li class="obj"><a href="#vstr_cmp%28%29">vstr_cmp()</a>
<li class="obj"><a href="#vstr_cmp_buf%28%29">vstr_cmp_buf()</a>
<li class="obj"><a href="#vstr_cmp_case%28%29">vstr_cmp_case()</a>
<li class="obj"><a href="#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a>
<li class="obj"><a href="#vstr_cmp_fast%28%29">vstr_cmp_fast()</a>
<li class="obj"><a href="#vstr_cmp_fast_buf%28%29">vstr_cmp_fast_buf()</a>
<li class="obj"><a href="#vstr_cmp_vers%28%29">vstr_cmp_vers()</a>
<li class="obj"><a href="#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a>
<li class="obj"><a href="#vstr_cmp_eq%28%29">vstr_cmp_eq()</a>
<li class="obj"><a href="#vstr_cmp_cstr%28%29">vstr_cmp_cstr()</a>
<li class="obj"><a href="#vstr_cmp_buf_eq%28%29">vstr_cmp_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_cstr_eq%28%29">vstr_cmp_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_eq%28%29">vstr_cmp_case_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_cstr%28%29">vstr_cmp_case_cstr()</a>
<li class="obj"><a href="#vstr_cmp_case_buf_eq%28%29">vstr_cmp_case_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_cstr_eq%28%29">vstr_cmp_case_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_fast_cstr%28%29">vstr_cmp_fast_cstr()</a>
<li class="obj"><a href="#vstr_cmp_vers_eq%28%29">vstr_cmp_vers_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_cstr%28%29">vstr_cmp_vers_cstr()</a>
<li class="obj"><a href="#vstr_cmp_vers_buf_eq%28%29">vstr_cmp_vers_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_cstr_eq%28%29">vstr_cmp_vers_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_bod%28%29">vstr_cmp_bod()</a>
<li class="obj"><a href="#vstr_cmp_eod%28%29">vstr_cmp_eod()</a>
<li class="obj"><a href="#vstr_cmp_bod_eq%28%29">vstr_cmp_bod_eq()</a>
<li class="obj"><a href="#vstr_cmp_eod_eq%28%29">vstr_cmp_eod_eq()</a>
<li class="obj"><a href="#vstr_cmp_bod_buf%28%29">vstr_cmp_bod_buf()</a>
<li class="obj"><a href="#vstr_cmp_eod_buf%28%29">vstr_cmp_eod_buf()</a>
<li class="obj"><a href="#vstr_cmp_bod_buf_eq%28%29">vstr_cmp_bod_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_eod_buf_eq%28%29">vstr_cmp_eod_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_bod_cstr%28%29">vstr_cmp_bod_cstr()</a>
<li class="obj"><a href="#vstr_cmp_eod_cstr%28%29">vstr_cmp_eod_cstr()</a>
<li class="obj"><a href="#vstr_cmp_bod_cstr_eq%28%29">vstr_cmp_bod_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_eod_cstr_eq%28%29">vstr_cmp_eod_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_bod%28%29">vstr_cmp_case_bod()</a>
<li class="obj"><a href="#vstr_cmp_case_eod%28%29">vstr_cmp_case_eod()</a>
<li class="obj"><a href="#vstr_cmp_case_bod_eq%28%29">vstr_cmp_case_bod_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_eod_eq%28%29">vstr_cmp_case_eod_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_bod_buf%28%29">vstr_cmp_case_bod_buf()</a>
<li class="obj"><a href="#vstr_cmp_case_eod_buf%28%29">vstr_cmp_case_eod_buf()</a>
<li class="obj"><a href="#vstr_cmp_case_bod_buf_eq%28%29">vstr_cmp_case_bod_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_eod_buf_eq%28%29">vstr_cmp_case_eod_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_bod_cstr%28%29">vstr_cmp_case_bod_cstr()</a>
<li class="obj"><a href="#vstr_cmp_case_eod_cstr%28%29">vstr_cmp_case_eod_cstr()</a>
<li class="obj"><a href="#vstr_cmp_case_bod_cstr_eq%28%29">vstr_cmp_case_bod_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_case_eod_cstr_eq%28%29">vstr_cmp_case_eod_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_bod%28%29">vstr_cmp_vers_bod()</a>
<li class="obj"><a href="#vstr_cmp_vers_eod%28%29">vstr_cmp_vers_eod()</a>
<li class="obj"><a href="#vstr_cmp_vers_bod_eq%28%29">vstr_cmp_vers_bod_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_eod_eq%28%29">vstr_cmp_vers_eod_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_bod_buf%28%29">vstr_cmp_vers_bod_buf()</a>
<li class="obj"><a href="#vstr_cmp_vers_eod_buf%28%29">vstr_cmp_vers_eod_buf()</a>
<li class="obj"><a href="#vstr_cmp_vers_bod_buf_eq%28%29">vstr_cmp_vers_bod_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_eod_buf_eq%28%29">vstr_cmp_vers_eod_buf_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_bod_cstr%28%29">vstr_cmp_vers_bod_cstr()</a>
<li class="obj"><a href="#vstr_cmp_vers_eod_cstr%28%29">vstr_cmp_vers_eod_cstr()</a>
<li class="obj"><a href="#vstr_cmp_vers_bod_cstr_eq%28%29">vstr_cmp_vers_bod_cstr_eq()</a>
<li class="obj"><a href="#vstr_cmp_vers_eod_cstr_eq%28%29">vstr_cmp_vers_eod_cstr_eq()</a>
<li class="obj"><a href="#VSTR_CMP_EQ%28%29">VSTR_CMP_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_CSTR%28%29">VSTR_CMP_CSTR()</a>
<li class="obj"><a href="#VSTR_CMP_BUF_EQ%28%29">VSTR_CMP_BUF_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_CSTR_EQ%28%29">VSTR_CMP_CSTR_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_CASE_EQ%28%29">VSTR_CMP_CASE_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_CASE_CSTR%28%29">VSTR_CMP_CASE_CSTR()</a>
<li class="obj"><a href="#VSTR_CMP_CASE_BUF_EQ%28%29">VSTR_CMP_CASE_BUF_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_CASE_CSTR_EQ%28%29">VSTR_CMP_CASE_CSTR_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_VERS_EQ%28%29">VSTR_CMP_VERS_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_VERS_CSTR%28%29">VSTR_CMP_VERS_CSTR()</a>
<li class="obj"><a href="#VSTR_CMP_VERS_BUF_EQ%28%29">VSTR_CMP_VERS_BUF_EQ()</a>
<li class="obj"><a href="#VSTR_CMP_VERS_CSTR_EQ%28%29">VSTR_CMP_VERS_CSTR_EQ()</a>
</ul><li><a id="indx-Searching%20for%20data%20functions" href="#Searching%20for%20data%20functions">Searching for data functions</a>
<ul>
<li class="obj"><a href="#vstr_srch_chr_fwd%28%29">vstr_srch_chr_fwd()</a>
<li class="obj"><a href="#vstr_srch_chr_rev%28%29">vstr_srch_chr_rev()</a>
<li class="obj"><a href="#vstr_srch_chrs_fwd%28%29">vstr_srch_chrs_fwd()</a>
<li class="obj"><a href="#vstr_srch_chrs_rev%28%29">vstr_srch_chrs_rev()</a>
<li class="obj"><a href="#vstr_csrch_chrs_fwd%28%29">vstr_csrch_chrs_fwd()</a>
<li class="obj"><a href="#vstr_csrch_chrs_rev%28%29">vstr_csrch_chrs_rev()</a>
<li class="obj"><a href="#vstr_srch_buf_fwd%28%29">vstr_srch_buf_fwd()</a>
<li class="obj"><a href="#vstr_srch_buf_rev%28%29">vstr_srch_buf_rev()</a>
<li class="obj"><a href="#vstr_srch_vstr_fwd%28%29">vstr_srch_vstr_fwd()</a>
<li class="obj"><a href="#vstr_srch_vstr_rev%28%29">vstr_srch_vstr_rev()</a>
<li class="obj"><a href="#vstr_srch_case_chr_fwd%28%29">vstr_srch_case_chr_fwd()</a>
<li class="obj"><a href="#vstr_srch_case_chr_rev%28%29">vstr_srch_case_chr_rev()</a>
<li class="obj"><a href="#vstr_srch_case_buf_fwd%28%29">vstr_srch_case_buf_fwd()</a>
<li class="obj"><a href="#vstr_srch_case_buf_rev%28%29">vstr_srch_case_buf_rev()</a>
<li class="obj"><a href="#vstr_srch_case_vstr_fwd%28%29">vstr_srch_case_vstr_fwd()</a>
<li class="obj"><a href="#vstr_srch_case_vstr_rev%28%29">vstr_srch_case_vstr_rev()</a>
<li class="obj"><a href="#vstr_srch_cstr_buf_fwd%28%29">vstr_srch_cstr_buf_fwd()</a>
<li class="obj"><a href="#vstr_srch_cstr_buf_rev%28%29">vstr_srch_cstr_buf_rev()</a>
<li class="obj"><a href="#vstr_srch_cstr_chrs_fwd%28%29">vstr_srch_cstr_chrs_fwd()</a>
<li class="obj"><a href="#vstr_srch_cstr_chrs_rev%28%29">vstr_srch_cstr_chrs_rev()</a>
<li class="obj"><a href="#vstr_csrch_cstr_chrs_fwd%28%29">vstr_csrch_cstr_chrs_fwd()</a>
<li class="obj"><a href="#vstr_csrch_cstr_chrs_rev%28%29">vstr_csrch_cstr_chrs_rev()</a>
<li class="obj"><a href="#vstr_srch_case_cstr_buf_fwd%28%29">vstr_srch_case_cstr_buf_fwd()</a>
<li class="obj"><a href="#vstr_srch_case_cstr_buf_rev%28%29">vstr_srch_case_cstr_buf_rev()</a>
<li class="obj"><a href="#VSTR_SRCH_CSTR_BUF_FWD%28%29">VSTR_SRCH_CSTR_BUF_FWD()</a>
<li class="obj"><a href="#VSTR_SRCH_CSTR_BUF_REV%28%29">VSTR_SRCH_CSTR_BUF_REV()</a>
<li class="obj"><a href="#VSTR_SRCH_CSTR_CHRS_FWD%28%29">VSTR_SRCH_CSTR_CHRS_FWD()</a>
<li class="obj"><a href="#VSTR_SRCH_CSTR_CHRS_REV%28%29">VSTR_SRCH_CSTR_CHRS_REV()</a>
<li class="obj"><a href="#VSTR_CSRCH_CSTR_CHRS_FWD%28%29">VSTR_CSRCH_CSTR_CHRS_FWD()</a>
<li class="obj"><a href="#VSTR_CSRCH_CSTR_CHRS_REV%28%29">VSTR_CSRCH_CSTR_CHRS_REV()</a>
<li class="obj"><a href="#VSTR_SRCH_CASE_CSTR_BUF_FWD%28%29">VSTR_SRCH_CASE_CSTR_BUF_FWD()</a>
<li class="obj"><a href="#VSTR_SRCH_CASE_CSTR_BUF_REV%28%29">VSTR_SRCH_CASE_CSTR_BUF_REV()</a>
</ul><li><a id="indx-Span%20of%20data%20calculation%20functions" href="#Span%20of%20data%20calculation%20functions">Span of data calculation functions</a>
<ul>
<li class="obj"><a href="#vstr_spn_bmap_eq_fwd%28%29">vstr_spn_bmap_eq_fwd()</a>
<li class="obj"><a href="#vstr_spn_bmap_eq_rev%28%29">vstr_spn_bmap_eq_rev()</a>
<li class="obj"><a href="#vstr_spn_bmap_and_fwd%28%29">vstr_spn_bmap_and_fwd()</a>
<li class="obj"><a href="#vstr_spn_bmap_and_rev%28%29">vstr_spn_bmap_and_rev()</a>
<li class="obj"><a href="#vstr_spn_chrs_fwd%28%29">vstr_spn_chrs_fwd()</a>
<li class="obj"><a href="#vstr_spn_chrs_rev%28%29">vstr_spn_chrs_rev()</a>
<li class="obj"><a href="#vstr_cspn_bmap_eq_fwd%28%29">vstr_cspn_bmap_eq_fwd()</a>
<li class="obj"><a href="#vstr_cspn_bmap_eq_rev%28%29">vstr_cspn_bmap_eq_rev()</a>
<li class="obj"><a href="#vstr_cspn_bmap_and_fwd%28%29">vstr_cspn_bmap_and_fwd()</a>
<li class="obj"><a href="#vstr_cspn_bmap_and_rev%28%29">vstr_cspn_bmap_and_rev()</a>
<li class="obj"><a href="#vstr_cspn_chrs_fwd%28%29">vstr_cspn_chrs_fwd()</a>
<li class="obj"><a href="#vstr_cspn_chrs_rev%28%29">vstr_cspn_chrs_rev()</a>
<li class="obj"><a href="#vstr_spn_cstr_chrs_fwd%28%29">vstr_spn_cstr_chrs_fwd()</a>
<li class="obj"><a href="#vstr_spn_cstr_chrs_rev%28%29">vstr_spn_cstr_chrs_rev()</a>
<li class="obj"><a href="#vstr_cspn_cstr_chrs_fwd%28%29">vstr_cspn_cstr_chrs_fwd()</a>
<li class="obj"><a href="#vstr_cspn_cstr_chrs_rev%28%29">vstr_cspn_cstr_chrs_rev()</a>
<li class="obj"><a href="#VSTR_SPN_CSTR_CHRS_FWD%28%29">VSTR_SPN_CSTR_CHRS_FWD()</a>
<li class="obj"><a href="#VSTR_SPN_CSTR_CHRS_REV%28%29">VSTR_SPN_CSTR_CHRS_REV()</a>
<li class="obj"><a href="#VSTR_CSPN_CSTR_CHRS_FWD%28%29">VSTR_CSPN_CSTR_CHRS_FWD()</a>
<li class="obj"><a href="#VSTR_CSPN_CSTR_CHRS_REV%28%29">VSTR_CSPN_CSTR_CHRS_REV()</a>
</ul><li><a id="indx-Convertion%20of%20data%20functions" href="#Convertion%20of%20data%20functions">Convertion of data functions</a>
<ul>
<li class="obj"><a href="#vstr_conv_lowercase%28%29">vstr_conv_lowercase()</a>
<li class="obj"><a href="#vstr_conv_uppercase%28%29">vstr_conv_uppercase()</a>
<li class="obj"><a href="#vstr_conv_unprintable_chr%28%29">vstr_conv_unprintable_chr()</a>
<li class="obj"><a href="#vstr_conv_unprintable_del%28%29">vstr_conv_unprintable_del()</a>
<li class="obj"><a href="#vstr_conv_encode_uri%28%29">vstr_conv_encode_uri()</a>
<li class="obj"><a href="#vstr_conv_decode_uri%28%29">vstr_conv_decode_uri()</a>
</ul><li><a id="indx-Section%20of%20Vstr%20string%20functions" href="#Section%20of%20Vstr%20string%20functions">Section of Vstr string functions</a>
<ul>
<li class="obj"><a href="#VSTR_SECTS_DECL%28%29">VSTR_SECTS_DECL()</a>
<li class="obj"><a href="#VSTR_SECTS_EXTERN_DECL%28%29">VSTR_SECTS_EXTERN_DECL()</a>
<li class="obj"><a href="#VSTR_SECTS_DECL_INIT%28%29">VSTR_SECTS_DECL_INIT()</a>
<li class="obj"><a href="#VSTR_SECTS_INIT%28%29">VSTR_SECTS_INIT()</a>
<li class="obj"><a href="#VSTR_SECTS_NUM%28%29">VSTR_SECTS_NUM()</a>
<li class="obj"><a href="#vstr_sects_make%28%29">vstr_sects_make()</a>
<li class="obj"><a href="#vstr_sects_free%28%29">vstr_sects_free()</a>
<li class="obj"><a href="#vstr_sects_add%28%29">vstr_sects_add()</a>
<li class="obj"><a href="#vstr_sects_del%28%29">vstr_sects_del()</a>
<li class="obj"><a href="#vstr_sects_foreach%28%29">vstr_sects_foreach()</a>
<li class="obj"><a href="#vstr_sects_update_add%28%29">vstr_sects_update_add()</a>
<li class="obj"><a href="#vstr_sects_update_del%28%29">vstr_sects_update_del()</a>
<li class="obj"><a href="#vstr_sects_srch%28%29">vstr_sects_srch()</a>
</ul><li><a id="indx-Splitting%20data%20into%20sections%20functions" href="#Splitting%20data%20into%20sections%20functions">Splitting data into sections functions</a>
<ul>
<li class="obj"><a href="#vstr_split_buf%28%29">vstr_split_buf()</a>
<li class="obj"><a href="#vstr_split_chrs%28%29">vstr_split_chrs()</a>
<li class="obj"><a href="#vstr_split_cstr_buf%28%29">vstr_split_cstr_buf()</a>
<li class="obj"><a href="#vstr_split_cstr_chrs%28%29">vstr_split_cstr_chrs()</a>
<li class="obj"><a href="#VSTR_SPLIT_CSTR_BUF%28%29">VSTR_SPLIT_CSTR_BUF()</a>
<li class="obj"><a href="#VSTR_SPLIT_CSTR_CHRS%28%29">VSTR_SPLIT_CSTR_CHRS()</a>
</ul><li><a id="indx-Parsing%20data%20functions" href="#Parsing%20data%20functions">Parsing data functions</a>
<ul>
<li class="obj"><a href="#vstr_parse_num%28%29">vstr_parse_num()</a>
<li class="obj"><a href="#vstr_parse_short%28%29">vstr_parse_short()</a>
<li class="obj"><a href="#vstr_parse_ushort%28%29">vstr_parse_ushort()</a>
<li class="obj"><a href="#vstr_parse_int%28%29">vstr_parse_int()</a>
<li class="obj"><a href="#vstr_parse_uint%28%29">vstr_parse_uint()</a>
<li class="obj"><a href="#vstr_parse_long%28%29">vstr_parse_long()</a>
<li class="obj"><a href="#vstr_parse_ulong%28%29">vstr_parse_ulong()</a>
<li class="obj"><a href="#vstr_parse_intmax%28%29">vstr_parse_intmax()</a>
<li class="obj"><a href="#vstr_parse_uintmax%28%29">vstr_parse_uintmax()</a>
<li class="obj"><a href="#vstr_parse_netstr%28%29">vstr_parse_netstr()</a>
<li class="obj"><a href="#vstr_parse_netstr2%28%29">vstr_parse_netstr2()</a>
<li class="obj"><a href="#vstr_parse_ipv4%28%29">vstr_parse_ipv4()</a>
<li class="obj"><a href="#vstr_parse_ipv6%28%29">vstr_parse_ipv6()</a>
</ul><li><a id="indx-Custom%20formatter%20functions" href="#Custom%20formatter%20functions">Custom formatter functions</a>
<ul>
<li class="obj"><a href="#vstr_fmt_add%28%29">vstr_fmt_add()</a>
<li class="obj"><a href="#vstr_fmt_del%28%29">vstr_fmt_del()</a>
<li class="obj"><a href="#vstr_fmt_srch%28%29">vstr_fmt_srch()</a>
<li class="obj"><a href="#VSTR_FMT_CB_ARG_PTR%28%29">VSTR_FMT_CB_ARG_PTR()</a>
<li class="obj"><a href="#VSTR_FMT_CB_ARG_VAL%28%29">VSTR_FMT_CB_ARG_VAL()</a>
</ul><li><a id="indx-Short%20cut%20helper%20functions" href="#Short%20cut%20helper%20functions">Short cut helper functions</a>
<ul>
<li class="obj"><a href="#vstr_sc_bmap_init_eq_spn_buf%28%29">vstr_sc_bmap_init_eq_spn_buf()</a>
<li class="obj"><a href="#vstr_sc_bmap_init_eq_spn_cstr%28%29">vstr_sc_bmap_init_eq_spn_cstr()</a>
<li class="obj"><a href="#vstr_sc_bmap_init_or_spn_buf%28%29">vstr_sc_bmap_init_or_spn_buf()</a>
<li class="obj"><a href="#vstr_sc_bmap_init_or_spn_cstr%28%29">vstr_sc_bmap_init_or_spn_cstr()</a>
<li class="obj"><a href="#vstr_sc_posdiff%28%29">vstr_sc_posdiff()</a>
<li class="obj"><a href="#VSTR_SC_POSDIFF%28%29">VSTR_SC_POSDIFF()</a>
<li class="obj"><a href="#vstr_sc_poslast%28%29">vstr_sc_poslast()</a>
<li class="obj"><a href="#VSTR_SC_POSLAST%28%29">VSTR_SC_POSLAST()</a>
<li class="obj"><a href="#vstr_sc_reduce%28%29">vstr_sc_reduce()</a>
<li class="obj"><a href="#vstr_sc_basename%28%29">vstr_sc_basename()</a>
<li class="obj"><a href="#vstr_sc_add_grpbasenum_buf%28%29">vstr_sc_add_grpbasenum_buf()</a>
<li class="obj"><a href="#vstr_sc_add_grpbasenum_ptr%28%29">vstr_sc_add_grpbasenum_ptr()</a>
<li class="obj"><a href="#vstr_sc_add_grpbasenum_ref%28%29">vstr_sc_add_grpbasenum_ref()</a>
<li class="obj"><a href="#vstr_sc_add_grpnum_buf%28%29">vstr_sc_add_grpnum_buf()</a>
<li class="obj"><a href="#vstr_sc_add_cstr_grpbasenum_buf%28%29">vstr_sc_add_cstr_grpbasenum_buf()</a>
<li class="obj"><a href="#vstr_sc_add_cstr_grpbasenum_ptr%28%29">vstr_sc_add_cstr_grpbasenum_ptr()</a>
<li class="obj"><a href="#vstr_sc_add_cstr_grpbasenum_ref%28%29">vstr_sc_add_cstr_grpbasenum_ref()</a>
<li class="obj"><a href="#VSTR_SC_ADD_CSTR_GRPBASENUM_BUF%28%29">VSTR_SC_ADD_CSTR_GRPBASENUM_BUF()</a>
<li class="obj"><a href="#VSTR_SC_ADD_CSTR_GRPBASENUM_PTR%28%29">VSTR_SC_ADD_CSTR_GRPBASENUM_PTR()</a>
<li class="obj"><a href="#VSTR_SC_ADD_CSTR_GRPBASENUM_REF%28%29">VSTR_SC_ADD_CSTR_GRPBASENUM_REF()</a>
<li class="obj"><a href="#vstr_sc_add_cstr_grpnum_buf%28%29">vstr_sc_add_cstr_grpnum_buf()</a>
<li class="obj"><a href="#VSTR_SC_ADD_CSTR_GRPNUM_BUF%28%29">VSTR_SC_ADD_CSTR_GRPNUM_BUF()</a>
<li class="obj"><a href="#vstr_sc_conv_num_uint%28%29">vstr_sc_conv_num_uint()</a>
<li class="obj"><a href="#vstr_sc_conv_num10_uint%28%29">vstr_sc_conv_num10_uint()</a>
<li class="obj"><a href="#vstr_sc_conv_num_ulong%28%29">vstr_sc_conv_num_ulong()</a>
<li class="obj"><a href="#vstr_sc_conv_num10_ulong%28%29">vstr_sc_conv_num10_ulong()</a>
<li class="obj"><a href="#vstr_sc_conv_num_size%28%29">vstr_sc_conv_num_size()</a>
<li class="obj"><a href="#vstr_sc_conv_num10_size%28%29">vstr_sc_conv_num10_size()</a>
<li class="obj"><a href="#vstr_sc_conv_num_uintmax%28%29">vstr_sc_conv_num_uintmax()</a>
<li class="obj"><a href="#vstr_sc_conv_num10_uintmax%28%29">vstr_sc_conv_num10_uintmax()</a>
<li class="obj"><a href="#vstr_sc_dirname%28%29">vstr_sc_dirname()</a>
<li class="obj"><a href="#vstr_sc_fmt_cb_beg%28%29">vstr_sc_fmt_cb_beg()</a>
<li class="obj"><a href="#vstr_sc_fmt_cb_end%28%29">vstr_sc_fmt_cb_end()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_vstr%28%29">vstr_sc_fmt_add_vstr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_buf%28%29">vstr_sc_fmt_add_buf()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ptr%28%29">vstr_sc_fmt_add_ptr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_non%28%29">vstr_sc_fmt_add_non()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ref%28%29">vstr_sc_fmt_add_ref()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_rep_chr%28%29">vstr_sc_fmt_add_rep_chr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_Byte_uint%28%29">vstr_sc_fmt_add_bkmg_Byte_uint()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_Bytes_uint%28%29">vstr_sc_fmt_add_bkmg_Bytes_uint()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_bit_uint%28%29">vstr_sc_fmt_add_bkmg_bit_uint()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_bits_uint%28%29">vstr_sc_fmt_add_bkmg_bits_uint()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_Byte_uintmax%28%29">vstr_sc_fmt_add_bkmg_Byte_uintmax()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_Bytes_uintmax%28%29">vstr_sc_fmt_add_bkmg_Bytes_uintmax()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_bit_uintmax%28%29">vstr_sc_fmt_add_bkmg_bit_uintmax()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_bkmg_bits_uintmax%28%29">vstr_sc_fmt_add_bkmg_bits_uintmax()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ipv4_ptr%28%29">vstr_sc_fmt_add_ipv4_ptr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ipv6_ptr%28%29">vstr_sc_fmt_add_ipv6_ptr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ipv4_vec%28%29">vstr_sc_fmt_add_ipv4_vec()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ipv6_vec%28%29">vstr_sc_fmt_add_ipv6_vec()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ipv4_vec_cidr%28%29">vstr_sc_fmt_add_ipv4_vec_cidr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_ipv6_vec_cidr%28%29">vstr_sc_fmt_add_ipv6_vec_cidr()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_upper_base2_uint%28%29">vstr_sc_fmt_add_upper_base2_uint()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_upper_base2_ulong%28%29">vstr_sc_fmt_add_upper_base2_ulong()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_upper_base2_size%28%29">vstr_sc_fmt_add_upper_base2_size()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_upper_base2_uintmax%28%29">vstr_sc_fmt_add_upper_base2_uintmax()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_lower_base2_uint%28%29">vstr_sc_fmt_add_lower_base2_uint()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_lower_base2_ulong%28%29">vstr_sc_fmt_add_lower_base2_ulong()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_lower_base2_size%28%29">vstr_sc_fmt_add_lower_base2_size()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_lower_base2_uintmax%28%29">vstr_sc_fmt_add_lower_base2_uintmax()</a>
<li class="obj"><a href="#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
<li class="obj"><a href="#VSTR_SC_FMT_ADD%28%29">VSTR_SC_FMT_ADD()</a>
<li class="obj"><a href="#vstr_sc_mmap_fd%28%29">vstr_sc_mmap_fd()</a>
<li class="obj"><a href="#vstr_sc_mmap_file%28%29">vstr_sc_mmap_file()</a>
<li class="obj"><a href="#vstr_sc_read_iov_fd%28%29">vstr_sc_read_iov_fd()</a>
<li class="obj"><a href="#vstr_sc_read_len_fd%28%29">vstr_sc_read_len_fd()</a>
<li class="obj"><a href="#vstr_sc_read_iov_file%28%29">vstr_sc_read_iov_file()</a>
<li class="obj"><a href="#vstr_sc_read_len_file%28%29">vstr_sc_read_len_file()</a>
<li class="obj"><a href="#vstr_sc_write_fd%28%29">vstr_sc_write_fd()</a>
<li class="obj"><a href="#vstr_sc_write_file%28%29">vstr_sc_write_file()</a>
<li class="obj"><a href="#vstr_sc_add_b_uint16%28%29">vstr_sc_add_b_uint16()</a>
<li class="obj"><a href="#vstr_sc_add_b_uint32%28%29">vstr_sc_add_b_uint32()</a>
<li class="obj"><a href="#vstr_sc_sub_b_uint16%28%29">vstr_sc_sub_b_uint16()</a>
<li class="obj"><a href="#vstr_sc_sub_b_uint32%28%29">vstr_sc_sub_b_uint32()</a>
<li class="obj"><a href="#vstr_sc_parse_b_uint16%28%29">vstr_sc_parse_b_uint16()</a>
<li class="obj"><a href="#vstr_sc_parse_b_uint32%28%29">vstr_sc_parse_b_uint32()</a>
</ul><li><a id="indx-Interator%20functions" href="#Interator%20functions">Interator functions</a>
<ul>
<li class="obj"><a href="#vstr_iter_fwd_beg%28%29">vstr_iter_fwd_beg()</a>
<li class="obj"><a href="#vstr_iter_fwd_nxt%28%29">vstr_iter_fwd_nxt()</a>
<li class="obj"><a href="#vstr_iter_fwd_chr%28%29">vstr_iter_fwd_chr()</a>
<li class="obj"><a href="#vstr_iter_fwd_buf%28%29">vstr_iter_fwd_buf()</a>
<li class="obj"><a href="#vstr_iter_fwd_cstr%28%29">vstr_iter_fwd_cstr()</a>
<li class="obj"><a href="#vstr_iter_pos%28%29">vstr_iter_pos()</a>
<li class="obj"><a href="#vstr_iter_len%28%29">vstr_iter_len()</a>
</ul><li><a id="indx-Miscellaneous%20functions" href="#Miscellaneous%20functions">Miscellaneous functions</a>
<ul>
<li class="obj"><a href="#vstr_cntl_opt%28%29">vstr_cntl_opt()</a>
<li class="obj"><a href="#vstr_cntl_base%28%29">vstr_cntl_base()</a>
<li class="obj"><a href="#vstr_cntl_conf%28%29">vstr_cntl_conf()</a>
<li class="obj"><a href="#VSTR_FLAGXX%28%29">VSTR_FLAGXX()</a>
<li class="obj"><a href="#vstr_num%28%29">vstr_num()</a>
<li class="obj"><a href="#vstr_cache_add%28%29">vstr_cache_add()</a>
<li class="obj"><a href="#vstr_cache_get%28%29">vstr_cache_get()</a>
<li class="obj"><a href="#vstr_cache_set%28%29">vstr_cache_set()</a>
<li class="obj"><a href="#vstr_cache_srch%28%29">vstr_cache_srch()</a>
<li class="obj"><a href="#vstr_cache_cb_sub%28%29">vstr_cache_cb_sub()</a>
<li class="obj"><a href="#vstr_cache_cb_free%28%29">vstr_cache_cb_free()</a>
<li class="obj"><a href="#vstr_data_add%28%29">vstr_data_add()</a>
<li class="obj"><a href="#vstr_data_srch%28%29">vstr_data_srch()</a>
<li class="obj"><a href="#vstr_data_del%28%29">vstr_data_del()</a>
<li class="obj"><a href="#vstr_data_get%28%29">vstr_data_get()</a>
<li class="obj"><a href="#vstr_data_set%28%29">vstr_data_set()</a>
<li class="obj"><a href="#vstr_swap_conf%28%29">vstr_swap_conf()</a>
</ul></ul>

</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Library%20initialization%20and%20exit%20functions">Library initialization and exit functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_init%28%29">vstr_init()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: Nothing<br>Type<strong>[1]</strong>: void
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function needs to be called before any of the other functions are
 called.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function can be called multiple times, without any problems.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_exit%28%29">vstr_exit()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Nothing<br>Type<strong>[1]</strong>: void
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function can be called before exit, after all vstr objects have been
 freed, to cleanup data allocated internally in the Vstr library.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function isn't needed but helps make sure there are no memory leaks, when
 used with a memory checker (or with the internal memory checker in the debug
 build).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Exporting%20data%20functions">Exporting data functions</a></h2>


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a>
<br>Returns: A pointer to an array of characters, terminated by NIL<br>Type: const char *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a pointer to an array of characters of length
 (Parameter[3] + 1), the last byte will be a 0 to terminate the "C string".
</p><p>  Multiple adjacent calls will return the same pointer.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return NULL if it needs to allocate memory and cannot do so.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If you alter the Vstr in anyway then the returned pointer may point to
 free()'d memory. To get a reference to this data use <a href="functions#vstr_export_cstr_ref%28%29">vstr_export_cstr_ref()</a>
 instead.
</p><p>  This data needs to be cached in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>, and so can only work if the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> has the ability to cache data (see
 <a href="constants#VSTR_CNTL_BASE_GET_FLAG_HAVE_CACHE">VSTR_CNTL_BASE_GET_FLAG_HAVE_CACHE</a>). If you want to make sure that the cached
 data is gone from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>, cache then you can call
 <a href="functions#vstr_cache_cb_free%28%29">vstr_cache_cb_free()</a> on the cookie from "/vstr__/cstr".
</p><p>  Any _NON data in the Vstr will be uninitialized data in the &quot;C string&quot;.
</p><p>  If there are any 0 bytes in the Vstr they will make the string look shorter
 than it really is to normal C style string functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_cstr_malloc%28%29">vstr_export_cstr_malloc()</a>
<br>Returns: A malloc'd pointer to an array of characters, terminated by NIL<br>Type: char *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a malloc'd pointer to an array of characters
 of length (Parameter[3] + 1), the last byte will be a 0 to terminate the
 "C string". You will need to pass the pointer to free(), when you are done
 with it.
</p><p>  Each call will return a different pointer.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return NULL if it needs to allocate memory and cannot do so.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Any _NON data in the Vstr will be uninitialized data in the &quot;C string&quot;.
</p><p>  If there are any 0 bytes in the Vstr they will make the string look shorter
 than it really is to normal C/POSIX string functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_cstr_buf%28%29">vstr_export_cstr_buf()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Data array to export to<br>Type<strong>[4]</strong>: void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a copy of the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> to a
 data array, the maximum amount of data stored in the array will be of length
 (Parameter[3] + 1), the last byte will be a 0 to terminate the "C string".
 However the data before the terminator of the "C string" is limited to
 (Parameter[5] - 1).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data from nodes of type NON are exported by not doing anything to the
 underlying data array (Ie. It'll have whatever data was in there to
 start with).
</p><p>  If there are any 0 bytes in the Vstr they will make the &quot;C string&quot; look
 shorter than it really is to normal C/POSIX string functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_cstr_ref%28%29">vstr_export_cstr_ref()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset of Vstr memory reference (Return)<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to return a pointer to a Vstr memory reference of at
 least length (Parameter[3] + 1), the last byte will be a 0 to terminate the
 "C string" stored in (Vstr_ref *)->ptr. The offset (Parameter[4]) should be
 used to find the beginning of the block of memory to use.
</p><p>  When you are finished with the reference you need to use <a href="functions#vstr_ref_del%28%29">vstr_ref_del()</a> or
 the memory will stay allocated forever.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return NULL if it needs to allocate memory and cannot do so.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If you want to make sure that the cached data is gone from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 cache then you can call <a href="functions#vstr_cache_cb_free%28%29">vstr_cache_cb_free()</a> on the cookie from "/vstr__/cstr".
</p><p>  Any _NON data in the Vstr will be uninitialized data in the &quot;C string&quot;.
</p><p>  If there are any 0 bytes in the Vstr they will make the string look shorter
 than it really is to normal C/POSIX string functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_iovec_ptr_all%28%29">vstr_export_iovec_ptr_all()</a>
<br>Returns: Size of bytes in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Returns the start of the iovec array<br>Type<strong>[2]</strong>: struct iovec **
</td></tr><tr><td>Parameter<strong>[2]</strong>: Returns the number of iovec structures in the array<br>Type<strong>[2]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a pointer to an array of iovec structures
 this can then be passed directly to writev() etc. or just used to
 quickly access the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Nodes of type NON are represented by a iov_base set to NULL.
</p><p>  Altering the iov_base/iov_len members will probably do very bad things, if
 you need to do this use the <a href="functions#vstr_export_iovec_cpy_ptr%28%29">vstr_export_iovec_cpy_ptr()</a>
</p><p>  Altering the data in the iovec structure isn't a good idea as it isn't easy
 for the programer to know if the data is shared/read-only. If you need to do
 this you should use either the vstr_sub_* functions instead or
 <a href="functions#vstr_export_iovec_cpy_buf%28%29">vstr_export_iovec_cpy_buf()</a> (the later does a copy). However if you do alter
 the data then you'll need to do <a href="functions#vstr_cache_cb_sub%28%29">vstr_cache_cb_sub()</a>.
</p><p>  Either of the pointers for the iovec array (Parameter[2]) or the number of
 iovecs (Parameter[3]) can be the NULL pointer, in which case nothing will be
 written to those pointers.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_iovec_cpy_buf%28%29">vstr_export_iovec_cpy_buf()</a>
<br>Returns: Size of bytes exported from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to array of initialized iovec structures<br>Type<strong>[4]</strong>: struct iovec *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Number of iovec structures (Parameter[4])<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns the number of iovec structures used in the array<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a copy of the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> to an
 array of iovec structures this can then be passed directly to writev()
 (or even a readv() although that wouldn't often be useful) etc.
</p><p>  Think of this function as doing a readv() from a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data from nodes of type NON are exported by not doing anything to the
 underlying iov_base data arrays (Ie. It'll have whatever data was in there to
 start with).
</p><p>  The length returned may be shorter than that given as Parameter[3], as it's
 the number of bytes copied into the iov_base arrays in the iovec structures.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_iovec_cpy_ptr%28%29">vstr_export_iovec_cpy_ptr()</a>
<br>Returns: Size of bytes exported from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to array of iovec structures<br>Type<strong>[4]</strong>: struct iovec *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Number of iovec structures (Parameter[4])<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns the number of iovec structures used in the array<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a set of pointer/length pairs to the data
 specified in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>, this can then be passed directly to writev() etc.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Nodes of type NON are represented by a iov_base set to NULL.
</p><p>  Altering the data in the iovec structure isn't a good idea as it isn't easy
 for the programer to know if the data is shared/read-only. If you need to do
 this you should use either the vstr_sub_* functions instead or
 <a href="functions#vstr_export_iovec_cpy_buf%28%29">vstr_export_iovec_cpy_buf()</a> (the later does a copy).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_buf%28%29">vstr_export_buf()</a>
<br>Returns: Size of bytes exported from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Data array to export to<br>Type<strong>[4]</strong>: void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to export a copy of the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> to a
 data array.
</p><p>  Think of this function as doing a read() from a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>. However the
 data will be limited to the minimum of the length of the vstr (Parameter[3])
 and the length of the data (Parameter[5]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data from nodes of type NON are exported by not doing anything to the
 underlying data array (Ie. It'll have whatever data was in there to
 start with).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_chr%28%29">vstr_export_chr()</a>
<br>Returns: Character exported from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: char
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to return a character at a certain position in a
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  It is impossible to distinguish between an error, data from a NON node
 and real data that is equal to the value 0.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_export_ref%28%29">vstr_export_ref()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset of Vstr memory reference (Return)<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to return a pointer to a Vstr memory reference of at
 least length (Parameter[3]). The offset (Parameter[4]) should be used to find
 the beginning of the block of memory to use.
</p><p>  When you are finished with the reference you need to use <a href="functions#vstr_ref_del%28%29">vstr_ref_del()</a> or
 the memory will stay allocated forever.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return NULL if it needs to allocate memory and cannot do so.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Any _NON data in the Vstr will be uninitialized data in the memory pointed
 to by the memory reference.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Memory%20reference%20functions">Memory reference functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_add%28%29">vstr_ref_add()</a>
<br>Returns: Vstr memory reference (Parameter[1])<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr memory reference<br>Type<strong>[1]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will add a reference count to the Vstr_ref (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_del%28%29">vstr_ref_del()</a>
 Returns:
<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr memory reference<br>Type<strong>[1]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will delete a reference count from the Vstr_ref (Parameter[1]),
 when the reference count reaches zero then the cleanup function will be called.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_cb_free_nothing%28%29">vstr_ref_cb_free_nothing()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr memory reference<br>Type<strong>[1]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function does nothing.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_cb_free_ref%28%29">vstr_ref_cb_free_ref()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr memory reference<br>Type<strong>[1]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This will call free() on the Vstr_ref (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_cb_free_ptr%28%29">vstr_ref_cb_free_ptr()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr memory reference<br>Type<strong>[1]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This will call free() on the data in the Vstr_ref (Parameter[1])-&gt;ptr (unless
 the passed reference is the NULL pointer, then it does nothing).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_cb_free_ptr_ref%28%29">vstr_ref_cb_free_ptr_ref()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Vstr memory reference<br>Type<strong>[1]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This will call free() on the data in the Vstr_ref (Parameter[1])-&gt;ptr and
 then call free() on the Vstr_ref (Parameter[1]) (unless the passed reference
 is the NULL pointer, then it does nothing).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_malloc%28%29">vstr_ref_make_malloc()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Size of malloc'd area to create in the memory reference<br>Type<strong>[1]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will create an area of memory, using malloc, and create a Vstr
 memory reference to that memory. The Vstr memory reference will have a
 reference count of 1 and the cleanup function will point to a function to
 free both the reference and the copy of memory.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_ptr%28%29">vstr_ref_make_ptr()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to memory<br>Type<strong>[1]</strong>: void *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Function callback for Vstr memory reference<br>Type<strong>[2]</strong>: void (*)(struct Vstr_ref *)
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will call malloc() to create a Vstr memory reference. The Vstr
 memory reference will have a reference count of 1, a pointer value of pointer
 passed (Parameter[1]) and a cleanup function of the function
 passed (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_memdup%28%29">vstr_ref_make_memdup()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to memory<br>Type<strong>[1]</strong>: void *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of memory block<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will create a Vstr memory reference. The Vstr memory reference
 will have a reference count of 1 and a copy of the memory pointed to
 by (Parameter[1]) of length (Parameter[2]) will be the pointer value. The
 cleanup function will point to a function to free both the reference and the
 copy of memory.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_strdup%28%29">vstr_ref_make_strdup()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to data<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_ref_make_memdup%28%29">vstr_ref_make_memdup()</a> with the length being the value of
 (strlen() + 1) on the data parameter (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_REF_MAKE_STRDUP%28%29">VSTR_REF_MAKE_STRDUP()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to data<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_ref_make_memdup%28%29">vstr_ref_make_memdup()</a> with the length being the
 value of (strlen() + 1) on the data parameter (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_vstr_base%28%29">vstr_ref_make_vstr_base()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will create a Vstr memory reference. The Vstr memory reference
 will have a reference count of 1, a pointer value of the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]). The cleanup function will point to a function to
 free both the reference and the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_vstr_conf%28%29">vstr_ref_make_vstr_conf()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will create a Vstr memory reference. The Vstr memory reference
 will have a reference count of 1, a pointer value of the
 <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> (Parameter[1]). The cleanup function will point to a
 function to free both the reference and the <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_ref_make_vstr_sects%28%29">vstr_ref_make_vstr_sects()</a>
<br>Returns: Vstr memory reference<br>Type: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will create a Vstr memory reference. The Vstr memory reference
 will have a reference count of 1, a pointer value of the
 <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[1]). The cleanup function will point to a function to
 free both the reference and the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Creation%2fdestruction%20of%20core%20objects">Creation/destruction of core objects</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_make_conf%28%29">vstr_make_conf()</a>
<br>Returns: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Nothing<br>Type<strong>[1]</strong>: void
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will make a <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>, or return NULL.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_free_conf%28%29">vstr_free_conf()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will free a <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>, allocated by <a href="functions#vstr_make_conf%28%29">vstr_make_conf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_make_base%28%29">vstr_make_base()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will make a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>, or return NULL.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  If there are spare base objects, then no allocations are done.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_free_base%28%29">vstr_free_base()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will free a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>, allocated by <a href="functions#vstr_make_base%28%29">vstr_make_base()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the base object <a href="constants#VSTR_CNTL_BASE_GET_TYPE_GRPALLOC_CACHE">VSTR_CNTL_BASE_GET_TYPE_GRPALLOC_CACHE</a> is of the same type
 as it's configurations <a href="constants#VSTR_CNTL_CONF_GET_TYPE_GRPALLOC_CACHE">VSTR_CNTL_CONF_GET_TYPE_GRPALLOC_CACHE</a>, then the base
 object will be turned into a spare object so it can be reused by
 <a href="functions#vstr_make_base%28%29">vstr_make_base()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_buf%28%29">vstr_dup_buf()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length of data (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is equivalent to calling <a href="functions#vstr_make_base%28%29">vstr_make_base()</a> and then
 <a href="functions#vstr_add_buf%28%29">vstr_add_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_ptr%28%29">vstr_dup_ptr()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length of data (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is equivalent to calling <a href="functions#vstr_make_base%28%29">vstr_make_base()</a> and then
 <a href="functions#vstr_add_ptr%28%29">vstr_add_ptr()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_non%28%29">vstr_dup_non()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of non data<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is equivalent to calling <a href="functions#vstr_make_base%28%29">vstr_make_base()</a> and then
 <a href="functions#vstr_add_non%28%29">vstr_add_non()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_ref%28%29">vstr_dup_ref()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Vstr memory reference<br>Type<strong>[2]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Offset of Vstr memory reference (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of Vstr memory reference (Parameter[2])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is equivalent to calling <a href="functions#vstr_make_base%28%29">vstr_make_base()</a> and then
 <a href="functions#vstr_add_ref%28%29">vstr_add_ref()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_vstr%28%29">vstr_dup_vstr()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[2])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Flags for Vstr add (<a href="constants#vstr_dup_vstr%28%29">VSTR_TYPE_ADD_*</a>)<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is equivalent to calling <a href="functions#vstr_make_base%28%29">vstr_make_base()</a> and then
 <a href="functions#vstr_add_vstr%28%29">vstr_add_vstr()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_rep_chr%28%29">vstr_dup_rep_chr()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Character to repeat<br>Type<strong>[2]</strong>: char
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number of times to repeat character (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is equivalent to calling <a href="functions#vstr_make_base%28%29">vstr_make_base()</a> and then
 <a href="functions#vstr_add_rep_chr%28%29">vstr_add_rep_chr()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_cstr_buf%28%29">vstr_dup_cstr_buf()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_dup_buf%28%29">vstr_dup_buf()</a> with the length being the value of
 strlen() on the data parameter (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_cstr_ptr%28%29">vstr_dup_cstr_ptr()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> with the length being the value of
 strlen() on the data parameter (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_dup_cstr_ref%28%29">vstr_dup_cstr_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Vstr memory reference<br>Type<strong>[2]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Offset of Vstr memory reference (Parameter[3])<br>Type<strong>[3]</strong>: size_t

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_dup_ref%28%29">vstr_dup_ref()</a> with the length being the value of
 strlen() on the memory from the Vstr memory reference (Parameter[3]) starting
 at the offset (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_DUP_CSTR_BUF%28%29">VSTR_DUP_CSTR_BUF()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_dup_buf%28%29">vstr_dup_buf()</a> with the length being the value of
 strlen() on the data parameter (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_DUP_CSTR_PTR%28%29">VSTR_DUP_CSTR_PTR()</a>
<br>Returns: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> with the length being the value of
 strlen() on the data parameter (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_DUP_CSTR_REF%28%29">VSTR_DUP_CSTR_REF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Vstr memory reference<br>Type<strong>[2]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Offset of Vstr memory reference (Parameter[3])<br>Type<strong>[3]</strong>: size_t

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_dup_ref%28%29">vstr_dup_ref()</a> with the length being the value of
 strlen() on the memory from the Vstr memory reference (Parameter[3]) starting
 at the offset (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_make_spare_nodes%28%29">vstr_make_spare_nodes()</a>
<br>Returns: Number of nodes created<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Type of nodes to create<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number of nodes to create<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will try and create a number (Parameter[3]) of nodes of type
 (Parameter[2]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The number of nodes created will be less than or equal to the number requested
 (Parameter[3]), however if it is less than then the malloc_bad flag will be set
 (Parameter[1])->malloc_bad.
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_free_spare_nodes%28%29">vstr_free_spare_nodes()</a>
<br>Returns: Number of nodes destroyed<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Type of nodes to destroy<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number of nodes to destroy<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will try and destroy a number (Parameter[3]) of nodes of type
 (Parameter[2]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The number of nodes destroyed will be less than or equal to the number
 requested (Parameter[3]), the only reason that less will be destroyed is
 if there are no more unused nodes of that type (Parameter[2]).
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Adding%20and%20deleting%20of%20data%20functions">Adding and deleting of data functions</a></h2>


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_buf%28%29">vstr_add_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a copy of the data in the data array to a
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  Think of this function as doing a write() into a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_ptr%28%29">vstr_add_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a pointer to a data array to a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the data in the array needs to be free'd the programer will have to
 decide when it is no longer being used by the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> and free it. It
 is often easier to create a memory reference and use <a href="functions#vstr_add_ref%28%29">vstr_add_ref()</a> instead.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_non%28%29">vstr_add_non()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length of non data<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add &quot;non&quot; (or invisible) data to a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_ref%28%29">vstr_add_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Vstr memory reference<br>Type<strong>[3]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset of Vstr memory reference (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of Vstr memory reference (Parameter[3])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a memory reference to a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_vstr%28%29">vstr_add_vstr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[3]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Type for Vstr add (<a href="constants#vstr_add_vstr%28%29">VSTR_TYPE_ADD_*</a>)<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add data in one <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) to
 another <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function can change how the data is added to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>
 (Parameter[1]) and in some cases even how the data is represented in the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) for more information see the documentation on the
 VSTR_TYPE_ADD_* constants.
</p><p>  This function will set _both_ (Parameter[1])-&gt;conf-&gt;malloc_bad and
 (Parameter[3])->conf->malloc_bad if any of the allocation calls fails.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_rep_chr%28%29">vstr_add_rep_chr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Character to repeat<br>Type<strong>[3]</strong>: char
</td></tr><tr><td>Parameter<strong>[4]</strong>: Number of times to repeat character (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add 1 or more copies of the character (Parameter[3])
 to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  Think of this function as doing a memset() into data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_cstr_buf%28%29">vstr_add_cstr_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_add_buf%28%29">vstr_add_buf()</a> with the length being the value of
 strlen() on the data parameter (Parameter[3]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_cstr_ptr%28%29">vstr_add_cstr_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_add_ptr%28%29">vstr_add_ptr()</a> with the length being the value of
 strlen() on the data parameter (Parameter[3]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_cstr_ref%28%29">vstr_add_cstr_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Vstr memory reference<br>Type<strong>[3]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset of Vstr memory reference (Parameter[3])<br>Type<strong>[4]</strong>: size_t

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_add_ref%28%29">vstr_add_ref()</a> with the length being the value of
 strlen() on the memory from the Vstr memory reference (Parameter[3]) starting
 at the offset (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_ADD_CSTR_BUF%28%29">VSTR_ADD_CSTR_BUF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_add_buf%28%29">vstr_add_buf()</a> with the length being the value of
 strlen() on the data parameter (Parameter[3]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_ADD_CSTR_PTR%28%29">VSTR_ADD_CSTR_PTR()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_add_ptr%28%29">vstr_add_ptr()</a> with the length being the value of
 strlen() on the data parameter (Parameter[3]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_ADD_CSTR_REF%28%29">VSTR_ADD_CSTR_REF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Vstr memory reference<br>Type<strong>[3]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset of Vstr memory reference (Parameter[3])<br>Type<strong>[4]</strong>: size_t

</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_add_ref%28%29">vstr_add_ref()</a> with the length being the value of
 strlen() on the memory from the Vstr memory reference (Parameter[3]) starting
 at the offset (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_vfmt%28%29">vstr_add_vfmt()</a>
<br>Returns: Number of bytes added<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Format string, a superset of the rules for C99 printf<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Standard argument object from va_start()<br>Type<strong>[4]</strong>: va_list
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function works like calling vsprintf() directly into a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 however this is a portable implementation which is feature complete with
 glibc-2.2.x sprintf(); implements custom specifiers, if you use the
 <a href="functions#vstr_fmt_add%28%29">vstr_fmt_add()</a> function, and doesn't require a double copy.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Depending on how the library was compiled double support is implemented by
 either calling the underlying host implementation of sprintf(), by internal
 code or simply by assuming all double's are zero. When using the host
 implementation system bugs of inaccuracy will show through, however the
 feature set remains the same (Ie. the ' flag works the same).
</p><p>  Because specifiers can be overridden using <a href="functions#vstr_fmt_add%28%29">vstr_fmt_add()</a> if you are adding
 data to a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> that you didn't create you should use either
 <a href="functions#vstr_add_vsysfmt%28%29">vstr_add_vsysfmt()</a> or <a href="functions#vstr_swap_conf%28%29">vstr_swap_conf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_fmt%28%29">vstr_add_fmt()</a>
<br>Returns: Number of bytes added<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Format string, a superset of the rules for C99 printf<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Options depending on value of Parameter[3]<br>Type<strong>[4]</strong>: ...
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This just calls <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a> after converting the argument list
 (Parameter[4]) a va_list object.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_vsysfmt%28%29">vstr_add_vsysfmt()</a>
<br>Returns: Number of bytes added<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Format string, a superset of the rules for C99 printf<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Standard argument object from va_start()<br>Type<strong>[4]</strong>: va_list
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function does the same thing as <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a> but ignores custom
 specifiers (see <a href="functions#vstr_fmt_add%28%29">vstr_fmt_add()</a>).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_sysfmt%28%29">vstr_add_sysfmt()</a>
<br>Returns: Number of bytes added<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Format string, a superset of the rules for C99 printf<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Options depending on value of Parameter[3]<br>Type<strong>[4]</strong>: ...
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This just calls <a href="functions#vstr_add_vsysfmt%28%29">vstr_add_vsysfmt()</a> after converting the argument list
 (Parameter[4]) a va_list object.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>
<br>Returns: Number of bytes in the iovec array<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Minimum amount of iovecs to add<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Maximum amount of iovecs to add<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns the start of the iovec array<br>Type<strong>[5]</strong>: struct iovec **
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns the number of iovec structures in the array<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a copy of data directly into the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 the amount of data available will be between the minimum (Parameter[4]) and
 maximum ((Parameter[5]) + 1) number of iovecs multiplied by the length of
 data in _BUF type nodes. The obvious use for the data is to call readv() on it.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  You shouldn't call any other vstr functions between <a href="functions#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>
 and <a href="functions#vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a>, unless you know that they are operating on a
 different <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> which is using a different <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>.
</p><p>  The reason there is a +1 on the maximum value is that data may be appended to
 a _BUF node just before the start of where the data is to go, this is almost
 guaranteed to happen when adding to the end of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> and saves a lot
 of wasted space.
</p><p>  It is currently believed that, on Linux, doing disk IO in amounts greater than
 8k gives little real performance improvement. This can be converted into iovec
 numbers by using a formula like...
</p><pre>
    min = (8k / buf_sz) + 2;
    max = min + (min / 2);    

</pre><p> ...where the +2 is due to both the extra space at the end of the current last
 node, and rounding errors due to the division. The max being slightly bigger
 is an attempt to make the constant overhead of the call slightly less, and may
 not be useful. It is very possible that some kind of dynamic scaling of the
 values would result in the best performance, however the solution to that
 doesn't fit in the margin :).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number of bytes added to the iovec array<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used after calling <a href="functions#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a> and you've then
 filled in a bunch of data.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Although it's safe to not bother calling this function if you didn't have
 anything to add to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> it is often more efficient to call this
 function with Parameter[3] as 0.

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_netstr_beg%28%29">vstr_add_netstr_beg()</a>
<br>Returns: Position of start of netstr (Parameter[2]) + 1<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function creates the start of a netstring
 http://cr.yp.to/proto/netstrings.txt this can be used in conjunction with
 <a href="functions#vstr_add_netstr_end%28%29">vstr_add_netstr_end()</a> to easily create netstrings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_netstr_end%28%29">vstr_add_netstr_end()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position returned from <a href="functions#vstr_add_netstr_beg%28%29">vstr_add_netstr_beg()</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: End of netstring<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is called after calling <a href="functions#vstr_add_netstr_beg%28%29">vstr_add_netstr_beg()</a>, adding all the
 data you want to the netstring and then passing the position of the end of
 that data.
</p><p>  Upon success a valid netstring will contain all the data added between the two
 calls.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  It is valid to pass the same values for (Parameter[2]) and (parameter[3]), as
 that signifies that there is no data in the netstring.
</p><p>  It is almost guaranteed that data will need to be removed from the beginning of
 the netstring due to the length being shorter than the maximum, this is
 inefficient and could cause problems if you know how big the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> is
 you can use the vstr_add_netstr2_* functions to solve both problems.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_netstr2_beg%28%29">vstr_add_netstr2_beg()</a>
<br>Returns: Position of start of netstr (Parameter[2]) + 1<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function creates the start of a netstring2 which is like a netstring
 http://cr.yp.to/proto/netstrings.txt but can have leading zeros, this can be
 used in conjunction with <a href="functions#vstr_add_netstr2_end%28%29">vstr_add_netstr2_end()</a> to easily create netstring2s.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_add_netstr2_end%28%29">vstr_add_netstr2_end()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position returned from <a href="functions#vstr_add_netstr2_beg%28%29">vstr_add_netstr2_beg()</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: End of netstring2<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is called after calling <a href="functions#vstr_add_netstr2_beg%28%29">vstr_add_netstr2_beg()</a>, adding all the
 data you want to the netstring2 and then passing the position of the end of
 that data.
</p><p>  Upon success a netstring2 will contain all the data added between the two
 calls.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  It is valid to pass the same values for (Parameter[2]) and (parameter[3]), as
 that signifies that there is no data in the netstring.
</p><p>  No data is ever removed from the beginning of a netstring2, this is
 incompatible with the netstring spec. but is more efficient and doesn't
 cause problems if you know how big the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> is and can't have it lose
 data from the beginning/middle.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_del%28%29">vstr_del()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to delete data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Deleted nodes do not get returned to the system, they get put into a pool in
 the <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> for reuse on the next call to a vstr_add_*() function.
</p><p>  Deleting the entire <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> and deleting from the beginning onward are
 faster operations than a generic delete. They also never require allocating
 memory and so the return value can be ignored.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_mov%28%29">vstr_mov()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[3]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to move data, deleting it from one <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>
 (Parameter[3]) and adding it to another <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Substitution%20of%20data%20functions">Substitution of data functions</a></h2>


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_buf%28%29">vstr_sub_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> with a copy
 of the data in the data array.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) can be larger or smaller than the
 length of the data (Parameter[5]).
</p><p>  Think of this function as doing a <a href="functions#vstr_del%28%29">vstr_del()</a> and then a <a href="functions#vstr_add_buf%28%29">vstr_add_buf()</a>
 (but it's atomic).
</p><p>  If the length of the data (Parameter[5]) is less than or equal to the
 length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) and the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> is in
 a BUF node then the data will just be overwritten (Ie. no allocations will
 happen).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_ptr%28%29">vstr_sub_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> with a pointer
 to a data array.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) can be larger or smaller than the
 length of the data (Parameter[7]), think of this function like doing a
 <a href="functions#vstr_del%28%29">vstr_del()</a> and then a <a href="functions#vstr_add_ptr%28%29">vstr_add_ptr()</a> (but it's atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_non%28%29">vstr_sub_non()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of non data<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> with
 "non" (or invisible) data.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) can be larger or smaller than the
 length of the data (Parameter[7]), think of this function like doing a
 <a href="functions#vstr_del%28%29">vstr_del()</a> and then a <a href="functions#vstr_add_non%28%29">vstr_add_non()</a> (but it's atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_ref%28%29">vstr_sub_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Vstr memory reference<br>Type<strong>[4]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Offset of Vstr memory reference (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length of Vstr memory reference (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> with a
 memory reference.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) can be larger or smaller than the
 length of the data (Parameter[7]), think of this function like doing a
 <a href="functions#vstr_del%28%29">vstr_del()</a> and then a <a href="functions#vstr_add_ref%28%29">vstr_add_ref()</a> (but it's atomic).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_vstr%28%29">vstr_sub_vstr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Type for Vstr sub (<a href="constants#vstr_sub_vstr%28%29">VSTR_TYPE_SUB_*</a>)<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>
 (Parameter[1]) with the data in another <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) can be larger or smaller than the
 length of the data (Parameter[7]), think of this function like doing a
 <a href="functions#vstr_del%28%29">vstr_del()</a> and then a <a href="functions#vstr_add_vstr%28%29">vstr_add_vstr()</a> (but it's atomic).
</p><p>  The function can change how the data is added to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>
 (Parameter[1]) and in some cases even how the data is represented in the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) for more information see the documentation on the
 VSTR_TYPE_SUB_* constants.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_rep_chr%28%29">vstr_sub_rep_chr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Character to repeat<br>Type<strong>[4]</strong>: char
</td></tr><tr><td>Parameter<strong>[5]</strong>: Number of times to repeat character (Parameter[3])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> with one or
 more copies of the character (Parameter[3]).
</p><p>  Think of this function as doing a memset() into data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so,
 although if it does fail the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> won't have changed (Ie. the function
 is atomic).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) can be larger or smaller than the
 length of the data (Parameter[5]).
</p><p>  Think of this function as doing a <a href="functions#vstr_del%28%29">vstr_del()</a> and then a <a href="functions#vstr_add_rep_chr%28%29">vstr_add_rep_chr()</a>
 (but it's atomic).
</p><p>  If the length of the data (Parameter[5]) is equal to the
 length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[3]) and the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> is in
 a BUF node then the data will just be overwritten (Ie. no allocations will
 happen).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_cstr_buf%28%29">vstr_sub_cstr_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sub_buf%28%29">vstr_sub_buf()</a> with the length being the value of
 strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_cstr_ptr%28%29">vstr_sub_cstr_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sub_ptr%28%29">vstr_sub_ptr()</a> with the length being the value of
 strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sub_cstr_ref%28%29">vstr_sub_cstr_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Vstr memory reference<br>Type<strong>[4]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Offset of Vstr memory reference (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sub_ref%28%29">vstr_sub_ref()</a> with the length being the value of
 strlen() on the memory from the Vstr memory reference (Parameter[3]) starting
 at the offset (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SUB_CSTR_BUF%28%29">VSTR_SUB_CSTR_BUF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sub_buf%28%29">vstr_sub_buf()</a> with the length being the value of
 strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SUB_CSTR_PTR%28%29">VSTR_SUB_CSTR_PTR()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sub_ptr%28%29">vstr_sub_ptr()</a> with the length being the value of
 strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SUB_CSTR_REF%28%29">VSTR_SUB_CSTR_REF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Vstr memory reference<br>Type<strong>[4]</strong>: struct Vstr_ref *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Offset of Vstr memory reference (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sub_ref%28%29">vstr_sub_ref()</a> with the length being the value of
 strlen() on the memory from the Vstr memory reference (Parameter[3]) starting
 at the offset (Parameter[4]).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Comparison%20of%20data%20functions">Comparison of data functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp%28%29">vstr_cmp()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to compares the data in one <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])
 with data in another <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4]) byte by byte, all data is
 compared unsigned.
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on each <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to memcmp() (although it doesn't allocate anything).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data of type _NON is assumed to have the value -1, and so all data compares
 as greater than it.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_buf%28%29">vstr_cmp_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp%28%29">vstr_cmp()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case%28%29">vstr_cmp_case()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is like <a href="functions#vstr_cmp%28%29">vstr_cmp()</a> but uppercase and lowercase ASCII
 values compare equally with each other.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data of type _NON is assumed to have the value -1, and so all data compares
 as greater than it.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_case%28%29">vstr_cmp_case()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_fast%28%29">vstr_cmp_fast()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is like <a href="functions#vstr_cmp%28%29">vstr_cmp()</a> but it is meant to provide &quot;fast&quot; results for
 use in internal comparisons (Ie. output is unlikely to be enjoyed by humans).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data of type _NON is assumed to have the value -1, and so all data compares
 as greater than it.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_fast_buf%28%29">vstr_cmp_fast_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_fast%28%29">vstr_cmp_fast()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers%28%29">vstr_cmp_vers()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to compare the data in one <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])
 with data in another <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4]), however for ASCII digits the
 algorithm tests on the numbers themselves (so "10" is greater than "9" but
 "01" is greater than "012", as the later are fractions).
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on each <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to strverscmp() (although it doesn't allocate anything,
 _and_ it deals with 0 bytes in the data).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Data of type _NON is assumed to have the value -1, and so all data compares
 as greater than it.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_vers%28%29">vstr_cmp_vers()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eq%28%29">vstr_cmp_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp%28%29">vstr_cmp()</a> if both of the length values
 (Parameter[3] Parameter[6]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_cstr%28%29">vstr_cmp_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_buf%28%29">vstr_cmp_buf()</a> with the length of the buffer being
 the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_buf_eq%28%29">vstr_cmp_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_buf%28%29">vstr_cmp_buf()</a> if both of the length values
 (Parameter[3] Parameter[5]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_cstr_eq%28%29">vstr_cmp_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_buf%28%29">vstr_cmp_buf()</a>, if both of the length values are
 equal, with the length of the buffer being the value of strlen() on the data
 parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eq%28%29">vstr_cmp_case_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case%28%29">vstr_cmp_case()</a> if both of the length
 values (Parameter[3] Parameter[6]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_cstr%28%29">vstr_cmp_case_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_buf_eq%28%29">vstr_cmp_case_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a> if both of the length
 values (Parameter[3] Parameter[5]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_cstr_eq%28%29">vstr_cmp_case_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a>, if both of the length
 values are equal, with the length of the buffer being the value of strlen()
 on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_fast_cstr%28%29">vstr_cmp_fast_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_fast_buf%28%29">vstr_cmp_fast_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eq%28%29">vstr_cmp_vers_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers%28%29">vstr_cmp_vers()</a> if both of the length
 values (Parameter[3] Parameter[6]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_cstr%28%29">vstr_cmp_vers_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_buf_eq%28%29">vstr_cmp_vers_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a> if both of the length
 values (Parameter[3] Parameter[5]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_cstr_eq%28%29">vstr_cmp_vers_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a>, if both of the length
 values are equal, with the length of the buffer being the value of strlen()
 on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_bod%28%29">vstr_cmp_bod()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp%28%29">vstr_cmp()</a> with the both lengths as the lowest of either
 passed length (Parameter[3]) or (Parameter[6]). Thus you get a comparison of
 the beginning of the data in the two strings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eod%28%29">vstr_cmp_eod()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp%28%29">vstr_cmp()</a> with the both lengths as the lowest of either
 passed length (Parameter[3]) or (Parameter[6]) and with the positions
 (Parameter[3]) and (Parameter[6]) changed so that the length of each goes
 to the end of the string. Thus you get a comparison of the end of the data in
 the two strings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_bod_eq%28%29">vstr_cmp_bod_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_bod%28%29">vstr_cmp_bod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eod_eq%28%29">vstr_cmp_eod_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_eod%28%29">vstr_cmp_eod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_bod_buf%28%29">vstr_cmp_bod_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_bod%28%29">vstr_cmp_bod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eod_buf%28%29">vstr_cmp_eod_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_eod%28%29">vstr_cmp_eod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_bod_buf_eq%28%29">vstr_cmp_bod_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_bod_buf%28%29">vstr_cmp_bod_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eod_buf_eq%28%29">vstr_cmp_eod_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_eod_buf%28%29">vstr_cmp_eod_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_bod_cstr%28%29">vstr_cmp_bod_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_bod_buf%28%29">vstr_cmp_bod_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eod_cstr%28%29">vstr_cmp_eod_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_eod_buf%28%29">vstr_cmp_eod_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_bod_cstr_eq%28%29">vstr_cmp_bod_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_bod_buf_eq%28%29">vstr_cmp_bod_buf_eq()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_eod_cstr_eq%28%29">vstr_cmp_eod_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_eod_buf_eq%28%29">vstr_cmp_eod_buf_eq()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_bod%28%29">vstr_cmp_case_bod()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case%28%29">vstr_cmp_case()</a> with the both lengths as the lowest of either
 passed length (Parameter[3]) or (Parameter[6]). Thus you get a comparison of
 the beginning of the data in the two strings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eod%28%29">vstr_cmp_case_eod()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case%28%29">vstr_cmp_case()</a> with the both lengths as the lowest of
 either passed length (Parameter[3]) or (Parameter[6]) and with the positions
 (Parameter[3]) and (Parameter[6]) changed so that the length of each goes
 to the end of the string. Thus you get a comparison of the end of the data in
 the two strings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_bod_eq%28%29">vstr_cmp_case_bod_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case_bod%28%29">vstr_cmp_case_bod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eod_eq%28%29">vstr_cmp_case_eod_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case_eod%28%29">vstr_cmp_case_eod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_bod_buf%28%29">vstr_cmp_case_bod_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_case_bod%28%29">vstr_cmp_case_bod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eod_buf%28%29">vstr_cmp_case_eod_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_case_eod%28%29">vstr_cmp_case_eod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_bod_buf_eq%28%29">vstr_cmp_case_bod_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case_bod_buf%28%29">vstr_cmp_case_bod_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eod_buf_eq%28%29">vstr_cmp_case_eod_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_case_eod_buf%28%29">vstr_cmp_case_eod_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_bod_cstr%28%29">vstr_cmp_case_bod_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case_bod_buf%28%29">vstr_cmp_case_bod_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eod_cstr%28%29">vstr_cmp_case_eod_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case_eod_buf%28%29">vstr_cmp_case_eod_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_bod_cstr_eq%28%29">vstr_cmp_case_bod_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case_bod_buf_eq%28%29">vstr_cmp_case_bod_buf_eq()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_case_eod_cstr_eq%28%29">vstr_cmp_case_eod_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_case_eod_buf_eq%28%29">vstr_cmp_case_eod_buf_eq()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_bod%28%29">vstr_cmp_vers_bod()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers%28%29">vstr_cmp_vers()</a> with the both lengths as the lowest of either
 passed length (Parameter[3]) or (Parameter[6]). Thus you get a comparison of
 the beginning of the data in the two strings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eod%28%29">vstr_cmp_vers_eod()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers%28%29">vstr_cmp_vers()</a> with the both lengths as the lowest of
 either passed length (Parameter[3]) or (Parameter[6]) and with the positions
 (Parameter[3]) and (Parameter[6]) changed so that the length of each goes
 to the end of the string. Thus you get a comparison of the end of the data in
 the two strings.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_bod_eq%28%29">vstr_cmp_vers_bod_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers_bod%28%29">vstr_cmp_vers_bod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eod_eq%28%29">vstr_cmp_vers_eod_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers_eod%28%29">vstr_cmp_vers_eod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_bod_buf%28%29">vstr_cmp_vers_bod_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_vers_bod%28%29">vstr_cmp_vers_bod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eod_buf%28%29">vstr_cmp_vers_eod_buf()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Think of this function as doing a <a href="functions#vstr_dup_ptr%28%29">vstr_dup_ptr()</a> on the data array
 (Parameter[4]) and then calling <a href="functions#vstr_cmp_vers_eod%28%29">vstr_cmp_vers_eod()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_bod_buf_eq%28%29">vstr_cmp_vers_bod_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers_bod_buf%28%29">vstr_cmp_vers_bod_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eod_buf_eq%28%29">vstr_cmp_vers_eod_buf_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function returns !<a href="functions#vstr_cmp_vers_eod_buf%28%29">vstr_cmp_vers_eod_buf()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_bod_cstr%28%29">vstr_cmp_vers_bod_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers_bod_buf%28%29">vstr_cmp_vers_bod_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eod_cstr%28%29">vstr_cmp_vers_eod_cstr()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers_eod_buf%28%29">vstr_cmp_vers_eod_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_bod_cstr_eq%28%29">vstr_cmp_vers_bod_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers_bod_buf_eq%28%29">vstr_cmp_vers_bod_buf_eq()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cmp_vers_eod_cstr_eq%28%29">vstr_cmp_vers_eod_cstr_eq()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cmp_vers_eod_buf_eq%28%29">vstr_cmp_vers_eod_buf_eq()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_EQ%28%29">VSTR_CMP_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp%28%29">vstr_cmp()</a> if both of the length values
 (Parameter[3] Parameter[6]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_CSTR%28%29">VSTR_CMP_CSTR()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_cmp_buf%28%29">vstr_cmp_buf()</a> with the length of the buffer being
 the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_BUF_EQ%28%29">VSTR_CMP_BUF_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_buf%28%29">vstr_cmp_buf()</a> if both of the length values
 (Parameter[3] Parameter[5]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_CSTR_EQ%28%29">VSTR_CMP_CSTR_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_buf%28%29">vstr_cmp_buf()</a>, if both of the length values are
 equal, with the length of the buffer being the value of strlen() on the data
 parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_CASE_EQ%28%29">VSTR_CMP_CASE_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_case%28%29">vstr_cmp_case()</a> if both of the length
 values (Parameter[3] Parameter[6]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_CASE_CSTR%28%29">VSTR_CMP_CASE_CSTR()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_CASE_BUF_EQ%28%29">VSTR_CMP_CASE_BUF_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a> if both of the length
 values (Parameter[3] Parameter[5]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_CASE_CSTR_EQ%28%29">VSTR_CMP_CASE_CSTR_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_case_buf%28%29">vstr_cmp_case_buf()</a>, if both of the length
 values are equal, with the length of the buffer being the value of strlen()
 on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_VERS_EQ%28%29">VSTR_CMP_VERS_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_vers%28%29">vstr_cmp_vers()</a> if both of the length
 values (Parameter[3] Parameter[6]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_VERS_CSTR%28%29">VSTR_CMP_VERS_CSTR()</a>
<br>Returns: Less then zero, zero or greater than zero depending on comparison<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a> with the length of the buffer
 being the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_VERS_BUF_EQ%28%29">VSTR_CMP_VERS_BUF_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of ASCII C string (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a> if both of the length
 values (Parameter[3] Parameter[5]) are equal, or FALSE otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CMP_VERS_CSTR_EQ%28%29">VSTR_CMP_VERS_CSTR_EQ()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to ASCII C string<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns !<a href="functions#vstr_cmp_vers_buf%28%29">vstr_cmp_vers_buf()</a>, if both of the length
 values are equal, with the length of the buffer being the value of strlen()
 on the data parameter (Parameter[4]).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Searching%20for%20data%20functions">Searching for data functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_chr_fwd%28%29">vstr_srch_chr_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Character to search for<br>Type<strong>[4]</strong>: char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for a character in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to memchr() (although it's much faster than doing that and
 doesn't allocate anything).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the character cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_chr_rev%28%29">vstr_srch_chr_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Character<br>Type<strong>[4]</strong>: char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search reverse for a character in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to memrchr() (although it doesn't allocate anything).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the character cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_chrs_fwd%28%29">vstr_srch_chrs_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for any of the characters in the
 data array (Parameter[4]) in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If any of the characters cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_chrs_rev%28%29">vstr_srch_chrs_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search reverse for any of the characters in the
 data array (Parameter[4]) in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If any of the characters cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_csrch_chrs_fwd%28%29">vstr_csrch_chrs_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for any of the characters not in the
 data array (Parameter[4]) in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If any of the characters cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_csrch_chrs_rev%28%29">vstr_csrch_chrs_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search reverse for any of the characters not in the
 data array (Parameter[4]) in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If any of the characters cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_buf_fwd%28%29">vstr_srch_buf_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for the data in the data array
 (Parameter[4]) in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to memmem() (although it's much faster than doing that and
 doesn't allocate anything).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the data cannot be found 0 is returned.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the specified
 size (Parameter[5]) will be searched for.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_buf_rev%28%29">vstr_srch_buf_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search reverse for the data in the data array
 (Parameter[4]) in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the data cannot be found 0 is returned.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the specified
 size (Parameter[5]) will be searched for.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_vstr_fwd%28%29">vstr_srch_vstr_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>
 (Parameter[4]) in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on each <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to memmem() (although it's much faster than doing that and
 doesn't allocate anything).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the data cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_vstr_rev%28%29">vstr_srch_vstr_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search reverse for the data in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>
 (Parameter[4]) in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the data cannot be found 0 is returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_chr_fwd%28%29">vstr_srch_case_chr_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Character to search for<br>Type<strong>[4]</strong>: char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is the same as <a href="functions#vstr_srch_chr_fwd%28%29">vstr_srch_chr_fwd()</a> but uppercase and lowercase
 ASCII values are treated equivalently.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_chr_rev%28%29">vstr_srch_case_chr_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Character<br>Type<strong>[4]</strong>: char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is the same as <a href="functions#vstr_srch_chr_rev%28%29">vstr_srch_chr_rev()</a> but uppercase and lowercase
 ASCII values are treated equivalently.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_buf_fwd%28%29">vstr_srch_case_buf_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is the same as <a href="functions#vstr_srch_buf_fwd%28%29">vstr_srch_buf_fwd()</a> but uppercase and lowercase
 ASCII values are treated equivalently.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the specified
 size (Parameter[5]) will be searched for.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_buf_rev%28%29">vstr_srch_case_buf_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is the same as <a href="functions#vstr_srch_buf_fwd%28%29">vstr_srch_buf_fwd()</a> but uppercase and lowercase
 ASCII values are treated equivalently.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the specified
 size (Parameter[5]) will be searched for.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_vstr_fwd%28%29">vstr_srch_case_vstr_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is the same as <a href="functions#vstr_srch_vstr_fwd%28%29">vstr_srch_vstr_fwd()</a> but uppercase and lowercase
 ASCII values are treated equivalently.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_vstr_rev%28%29">vstr_srch_case_vstr_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[4]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is the same as <a href="functions#vstr_srch_vstr_rev%28%29">vstr_srch_vstr_rev()</a> but uppercase and lowercase
 ASCII values are treated equivalently.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_cstr_buf_fwd%28%29">vstr_srch_cstr_buf_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_srch_buf_fwd%28%29">vstr_srch_buf_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_cstr_buf_rev%28%29">vstr_srch_cstr_buf_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_srch_buf_rev%28%29">vstr_srch_buf_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_cstr_chrs_fwd%28%29">vstr_srch_cstr_chrs_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_srch_chrs_fwd%28%29">vstr_srch_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_cstr_chrs_rev%28%29">vstr_srch_cstr_chrs_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_srch_chrs_rev%28%29">vstr_srch_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_csrch_cstr_chrs_fwd%28%29">vstr_csrch_cstr_chrs_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_csrch_chrs_fwd%28%29">vstr_csrch_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_csrch_cstr_chrs_rev%28%29">vstr_csrch_cstr_chrs_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_csrch_chrs_rev%28%29">vstr_csrch_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_cstr_buf_fwd%28%29">vstr_srch_case_cstr_buf_fwd()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_srch_case_buf_fwd%28%29">vstr_srch_case_buf_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_srch_case_cstr_buf_rev%28%29">vstr_srch_case_cstr_buf_rev()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_srch_case_buf_rev%28%29">vstr_srch_case_buf_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SRCH_CSTR_BUF_FWD%28%29">VSTR_SRCH_CSTR_BUF_FWD()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_srch_buf_fwd%28%29">vstr_srch_buf_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SRCH_CSTR_BUF_REV%28%29">VSTR_SRCH_CSTR_BUF_REV()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_srch_buf_rev%28%29">vstr_srch_buf_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SRCH_CSTR_CHRS_FWD%28%29">VSTR_SRCH_CSTR_CHRS_FWD()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_srch_chrs_fwd%28%29">vstr_srch_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SRCH_CSTR_CHRS_REV%28%29">VSTR_SRCH_CSTR_CHRS_REV()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_srch_chrs_rev%28%29">vstr_srch_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CSRCH_CSTR_CHRS_FWD%28%29">VSTR_CSRCH_CSTR_CHRS_FWD()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_csrch_chrs_fwd%28%29">vstr_csrch_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CSRCH_CSTR_CHRS_REV%28%29">VSTR_CSRCH_CSTR_CHRS_REV()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the character<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_csrch_chrs_rev%28%29">vstr_csrch_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SRCH_CASE_CSTR_BUF_FWD%28%29">VSTR_SRCH_CASE_CSTR_BUF_FWD()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_srch_case_buf_fwd%28%29">vstr_srch_case_buf_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SRCH_CASE_CSTR_BUF_REV%28%29">VSTR_SRCH_CASE_CSTR_BUF_REV()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the data<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_srch_case_buf_rev%28%29">vstr_srch_case_buf_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Span%20of%20data%20calculation%20functions">Span of data calculation functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_bmap_eq_fwd%28%29">vstr_spn_bmap_eq_fwd()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Value to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the forward span of bytes, that have the
 value (Parameter[5]) in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_bmap_eq_rev%28%29">vstr_spn_bmap_eq_rev()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Value to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the reverse span of bytes, that have the
 value (Parameter[5]) in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_bmap_and_fwd%28%29">vstr_spn_bmap_and_fwd()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Bits to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the forward span of bytes, that have any
 bit set, in the value (Parameter[5]), in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_bmap_and_rev%28%29">vstr_spn_bmap_and_rev()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Bits to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the reverse span of bytes, that have any
 bit set, in the value (Parameter[5]), in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_chrs_fwd%28%29">vstr_spn_chrs_fwd()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of spanning characters (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the forward span of characters in the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> that are in the data array.
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to strspn() (although it's much faster than doing that and
 doesn't allocate anything, _and_ it deals with 0 bytes in the data).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the size 1
 will be looked for in the span.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_chrs_rev%28%29">vstr_spn_chrs_rev()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of spanning characters (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the reverse span of characters in the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> that are in the data array.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the size 1
 will be looked for in the span.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_bmap_eq_fwd%28%29">vstr_cspn_bmap_eq_fwd()</a>
<br>Returns: Number of characters in the complement span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Value to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the forward complement span of bytes, that
 have the value (Parameter[5]) in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_bmap_eq_rev%28%29">vstr_cspn_bmap_eq_rev()</a>
<br>Returns: Number of characters in the complement span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Value to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the reverse complement span of bytes, that
 have the value (Parameter[5]) in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_bmap_and_fwd%28%29">vstr_cspn_bmap_and_fwd()</a>
<br>Returns: Number of characters in the complement span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Bits to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the forward complement span of bytes, that
 have any bit set, in the value (Parameter[5]), in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_bmap_and_rev%28%29">vstr_cspn_bmap_and_rev()</a>
<br>Returns: Number of characters in the complement span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to bytemap<br>Type<strong>[4]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[5]</strong>: Bits to compare against in bytemap (Parameter[4])<br>Type<strong>[5]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the reverse complement span of bytes, that
 have any bit set, in the value (Parameter[5]), in the bytemap (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_chrs_fwd%28%29">vstr_cspn_chrs_fwd()</a>
<br>Returns: Number of characters in the compliment span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of spanning characters (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the forward span of characters in the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> that are in the compliment of those in the data array.
</p><p>  Think of this function as doing a <a href="functions#vstr_export_cstr_ptr%28%29">vstr_export_cstr_ptr()</a> on the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>,
 and then a call to strcspn() (although it's much faster than doing that and
 doesn't allocate anything, _and_ it deals with 0 bytes in the data).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the size 1
 will not be looked for in the span.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_chrs_rev%28%29">vstr_cspn_chrs_rev()</a>
<br>Returns: Number of characters in the compliment span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of spanning characters (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to calculate the reverse span of characters in the
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> that are in the compliment of those in the data array.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the pointer to data (Parameter[4]) is NULL then _NON data of the size 1
 will not be looked for in the span.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_cstr_chrs_fwd%28%29">vstr_spn_cstr_chrs_fwd()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_spn_chrs_fwd%28%29">vstr_spn_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_spn_cstr_chrs_rev%28%29">vstr_spn_cstr_chrs_rev()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_spn_chrs_rev%28%29">vstr_spn_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_cstr_chrs_fwd%28%29">vstr_cspn_cstr_chrs_fwd()</a>
<br>Returns: Number of characters in the compliment span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cspn_chrs_fwd%28%29">vstr_cspn_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cspn_cstr_chrs_rev%28%29">vstr_cspn_cstr_chrs_rev()</a>
<br>Returns: Number of characters in the compliment span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_cspn_chrs_rev%28%29">vstr_cspn_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SPN_CSTR_CHRS_FWD%28%29">VSTR_SPN_CSTR_CHRS_FWD()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_spn_chrs_fwd%28%29">vstr_spn_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SPN_CSTR_CHRS_REV%28%29">VSTR_SPN_CSTR_CHRS_REV()</a>
<br>Returns: Number of characters in the span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_spn_chrs_rev%28%29">vstr_spn_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CSPN_CSTR_CHRS_FWD%28%29">VSTR_CSPN_CSTR_CHRS_FWD()</a>
<br>Returns: Number of characters in the compliment span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_cspn_chrs_fwd%28%29">vstr_cspn_chrs_fwd()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_CSPN_CSTR_CHRS_REV%28%29">VSTR_CSPN_CSTR_CHRS_REV()</a>
<br>Returns: Number of characters in the compliment span<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to spanning characters<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_cspn_chrs_rev%28%29">vstr_cspn_chrs_rev()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Convertion%20of%20data%20functions">Convertion of data functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_conv_lowercase%28%29">vstr_conv_lowercase()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function converts all the uppercase ASCII characters into lowercase
 ASCII characters.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_conv_uppercase%28%29">vstr_conv_uppercase()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function converts all the lowercase ASCII characters into uppercase
 ASCII characters.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_conv_unprintable_chr%28%29">vstr_conv_unprintable_chr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Flags starting <a href="constants#vstr_conv_unprintable_chr%28%29">VSTR_FLAG_CONV_UNPRINTABLE_*</a><br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Character to substitute in place of the unprintable character<br>Type<strong>[5]</strong>: char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function substitutes all unprintable characters with the substitution
 character (Parameter[5]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_conv_unprintable_del%28%29">vstr_conv_unprintable_del()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Flags starting <a href="constants#vstr_conv_unprintable_del%28%29">VSTR_FLAG_CONV_UNPRINTABLE_*</a><br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function deletes all unprintable characters.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_conv_encode_uri%28%29">vstr_conv_encode_uri()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function converts characters to the URI %&lt;hex&gt;&lt;hex&gt; encoding, so the
 ASCII space character ' ' becomes the encoded sequence %20 etc.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  It converts all the characters in section 2.4.3 of rfc2396 into encoded
 form (that's all of the control, space, unwise and high ASCII characters).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_conv_decode_uri%28%29">vstr_conv_decode_uri()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function converts characters from the URI %&lt;hex&gt;&lt;hex&gt; encoding, so that
 the encoded sequence %20 becomes the ASCII space character ' ' etc.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Section%20of%20Vstr%20string%20functions">Section of <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SECTS_DECL%28%29">VSTR_SECTS_DECL()</a>
<br>Returns: Declaration of a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Name of variable to declare<br>Type<strong>[1]</strong>: &lt;symbol&gt;
</td></tr><tr><td>Parameter<strong>[2]</strong>: Maximum size of the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[1])<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function declares a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>, of the specified size
 (Parameter[2]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  <a href="functions#VSTR_SECTS_DECL_INIT%28%29">VSTR_SECTS_DECL_INIT()</a> needs to be called on the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> before it can
 be used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SECTS_EXTERN_DECL%28%29">VSTR_SECTS_EXTERN_DECL()</a>
<br>Returns: Extern declaration of a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Name of variable to declare<br>Type<strong>[1]</strong>: &lt;symbol&gt;
</td></tr><tr><td>Parameter<strong>[2]</strong>: Maximum size of the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function declares a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>, of the specified size
 (Parameter[2]), that is usable after an extern keyword.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SECTS_DECL_INIT%28%29">VSTR_SECTS_DECL_INIT()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function finishes initializing a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> that has been
 allocated using <a href="functions#VSTR_SECTS_DECL%28%29">VSTR_SECTS_DECL()</a>.
</p><p>  This macro function can be called multiple times without causing any problems.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SECTS_INIT%28%29">VSTR_SECTS_INIT()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Maximum number of the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[3]</strong>: Array of Vstr section nodes<br>Type<strong>[3]</strong>: struct Vstr_sect_node *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Non-zero if the nodes (Parameter[3]) can be passed to free()<br>Type<strong>[4]</strong>: int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  The macro function initializes a self declared <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Unlike <a href="functions#VSTR_SECTS_DECL_INIT%28%29">VSTR_SECTS_DECL_INIT()</a> this should only be called once per
 initialization.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SECTS_NUM%28%29">VSTR_SECTS_NUM()</a>
<br>Returns: The ith Vstr section node in the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: struct Vstr_sect_node *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Number of the section in the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[1])<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  Simple way to goto the Vstr section node in a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_make%28%29">vstr_sects_make()</a>
<br>Returns: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Maximum number of the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will make a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>, or return NULL.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_free%28%29">vstr_sects_free()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will free a <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>, allocated by <a href="functions#vstr_sects_make%28%29">vstr_sects_make()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_add%28%29">vstr_sects_add()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will add the position and length to a Vstr section node at the
 end of the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[1]). If space is not available and
 (Parameter[1])->can_add_sz is TRUE, then space try to be allocated.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_del%28%29">vstr_sects_del()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Number of the section in the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[1])<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will delete a specified Vstr section node. If
 (Parameter[1])->can_del_sz is TRUE then space may be compacted.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_foreach%28%29">vstr_sects_foreach()</a>
<br>Returns: Number of the times the foreach function ran the callback<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[2]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Flags starting <a href="constants#vstr_sects_foreach%28%29">VSTR_FLAG_SECT_FOREACH_*</a><br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Function to run as foreach body<br>Type<strong>[4]</strong>: unsigned int (*)(const Vstr_base *, size_t, size_t, void *)
</td></tr><tr><td>Parameter<strong>[5]</strong>: Data to pass to foreach body function (Parameter[4])<br>Type<strong>[5]</strong>: void *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will run the foreach body function (Parameter[4]) on every
 valid Vstr section node in the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a>.
</p><p>  The callback function (Parameter[4]) is passed the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]),
 the position and length from the current Vstr section node and finally the
 caller supplied data (Parameter[5]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The foreach callback body function returns types starting
 <a href="constants#VSTR_TYPE_SECT_FOREACH_">VSTR_TYPE_SECT_FOREACH_</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_update_add%28%29">vstr_sects_update_add()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[2]</strong>: struct Vstr_sects *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will cause the section (Parameter[2]) to automatically be
 updated when changes are made to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  You need to call <a href="functions#vstr_sects_update_del%28%29">vstr_sects_update_del()</a>, before you free the
 section (Parameter[2]). However if the next thing you are going to do is call
 <a href="functions#vstr_free_base%28%29">vstr_free_base()</a> on the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]), then nothing bad will
 happen if you call them in the oposite order.
</p><p>  This uses the <a href="functions#vstr_cache_add%28%29">vstr_cache_add()</a> function.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_update_del%28%29">vstr_sects_update_del()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[2]</strong>: struct Vstr_sects *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will cause the section (Parameter[2]) that was previously
 updated when changes are made to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]) to not be
 updated anymore.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sects_srch%28%29">vstr_sects_srch()</a>
<br>Returns: Number of the section in the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[1])<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[1]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will search for the first Vstr section node in a Vstr section
 (Parameter[1]) that matches the position and length.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Splitting%20data%20into%20sections%20functions">Splitting data into sections functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_split_buf%28%29">vstr_split_buf()</a>
<br>Returns: Number of Vstr section nodes added to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data to split on<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[6]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[7]</strong>: Limit of sections to add to <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])<br>Type<strong>[7]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[8]</strong>: Flags starting <a href="constants#vstr_split_buf%28%29">VSTR_FLAG_SPLIT_*</a><br>Type<strong>[8]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add section nodes to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])
 about the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]). The function will add one section before
 each occurrence of the data (Parameter[4]), and one final section for the
 rest of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  If the limit (Parameter[7]) is non-zero then ((Parameter[7]) - 1) occurrences
 of the data will be searched for and one final section will be added for the
 rest of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>. This means that "a:b:c" if split on ":" with a limit
 of 2 will split into "a" and "b:c", and that "a::" if split on ":" with a limit
 of 2 will split into "a" and ":".


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_split_chrs%28%29">vstr_split_chrs()</a>
<br>Returns: Number of Vstr section nodes added to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to characters to split on<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of characters (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[6]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[7]</strong>: Limit of sections to add to <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])<br>Type<strong>[7]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[8]</strong>: Flags starting VSTR_FLAG_SPLIT_<br>Type<strong>[8]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function works like <a href="functions#vstr_split_buf%28%29">vstr_split_buf()</a> except that instead of having to
 match all the data in the data buffer it matches any of the characters in the
 character buffer (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_split_cstr_buf%28%29">vstr_split_cstr_buf()</a>
<br>Returns: Number of Vstr section nodes added to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data to split on<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[5]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Limit of sections to add to <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Flags starting <a href="constants#vstr_split_cstr_buf%28%29">VSTR_FLAG_SPLIT_*</a><br>Type<strong>[7]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_split_buf%28%29">vstr_split_buf()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_split_cstr_chrs%28%29">vstr_split_cstr_chrs()</a>
<br>Returns: Number of Vstr section nodes added to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to characters to split on<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[5]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Limit of sections to add to <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Flags starting <a href="constants#vstr_split_cstr_chrs%28%29">VSTR_FLAG_SPLIT_*</a><br>Type<strong>[7]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_split_chrs%28%29">vstr_split_chrs()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SPLIT_CSTR_BUF%28%29">VSTR_SPLIT_CSTR_BUF()</a>
<br>Returns: Number of Vstr section nodes added to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data to split on<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[5]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Limit of sections to add to <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Flags starting <a href="constants#VSTR_SPLIT_CSTR_BUF%28%29">VSTR_FLAG_SPLIT_*</a><br>Type<strong>[7]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_split_buf%28%29">vstr_split_buf()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SPLIT_CSTR_CHRS%28%29">VSTR_SPLIT_CSTR_CHRS()</a>
<br>Returns: Number of Vstr section nodes added to the <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to characters to split on<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a><br>Type<strong>[5]</strong>: struct Vstr_sects *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Limit of sections to add to <a href="structs#struct%20Vstr_sects%20%28aka%2e%20Vstr%20sections%29">Vstr sections</a> (Parameter[6])<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Flags starting <a href="constants#VSTR_SPLIT_CSTR_CHRS%28%29">VSTR_FLAG_SPLIT_*</a><br>Type<strong>[7]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_split_chrs%28%29">vstr_split_chrs()</a> with the length being the
 value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Parsing%20data%20functions">Parsing data functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_num%28%29">vstr_parse_num()</a>
<br>Returns: Data returned from callback function<br>Type: void *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td>Parameter<strong>[7]</strong>: Function to run as parse body<br>Type<strong>[7]</strong>: void *(*)(unsigned int, int, unsigned int *, void *)
</td></tr><tr><td>Parameter<strong>[8]</strong>: Data to pass to parse number callback function (Parameter[7])<br>Type<strong>[8]</strong>: void *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, and pass it piece by piece to the callback
 function (Parameter[7]).
</p><p>  The callback function (Parameter[7]) is passed the base and the value of the
 current piece of the number, the pointer to a valid error code and finally
 the caller supplied data (Parameter[8]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If NULL is returned from the callback function, then parsing will stop at that
 point and immediately return.
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_short%28%29">vstr_parse_short()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: short
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range SHRT_MIN to SHRT_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_ushort%28%29">vstr_parse_ushort()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: unsigned short
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range 0 to USHRT_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_int%28%29">vstr_parse_int()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range INT_MIN to INT_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_uint%28%29">vstr_parse_uint()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range 0 to UINT_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_long%28%29">vstr_parse_long()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: long
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range LONG_MIN to LONG_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_ulong%28%29">vstr_parse_ulong()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: unsigned long
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range 0 to ULONG_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_intmax%28%29">vstr_parse_intmax()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: intmax_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range INTMAX_MIN to INTMAX_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.
</p><p>  If the intmax_t type is unavailable on the platform, then this function will
 act the same as <a href="functions#vstr_parse_long%28%29">vstr_parse_long()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_uintmax%28%29">vstr_parse_uintmax()</a>
<br>Returns: Number parsed from <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type: uintmax_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Base to parse number in and flags starting VSTR_FLAG_PARSE_NUM_<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns length of number (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_PARSE_NUM_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse a number, in the range 0 to UINTMAX_MAX, from
 the start of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.
</p><p>  The base that the number is parsed as is passed by specifying a number
 between 2 and 36 as part of the flags (Parameter[4]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A base of 0 specifies that the base should be automatically detected, by
 choosing base 16 if the number starts 0x or 0X, base 2 if the number
 starts 0b or 0B, base 8 if the number starts with a 0 and defaulting to
 base 10 otherwise.
</p><p>  If the intmax_t type is unavailable on the platform, then this function will
 act the same as <a href="functions#vstr_parse_ulong%28%29">vstr_parse_ulong()</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_netstr%28%29">vstr_parse_netstr()</a>
<br>Returns: Returns the length of the netstring<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Returns the position of the start of the netstring data<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns the length of the data in the netstring<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for the beginning of a netstring in
 the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the data cannot be found 0 is returned.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The netstring is only found if it is &quot;whole&quot;, in that the entire netstring
 and data exist in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>. If one is found but is not whole then the
 position of the start of data and the length of the netstring will still be
 returned.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_netstr2%28%29">vstr_parse_netstr2()</a>
<br>Returns: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> of the start of the netstring2<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Returns the position of the start of the netstring data<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns the length of the netstring<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to search forward for the beginning of a netstring in
 the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[4]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.
</p><p>  If the data cannot be found 0 is returned.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The netstring is only found if it is &quot;whole&quot;, in that the entire netstring
 and data exist in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>. If one is found but is not whole then the
 position of the start of data and the length of the netstring will still be
 returned.
</p><p>  The specification of a netstring2 is a superset of the specification of a
 netstring, so this function will find either.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_ipv4%28%29">vstr_parse_ipv4()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Returns ip in array elements 0 to 3<br>Type<strong>[4]</strong>: unsigned char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns CIDR mask, if requested<br>Type<strong>[5]</strong>: unsigned int *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Flags starting <a href="constants#vstr_parse_ipv4%28%29">VSTR_FLAG_PARSE_IPV4_*</a><br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Returns length of parsed ip address (Parameter[4] Parameter[5])<br>Type<strong>[7]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[8]</strong>: Returns error code starting VSTR_TYPE_PARSE_IPV4_ERR_<br>Type<strong>[8]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse an ipv4 address, or optionally an ipv4 address and a
 CIDR mask / netmask, from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_parse_ipv6%28%29">vstr_parse_ipv6()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Returns ip in array elements 0 to 7<br>Type<strong>[4]</strong>: unsigned int *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns CIDR mask<br>Type<strong>[5]</strong>: unsigned int *
</td></tr><tr><td>Parameter<strong>[6]</strong>: Flags starting <a href="constants#vstr_parse_ipv6%28%29">VSTR_FLAG_PARSE_IPV6_*</a><br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Returns length of parsed ip address (Parameter[4] Parameter[5])<br>Type<strong>[7]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[8]</strong>: Returns error code starting VSTR_TYPE_PARSE_IPV6_ERR_<br>Type<strong>[8]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will parse an ipv6 address, or optionally an ipv6 address and a
 CIDR mask, from the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Custom%20formatter%20functions">Custom formatter functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_fmt_add%28%29">vstr_fmt_add()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Function to use as callback from <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[3]</strong>: int (*)(struct Vstr_base *, size_t, struct Vstr_fmt_spec *)
</td></tr><tr><td>Parameter<strong>[4]</strong>: List of <a href="constants#vstr_fmt_add%28%29">VSTR_TYPE_FMT_*</a> types for format specifier (Parameter[2])<br>Type<strong>[4]</strong>: ...
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function allows you to register arbitrary format specifiers for printing
 from <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a>. Note that these trigger off the user escape character,
 which may or may not be the same as the "system" escape character of '%'.
</p><p>  The call back you register should return 0 (zero) if memory couldn't be
 allocated and 1 (one) otherwise.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  If the user escape character is '%', then you can override system specifiers
 by using a specifier name (Parameter[2]) of "i" etc. This isn't recommended, but
 is done so that you can have specifier names like "igloo" and it not be taken
 as a system specifier, however if you then did "%igoo" that would be
 interpreted as a "%i" (int) specification followed by the string "goo".
</p><p>  You can register multiple names with one callback, so you can register say
 "{Vstr}" and "{Vstr:%p%zu%zu%u}" ... the latter, with a user escape != '%',
 will do the right thing with current printf warning checks in gcc. We can
 all hope that the former will be as usable eventually.
</p><p>  If you register all your custom formatter names starting with one of
 "{", "[", "<" or "("  and ending with one of "}", "]", ">" or ")" and no
 other instances of those characters ... then matching custom formatters will
 be much faster.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_fmt_del%28%29">vstr_fmt_del()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function allows you to unregister a format specifier added
 using <a href="functions#vstr_fmt_add%28%29">vstr_fmt_add()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_fmt_srch%28%29">vstr_fmt_srch()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function allows you to find out if a format specifier has been added
 using <a href="functions#vstr_fmt_add%28%29">vstr_fmt_add()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_FMT_CB_ARG_PTR%28%29">VSTR_FMT_CB_ARG_PTR()</a>
<br>Returns: Pointer to data<br>Type: void *
</td></tr><tr><td>Parameter<strong>[1]</strong>: Format specifier passed to a callback of <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[1]</strong>: struct Vstr_fmt_spec *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Number of the parameter passed to the callback<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns the nth (Parameter[2]) parameter passed to a
 callback of <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a>, as a generic pointer.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_FMT_CB_ARG_VAL%28%29">VSTR_FMT_CB_ARG_VAL()</a>
<br>Returns: Data of specified type<br>Type: Parameter[2]
</td></tr><tr><td>Parameter<strong>[1]</strong>: Format specifier passed to a callback of <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[1]</strong>: struct Vstr_fmt_spec *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Type of the specified value<br>Type<strong>[2]</strong>: &lt;symbol&gt;
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number of the parameter for the callback<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function returns the nth (Parameter[3]) parameter passed to a
 callback of <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a>, by value.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Short%20cut%20helper%20functions">Short cut helper functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_bmap_init_eq_spn_buf%28%29">vstr_sc_bmap_init_eq_spn_buf()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to bytemap<br>Type<strong>[1]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length of a data (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Value to set in bytemap (Parameter[4])<br>Type<strong>[4]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to set all the bytes in the data (Parameter[2]), to the
 value (Parameter[4]) in the bytemap (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_bmap_init_eq_spn_cstr%28%29">vstr_sc_bmap_init_eq_spn_cstr()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to bytemap<br>Type<strong>[1]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Value to set in bytemap (Parameter[4])<br>Type<strong>[3]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sc_bmap_init_eq_spn_buf%28%29">vstr_sc_bmap_init_eq_spn_buf()</a> with the length being
 the value of strlen() on the data parameter (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_bmap_init_or_spn_buf%28%29">vstr_sc_bmap_init_or_spn_buf()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to bytemap<br>Type<strong>[1]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length of a data (Parameter[2])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Value of bits to set in bytemap (Parameter[1])<br>Type<strong>[4]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to set all the bytes in the data (Parameter[2]), to the
 value (Parameter[4]) combined with the original value, in the
 bytemap (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_bmap_init_or_spn_cstr%28%29">vstr_sc_bmap_init_or_spn_cstr()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: Pointer to bytemap<br>Type<strong>[1]</strong>: const unsigned char[256]
</td></tr><tr><td>Parameter<strong>[2]</strong>: Pointer to data<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Value of bits to set in bytemap (Parameter[1])<br>Type<strong>[3]</strong>: unsigned char
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sc_bmap_init_or_spn_buf%28%29">vstr_sc_bmap_init_or_spn_buf()</a> with the length being
 the value of strlen() on the data parameter (Parameter[2]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_posdiff%28%29">vstr_sc_posdiff()</a>
<br>Returns: Length of difference between two positions<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Start position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[2]</strong>: End position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to find the length between two positions inclusive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_POSDIFF%28%29">VSTR_SC_POSDIFF()</a>
<br>Returns: Length of difference between two positions<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Start position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[2]</strong>: End position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function is used to find the length between two positions
 inclusive.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_poslast%28%29">vstr_sc_poslast()</a>
<br>Returns: Last position of the given start and length<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Start position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to find the last poition, given a position and a length
 (it's basically the oposite of <a href="functions#vstr_sc_posdiff%28%29">vstr_sc_posdiff()</a>).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_POSLAST%28%29">VSTR_SC_POSLAST()</a>
<br>Returns: Last position of the given start and length<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Start position in a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function is used to find the last poition, given a position and
 a length (it's basically the oposite of <a href="functions#VSTR_SC_POSDIFF%28%29">VSTR_SC_POSDIFF()</a>).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_reduce%28%29">vstr_sc_reduce()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length to reduce the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to reduce the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> to the desired
 length (Ie. delete by a given ammount from the end of the given <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_basename%28%29">vstr_sc_basename()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Position of basename (Return)<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of basename (Return)<br>Type<strong>[5]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to return the basename of a path. Unlike
 other implementations of this function nothing is allocated and altered in the
 original string

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function, with <a href="functions#vstr_sc_dirname%28%29">vstr_sc_dirname()</a>, always returns values that can be
 combined to generate the original path. This means that this function will
 return an empty length for the path "/".


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_grpbasenum_buf%28%29">vstr_sc_add_grpbasenum_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to output a number with the Vstr strings
 locale grouping characters, for a specific base.
</p><p>  If copies both user data and locale data.

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_grpbasenum_ptr%28%29">vstr_sc_add_grpbasenum_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Length of data (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to output a number with the Vstr strings
 locale grouping characters, for a specific base.
</p><p>  If uses pointers for the user data and memory references for the locale data.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_grpbasenum_ref%28%29">vstr_sc_add_grpbasenum_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: Vstr_ref *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Offset of Vstr memory reference (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Length of Vstr memory reference (Parameter[4])<br>Type<strong>[6]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to output a number with the Vstr strings
 locale grouping characters, for a specific base.
</p><p>  If uses memory references for the user data and the locale data.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_grpnum_buf%28%29">vstr_sc_add_grpnum_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const void *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to output a number with the Vstr strings
 locale grouping characters.
</p><p>  If copies both user data and locale data.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function always uses the default locale information, if you have setup
 specific number base locale information using VSTR_CNTL_CONF_GET_LOC_REF_*
 etc. then you'll want to use the vstr_sc_add_grpbasenum_* functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_cstr_grpbasenum_buf%28%29">vstr_sc_add_cstr_grpbasenum_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sc_add_grpbasenum_buf%28%29">vstr_sc_add_grpbasenum_buf()</a> with the length being
 the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_cstr_grpbasenum_ptr%28%29">vstr_sc_add_cstr_grpbasenum_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sc_add_grpbasenum_ptr%28%29">vstr_sc_add_grpbasenum_ptr()</a> with the length being
 the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_cstr_grpbasenum_ref%28%29">vstr_sc_add_cstr_grpbasenum_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: Vstr_ref *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Offset of Vstr memory reference (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sc_add_grpbasenum_ref%28%29">vstr_sc_add_grpbasenum_ref()</a> with the length being
 the value of strlen() on memory from the Vstr memory reference (Parameter[4])
 starting at offset (Parameter[5]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_ADD_CSTR_GRPBASENUM_BUF%28%29">VSTR_SC_ADD_CSTR_GRPBASENUM_BUF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sc_add_grpbasenum_buf%28%29">vstr_sc_add_grpbasenum_buf()</a> with the length being
 the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_ADD_CSTR_GRPBASENUM_PTR%28%29">VSTR_SC_ADD_CSTR_GRPBASENUM_PTR()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sc_add_grpbasenum_ptr%28%29">vstr_sc_add_grpbasenum_ptr()</a> with the length being
 the value of strlen() on the data parameter (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_ADD_CSTR_GRPBASENUM_REF%28%29">VSTR_SC_ADD_CSTR_GRPBASENUM_REF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Base of the number in the data<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to data<br>Type<strong>[4]</strong>: Vstr_ref *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Offset of Vstr memory reference (Parameter[4])<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sc_add_grpbasenum_ref%28%29">vstr_sc_add_grpbasenum_ref()</a> with the length being
 the value of strlen() on memory from the Vstr memory reference (Parameter[4])
 starting at offset (Parameter[5]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_cstr_grpnum_buf%28%29">vstr_sc_add_cstr_grpnum_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function calls <a href="functions#vstr_sc_add_grpnum_buf%28%29">vstr_sc_add_grpnum_buf()</a> with the length being the value
 of strlen() on the data parameter (Parameter[3]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function always uses the default locale information, if you have setup
 specific number base locale information using VSTR_CNTL_CONF_GET_LOC_REF_*
 etc. then you'll want to use the vstr_sc_add_grpbasenum_* functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_ADD_CSTR_GRPNUM_BUF%28%29">VSTR_SC_ADD_CSTR_GRPNUM_BUF()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Pointer to data<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls <a href="functions#vstr_sc_add_grpnum_buf%28%29">vstr_sc_add_grpnum_buf()</a> with the length being
 the value of strlen() on the data parameter (Parameter[3]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This macro always uses the default locale information, if you have setup
 specific number base locale information using VSTR_CNTL_CONF_GET_LOC_REF_*
 etc. then you'll want to use the vstr_sc_add_grpbasenum_* functions.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num_uint%28%29">vstr_sc_conv_num_uint()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to array of numbers in the current base<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Base to convert number in<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of
 bytes, the number is converted by using the byte at the offset in the
 array of numbers (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num10_uint%28%29">vstr_sc_conv_num10_uint()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of numbers,
 in base 10, return value is the number of numbers written.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num_ulong%28%29">vstr_sc_conv_num_ulong()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to array of numbers in the current base<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Base to convert number in<br>Type<strong>[5]</strong>: unsigned long
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of
 bytes, the number is converted by using the byte at the offset in the
 array of numbers (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num10_ulong%28%29">vstr_sc_conv_num10_ulong()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: unsigned long
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of numbers,
 in base 10, return value is the number of numbers written.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num_size%28%29">vstr_sc_conv_num_size()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to array of numbers in the current base<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Base to convert number in<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of
 bytes, the number is converted by using the byte at the offset in the
 array of numbers (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num10_size%28%29">vstr_sc_conv_num10_size()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of numbers,
 in base 10, return value is the number of numbers written.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num_uintmax%28%29">vstr_sc_conv_num_uintmax()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: uintmax_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Pointer to array of numbers in the current base<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Base to convert number in<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of
 bytes, the number is converted by using the byte at the offset in the
 array of numbers (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_conv_num10_uintmax%28%29">vstr_sc_conv_num10_uintmax()</a>
<br>Returns: Number of bytes written to (Parameter[1])<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: Data array to export to<br>Type<strong>[1]</strong>: char *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length of data (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Number to output<br>Type<strong>[3]</strong>: uintmax_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will convert a number (Parameter[3]) into an array of numbers,
 in base 10, return value is the number of numbers written.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_dirname%28%29">vstr_sc_dirname()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the Vstr<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length from position in the Vstr<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of dirname (Return)<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function to return the directory of a path,
 excluding the basename. Unlike other implementations of this function nothing
 is allocated and nothing is altered in the original string.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function, with <a href="functions#vstr_sc_basename%28%29">vstr_sc_basename()</a>, always returns values that can be
 combined to generate the original path. This means that this function will
 return an empty length for a relative filename in the current directory.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_cb_beg%28%29">vstr_sc_fmt_cb_beg()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]), updated for padding.<br>Type<strong>[2]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Format specifier passed to a callback of <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[3]</strong>: struct Vstr_fmt_spec *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data you are going to add, updated due to precision.<br>Type<strong>[4]</strong>: size_t *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Flags starting <a href="constants#vstr_sc_fmt_cb_beg%28%29">VSTR_FLAG_SC_FMT_CB_BEG_*</a><br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function for any custom format specifiers you write,
 it takes care of truncation of length due to precision (on strings only) and
 printing initial output for numbers or strings.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If this function returns FALSE, you should probably just return from the
 callback with FALSE.

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_cb_end%28%29">vstr_sc_fmt_cb_end()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Position you added your data to the Vstr (Parameter[1]).<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Format specifier passed to a callback of <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[3]</strong>: struct Vstr_fmt_spec *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data you added.<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a helper function for any custom format specifiers you write,
 it takes care of doing the standard transforms to your data after it is
 output as if you were printing a string.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  You shouldn't alter the position between calling <a href="functions#vstr_sc_fmt_cb_beg%28%29">vstr_sc_fmt_cb_beg()</a> and
 <a href="functions#vstr_sc_fmt_cb_end%28%29">vstr_sc_fmt_cb_end()</a>, if padding is added in <a href="functions#vstr_sc_fmt_cb_end%28%29">vstr_sc_fmt_cb_end()</a> it is added
 at position (Parameter[2]) + length (Parameter[4]).
</p><p>  If this function returns FALSE, you should probably just return from the
 callback with FALSE.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_vstr%28%29">vstr_sc_fmt_add_vstr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 Vstr strings. It is equivalent to calling <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a>, <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a>,
 <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a>, <a href="constants#VSTR_TYPE_FMT_UINT">VSTR_TYPE_FMT_UINT</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>. These
 correspond to the last 4 arguments to <a href="functions#vstr_add_vstr%28%29">vstr_add_vstr()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  As you would expect the precision and field width values are used from the
 format, so the length of the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> printed is the lower bound of the
 length passed and the precision.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{vstr}&quot;, with the gcc warning
 compatible alternates using "{vstr:%p%zu%zu%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_buf%28%29">vstr_sc_fmt_add_buf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a memory block. It is equivalent to calling <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_CHAR">VSTR_TYPE_FMT_PTR_CHAR</a>, <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a> and
 <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>. These correspond to the last 2 arguments to <a href="functions#vstr_add_buf%28%29">vstr_add_buf()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  As you would expect the precision and field width values are used from the
 format, so the length of the memory block printed is the lower bound of the
 length passed and the precision.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{buf}&quot;, with the gcc warning
 compatible alternates using "{buf:%s%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ptr%28%29">vstr_sc_fmt_add_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a memory block. It is equivalent to calling <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_CHAR">VSTR_TYPE_FMT_PTR_CHAR</a>, <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a> and
 <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>. These correspond to the last 2 arguments to <a href="functions#vstr_add_ptr%28%29">vstr_add_ptr()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  As you would expect the precision and field width values are used from the
 format, so the length of the memory block printed is the lower bound of the
 length passed and the precision.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{ptr}&quot;, with the gcc warning
 compatible alternates using "{ptr:%s%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_non%28%29">vstr_sc_fmt_add_non()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a memory block. It is equivalent to calling <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>.
 These correspond to the last argument to <a href="functions#vstr_add_non%28%29">vstr_add_non()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  As you would expect the precision and field width values are used from the
 format, so the length of the memory block printed is the lower bound of the
 length passed and the precision.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{non}&quot;, with the gcc warning
 compatible alternates using "{non:%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ref%28%29">vstr_sc_fmt_add_ref()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a memory block. It is equivalent to calling <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a>, <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a>,
 <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>.
 These correspond to the last 3 arguments to <a href="functions#vstr_add_ref%28%29">vstr_add_ref()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  As you would expect the precision and field width values are used from the
 format, so the length of the memory block printed is the lower bound of the
 length passed and the precision.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{ref}&quot;, with the gcc warning
 compatible alternates using "{ref:%p%zu%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_rep_chr%28%29">vstr_sc_fmt_add_rep_chr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a memory block. It is equivalent to calling <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_INT">VSTR_TYPE_FMT_INT</a>, <a href="constants#VSTR_TYPE_FMT_SIZE_T">VSTR_TYPE_FMT_SIZE_T</a> and
 <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>. These correspond to the last 2 arguments to
 <a href="functions#vstr_add_rep_chr%28%29">vstr_add_rep_chr()</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  As you would expect the precision and field width values are used from the
 format, so the length of the memory block printed is the lower bound of the
 length passed and the precision.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{rep_chr}&quot;, with the gcc warning
 compatible alternates using "{rep_chr:%c%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_Byte_uint%28%29">vstr_sc_fmt_add_bkmg_Byte_uint()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "B" for bytes.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{BKMG.u}&quot;, with the gcc warning
 compatible alternates using "{BKMG.u:%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_Bytes_uint%28%29">vstr_sc_fmt_add_bkmg_Bytes_uint()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "B/s" for bytes per second.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{BKMG/s.u}&quot;, with the gcc warning
 compatible alternates using "{BKMG/s.u:%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_bit_uint%28%29">vstr_sc_fmt_add_bkmg_bit_uint()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "b" for bits.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{bKMG.u}&quot;, with the gcc warning
 compatible alternates using "{bKMG.u:%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_bits_uint%28%29">vstr_sc_fmt_add_bkmg_bits_uint()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "b/s" for bits per second.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{bKMG/s.u}&quot;, with the gcc warning
 compatible alternates using "{bKMG/s.u:%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_Byte_uintmax%28%29">vstr_sc_fmt_add_bkmg_Byte_uintmax()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "B" for bytes.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{BKMG.ju}&quot;, with the gcc warning
 compatible alternates using "{BKMG.ju:%ju}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_Bytes_uintmax%28%29">vstr_sc_fmt_add_bkmg_Bytes_uintmax()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "B/s" for bytes per second.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{BKMG/s.u}&quot;, with the gcc warning
 compatible alternates using "{BKMG/s.ju:%ju}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_bit_uintmax%28%29">vstr_sc_fmt_add_bkmg_bit_uintmax()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "b" for bits.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{bKMG.ju}&quot;, with the gcc warning
 compatible alternates using "{bKMG.ju:%ju}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_bkmg_bits_uintmax%28%29">vstr_sc_fmt_add_bkmg_bits_uintmax()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a number in a human accessible form. Displaying either K, M or G after the
 number and before a "b/s" for bits per second.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision specifies how many digits are included after the &quot;whole&quot; part
 of the number, the default precision is 2.
</p><p>  The padding of the number can be done with spaces or zero characters, and
 the '+' or ' ' modifiers will work as on unsigned ints.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{bKMG/s.ju}&quot;, with the gcc warning
 compatible alternates using "{bKMG/s.ju:%ju}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ipv4_ptr%28%29">vstr_sc_fmt_add_ipv4_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 ipv4 IP addresses from a struct in_addr *. It is equivalent to calling
 <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>. This pointer is
 a struct in_addr *, to be passed to inet_ntop().

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{ipv4.p}&quot;, with the gcc warning
 compatible alternates using "{ipv4.p:%p}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ipv6_ptr%28%29">vstr_sc_fmt_add_ipv6_ptr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 ipv6 IP addresses from a struct in6_addr *. It is equivalent to calling
 <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>. This pointer is
 a struct in6_addr *, to be passed to inet_ntop().

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{ipv4.p}&quot;, with the gcc warning
 compatible alternates using "{ipv4.p:%p}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ipv4_vec%28%29">vstr_sc_fmt_add_ipv4_vec()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 ipv4 IP addresses from a vector of 4 unsigned char.
 It is equivalent to calling
 <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>, the vector is one
 unsigned char for each part of the ipv4 address.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{ipv4.v}&quot;, with the gcc warning
 compatible alternates using "{ipv4.v:%p}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ipv6_vec%28%29">vstr_sc_fmt_add_ipv6_vec()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 ipv6 IP addresses from a vector of 8 unsigned int.
 It is equivalent to calling
 <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a>, <a href="constants#VSTR_TYPE_FMT_UINT">VSTR_TYPE_FMT_UINT</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>,
 the vector is one unsigned int for each part of the ipv6 address, the
 second argument of flags, change how the ipv6 address is printed.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  It is recommended that you use the name &quot;{ipv6.v}&quot;, with the gcc warning
 compatible alternates using "{ipv6.v:%p%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ipv4_vec_cidr%28%29">vstr_sc_fmt_add_ipv4_vec_cidr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 ipv4 IP addresses with a CIDR mask from a vector of 4 unsigned char and an
 unsigned int.
 It is equivalent to calling
 <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a>, <a href="constants#VSTR_TYPE_FMT_UINT">VSTR_TYPE_FMT_UINT</a> and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>,
 the vector is one unsigned char for each part of the ipv4 address.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  It is recommended that you use the name &quot;{ipv4.v+C}&quot;, with the gcc warning
 compatible alternates using "{ipv4.v+C:%p%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_ipv6_vec_cidr%28%29">vstr_sc_fmt_add_ipv6_vec_cidr()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 ipv6 IP addresses with a CIDR mask from a vector of 8 unsigned int and an
 unsigned int.
 It is equivalent to calling
 <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> with the type
 arguments of <a href="constants#VSTR_TYPE_FMT_PTR_VOID">VSTR_TYPE_FMT_PTR_VOID</a>, <a href="constants#VSTR_TYPE_FMT_UINT">VSTR_TYPE_FMT_UINT</a>, <a href="constants#VSTR_TYPE_FMT_UINT">VSTR_TYPE_FMT_UINT</a>
 and <a href="constants#VSTR_TYPE_FMT_END">VSTR_TYPE_FMT_END</a>,
 the vector is one unsigned int for each part of the ipv6 address, the
 second argument of flags, change how the ipv6 address is printed.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  It is recommended that you use the name &quot;{ipv6.v+C}&quot;, with the gcc warning
 compatible alternates using "{ipv6.v+C:%p%u%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_upper_base2_uint%28%29">vstr_sc_fmt_add_upper_base2_uint()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 an unsigned int number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{B.u}&quot;, with the gcc warning
 compatible alternates using "{B.u:%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_upper_base2_ulong%28%29">vstr_sc_fmt_add_upper_base2_ulong()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 an unsigned long number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{B.lu}&quot;, with the gcc warning
 compatible alternates using "{B.lu:%lu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_upper_base2_size%28%29">vstr_sc_fmt_add_upper_base2_size()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a size_t number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{B.zu}&quot;, with the gcc warning
 compatible alternates using "{B.zu:%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_upper_base2_uintmax%28%29">vstr_sc_fmt_add_upper_base2_uintmax()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a uintmax_t number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{B.ju}&quot;, with the gcc warning
 compatible alternates using "{B.ju:%ju}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_lower_base2_uint%28%29">vstr_sc_fmt_add_lower_base2_uint()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 an unsigned int number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{b.u}&quot;, with the gcc warning
 compatible alternates using "{b.u:%u}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_lower_base2_ulong%28%29">vstr_sc_fmt_add_lower_base2_ulong()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 an unsigned long number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{b.lu}&quot;, with the gcc warning
 compatible alternates using "{b.lu:%lu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_lower_base2_size%28%29">vstr_sc_fmt_add_lower_base2_size()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a size_t number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{b.zu}&quot;, with the gcc warning
 compatible alternates using "{b.zu:%zu}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_lower_base2_uintmax%28%29">vstr_sc_fmt_add_lower_base2_uintmax()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Specifier name, for use with <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a><br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a custom specifier function to print
 a uintmax_t number in a base 2 form.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The precision, field width, #, + and - attributes all act as they would on
 hex or octal numbers (Ie. %x or %o). The # flag prints a "0b" in the same way
 hex prints "0x".
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  It is recommended that you use the name &quot;{b.ju}&quot;, with the gcc warning
 compatible alternates using "{b.ju:%ju}" etc. <a href="functions#vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
 will add this formatter using those names.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_fmt_add_all%28%29">vstr_sc_fmt_add_all()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is a shortcut to adding a custom formatter for each of the
 specific custom formatters. The names used are as those given in the notes
 section of each custom formatter. Also 4 alternate names are given so that
 the formatter can be used in a gcc warning compatible way. For instance
 the <a href="functions#vstr_add_buf%28%29">vstr_add_buf()</a> formatter is "{buf}", however the names "{buf:%s%zu}",
 "{buf:%*s%zu}", "{buf:%.*s%zu}", "{buf:%*.*s%zu}", "{buf:%d%s%zu}" and 
 "{buf:%d%d%s%zu}" are also added (the later two are slightly less readable,
 but required for custom formaters whos first argument is a %p.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  If any of the custom formatter adds fails (for example, if the name is
 already in use) then all the rest of the names of that type will fail,
 however the other remaining types of formatters will be tried.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_SC_FMT_ADD%28%29">VSTR_SC_FMT_ADD()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Function to add the custom formatter ability<br>Type<strong>[2]</strong>: int (*)(struct Vstr_conf *, const char *)
</td></tr><tr><td>Parameter<strong>[3]</strong>: Prefix string<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Static format check string, without the leading % sign<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Postfix string<br>Type<strong>[5]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This macro function calls the function to add the custom formatting ability
 (Parameter[2]), with the <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> (Parameter[1]) and a string
 composed of the values from prefix, and the postfix. It then calls the
 function with the prefix, various middle strings with the static format
 check string, and the postfix.
  For example the following call...
</p><pre>
    VSTR_SC_FMT_ADD(NULL, func, "<foo", "p", ">");

</pre><p> ...will register the format "<foo>", but also the formats "<foo:%p>",
 "<foo:%p>", "<foo:%*p>", "<foo:%.*p>", "<foo:%*.*p>",
 "<foo:%d%p>" and "<foo:%d%d%p>". This is all that is required to fool static
 format string checkers, even when you are passing formating information in
 parameters.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  No cleanup is done on failure, so if the second registration fails then the
 first custom formatter will still be registered on return.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_mmap_fd%28%29">vstr_sc_mmap_fd()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: File descriptor<br>Type<strong>[3]</strong>: int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset to start map in file descriptor<br>Type<strong>[4]</strong>: off64_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Size of map in file descriptor<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_SC_MMAP_FD_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a mmap()d mapping of data from a file descriptor
 (Parameter[3]) at offset (Parameter[4]) and of size (Parameter[5]) to a
 <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the size (Parameter[5]) is zero, then then the size of the file is
 automatically worked out and the size (Parameter[5]) becomes the file size
 minus the offset (Parameter[4]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_mmap_file%28%29">vstr_sc_mmap_file()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Filename to add a mapping from<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset to start map in file open()'d by filename<br>Type<strong>[4]</strong>: off64_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Size of map in file open()'d by filename<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_SC_MMAP_FILE_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a mmap()d mapping of the entire data of filename
 (Parameter[3]) to a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_read_iov_fd%28%29">vstr_sc_read_iov_fd()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: File descriptor<br>Type<strong>[3]</strong>: int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Minimum amount of nodes to read into<br>Type<strong>[4]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[5]</strong>: Maximum amount of nodes to read into<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_SC_READ_FD_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to call <a href="functions#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>, then readv() with
 the file descriptor (Parameter[3]) and finally <a href="functions#vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a>
 before returning.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_read_len_fd%28%29">vstr_sc_read_len_fd()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: File descriptor<br>Type<strong>[3]</strong>: int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Size of data to try to read<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Returns error code starting VSTR_TYPE_SC_READ_FD_ERR_<br>Type<strong>[5]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to call <a href="functions#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>, then readv() with
 the file descriptor (Parameter[3]) and finally <a href="functions#vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a>
 before returning.
</p><p>  However the arguments to the vstr_add_iovec_buf_* calls
 are limited so that only up to size (Parameter[4]) data will be read.
</p><p>  If size (Parameter[4]) is zero then the entire file will try to be read.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  As with all calls in the vstr library, this is a non-blocking call. If you
 need all of the data specified (Parameter[4]) then you'll need to loop.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_read_iov_file%28%29">vstr_sc_read_iov_file()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Filename to read from<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset to start reading at<br>Type<strong>[4]</strong>: off64_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Minimum amount of nodes to read into<br>Type<strong>[5]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[6]</strong>: Maximum amount of nodes to read into<br>Type<strong>[6]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[7]</strong>: Returns error code starting VSTR_TYPE_SC_READ_FILE_ERR_<br>Type<strong>[7]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to call <a href="functions#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>, then readv() with
 the file descriptor got by opening the filename (Parameter[3]) and finally
 <a href="functions#vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a> before returning.
</p><p>  However the arguments to the vstr_add_iovec_buf_* calls
 are limited so that only up to size (Parameter[4]) data will be read.
</p><p>  However the arguments to the vstr_add_iovec_buf_* calls are limited so that
 only up to exactly size (Parameter[4]) data will be read. If size
 (Parameter[5]) is zero then the entire file, minus the offset (Parameter[4])
 will try and be read.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If all the data is read() and then close() fails with an error, although
 the error code will signify this the data will stay inside the Vstr as this
 seemed the most useful/sane behaviour.
</p><p>  read() is called multiple times from this function, so it should return
 after either all the data has been read from the file into the Vstr or an
 error has occured.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_read_len_file%28%29">vstr_sc_read_len_file()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Filename to read from<br>Type<strong>[3]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Offset to start reading at<br>Type<strong>[4]</strong>: off64_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: Size of data to try to read<br>Type<strong>[5]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[6]</strong>: Returns error code starting VSTR_TYPE_SC_READ_FILE_ERR_<br>Type<strong>[6]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to call <a href="functions#vstr_add_iovec_buf_beg%28%29">vstr_add_iovec_buf_beg()</a>, then readv() with
 the file descriptor got by opening the filename (Parameter[3]) and finally
 <a href="functions#vstr_add_iovec_buf_end%28%29">vstr_add_iovec_buf_end()</a> before returning.
</p><p>  However the arguments to the vstr_add_iovec_buf_* calls are limited so that
 only up to exactly size (Parameter[4]) data will be read. If size
 (Parameter[5]) is zero then the entire file, minus the offset (Parameter[4])
 will try and be read.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If all the data is read() and then close() fails with an error, although
 the error code will signify this the data will stay inside the Vstr as this
 seemed the most useful/sane behaviour.
</p><p>  read() is called multiple times from this function, so it should return
 after either all the data has been read from the file into the Vstr or an
 error has occured.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_write_fd%28%29">vstr_sc_write_fd()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: File descriptor<br>Type<strong>[3]</strong>: int
</td></tr><tr><td>Parameter<strong>[4]</strong>: Returns error code starting VSTR_TYPE_SC_WRITE_FD_ERR_<br>Type<strong>[4]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to take data from a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> and write it to a
 file descriptor. Specifically this means that after the call any data written
 will be removed from the Vstr (Parameter[1]), making write analogous to
 read which fills in the data.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the start position is 1, the length is (Parameter[1])-&gt;len and caching is
 available for the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> the data will be exported as though
 <a href="functions#vstr_export_iovec_ptr_all%28%29">vstr_export_iovec_ptr_all()</a>, writev() and then <a href="functions#vstr_del%28%29">vstr_del()</a> were called.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_write_file%28%29">vstr_sc_write_file()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Filename to add a mapping from<br>Type<strong>[4]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[5]</strong>: Flags to pass to the open() system call<br>Type<strong>[5]</strong>: int
</td></tr><tr><td>Parameter<strong>[6]</strong>: Mode to pass to the open() system call<br>Type<strong>[6]</strong>: mode_t
</td></tr><tr><td>Parameter<strong>[7]</strong>: Offset to start writing at<br>Type<strong>[7]</strong>: off64_t
</td></tr><tr><td>Parameter<strong>[8]</strong>: Returns error code starting VSTR_TYPE_SC_WRITE_FILE_ERR_<br>Type<strong>[8]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to take data from a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> and write it to a
 file, after open()ing the file (Parameter[4]) with open flags (Parameter[5])
 and open mode (Parameter[6]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Because multiple system calls will be done inside this function, and 
 that doing a write automatically removes data it's possible for this function
 to return failure but have actually written some data out. The other
 alternative would be to copy all the data until after the close() happened,
 which would be vastly less efficient.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_b_uint16%28%29">vstr_sc_add_b_uint16()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Binary value to add<br>Type<strong>[3]</strong>: uint_least16_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a 16bit (two byte) binary value (Parameter[3]),
 in Big Endian format, to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function is here because too many existing network protcols send binary
 values, in Big Endian format. This does not mean it is a good thing to do for
 new protcols, look at netstrings or something equally nicer.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_add_b_uint32%28%29">vstr_sc_add_b_uint32()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Append position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Binary value to add<br>Type<strong>[3]</strong>: uint_least32_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to add a 32bit (four byte) binary value (Parameter[3]),
 in Big Endian format, to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function is here because too many existing network protcols send binary
 values, in Big Endian format. This does not mean it is a good thing to do for
 new protcols, look at netstrings or something equally nicer.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_sub_b_uint16%28%29">vstr_sc_sub_b_uint16()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Binary value to add<br>Type<strong>[4]</strong>: uint_least16_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute a 16bit (two byte) binary
 value (Parameter[4]), in Big Endian format, to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function is here because too many existing network protcols send binary
 values, in Big Endian format. This does not mean it is a good thing to do for
 new protcols, look at netstrings or something equally nicer.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_sub_b_uint32%28%29">vstr_sc_sub_b_uint32()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: Binary value to add<br>Type<strong>[4]</strong>: uint_least32_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to substitute a 32bit (four byte) binary
 value (Parameter[4]), in Big Endian format, to the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function is here because too many existing network protcols send binary
 values, in Big Endian format. This does not mean it is a good thing to do for
 new protcols, look at netstrings or something equally nicer.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_parse_b_uint16%28%29">vstr_sc_parse_b_uint16()</a>
<br>Returns: Binary value to add<br>Type: uint_least16_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to parse a 16bit (two byte) binary
 value (Parameter[4]), in Big Endian format, from the Vstr
 string (Parameter[1]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function is here because too many existing network protcols send binary
 values, in Big Endian format. This does not mean it is a good thing to do for
 new protcols, look at netstrings or something equally nicer.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_sc_parse_b_uint32%28%29">vstr_sc_parse_b_uint32()</a>
<br>Returns: Binary value to add<br>Type: uint_least32_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to parse a 32bit (four byte) binary
 value (Parameter[4]), in Big Endian format, from the Vstr
 string (Parameter[1]).
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This function is here because too many existing network protcols send binary
 values, in Big Endian format. This does not mean it is a good thing to do for
 new protcols, look at netstrings or something equally nicer.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Interator%20functions">Interator functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_fwd_beg%28%29">vstr_iter_fwd_beg()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[4]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[4]</strong>: struct Vstr_iter *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to initialized an iteration.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The only time this function will return FALSE is if you pass an invalid
 position and length.
</p><p>  If you alter the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]) while using a iteration, then
 the iteration will be in an undefined state.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_fwd_nxt%28%29">vstr_iter_fwd_nxt()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[1]</strong>: struct Vstr_iter *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to step to the next iteration.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If you alter the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]) while using a iteration, then
 the iteration will be in an undefined state.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_fwd_chr%28%29">vstr_iter_fwd_chr()</a>
<br>Returns: Character at that point in iteration<br>Type: char
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[1]</strong>: struct Vstr_iter *
</td></tr><tr><td>Parameter<strong>[2]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a> return type  (<a href="constants#vstr_iter_fwd_chr%28%29">VSTR_TYPE_ITER_*</a>).<br>Type<strong>[2]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to return the current character and post increment the
 iteration (Ie think "ret = *iter++"). However it is safe to call
 <a href="functions#vstr_iter_fwd_chr%28%29">vstr_iter_fwd_chr()</a> forever, after it gets to the end of the iteration it
 will just return 0 (and set the return type to _END).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If you alter the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]) while using a iteration, then
 the iteration will be in an undefined state.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_fwd_buf%28%29">vstr_iter_fwd_buf()</a>
<br>Returns: Length of iteration moved<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[1]</strong>: struct Vstr_iter *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length to move iteration forward (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Data array to export to<br>Type<strong>[3]</strong>: void *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a> return type  (<a href="constants#vstr_iter_fwd_buf%28%29">VSTR_TYPE_ITER_*</a>).<br>Type<strong>[5]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to move the iteration forward a particular
 length (Parameter[2]). It will also export the data for the length, if there is
 room.
</p><p>  It is safe to call <a href="functions#vstr_iter_fwd_buf%28%29">vstr_iter_fwd_buf()</a> forever, after it gets to the
 end of the iteration it will just return 0 (and set the return type to _END).
 If the passed length is greater than the length of the iteration left, the
 length will be truncated and the truncated value will be returned.
</p><p>  Passing NULL as the buffer (Parameter[3]) is only valid if the buffer length
 (Parameter[4]) is zero.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If you alter the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]) while using a iteration, then
 the iteration will be in an undefined state.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_fwd_cstr%28%29">vstr_iter_fwd_cstr()</a>
<br>Returns: Length of iteration moved<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[1]</strong>: struct Vstr_iter *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Length to move iteration forward (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Data array to export to<br>Type<strong>[3]</strong>: char *
</td></tr><tr><td>Parameter<strong>[4]</strong>: Length of data (Parameter[3])<br>Type<strong>[4]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[5]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a> return type  (<a href="constants#vstr_iter_fwd_cstr%28%29">VSTR_TYPE_ITER_*</a>).<br>Type<strong>[5]</strong>: unsigned int *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function works like <a href="functions#vstr_iter_fwd_buf%28%29">vstr_iter_fwd_buf()</a>, except that the
 buffer (Parameter[3]) must be non-NULL and the end of the data exported using
 the iteration will always be NIL terminated.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_pos%28%29">vstr_iter_pos()</a>
<br>Returns: Position of iteration<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[1]</strong>: struct Vstr_iter *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to return the current position in the iteration.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_iter_len%28%29">vstr_iter_len()</a>
<br>Returns: Length of iteration<br>Type: size_t
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_iter%20%28aka%2e%20Vstr%20iterator%29">Vstr iteration</a><br>Type<strong>[1]</strong>: struct Vstr_iter *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to return the length remaining of the iteration.


</td></tr></table><table width="90%"><tr><td class="sect"><h2><a id="Miscellaneous%20functions">Miscellaneous functions</a></h2>

</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cntl_opt%28%29">vstr_cntl_opt()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: Option type starting <a href="constants#vstr_cntl_opt%28%29">VSTR_CNTL_OPT_*</a><br>Type<strong>[1]</strong>: int
</td></tr><tr><td>Parameter<strong>[ ... ]</strong>: Options depending on value of Parameter[1]<br>Type<strong>[ ... ]</strong>: ...
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will get or set global options.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cntl_base%28%29">vstr_cntl_base()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Option type starting <a href="constants#vstr_cntl_base%28%29">VSTR_CNTL_BASE_*</a><br>Type<strong>[2]</strong>: int
</td></tr><tr><td>Parameter<strong>[ ... ]</strong>: Options depending on value of Parameter[2]<br>Type<strong>[ ... ]</strong>: ...
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will get or set options for the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1]).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cntl_conf%28%29">vstr_cntl_conf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
 Parameter[1]:
<br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Option type starting <a href="constants#vstr_cntl_conf%28%29">VSTR_CNTL_CONF_*</a><br>Type<strong>[2]</strong>: int
</td></tr><tr><td>Parameter<strong>[ ... ]</strong>: Options depending on value of Parameter[2]<br>Type<strong>[ ... ]</strong>: ...
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will get or set options for the
 <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> (Parameter[1]).

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="VSTR_FLAGXX%28%29">VSTR_FLAGXX()</a>
<br>Returns: The value of the flags combined<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: Name of flag type to use.<br>Type<strong>[1]</strong>: &lt;symbol&gt;
</td></tr><tr><td>Parameter<strong>[ ... ]</strong>: Names of a flags in the given flag type<br>Type<strong>[ ... ]</strong>: &lt;symbol&gt;
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This isn't one macro function but a group of functions that all do the same
 thing, just with different numbers of arguments. They combine the namespace
 requirements so that you can specify multiple flags in a concise manner. For
 instance VSTR_FLAG06() combines 6 flags. So instead of having to wite...
</p><pre>
    (VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_NUL |
     VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BEL |
     VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_BS |
     VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_HT |
     VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_LF |
     VSTR_FLAG_CONV_UNPRINTABLE_ALLOW_VT)

</pre><p> ...you can write...
</p><pre>
    VSTR_FLAG06(CONV_UNPRINTABLE_ALLOW, NUL, BEL, BS, HT, LF, VT)

</pre><p> ...which is a lot more readable as the number of flags increases.
</p><p>  The Range of macro functions is from <a href="functions#VSTR_FLAG01%28%29">VSTR_FLAG01()</a> to <a href="functions#VSTR_FLAG31%28%29">VSTR_FLAG31()</a>, the
 number at the end referring to how many flags are passed to it (not the number
 of parameters, which is one more than that).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_num%28%29">vstr_num()</a>
<br>Returns: Number of nodes used in the vstr<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function is used to find out how many nodes are being used for a given
 section of a vstr.
</p><p>  If the function can detect that the values of parameters are in error the
 function will return 0 to indicate an error.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cache_add%28%29">vstr_cache_add()</a>
<br>Returns: Cookie reference for cache function<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Name of cache function<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Function to use as callback from the cache<br>Type<strong>[3]</strong>: void *(*)(const struct Vstr_base *, size_t, size_t, unsigned int, void *)
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will add the callback function (Parameter[3]) to the
 <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> for use in all Vstr strings that use the <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>
 and have a cache. The name of the cache function (Parameter[2]) should be
 unique, the vstr library uses names starting "/vstr__/".

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The name of the cache function should be placed in permanent storage, Ie.
 only the pointer to the name will be stored so you cannot malloc() the name
 and then free() it after calling the function.
</p><p>  The callback function parameters, are the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>, position, length,
 the type of callback starting <a href="constants#VSTR_TYPE_CACHE_">VSTR_TYPE_CACHE_</a> and the data for the cache
 function.
</p><p>  The callback function will not be called if the data for the cache function
 is NULL.
</p><p>  The inline adding and delete from the Vstr strings is not performed if
 callbacks are registered for the string (because functions will have to be
 called anyway).


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cache_get%28%29">vstr_cache_get()</a>
<br>Returns: Data for cache function<br>Type: void *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Cookie reference for cache function<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will get the data for the cache function.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cache_set%28%29">vstr_cache_set()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Cookie reference for cache function<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[3]</strong>: Data for cache function<br>Type<strong>[3]</strong>: void *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will set the data for the cache function.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  The callback function will not be called if the data for the cache function
 is NULL.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cache_srch%28%29">vstr_cache_srch()</a>
<br>Returns: Cookie reference for cache functions<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Name of cache function<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will find a cache function name (Parameter[2]) and return the
 cookie reference for use in the other cache functions.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cache_cb_sub%28%29">vstr_cache_cb_sub()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Start position in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[2]</strong>: size_t
</td></tr><tr><td>Parameter<strong>[3]</strong>: Length in the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> (Parameter[1])<br>Type<strong>[3]</strong>: size_t
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  If you are substituting data in a vstr (from an iovec export, followed by a
 readv for instance or changing the data in a mmap()'d area) then you can use
 this function to notify the vstr caching mechanisms.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  This is a last resort function, to make the hard things possible, use the
 vstr_sub_*() functions instead.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_cache_cb_free%28%29">vstr_cache_cb_free()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: const struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Cookie reference for cache function<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  If you have generated cache data, this function will tell the cache function
 to free that data.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  A Cookie reference of &quot;zero&quot; means tell all cache functions to free cached
 data. Note that this can cause severe performance degradation if overly used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_data_add%28%29">vstr_data_add()</a>
<br>Returns: Cookie reference for cache function<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Name of cache function<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td>Parameter<strong>[3]</strong>: Reference to data to store in the configuration<br>Type<strong>[3]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will add the data reference (Parameter[3]) to the
 <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>. The name of the data reference (Parameter[2]) should be
 unique, the vstr library will use names starting "/vstr__/".

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  The name of the cache function should be placed in permanent storage, Ie.
 only the pointer to the name will be stored so you cannot malloc() the name
 and then free() it after calling the function (you can free it after calling
 <a href="functions#vstr_data_del%28%29">vstr_data_del()</a>).
</p><p>  Storing a reference that is NULL is valid, and will act like storing a
 reference to NULL.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_data_srch%28%29">vstr_data_srch()</a>
<br>Returns: Cookie reference for data configuration functions<br>Type: unsigned int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Name of data configuration function<br>Type<strong>[2]</strong>: const char *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will find a configuration data name (Parameter[2]) and return
 the cookie reference for use in the other data functions.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_data_del%28%29">vstr_data_del()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Cookie reference for configuration data function<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will release the reference on the configuration data, and allow
 the cookie to be reused on a later <a href="functions#vstr_data_add%28%29">vstr_data_add()</a> call.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_data_get%28%29">vstr_data_get()</a>
<br>Returns: Data for configuration data function<br>Type: void *
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Cookie reference for configuration data function<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will get the data for the configuration data storage function.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_data_set%28%29">vstr_data_set()</a>
<br>Returns: Nothing<br>Type: void
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_conf *
</td></tr><tr><td>Parameter<strong>[2]</strong>: Cookie reference for configuration data function<br>Type<strong>[2]</strong>: unsigned int
</td></tr><tr><td>Parameter<strong>[3]</strong>: Reference to data to store in the configuration<br>Type<strong>[3]</strong>: struct Vstr_ref *
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will set the data for the configuration data storage function.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  If the configuration (Parameter[1]) is NULL, then the global configuration is
 used.
</p><p>  Storing a reference that is NULL is valid, and will act like storing a
 reference to NULL.
</p><p>  All allocations are done at <a href="functions#vstr_data_add%28%29">vstr_data_add()</a> time, so this function can never
 fail.


</td></tr></table><table width="80%"><tr><td class="obj">
<strong>Function: </strong> <a id="vstr_swap_conf%28%29">vstr_swap_conf()</a>
<br>Returns: TRUE on success and FALSE on failure<br>Type: int
</td></tr><tr><td>Parameter<strong>[1]</strong>: <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a><br>Type<strong>[1]</strong>: struct Vstr_base *
</td></tr><tr><td>Parameter<strong>[2]</strong>: New <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a>; returned old <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a><br>Type<strong>[2]</strong>: struct Vstr_conf **
</td></tr><tr><td><strong>Explanation:</strong></td></tr><tr><td><p>
</p><p>  This function will swap a <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> into a <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> possibly
 changing the <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> to be compatible with the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a>. On
 success the <a href="structs#struct%20Vstr_conf%20%28aka%2e%20Vstr%20configuration%29">Vstr configuration</a> that was being used by the <a href="structs#struct%20Vstr_base%20%28aka%2e%20Vstr%20string%29">Vstr string</a> is
 returned.

</td></tr><tr><td><strong>Note:</strong></td></tr><tr><td><p>
</p><p>  Using this function allows you to use <a href="functions#vstr_add_fmt%28%29">vstr_add_fmt()</a> and <a href="functions#vstr_add_vfmt%28%29">vstr_add_vfmt()</a> on
 a Vstr that you don't own, by doing...
</p><pre>
     if (vstr_swap_conf(notmy_vstr_string, &my_vstr_conf))
     {
       vstr_add_fmt(notmy_vstr_string, ... );
       vstr_swap_conf(notmy_vstr_string, &my_vstr_conf);
     }

</pre><p> ...note that the last call swaps the configuration back. However if you are
 not using any custom specifiers then you can just call <a href="functions#vstr_add_sysfmt%28%29">vstr_add_sysfmt()</a>
 instead.
</p><p>  The function will return 0 if it needs to allocate memory and cannot do so.



</td></tr></table>
</body></html>