/*  Copyright(c) 2009-2011 Shenzhen TP-LINK Technologies Co.Ltd.
 *
 * file		pjsua_app.c
 * brief		
 * details	
 *
 * author	Yu Chuwei
 * version	
 * date		05Jul11
 *
 * warning	
 *
 * history \arg	
 */
/*  Copyright(c) 2009-2011 Shenzhen TP-LINK Technologies Co.Ltd.
 *
 * file		pjsua_app.c
 * brief		
 * details	
 *
 * author	Yu Chuwei
 * version	
 * date		05Jul11
 *
 * warning	
 *
 * history \arg	
 */
/* $Id: pjsua_app.c 3553 2011-05-05 06:14:19Z nanang $ */
/* 
 * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)
 * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */
#include <pjsua-lib/pjsua.h>
#include <pjsua-lib/pjsua_internal.h>
#include "gui.h"

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

#include "cmsip_transport.h"
/* Added by sirrain zhang */
#ifdef INCLUDE_USB_VOICEMAIL
#include "usbvm_remotePlay.h"
#include "usbvm_remoteRecord.h"
#endif /* INCLUDE_USB_VOICEMAIL */
#include "dtmfrcv_dtmfReceiver.h"

#define THIS_FILE	"pjsua_app.c"
#define NO_LIMIT	(int)0x7FFFFFFF

//#define STEREO_DEMO
//#define TRANSPORT_ADAPTER_SAMPLE
//#define HAVE_MULTIPART_TEST

/* Ringtones		    US	       UK  */
#define RINGBACK_FREQ1	    440	    /* 400 */
#define RINGBACK_FREQ2	    480	    /* 450 */
#define RINGBACK_ON	    2000    /* 400 */
#define RINGBACK_OFF	    4000    /* 200 */
#define RINGBACK_CNT	    1	    /* 2   */
#define RINGBACK_INTERVAL   4000    /* 2000 */

#define RING_FREQ1	    800
#define RING_FREQ2	    640
#define RING_ON		    200
#define RING_OFF	    100
#define RING_CNT	    3
#define RING_INTERVAL	    3000


/* Call specific data */
struct call_data
{
    pj_timer_entry	    timer;
    pj_bool_t		    ringback_on;
    pj_bool_t		    ring_on;
};


/* Pjsua application data */
static struct app_config
{
    pjsua_config	    cfg;
#if (1 <= PJ_LOG_MAX_LEVEL)
    pjsua_logging_config    log_cfg;
#endif /* (1 <= PJ_LOG_MAX_LEVEL) */
    pjsua_media_config	    media_cfg;
    pj_bool_t		    no_refersub;
    pj_bool_t		    ipv6;
    pj_bool_t		    enable_qos;
    pj_bool_t		    no_tcp;
    pj_bool_t		    no_udp;
    pj_bool_t		    use_tls;
    pjsua_transport_config  udp_cfg;
    pjsua_transport_config  rtp_cfg;
    pjsip_redirect_op	    redir_op;


    unsigned		    acc_cnt;
    pjsua_acc_config	    acc_cfg[PJSUA_MAX_ACC];

#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
    unsigned		    buddy_cnt;
    pjsua_buddy_config	    buddy_cfg[PJSUA_MAX_BUDDIES];
#	endif

    struct call_data	    call_data[PJSUA_MAX_CALLS];

    pj_pool_t		   *pool;
    /* Compatibility with older pjsua */

    unsigned		    codec_cnt;
    pj_str_t		    codec_arg[32];
    unsigned		    codec_dis_cnt;
    pj_str_t          codec_dis[32];
	 #if 0
    pj_bool_t		    null_audio;
    unsigned		    wav_count;
    pj_str_t		    wav_files[32];
 	 #endif

	 /*ycw-pjsip-delete tone, generated by dsp, not sip stack*/
	 #if 0
    unsigned		    tone_count;
    pjmedia_tone_desc	    tones[32];
    pjsua_conf_port_id	    tone_slots[32];
	 #endif
	 #if 0
    pjsua_player_id	    wav_id;
    pjsua_conf_port_id	    wav_port;
    pj_bool_t		    auto_play;
    pj_bool_t		    auto_play_hangup;
    pj_timer_entry	    auto_hangup_timer;
    pj_bool_t		    auto_loop;
    pj_bool_t		    auto_conf;
    pj_str_t		    rec_file;
    pj_bool_t		    auto_rec;
    pjsua_recorder_id	    rec_id;
    pjsua_conf_port_id	    rec_port;
    unsigned		    auto_answer;
 	 #endif

    unsigned		    duration;

#if 0
    unsigned		    capture_lat, playback_lat;
    pj_bool_t		    no_tones;
#endif

	/*ycw-pjsip-delete sound device*/
#if 0
    int			    ringback_slot;
    int			    ringback_cnt;
    pjmedia_port	   *ringback_port;
    int			    ring_slot;
    int			    ring_cnt;
    pjmedia_port	   *ring_port;
#endif
	/*ycw-pjsip-usbvm*/
	#if 1
	int usbvmEndpt_cnt;
	USBVMENDPTCONFIG usbvmEndptConfig[PJSUA_MAX_CMENDPT];
	#endif
	/*ycw-pjsip-enableT38*/
	pj_bool_t enableT38;

#	if defined(INCLUDE_USB_VOICEMAIL)
	/* wlm: voice mail remote access */
	pj_bool_t enableVMRemoteAcc;
#   endif /* INCLUDE_USB_VOICEMAIL */

	/* to set iptables rule:
	0 -- don't set iptables rules;
	1 -- only set netfilter table's iptables rules;
	2 -- set iptables rules of both nat table and netfilter table.
	*/
	pj_uint8_t fwType;

#if INCLUDE_FWMARK
	pj_int32_t	fwmark;		/* 0: not enabled */
#endif

} app_config;

//static pjsua_acc_id	current_acc;
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
#define current_acc	pjsua_acc_get_default()
#	endif
static pjsua_call_id	current_call = PJSUA_INVALID_ID;
#	if 0
static pj_bool_t	cmd_echo;
static pj_bool_t	stdout_refresh_quit = PJ_FALSE;
#	endif
static pj_str_t		uri_arg;

static char some_buf[1024 * 3];

#ifdef STEREO_DEMO
static void stereo_demo();
#endif
#ifdef TRANSPORT_ADAPTER_SAMPLE
static pj_status_t transport_adapter_sample(void);
#endif
static pj_status_t create_ipv6_media_transports(void);
pj_status_t app_destroy(void);

/*ycw-pjsip--delete conference*/
#if 0
static void ringback_start(pjsua_call_id call_id);
static void ring_start(pjsua_call_id call_id);
static void ring_stop(pjsua_call_id call_id);
#endif

pj_bool_t 	app_restart;
pj_bool_t	app_exit_without_unregister = PJ_FALSE;
pj_log_func     *log_cb = NULL;

/*****************************************************************************
 * Configuration manipulation
 */

#if (defined(PJ_IPHONE_OS_HAS_MULTITASKING_SUPPORT) && \
    PJ_IPHONE_OS_HAS_MULTITASKING_SUPPORT!=0) || \
    defined(__IPHONE_4_0)
void keepAliveFunction(int timeout)
{
    int i;
    for (i=0; i<(int)pjsua_acc_get_count(); ++i) {
	if (!pjsua_acc_is_valid(i))
	    continue;

	if (app_config.acc_cfg[i].reg_timeout < timeout)
	    app_config.acc_cfg[i].reg_timeout = timeout;

	pjsua_acc_set_registration(i, PJ_TRUE, PJ_FALSE);
    }
}
#endif

/* Set default config. */
static void default_config(struct app_config *cfg)
{
    char tmp[80];
    unsigned i;

    pjsua_config_default(&cfg->cfg);
    pj_ansi_sprintf(tmp, "TP-Link SIP Stack V1.0.0");
    pj_strdup2_with_null(app_config.pool, &cfg->cfg.user_agent, tmp);

#if (1 <= PJ_LOG_MAX_LEVEL)
    pjsua_logging_config_default(&cfg->log_cfg);
#endif /* (1 <= PJ_LOG_MAX_LEVEL) */
    pjsua_media_config_default(&cfg->media_cfg);
    pjsua_transport_config_default(&cfg->udp_cfg);
    cfg->udp_cfg.port = 5060;
    pjsua_transport_config_default(&cfg->rtp_cfg);
	/*yuchuwei*/
#	ifdef SUPPORT_METABOLIC_MEDIA_PORT
	cfg->rtp_cfg.port = 60000;
#	else
    cfg->rtp_cfg.port = 4000;
#	endif
    cfg->redir_op = PJSIP_REDIRECT_ACCEPT;
    cfg->duration = NO_LIMIT;
	 #if 0
    cfg->wav_id = PJSUA_INVALID_ID;
    cfg->rec_id = PJSUA_INVALID_ID;
    cfg->wav_port = PJSUA_INVALID_ID;
    cfg->rec_port = PJSUA_INVALID_ID;
 	 #endif

	 /*ycw-pjsip*/
	 cfg->cfg.has_telephone_event = PJ_FALSE;

#if INCLUDE_FWMARK
	cfg->fwmark = 0;
#endif

/*ycw-pjsip-enableT38*/
	cfg->enableT38 = PJ_FALSE;

#	if defined(INCLUDE_USB_VOICEMAIL)
/* wlm: for voice mail remote access */
    cfg->enableVMRemoteAcc = PJ_FALSE;
#   endif /* INCLUDE_USB_VOICEMAIL */

	/*ycw-sip-delete sound device*/
	#if 0
    cfg->mic_level = cfg->speaker_level = 1.0;
    cfg->capture_dev = PJSUA_INVALID_ID;
    cfg->playback_dev = PJSUA_INVALID_ID;
    cfg->capture_lat = PJMEDIA_SND_DEFAULT_REC_LATENCY;
    cfg->playback_lat = PJMEDIA_SND_DEFAULT_PLAY_LATENCY;
 	#endif

	/*ycw-sip-delete sound device*/
	#if 0	
    cfg->ringback_slot = PJSUA_INVALID_ID;
    cfg->ring_slot = PJSUA_INVALID_ID;
	#endif

    for (i=0; i<PJ_ARRAY_SIZE(cfg->acc_cfg); ++i)
	pjsua_acc_config_default(&cfg->acc_cfg[i]);

#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
    for (i=0; i<PJ_ARRAY_SIZE(cfg->buddy_cfg); ++i)
	pjsua_buddy_config_default(&cfg->buddy_cfg[i]);
#	endif
}


/*
 * Read command arguments from config file.
 */
static int read_config_file(pj_pool_t *pool, const char *filename, 
			    int *app_argc, char ***app_argv)
{
    int i;
    FILE *fhnd;
    char line[256];
    int argc = 0;
    char **argv;
	 /*ycw-pjsip*/
	 #if 0
    enum { MAX_ARGS = 128 };
	 #else
	 enum { MAX_ARGS = 512 };
	 #endif

    /* Allocate MAX_ARGS+1 (argv needs to be terminated with NULL argument) */
    argv = pj_pool_calloc(pool, MAX_ARGS+1, sizeof(char*));
    argv[argc++] = *app_argv[0];

    /* Open config file. */
    fhnd = fopen(filename, "rt");
    if (!fhnd)
	 {
		PJ_LOG(1,(THIS_FILE, "Unable to open config file %s", filename));
		fflush(stdout);
		return -1;
    }

    /* Scan tokens in the file. */
    while (argc < MAX_ARGS && !feof(fhnd))
	 {
		char  *token;
		char  *p;
		const char *whitespace = " \t\r\n";
		char  cDelimiter;
		int   len, token_len;

		memset(line, 0, sizeof(line));
		if (fgets(line, sizeof(line), fhnd) == NULL)
		{
			break;
		}
	
		// Trim ending newlines
		len = strlen(line);
		if (line[len-1]=='\n')
	   {
	   	line[--len] = '\0';
		}
		
		if (line[len-1]=='\r')
	   {
	   	line[--len] = '\0';
		}

		if (len==0)
		{
			continue;
		}

		for (p = line; *p != '\0' && argc < MAX_ARGS; p++)
		{
	   	// first, scan whitespaces
	    	while (*p != '\0' && strchr(whitespace, *p) != NULL)
			{
				p++;
	    	}

	    	if (*p == '\0')		    // are we done yet?
	    	{
				break;
	    	}
	    
	    	if (*p == '"' || *p == '\'')	// is token a quoted string
			{    
				cDelimiter = *p++;	    // save quote delimiter
				token = p;
#	if 0		
				while (*p != '\0' && *p != cDelimiter)
				{
					p++;
				}
#	else
				while (*p!='\0' && ((*p!=cDelimiter) || (*(p+1)!='\0')))
				{
					p++;
				}
#	endif
		
				if (*p == '\0')		// found end of the line, but,
				{
		    		cDelimiter = '\0';	// didn't find a matching quote
				}

	    	}
			else
			{			// token's not a quoted string
				token = p;
		
				while (*p != '\0' && strchr(whitespace, *p) == NULL)
				{
					p++;
				}
		
				cDelimiter = *p;
	    	}
	    
	    	*p = '\0';
	    	token_len = p-token;
	    
	    	if (token_len > 0)
			{
				/* dingcheng-pjsip:we shouldn't ignore this as the username and password may start with '#' */
#if 0
				if (*token == '#')
				{
		    		break;  // ignore remainder of line
				}
#endif	
				argv[argc] = pj_pool_alloc(pool, token_len + 1);
				pj_memcpy(argv[argc], token, token_len + 1);
				CMSIP_PRINT("%s", argv[argc]);
				++argc;
			}
	    
			*p = cDelimiter;
		}
    }

    /* Copy arguments from command line */
    for (i=1; i<*app_argc && argc < MAX_ARGS; ++i)
    {
		argv[argc++] = (*app_argv)[i];
    }

    if (argc == MAX_ARGS && (i!=*app_argc || !feof(fhnd)))
	 {
		PJ_LOG(1,(THIS_FILE, 
		  "Too many arguments specified in cmd line/config file"));
		fflush(stdout);
		fclose(fhnd);
		return -1;
    }

    fclose(fhnd);

	/*delete this file because it is useless untill next start.
	* by yuchuwei.
	*/
	pj_file_delete(filename);

    /* Assign the new command line back to the original command line. */
    *app_argc = argc;
    *app_argv = argv;
    return 0;

}

static int my_atoi(const char *cs)
{
    pj_str_t s;

    pj_cstr(&s, cs);
    if (cs[0] == '-') {
	s.ptr++, s.slen--;
	return 0 - (int)pj_strtoul(&s);
    } else if (cs[0] == '+') {
	s.ptr++, s.slen--;
	return pj_strtoul(&s);
    } else {
	return pj_strtoul(&s);
    }
}


/* Parse arguments. */
static pj_status_t parse_args(int argc, char *argv[],
			      struct app_config *cfg,
			      pj_str_t *uri_to_call)
{
    int c;
    int option_index;
    enum 
	 { OPT_CONFIG_FILE=127,
#if 0
	 	OPT_LOG_FILE, 
	 	OPT_LOG_LEVEL, 
	 	OPT_APP_LOG_LEVEL, 
	   OPT_LOG_APPEND, 
	   OPT_COLOR, 
	   OPT_NO_COLOR, 
	   OPT_LIGHT_BG,
	   OPT_LOCAL_PORT, 
	   OPT_IP_ADDR, 
#endif

	   OPT_PROXY, 
/*yuchuwei@2012-04-05:we don't use the global outbound proxy*/
#	if 0
	   OPT_OUTBOUND_PROXY, 
#	endif
	   OPT_REGISTRAR, 
	   OPT_REG_TIMEOUT, 
#if 0
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	   OPT_PUBLISH, 
#	endif
#endif
	   OPT_ID,
	   OPT_CODEC,
	   OPT_CMINDEX,
#if 0
	   OPT_CONTACT,
#endif
	   OPT_BOUND_ADDR, 
	   /*ycw-firewall*/
	   OPT_BOUND_NETMASK,
#if 0
	   OPT_CONTACT_PARAMS, 
	   OPT_CONTACT_URI_PARAMS,
#endif
	   /*ycw-pjsip.*/
	 	OPT_MAPENDPT,
	 	OPT_ACCT_PRIO,
	   OPT_100REL, 
#if 0
	   OPT_USE_IMS, 
#endif
	   OPT_REALM, 
	   OPT_USERNAME, 
	   OPT_PASSWORD,
	   OPT_REG_RETRY_INTERVAL, 
	   OPT_REG_USE_PROXY,
	   OPT_MWI, 
/*yuchuwei@2012-04-05*/
#if PJSIP_HAS_RESOLVER
		/*By yuchuwei, For Telefonica*/
	   OPT_NAMESERVER,
#endif
#	if 0
	   OPT_STUN_SRV, 
	   OPT_OUTB_RID,
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	   OPT_ADD_BUDDY, 
#	endif
	   OPT_OFFER_X_MS_MSG, 
	   OPT_NO_PRESENCE,
	   OPT_CLOCK_RATE, 
	   OPT_SND_CLOCK_RATE, 
	   OPT_USE_ICE, 
	   OPT_ICE_REGULAR, 
	   OPT_USE_SRTP, 
	   OPT_SRTP_SECURE,
	   OPT_USE_TURN, 
	   OPT_ICE_MAX_HOSTS, 
	   OPT_ICE_NO_RTCP, 
	   OPT_TURN_SRV, 
	   OPT_TURN_TCP, 
	   OPT_TURN_USER, 
	   OPT_TURN_PASSWD,
	   OPT_RTP_PORT, 
#	endif
	   OPT_ADD_CODEC, 
#if 0
	   OPT_ILBC_MODE, 
	   OPT_COMPLEXITY, 
	   OPT_QUALITY,
#endif
	   OPT_PTIME, 
#if 0
	   OPT_NO_VAD,
	   OPT_RX_DROP_PCT, 
	   OPT_TX_DROP_PCT, 
	   OPT_EC_TAIL, 
	   OPT_EC_OPT,
#endif
	   OPT_NEXT_ACCOUNT, 
	   OPT_NEXT_CRED, 
	   OPT_MAX_CALLS, 
#if 0
	   OPT_DURATION, 
#endif
	   OPT_NO_TCP, 
	   OPT_NO_UDP, 
#if 0
	   OPT_THREAD_CNT,
	   OPT_NOREFERSUB, 
	   OPT_ACCEPT_REDIRECT,
	   OPT_USE_TLS, 
	   OPT_TLS_CA_FILE, 
	   OPT_TLS_CERT_FILE, 
	   OPT_TLS_PRIV_FILE,
	   OPT_TLS_PASSWORD, 
	   OPT_TLS_VERIFY_SERVER, 
	   OPT_TLS_VERIFY_CLIENT,
	   OPT_TLS_NEG_TIMEOUT, 
	   OPT_TLS_SRV_NAME,
#endif
/*ycw-pjsip-enableT38*/
	   OPT_ENABLE_T38,

#	if defined(INCLUDE_USB_VOICEMAIL)
/* wlm: add for voice mail remote access */
	   OPT_ENABLE_VM_REMOTE_ACCESS,
#   endif /* INCLUDE_USB_VOICEMAIL */

#if 0
	   OPT_IPV6,
#endif
		OPT_SIP_QOS,
		OPT_RTP_QOS,
#if 0
#ifdef _IONBF
	   OPT_STDOUT_NO_BUF,
#endif
	   OPT_AUTO_UPDATE_NAT,
	   OPT_USE_COMPACT_FORM,
#endif
	   OPT_DIS_CODEC,
	   OPT_NO_FORCE_LR,
	   OPT_TIMER, 
	   OPT_TIMER_SE, 
	   OPT_TIMER_MIN_SE,
	   /*USB Voice Mail*/
		OPT_DEL_EXPIRED,
		OPT_GLOBAL_WAV,
		OPT_LOCAL_NOTIFY,
		OPT_MSG_EXPIRES,
		OPT_REC_DURATION,
		OPT_VM_CAPACITY,
		OPT_CUSTOM_NOTIFY,
		OPT_SEL_NOTIFY,
		OPT_PIN_NUMBER,
		/*ycw-pjsip. add telephone-event pt or not*/
		OPT_HAS_TELEVT,
		OPT_NEXT_ENDPT,
		OPT_BOUND_IFNAME,
		OPT_FWTYPE,
#ifdef INCLUDE_TFC_ES
		OPT_NAI_SUPPORT,
		OPT_REQUEST_PRIV,
		OPT_PREFER_ID,
#endif
		OPT_FWMARK,
    };
    struct pj_getopt_option long_options[] = {
		{ "config-file",					1,	0, OPT_CONFIG_FILE},
#if 0
		{ "log-file",						1, 0, OPT_LOG_FILE},
		{ "log-level",						1, 0, OPT_LOG_LEVEL},
		{ "app-log-level",				1,	0,	OPT_APP_LOG_LEVEL},
		{ "log-append", 					0, 0, OPT_LOG_APPEND},
		{ "color",							0, 0, OPT_COLOR},
		{ "no-color",						0, 0, OPT_NO_COLOR},
		{ "light-bg",						0, 0, OPT_LIGHT_BG},
#endif
		#if 0
		{ "help",							0, 0, OPT_HELP},
		{ "version",						0, 0, OPT_VERSION},
		#endif
#if 0
		{ "clock-rate",					1, 0, OPT_CLOCK_RATE},
		{ "snd-clock-rate",				1, 0, OPT_SND_CLOCK_RATE},
#endif
		#if 0
		{ "stereo",							0, 0, OPT_STEREO},
		{ "null-audio", 					0, 0, OPT_NULL_AUDIO},
		#endif
#if 0
		{ "local-port", 					1, 0, OPT_LOCAL_PORT},
		{ "ip-addr",						1, 0, OPT_IP_ADDR},
#endif
		{ "bound-addr", 					1, 0, OPT_BOUND_ADDR},
		/*ycw-firewall*/
		{ "bound-netmask",				1, 0, OPT_BOUND_NETMASK},
		{ "no-tcp",     					0, 0, OPT_NO_TCP},
		{ "no-udp",     					0, 0, OPT_NO_UDP},
#if 0
		{ "norefersub", 					0, 0, OPT_NOREFERSUB},
#endif
		{ "proxy",							1, 0, OPT_PROXY},
/*yuchuwei@2012-04-05:we don't use the global outbound proxy*/
#	if 0
		{ "outbound",						1, 0, OPT_OUTBOUND_PROXY},
#	endif
		{ "registrar",						1, 0, OPT_REGISTRAR},
		{ "reg-timeout",					1, 0, OPT_REG_TIMEOUT},
#if 0
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
		{ "publish",    					0, 0, OPT_PUBLISH},
#	endif
#endif
		{ "mwi",								0, 0, OPT_MWI},
		{ "use-100rel", 					0, 0, OPT_100REL},
#if 0
		{ "use-ims",    					0, 0, OPT_USE_IMS},
#endif
		{ "id",								1, 0, OPT_ID},
		{ "codec",							1,	0,	OPT_CODEC},
		{ "cmindex",						1,	0,	OPT_CMINDEX},
#if 0
		{ "contact",						1, 0, OPT_CONTACT},
		{ "contact-params",				1,	0, OPT_CONTACT_PARAMS},
		{ "contact-uri-params",			1,	0, OPT_CONTACT_URI_PARAMS},
#endif
		/*ycw-pjsip*/
		{ "map-endpt",						1, 0, OPT_MAPENDPT},
		{ "acct-prio",						1,	0,	OPT_ACCT_PRIO},
#if 0
		{ "auto-update-nat",				1, 0, OPT_AUTO_UPDATE_NAT},
	   { "use-compact-form",			0, 0, OPT_USE_COMPACT_FORM},
		{ "accept-redirect", 			1, 0, OPT_ACCEPT_REDIRECT},
#endif
		{ "no-force-lr",					0, 0, OPT_NO_FORCE_LR},
		{ "realm",							1, 0, OPT_REALM},
		{ "username",						1, 0, OPT_USERNAME},
		{ "password",						1, 0, OPT_PASSWORD},
		{ "rereg-delay",					1, 0, OPT_REG_RETRY_INTERVAL},
		{ "reg-use-proxy", 				1, 0, OPT_REG_USE_PROXY},
/*yuchuwei@2012-04-05*/
#if PJSIP_HAS_RESOLVER
		{ "nameserver", 					1, 0, OPT_NAMESERVER},
#	endif
#if 0
		{ "stun-srv",   					1, 0, OPT_STUN_SRV},
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
		{ "add-buddy",  					1, 0, OPT_ADD_BUDDY},
#	endif
		{ "offer-x-ms-msg",				0,	0,	OPT_OFFER_X_MS_MSG},
		{ "no-presence", 					0, 0, OPT_NO_PRESENCE},
		{ "auto-answer",					1, 0, OPT_AUTO_ANSWER},
		{ "auto-play",  					0, 0, OPT_AUTO_PLAY},
		{ "auto-play-hangup",			0, 0, OPT_AUTO_PLAY_HANGUP},
		{ "auto-rec",   					0, 0, OPT_AUTO_REC},
		{ "auto-loop",  					0, 0, OPT_AUTO_LOOP},
		{ "auto-conf",  					0, 0, OPT_AUTO_CONF},
		{ "play-file",  					1, 0, OPT_PLAY_FILE},
		{ "play-tone",  					1, 0, OPT_PLAY_TONE},
		{ "rec-file",   					1, 0, OPT_REC_FILE},
		{ "rtp-port",						1, 0, OPT_RTP_PORT},
		{ "use-ice",    					0, 0, OPT_USE_ICE},
		{ "ice-regular",					0, 0, OPT_ICE_REGULAR},
		{ "use-turn",						0, 0, OPT_USE_TURN},
		{ "ice-max-hosts",				1, 0, OPT_ICE_MAX_HOSTS},
		{ "ice-no-rtcp",					0, 0, OPT_ICE_NO_RTCP},
		{ "turn-srv",						1, 0, OPT_TURN_SRV},
		{ "turn-tcp",						0, 0, OPT_TURN_TCP},
		{ "turn-user",						1, 0, OPT_TURN_USER},
		{ "turn-passwd",					1, 0, OPT_TURN_PASSWD},
#if defined(PJMEDIA_HAS_SRTP) && (PJMEDIA_HAS_SRTP != 0)
		{ "use-srtp",   					1, 0, OPT_USE_SRTP},
		{ "srtp-secure",					1, 0, OPT_SRTP_SECURE},
#endif
#endif
		{ "add-codec",  					1, 0, OPT_ADD_CODEC},
		{ "dis-codec",  					1, 0, OPT_DIS_CODEC},
#if 0
		{ "complexity",					1, 0, OPT_COMPLEXITY},
		{ "quality",						1, 0, OPT_QUALITY},
#endif
		{ "ptime",      					1, 0, OPT_PTIME},
#if 0
		{ "no-vad",     					0, 0, OPT_NO_VAD},
		{ "ec-tail",    					1, 0, OPT_EC_TAIL},
		{ "ec-opt",							1, 0, OPT_EC_OPT},
		{ "ilbc-mode",						1, 0, OPT_ILBC_MODE},
		{ "rx-drop-pct",					1, 0, OPT_RX_DROP_PCT},
		{ "tx-drop-pct",					1, 0, OPT_TX_DROP_PCT},
#endif
		{ "next-account",					0,	0, OPT_NEXT_ACCOUNT},
		{ "next-cred",						0, 0, OPT_NEXT_CRED},
		{ "max-calls",						1, 0, OPT_MAX_CALLS},
#if 0
		{ "duration",						1, 0, OPT_DURATION},
		{ "thread-cnt",					1, 0, OPT_THREAD_CNT},
		{ "use-tls",						0, 0, OPT_USE_TLS}, 
		{ "tls-ca-file",					1, 0, OPT_TLS_CA_FILE},
		{ "tls-cert-file",				1,	0, OPT_TLS_CERT_FILE}, 
		{ "tls-privkey-file",			1,	0, OPT_TLS_PRIV_FILE},
		{ "tls-password",					1,	0, OPT_TLS_PASSWORD},
		{ "tls-verify-server", 			0, 0, OPT_TLS_VERIFY_SERVER},
		{ "tls-verify-client", 			0, 0, OPT_TLS_VERIFY_CLIENT},
		{ "tls-neg-timeout", 			1, 0, OPT_TLS_NEG_TIMEOUT},
		{ "tls-srv-name", 				1, 0, OPT_TLS_SRV_NAME},
#endif
#if	0 /*ycw-pjsip*/
		{ "capture-dev",    				1, 0, OPT_CAPTURE_DEV},
		{ "playback-dev",   				1, 0, OPT_PLAYBACK_DEV},
		{ "capture-lat",    				1, 0, OPT_CAPTURE_LAT},
		{ "playback-lat",   				1, 0, OPT_PLAYBACK_LAT},
#endif
/*ycw-pjsip-enableT38*/
		{ "enable-t38", 					1, 0, OPT_ENABLE_T38},
			
#if defined(INCLUDE_USB_VOICEMAIL)
/* wlm: for voice mail remote access */
		{ "enable-voice-mail-remote-access",1, 0, OPT_ENABLE_VM_REMOTE_ACCESS},
#endif /* INCLUDE_USB_VOICEMAIL */

#if 0
#ifdef _IONBF
		{ "stdout-no-buf",  				0, 0, OPT_STDOUT_NO_BUF },
#endif
#endif
#if 0
		{ "snd-auto-close", 				1, 0, OPT_SND_AUTO_CLOSE},
		{ "no-tones",    					0, 0, OPT_NO_TONES},
#endif
		#if 0
		{ "jb-max-size", 					1, 0, OPT_JB_MAX_SIZE},
		#endif
#if defined(PJ_HAS_IPV6) && PJ_HAS_IPV6
		{ "ipv6",	 						0, 0, OPT_IPV6},
#endif
/*ycw-pjsip-qos*/
#if 0
		{ "set-qos",	 					0, 0, OPT_QOS},
#else
		{ "set-sip-qos",					1, 0, OPT_SIP_QOS},
		{ "set-rtp-qos",					1,	0,	OPT_RTP_QOS},
#endif
		{ "use-timer",  					1, 0, OPT_TIMER},
		{ "timer-se",   					1, 0, OPT_TIMER_SE},
		{ "timer-min-se", 				1, 0, OPT_TIMER_MIN_SE},
#if 0
		{ "outb-rid",						1, 0, OPT_OUTB_RID},
#endif
		/*USB Voice Mail*/
		{ "usbvm-del-expired",			0, 0, OPT_DEL_EXPIRED},
		{ "usbvm-global-wav",			0, 0, OPT_GLOBAL_WAV},
		{ "usbvm-local-opera-notify",	0,	0,	OPT_LOCAL_NOTIFY},
		{ "usbvm-message-expires",		1,	0,	OPT_MSG_EXPIRES},
		{ "usbvm-rec-duration",			1,	0,	OPT_REC_DURATION},
		{ "usbvm-capacity",				1,	0,	OPT_VM_CAPACITY},
		{ "usbvm-custom-notify",		0,	0,	OPT_CUSTOM_NOTIFY},
		{ "usbvm-select-notify",		1,	0,	OPT_SEL_NOTIFY},
		{ "usbvm-pin-number",			1,	0,	OPT_PIN_NUMBER},
		{ "usbvm-next-endpt",			0,	0,	OPT_NEXT_ENDPT},
		/*ycw-pjsip*/
		{ "has-televt",					0,	0,	OPT_HAS_TELEVT},
		{ "bound-ifname",				1,	0,	OPT_BOUND_IFNAME},
		{ "fwtype",						1,	0,	OPT_FWTYPE},
#ifdef INCLUDE_TFC_ES
		{ "nai-support",				0,	0,	OPT_NAI_SUPPORT},
		{ "request-priv",				0,	0,	OPT_REQUEST_PRIV},
		{ "prefer-id",					1,	0,	OPT_PREFER_ID},
#endif
		{ "enable-fwmark",				1,	0,	OPT_FWMARK},
		{ NULL, 								0, 0, 0}
    };
    pj_status_t status;
    pjsua_acc_config *cur_acc;
    char *config_file = NULL;
    unsigned i;

    /* Run pj_getopt once to see if user specifies config file to read. */ 
    pj_optind = 0;
    while ((c=pj_getopt_long(argc, argv, "", long_options, &option_index)) != -1) 
    {
		switch (c)
		{
		case OPT_CONFIG_FILE:
	   	config_file = pj_optarg;
	   	break;
		}
		
		if (config_file)
	   {
	   	break;
		}
    }

    if (config_file)
	 {
		status = read_config_file(app_config.pool, config_file, &argc, &argv);
		if (status != 0)
	   {
	   	return status;
		}
    }

    cfg->acc_cnt = 0;
    cur_acc = &cfg->acc_cfg[0];

    /* Reinitialize and re-run pj_getopt again, possibly with new arguments
     * read from config file.
     */
    pj_optind = 0;
    while((c=pj_getopt_long(argc,argv, "", long_options,&option_index))!=-1)
	 {
		pj_str_t tmp;
		long lval;

		switch (c)
		{
		case OPT_CONFIG_FILE:
	    	/* Ignore as this has been processed before */
	    	break;
#if 0	
		case OPT_LOG_FILE:
	   	cfg->log_cfg.log_filename = pj_str(pj_optarg);
	    	break;

		case OPT_LOG_LEVEL:
	   	c = pj_strtoul(pj_cstr(&tmp, pj_optarg));
	   	if (c < 0 || c > 6)
			{
				PJ_LOG(1,(THIS_FILE, 
			  		"Error: expecting integer value 0-6 "
			  		"for --log-level"));
				return PJ_EINVAL;
	    	}
	    	cfg->log_cfg.level = c;
	    	pj_log_set_level( c );
	    	break;

		case OPT_APP_LOG_LEVEL:
	   	cfg->log_cfg.console_level = pj_strtoul(pj_cstr(&tmp, pj_optarg));
	    	if (cfg->log_cfg.console_level < 0 || cfg->log_cfg.console_level > 6)
			{
				PJ_LOG(1,(THIS_FILE, 
				"Error: expecting integer value 0-6 "
				"for --app-log-level"));
				return PJ_EINVAL;
	    	}
	    	break;

		case OPT_LOG_APPEND:
			cfg->log_cfg.log_file_flags |= PJ_O_APPEND;
			break;

		case OPT_COLOR:
		    cfg->log_cfg.decor |= PJ_LOG_HAS_COLOR;
		    break;

		case OPT_NO_COLOR:
		    cfg->log_cfg.decor &= ~PJ_LOG_HAS_COLOR;
		    break;

		case OPT_LIGHT_BG:
		    pj_log_set_color(1, PJ_TERM_COLOR_R);
		    pj_log_set_color(2, PJ_TERM_COLOR_R | PJ_TERM_COLOR_G);
		    pj_log_set_color(3, PJ_TERM_COLOR_B | PJ_TERM_COLOR_G);
		    pj_log_set_color(4, 0);
		    pj_log_set_color(5, 0);
		    pj_log_set_color(77, 0);
		    break;

		case OPT_HELP:
		    usage();
		    return PJ_EINVAL;

			

		case OPT_VERSION:   /* version */
		    pj_dump_config();
		    return PJ_EINVAL;

		case OPT_NULL_AUDIO:
		    cfg->null_audio = PJ_TRUE;
		    break;

		case OPT_CLOCK_RATE:
		    lval = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		    if (lval < 8000 || lval > 192000)
			 {
				PJ_LOG(1,(THIS_FILE, "Error: expecting value between "
					     "8000-192000 for conference clock rate"));
				return PJ_EINVAL;
		    }
		    cfg->media_cfg.clock_rate = lval; 
		    break;

		case OPT_SND_CLOCK_RATE:
		    lval = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		    if (lval < 8000 || lval > 192000)
			 {
				PJ_LOG(1,(THIS_FILE, "Error: expecting value between "
					     "8000-192000 for sound device clock rate"));
				return PJ_EINVAL;
		    }
		    cfg->media_cfg.snd_clock_rate = lval; 
		    break;

		case OPT_STEREO:
		    cfg->media_cfg.channel_count = 2;
		    break;

		case OPT_LOCAL_PORT:   /* local-port */
		    lval = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		    if (lval < 0 || lval > 65535)
			 {
				PJ_LOG(1,(THIS_FILE, 
				  "Error: expecting integer value for "
				  "--local-port"));
				return PJ_EINVAL;
		    }
		    cfg->udp_cfg.port = (pj_uint16_t)lval;
		    break;

		case OPT_IP_ADDR: /* ip-addr */
		    cfg->udp_cfg.public_addr = pj_str(pj_optarg);
		    cfg->rtp_cfg.public_addr = pj_str(pj_optarg);
		    break;
#endif

		case OPT_BOUND_ADDR: /* bound-addr */
		    cfg->udp_cfg.bound_addr = pj_str(pj_optarg);
		    cfg->rtp_cfg.bound_addr = pj_str(pj_optarg);
			 pjsua_var.BoundIp = pj_str(pj_optarg);
		    break;
		/*ycw-firewall*/
		case OPT_BOUND_NETMASK:/*bound-netmask*/
			cfg->udp_cfg.bound_addr_netmask = pj_str(pj_optarg);
			cfg->rtp_cfg.bound_addr_netmask = pj_str(pj_optarg);
			break;

		case OPT_NO_UDP: /* no-udp */
		    if (cfg->no_tcp)
			 {
		      PJ_LOG(1,(THIS_FILE,"Error: can not disable both TCP and UDP"));
		      return PJ_EINVAL;
		    }

		    cfg->no_udp = PJ_TRUE;
		    break;
#if 0
		case OPT_NOREFERSUB: /* norefersub */
		    cfg->no_refersub = PJ_TRUE;
		    break;
#endif
		case OPT_NO_TCP: /* no-tcp */
		    if (cfg->no_udp)
			 {
		      PJ_LOG(1,(THIS_FILE,"Error: can not disable both TCP and UDP"));
		      return PJ_EINVAL;
		    }

		    cfg->no_tcp = PJ_TRUE;
		    break;

		case OPT_PROXY:   /* proxy */
		    if (pjsua_verify_sip_url(pj_optarg) != 0)
			 {
#	if defined(CMSIP_DEBUG) && CMSIP_DEBUG!=0
				PJ_LOG(1,(THIS_FILE, 
				  "Error: invalid SIP URL '%s' "
				  "in proxy argument", pj_optarg));
#	else
				cmsip_send_systemlog(CMSIP_SYSTEMLOG_WARN, "Error: invalid SIP URL '%s' "
				  "in proxy argument", pj_optarg);
#	endif
#	if 0				
				return PJ_EINVAL;
#	endif
		    }
		    cur_acc->proxy[cur_acc->proxy_cnt++] = pj_str(pj_optarg);
		    break;

/*yuchuwei@2012-04-05:we don't use the global outbound proxy*/
#	if 0
		case OPT_OUTBOUND_PROXY:   /* outbound proxy */
		    if (pjsua_verify_sip_url(pj_optarg) != 0)
			 {
				PJ_LOG(1,(THIS_FILE, 
				  "Error: invalid SIP URL '%s' "
				  "in outbound proxy argument", pj_optarg));
				return PJ_EINVAL;
		    }
		    cfg->cfg.outbound_proxy[cfg->cfg.outbound_proxy_cnt++] = pj_str(pj_optarg);
		    break;
#	endif
		case OPT_REGISTRAR:   /* registrar */
	   	 if (pjsua_verify_sip_url(pj_optarg) != 0)
			 {
#	if defined(CMSIP_DEBUG) && CMSIP_DEBUG!=0
				PJ_LOG(1,(THIS_FILE, 
			  		"Error: invalid SIP URL '%s' in "
			  		"registrar argument", pj_optarg));
#	else
				cmsip_send_systemlog(CMSIP_SYSTEMLOG_WARN, "Error: invalid SIP URL '%s' in "
			  		"registrar argument", pj_optarg);
#	endif
/*Because of the complexity of */
#	if 0
				return PJ_EINVAL;
#	endif
	    	 }
	    	 cur_acc->reg_uri = pj_str(pj_optarg);
	    	 break;

		case OPT_REG_TIMEOUT:   /* reg-timeout */
			#	if 0
	    		cur_acc->reg_timeout = pj_strtoul(pj_cstr(&tmp,pj_optarg));
	    		if (cur_acc->reg_timeout < 1 || cur_acc->reg_timeout > 3600)
				{
					PJ_LOG(1,(THIS_FILE, 
						  "Error: invalid value for --reg-timeout "
						  "(expecting 1-3600)"));
					return PJ_EINVAL;
	    		}
			#	endif
				cfg->cfg.reg_timeout = pj_strtoul(pj_cstr(&tmp, pj_optarg));
				if (cfg->cfg.reg_timeout < 1 || cfg->cfg.reg_timeout > 3600)
				{
					PJ_LOG(1, (THIS_FILE, "Error: invalid value for --reg-timeout(expecting 1-3600)."
						"Set the value to 3600."));
					cfg->cfg.reg_timeout = 3600;
				}				
	    		break;
#if 0
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	case OPT_PUBLISH:   /* publish */
	    cur_acc->publish_enabled = PJ_TRUE;
	    break;
#	endif
#endif
	case OPT_MWI:	/* mwi */
	    cur_acc->mwi_enabled = PJ_TRUE;
	    break;

	case OPT_100REL: /** 100rel */
	    cur_acc->require_100rel = PJ_TRUE;
	    cfg->cfg.require_100rel = PJ_TRUE;
	    break;

	case OPT_TIMER: /** session timer */
	    lval = pj_strtoul(pj_cstr(&tmp, pj_optarg));
	    if (lval < 0 || lval > 3) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: expecting integer value 0-3 for --use-timer"));
		return PJ_EINVAL;
	    }
	    cur_acc->use_timer = lval;
	    cfg->cfg.use_timer = lval;
	    break;

	case OPT_TIMER_SE: /** session timer session expiration */
	    cur_acc->timer_setting.sess_expires = pj_strtoul(pj_cstr(&tmp, pj_optarg));
	    if (cur_acc->timer_setting.sess_expires < 90) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: invalid value for --timer-se "
			  "(expecting higher than 90)"));
		return PJ_EINVAL;
	    }
	    cfg->cfg.timer_setting.sess_expires = cur_acc->timer_setting.sess_expires;
	    break;

	case OPT_TIMER_MIN_SE: /** session timer minimum session expiration */
	    cur_acc->timer_setting.min_se = pj_strtoul(pj_cstr(&tmp, pj_optarg));
	    if (cur_acc->timer_setting.min_se < 90) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: invalid value for --timer-min-se "
			  "(expecting higher than 90)"));
		return PJ_EINVAL;
	    }
	    cfg->cfg.timer_setting.min_se = cur_acc->timer_setting.min_se;
	    break;
#if 0
	case OPT_OUTB_RID: /* Outbound reg-id */
	    cur_acc->rfc5626_reg_id = pj_str(pj_optarg);
	    break;

	case OPT_USE_IMS: /* Activate IMS settings */
	    cur_acc->auth_pref.initial_auth = PJ_TRUE;
	    break;
#endif
	case OPT_ID:   /* id */
	{
		char *p1 = NULL;
		char *p2 = NULL;
				
		p1 = strchr(pj_optarg, '\\');
		if (p1)
		{
			*p1 = '\"';
			p2 = strchr(pj_optarg, '\\');
			if (p2)
			{
				*p2 = '\"';
			}
		}

		if (pjsua_verify_url(pj_optarg) != 0)
		{
#	if defined(CMSIP_DEBUG) && CMSIP_DEBUG!=0
			PJ_LOG(1,(THIS_FILE, 
			  "Error: invalid SIP URL '%s' "
			  "in local id argument", pj_optarg));
#	else
			cmsip_send_systemlog(CMSIP_SYSTEMLOG_WARN, "Error: invalid SIP URL '%s' "
			  "in local id argument", pj_optarg);
#	endif
#	if 0
			return PJ_EINVAL;
#	endif
		}

		cur_acc->id = pj_str(pj_optarg);
	}
		break;

	/*ycw-pjsip-codec*/
	case OPT_CODEC:		
		cur_acc->codecs[cur_acc->codec_cnt++] = pj_str(pj_optarg);
		break;

	case OPT_CMINDEX:
		cur_acc->cmAcctIndex = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		break;
#if 0
	case OPT_CONTACT:   /* contact */
	    if (pjsua_verify_sip_url(pj_optarg) != 0) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: invalid SIP URL '%s' "
			  "in contact argument", pj_optarg));
		return PJ_EINVAL;
	    }
	    cur_acc->force_contact = pj_str(pj_optarg);
	    break;
	case OPT_CONTACT_PARAMS:
	    cur_acc->contact_params = pj_str(pj_optarg);
	    break;

	case OPT_CONTACT_URI_PARAMS:
	    cur_acc->contact_uri_params = pj_str(pj_optarg);
	    break;
#endif
		 
	/*ycw-pjsip*/
	#if 1
	case OPT_MAPENDPT:
		{
			pj_bool_t nagative = PJ_FALSE;
			while(' ' == *pj_optarg) ++pj_optarg;
			if ('-' == *pj_optarg)
			{
				nagative = PJ_TRUE;
				++pj_optarg;
			}
			
			cur_acc->mapEndpt	= pj_strtoul(pj_cstr(&tmp, pj_optarg));
			if (nagative)
			{
				cur_acc->mapEndpt = -cur_acc->mapEndpt;
			}
		}
		break;
	#endif

	#if 1
 	case OPT_ACCT_PRIO:
		cur_acc->priority = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		break;
	#endif
#if 0
	case OPT_AUTO_UPDATE_NAT:   /* OPT_AUTO_UPDATE_NAT */
            cur_acc->allow_contact_rewrite  = pj_strtoul(pj_cstr(&tmp, pj_optarg));
	    break;

	case OPT_USE_COMPACT_FORM:
	    /* enable compact form - from Ticket #342 */
      {
			extern pj_bool_t pjsip_use_compact_form;
			extern pj_bool_t pjsip_include_allow_hdr_in_dlg;
			extern pj_bool_t pjmedia_add_rtpmap_for_static_pt;

			pjsip_use_compact_form = PJ_TRUE;
			/* do not transmit Allow header */
			pjsip_include_allow_hdr_in_dlg = PJ_FALSE;
			/* Do not include rtpmap for static payload types (<96) */
			pjmedia_add_rtpmap_for_static_pt = PJ_FALSE;
       }
	    break;

	case OPT_ACCEPT_REDIRECT:
	    cfg->redir_op = my_atoi(pj_optarg);
	    if (cfg->redir_op<0 || cfg->redir_op>PJSIP_REDIRECT_STOP) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: accept-redirect value '%s' ", pj_optarg));
		return PJ_EINVAL;
	    }
	    break;
#endif
	case OPT_NO_FORCE_LR:
	    cfg->cfg.force_lr = PJ_FALSE;
	    break;

#ifdef INCLUDE_TFC_ES
	case OPT_NAI_SUPPORT:
		CMSIP_PRINT("enable Network Asserted Identity support");
		cur_acc->supportNAI = PJ_TRUE;
		break;
	case OPT_REQUEST_PRIV:
		CMSIP_PRINT("request Privacy");
		cur_acc->requestPriv = PJ_TRUE;
		break;
	case OPT_PREFER_ID:
		CMSIP_PRINT("get Prefered Identity(%s)", pj_optarg);
		cur_acc->preferId = pj_str(pj_optarg);
		break;
#endif

	case OPT_NEXT_ACCOUNT: /* Add more account. */
	    cfg->acc_cnt++;
	    cur_acc = &cfg->acc_cfg[cfg->acc_cnt];
	    break;

	case OPT_USERNAME:   /* Default authentication user */
	    cur_acc->cred_info[cur_acc->cred_count].username = pj_str(pj_optarg);
	    cur_acc->cred_info[cur_acc->cred_count].scheme = pj_str("Digest");
		CMSIP_PRINT("authenticate name(%d, %.*s)",
			cur_acc->cred_info[cur_acc->cred_count].username.slen,
			cur_acc->cred_info[cur_acc->cred_count].username.slen,
			cur_acc->cred_info[cur_acc->cred_count].username.ptr
		);
	    break;

	case OPT_REALM:	    /* Default authentication realm. */
	    cur_acc->cred_info[cur_acc->cred_count].realm = pj_str(pj_optarg);
	    break;

	case OPT_PASSWORD:   /* authentication password */
	    cur_acc->cred_info[cur_acc->cred_count].data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;
	    cur_acc->cred_info[cur_acc->cred_count].data = pj_str(pj_optarg);
#if PJSIP_HAS_DIGEST_AKA_AUTH
	    cur_acc->cred_info[cur_acc->cred_count].data_type |= PJSIP_CRED_DATA_EXT_AKA;
	    cur_acc->cred_info[cur_acc->cred_count].ext.aka.k = pj_str(pj_optarg);
	    cur_acc->cred_info[cur_acc->cred_count].ext.aka.cb = &pjsip_auth_create_aka_response;
#endif
	    break;

	case OPT_REG_RETRY_INTERVAL:
		#	if 0
	    cur_acc->reg_retry_interval = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		#	else
		 cfg->cfg.reg_retry_interval = pj_strtoul(pj_cstr(&tmp, pj_optarg));
		#	endif
	    break;

	case OPT_REG_USE_PROXY:
	    cur_acc->reg_use_proxy = (unsigned)pj_strtoul(pj_cstr(&tmp, pj_optarg));
	    if (cur_acc->reg_use_proxy > 3) {
		PJ_LOG(1,(THIS_FILE, "Error: invalid --reg-use-proxy value '%s'",
			  pj_optarg));
		return PJ_EINVAL;
	    }
	    break;

	case OPT_NEXT_CRED: /* next credential */
	    cur_acc->cred_count++;
	    break;

/*yuchuwei@2012-04-05*/
#if PJSIP_HAS_RESOLVER
	case OPT_NAMESERVER: /* nameserver */
	    cfg->cfg.nameserver[cfg->cfg.nameserver_count++] = pj_str(pj_optarg);		 
	    if (cfg->cfg.nameserver_count > PJ_ARRAY_SIZE(cfg->cfg.nameserver))
		 {
			PJ_LOG(1,(THIS_FILE, "Error: too many nameservers"));
			return PJ_ETOOMANY;
	    }
	    break;
#endif
#	if 0
	case OPT_STUN_SRV:   /* STUN server */
	    cfg->cfg.stun_host = pj_str(pj_optarg);
	    if (cfg->cfg.stun_srv_cnt==PJ_ARRAY_SIZE(cfg->cfg.stun_srv))
		 {
			PJ_LOG(1,(THIS_FILE, "Error: too many STUN servers"));
			return PJ_ETOOMANY;
	    }
	    cfg->cfg.stun_srv[cfg->cfg.stun_srv_cnt++] = pj_str(pj_optarg);
	    break;

#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	case OPT_ADD_BUDDY: /* Add to buddy list. */
	    if (pjsua_verify_url(pj_optarg) != 0) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: invalid URL '%s' in "
			  "--add-buddy option", pj_optarg));
		return -1;
	    }
	    if (cfg->buddy_cnt == PJ_ARRAY_SIZE(cfg->buddy_cfg)) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: too many buddies in buddy list."));
		return -1;
	    }
	    cfg->buddy_cfg[cfg->buddy_cnt].uri = pj_str(pj_optarg);
	    cfg->buddy_cnt++;
	    break;
#	endif
#endif
#if 0 /*ycw-pjsip*/
	case OPT_AUTO_PLAY:
	    cfg->auto_play = 1;
	    break;


	case OPT_AUTO_PLAY_HANGUP:
	    cfg->auto_play_hangup = 1;
	    break;

	case OPT_AUTO_REC:
	    cfg->auto_rec = 1;
	    break;
#endif
#if 0
	case OPT_AUTO_LOOP:
	    cfg->auto_loop = 1;
	    break;

	case OPT_AUTO_CONF:
	    cfg->auto_conf = 1;
	    break;
#endif
#if 0
	case OPT_PLAY_FILE:
	    cfg->wav_files[cfg->wav_count++] = pj_str(pj_optarg);
	    break;
#endif
/*ycw-pjsip-delete tone*/
#if 0
	case OPT_PLAY_TONE:
	    {
		int f1, f2, on, off;
		int n;

		n = sscanf(pj_optarg, "%d,%d,%d,%d", &f1, &f2, &on, &off);
		if (n != 4) {
		    puts("Expecting f1,f2,on,off in --play-tone");
		    return -1;
		}

		cfg->tones[cfg->tone_count].freq1 = (short)f1;
		cfg->tones[cfg->tone_count].freq2 = (short)f2;
		cfg->tones[cfg->tone_count].on_msec = (short)on;
		cfg->tones[cfg->tone_count].off_msec = (short)off;
		++cfg->tone_count;
	    }
	    break;
	case OPT_REC_FILE:
	    cfg->rec_file = pj_str(pj_optarg);
	    break;
#endif
#if 0
	case OPT_USE_ICE:
	    cfg->media_cfg.enable_ice = PJ_TRUE;
	    break;

	case OPT_ICE_REGULAR:
	    cfg->media_cfg.ice_opt.aggressive = PJ_FALSE;
	    break;

	case OPT_USE_TURN:
	    cfg->media_cfg.enable_turn = PJ_TRUE;
	    break;

	case OPT_ICE_MAX_HOSTS:
	    cfg->media_cfg.ice_max_host_cands = my_atoi(pj_optarg);
	    break;

	case OPT_ICE_NO_RTCP:
	    cfg->media_cfg.ice_no_rtcp = PJ_TRUE;
	    break;

	case OPT_TURN_SRV:
	    cfg->media_cfg.turn_server = pj_str(pj_optarg);
	    break;

	case OPT_TURN_TCP:
	    cfg->media_cfg.turn_conn_type = PJ_TURN_TP_TCP;
	    break;

	case OPT_TURN_USER:
	    cfg->media_cfg.turn_auth_cred.type = PJ_STUN_AUTH_CRED_STATIC;
	    cfg->media_cfg.turn_auth_cred.data.static_cred.realm = pj_str("*");
	    cfg->media_cfg.turn_auth_cred.data.static_cred.username = pj_str(pj_optarg);
	    break;

	case OPT_TURN_PASSWD:
	    cfg->media_cfg.turn_auth_cred.data.static_cred.data_type = PJ_STUN_PASSWD_PLAIN;
	    cfg->media_cfg.turn_auth_cred.data.static_cred.data = pj_str(pj_optarg);
	    break;

#if defined(PJMEDIA_HAS_SRTP) && (PJMEDIA_HAS_SRTP != 0)
	case OPT_USE_SRTP:
	    app_config.cfg.use_srtp = my_atoi(pj_optarg);
	    if (!pj_isdigit(*pj_optarg) || app_config.cfg.use_srtp > 3)
		 {
			PJ_LOG(1,(THIS_FILE, "Invalid value for --use-srtp option"));
			return -1;
	    }
		 
	    if ((int)app_config.cfg.use_srtp == 3)
		 {
			/* SRTP optional mode with duplicated media offer */
			app_config.cfg.use_srtp = PJMEDIA_SRTP_OPTIONAL;
			app_config.cfg.srtp_optional_dup_offer = PJ_TRUE;
			cur_acc->srtp_optional_dup_offer = PJ_TRUE;
	    }
	    cur_acc->use_srtp = app_config.cfg.use_srtp;
	    break;
	case OPT_SRTP_SECURE:
	    app_config.cfg.srtp_secure_signaling = my_atoi(pj_optarg);
	    if (!pj_isdigit(*pj_optarg) || 
		app_config.cfg.srtp_secure_signaling > 2) 
	    {
		PJ_LOG(1,(THIS_FILE, "Invalid value for --srtp-secure option"));
		return -1;
	    }
	    cur_acc->srtp_secure_signaling = app_config.cfg.srtp_secure_signaling;
	    break;
#endif

	case OPT_RTP_PORT:
	    cfg->rtp_cfg.port = my_atoi(pj_optarg);
	    if (cfg->rtp_cfg.port == 0) {
		enum { START_PORT=4000 };
		unsigned range;

		range = (65535-START_PORT-PJSUA_MAX_CALLS*2);
		cfg->rtp_cfg.port = START_PORT + 
				    ((pj_rand() % range) & 0xFFFE);
	    }

	    if (cfg->rtp_cfg.port < 1 || cfg->rtp_cfg.port > 65535) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: rtp-port argument value "
			  "(expecting 1-65535"));
		return -1;
	    }
	    break;
#endif
	case OPT_DIS_CODEC:
            cfg->codec_dis[cfg->codec_dis_cnt++] = pj_str(pj_optarg);
	    break;

	case OPT_ADD_CODEC:
	    cfg->codec_arg[cfg->codec_cnt++] = pj_str(pj_optarg);
	    break;

	/* These options were no longer valid after new pjsua */
	/*
	case OPT_COMPLEXITY:
	    cfg->complexity = my_atoi(pj_optarg);
	    if (cfg->complexity < 0 || cfg->complexity > 10) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --complexity (expecting 0-10"));
		return -1;
	    }
	    break;
	*/
#if 0
	case OPT_DURATION:
	    cfg->duration = my_atoi(pj_optarg);
	    break;

	case OPT_THREAD_CNT:
	    cfg->cfg.thread_cnt = my_atoi(pj_optarg);
	    if (cfg->cfg.thread_cnt > 128) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --thread-cnt option"));
		return -1;
	    }
	    break;
#endif
	case OPT_PTIME:
		#if 0 /*ycw-pjsip. Each account has a ptime, not all share a ptime*/
	    cfg->media_cfg.ptime = my_atoi(pj_optarg);
	    if (cfg->media_cfg.ptime < 10 || cfg->media_cfg.ptime > 1000) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --ptime option"));
		return -1;
	    }
		#else
		cur_acc->ptime = my_atoi(pj_optarg);
		#endif
	    break;
#if 0
	case OPT_NO_VAD:
	    cfg->media_cfg.no_vad = PJ_TRUE;
	    break;

	case OPT_EC_TAIL:
	    cfg->media_cfg.ec_tail_len = my_atoi(pj_optarg);
	    if (cfg->media_cfg.ec_tail_len > 1000) {
		PJ_LOG(1,(THIS_FILE, "I think the ec-tail length setting "
			  "is too big"));
		return -1;
	    }
	    break;

	case OPT_EC_OPT:
	    cfg->media_cfg.ec_options = my_atoi(pj_optarg);
	    break;

	case OPT_QUALITY:
	    cfg->media_cfg.quality = my_atoi(pj_optarg);
	    if (cfg->media_cfg.quality < 0 || cfg->media_cfg.quality > 10)
		 {
			PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --quality (expecting 0-10"));
			return -1;
	    }
	    break;

	case OPT_ILBC_MODE:
	    cfg->media_cfg.ilbc_mode = my_atoi(pj_optarg);
	    if (cfg->media_cfg.ilbc_mode!=20 && cfg->media_cfg.ilbc_mode!=30) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --ilbc-mode (expecting 20 or 30"));
		return -1;
	    }
	    break;

	case OPT_RX_DROP_PCT:
	    cfg->media_cfg.rx_drop_pct = my_atoi(pj_optarg);
	    if (cfg->media_cfg.rx_drop_pct > 100) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --rx-drop-pct (expecting <= 100"));
		return -1;
	    }
	    break;
	    
	case OPT_TX_DROP_PCT:
	    cfg->media_cfg.tx_drop_pct = my_atoi(pj_optarg);
	    if (cfg->media_cfg.tx_drop_pct > 100) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid --tx-drop-pct (expecting <= 100"));
		return -1;
	    }
	    break;
#endif
#if 0 /*ycw-pjsip*/
	case OPT_AUTO_ANSWER:
	    cfg->auto_answer = my_atoi(pj_optarg);
	    if (cfg->auto_answer < 100 || cfg->auto_answer > 699) {
		PJ_LOG(1,(THIS_FILE,
			  "Error: invalid code in --auto-answer "
			  "(expecting 100-699"));
		return -1;
	    }
	    break;
#endif

	case OPT_MAX_CALLS:
	    cfg->cfg.max_calls = my_atoi(pj_optarg);
	    if (cfg->cfg.max_calls < 1 || cfg->cfg.max_calls > PJSUA_MAX_CALLS) {
		PJ_LOG(1,(THIS_FILE,"Error: maximum call setting exceeds "
				    "compile time limit (PJSUA_MAX_CALLS=%d)",
			  PJSUA_MAX_CALLS));
		return -1;
	    }
	    break;
#if 0
	case OPT_USE_TLS:
	    cfg->use_tls = PJ_TRUE;
#if !defined(PJSIP_HAS_TLS_TRANSPORT) || PJSIP_HAS_TLS_TRANSPORT==0
	    PJ_LOG(1,(THIS_FILE, "Error: TLS support is not configured"));
	    return -1;
#endif
	    break;
	    
	case OPT_TLS_CA_FILE:
	    cfg->udp_cfg.tls_setting.ca_list_file = pj_str(pj_optarg);
#if !defined(PJSIP_HAS_TLS_TRANSPORT) || PJSIP_HAS_TLS_TRANSPORT==0
	    PJ_LOG(1,(THIS_FILE, "Error: TLS support is not configured"));
	    return -1;
#endif
	    break;
	    
	case OPT_TLS_CERT_FILE:
	    cfg->udp_cfg.tls_setting.cert_file = pj_str(pj_optarg);
#if !defined(PJSIP_HAS_TLS_TRANSPORT) || PJSIP_HAS_TLS_TRANSPORT==0
	    PJ_LOG(1,(THIS_FILE, "Error: TLS support is not configured"));
	    return -1;
#endif
	    break;
	    
	case OPT_TLS_PRIV_FILE:
	    cfg->udp_cfg.tls_setting.privkey_file = pj_str(pj_optarg);
	    break;

	case OPT_TLS_PASSWORD:
	    cfg->udp_cfg.tls_setting.password = pj_str(pj_optarg);
#if !defined(PJSIP_HAS_TLS_TRANSPORT) || PJSIP_HAS_TLS_TRANSPORT==0
	    PJ_LOG(1,(THIS_FILE, "Error: TLS support is not configured"));
	    return -1;
#endif
	    break;

	case OPT_TLS_VERIFY_SERVER:
	    cfg->udp_cfg.tls_setting.verify_server = PJ_TRUE;
	    break;

	case OPT_TLS_VERIFY_CLIENT:
	    cfg->udp_cfg.tls_setting.verify_client = PJ_TRUE;
	    cfg->udp_cfg.tls_setting.require_client_cert = PJ_TRUE;
	    break;

	case OPT_TLS_NEG_TIMEOUT:
	    cfg->udp_cfg.tls_setting.timeout.sec = atoi(pj_optarg);
	    break;

	case OPT_TLS_SRV_NAME:
	    cfg->udp_cfg.tls_setting.server_name = pj_str(pj_optarg);
	    break;
#endif
/*ycw-pjsip-enableT38*/
	case OPT_ENABLE_T38:
		cfg->enableT38 = atoi(pj_optarg);
		break;

#	if defined(INCLUDE_USB_VOICEMAIL)
    case OPT_ENABLE_VM_REMOTE_ACCESS:
	/* wlm: for voice mail remote access */
	    cfg->enableVMRemoteAcc = atoi(pj_optarg);
	    break;
#   endif /* INCLUDE_USB_VOICEMAIL */

#if 0
#ifdef _IONBF
	case OPT_STDOUT_NO_BUF:
	    setvbuf(stdout, NULL, _IONBF, 0);
	    break;
#endif
#endif

/*ycw-pjsip*/
#if 0
	case OPT_CAPTURE_LAT:
	    cfg->capture_lat = atoi(pj_optarg);
	    break;

	case OPT_PLAYBACK_LAT:
	    cfg->playback_lat = atoi(pj_optarg);
	    break;
#endif

#if 0
	case OPT_SND_AUTO_CLOSE:
	    cfg->media_cfg.snd_auto_close_time = atoi(pj_optarg);
	    break;
#endif
#if 0
	case OPT_NO_TONES:
	    cfg->no_tones = PJ_TRUE;
	    break;
#endif
#if 0
	case OPT_JB_MAX_SIZE:
	    cfg->media_cfg.jb_max = atoi(pj_optarg);
	    break;
#endif

#if defined(PJ_HAS_IPV6) && PJ_HAS_IPV6
	case OPT_IPV6:
	    cfg->ipv6 = PJ_TRUE;
	    break;
#endif
	/*ycw-pjsip-qos*/
#if 0
	case OPT_QOS:
	    cfg->enable_qos = PJ_TRUE;
	    /* Set RTP traffic type to Voice */
	    cfg->rtp_cfg.qos_type = PJ_QOS_TYPE_VOICE;
	    /* Directly apply DSCP value to SIP traffic. Say lets
	     * set it to CS3 (DSCP 011000). Note that this will not 
	     * work on all platforms.
	     */
	    cfg->udp_cfg.qos_params.flags = PJ_QOS_PARAM_HAS_DSCP;
	    cfg->udp_cfg.qos_params.dscp_val = 0x18;
	    break;
#else
	case OPT_SIP_QOS:
		cfg->udp_cfg.qos_params.flags = PJ_QOS_PARAM_HAS_DSCP;
		cfg->udp_cfg.qos_params.dscp_val = (pj_uint8_t)my_atoi(pj_optarg);
		break;
	case OPT_RTP_QOS:
		cfg->rtp_cfg.qos_params.flags = PJ_QOS_PARAM_HAS_DSCP;
		cfg->rtp_cfg.qos_params.dscp_val = (pj_uint8_t)my_atoi(pj_optarg);
		break;
#endif
	/*ycw-pjsip. Add telephone-event pt to SDP or not*/
	case OPT_HAS_TELEVT:
		{
			cfg->cfg.has_telephone_event = PJ_TRUE;
		}
		break;
	/*ycw-pjsip-usbvm*/
	case OPT_CUSTOM_NOTIFY:
		{
			cfg->usbvmEndptConfig[cfg->usbvmEndpt_cnt].customNotifyLocalRecordEnable = 1;
		}
		break;
	case OPT_SEL_NOTIFY:
		{
			cfg->usbvmEndptConfig[cfg->usbvmEndpt_cnt].useCustomeNotifyForRemote = (pj_uint8_t)my_atoi(pj_optarg);
		}
			break;
	case OPT_PIN_NUMBER:
		{
			#ifdef CMSIP_DEBUG
			int min = strlen(pj_optarg);
			PJ_ASSERT_RETURN(min < 10, -1);
			#else
			int bufLen = sizeof(cfg->usbvmEndptConfig[cfg->usbvmEndpt_cnt].pin) - 1;
			int strLen = strlen(pj_optarg);
			int min = (bufLen < strLen) ? bufLen : strLen;			
			#endif
			memcpy(cfg->usbvmEndptConfig[cfg->usbvmEndpt_cnt].pin, pj_optarg, min);
			cfg->usbvmEndptConfig[cfg->usbvmEndpt_cnt].pin[min] = 0;
		}
			break;
	case OPT_NEXT_ENDPT:
		{
			if (PJSUA_MAX_CMENDPT == cfg->usbvmEndpt_cnt)
			{
				PJ_LOG(1, (THIS_FILE, "CM only has %d endpoint, we can not add %d or more endpoint!", 
					PJSUA_MAX_CMENDPT, cfg->usbvmEndpt_cnt));
				return -1;
			}
			cfg->usbvmEndpt_cnt++;
		}
		break;
	case OPT_BOUND_IFNAME:
		{
			cfg->udp_cfg.bound_ifName = pj_str(pj_optarg);
			PJ_LOG(4, (THIS_FILE, "Get pjSIP Bound Ifname(%.*s)", cfg->udp_cfg.bound_ifName.slen,
				cfg->udp_cfg.bound_ifName.ptr));
		}
		break;
	case OPT_FWTYPE:
		{
			cfg->fwType = (pj_uint8_t)my_atoi(pj_optarg);
		}
		break;

	case OPT_FWMARK:
		{
			cfg->fwmark = my_atoi(pj_optarg);
		}
		break;
		
	default:
	    PJ_LOG(1,(THIS_FILE, 
		      "Argument \"%s\" is not valid. Use --help to see help",
		      argv[pj_optind-1]));
	    return -1;
	}
    }

    if (pj_optind != argc)
	 {
		pj_str_t uri_arg;
		if (pjsua_verify_url(argv[pj_optind]) != PJ_SUCCESS)
		{
	   	 PJ_LOG(1,(THIS_FILE, "Invalid SIP URI %s", argv[pj_optind]));
	    	return -1;
		}
		
	uri_arg = pj_str(argv[pj_optind]);
	if (uri_to_call)
	    *uri_to_call = uri_arg;
	pj_optind++;

#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	/* Add URI to call to buddy list if it's not already there */
	for (i=0; i<cfg->buddy_cnt; ++i) {
	    if (pj_stricmp(&cfg->buddy_cfg[i].uri, &uri_arg)==0)
		break;
	}
	if (i == cfg->buddy_cnt && cfg->buddy_cnt < PJSUA_MAX_BUDDIES) {
	    cfg->buddy_cfg[cfg->buddy_cnt++].uri = uri_arg;
	}
#	endif
    } else {
	if (uri_to_call)
	    uri_to_call->slen = 0;
    }

    if (pj_optind != argc) {
	PJ_LOG(1,(THIS_FILE, "Error: unknown options %s", argv[pj_optind]));
	return PJ_EINVAL;
    }

	/*ycw-pjsip.  --bound-addr option must present. */
	 if (cfg->udp_cfg.bound_addr.slen <= 0)
	 {
	 	PJ_LOG(1, (THIS_FILE, "Error: You must specified the 'bound address'\n"));
		return PJ_EINVAL;
	 }

    if (cfg->acc_cfg[cfg->acc_cnt].id.slen)
	cfg->acc_cnt++;

    for (i=0; i<cfg->acc_cnt; ++i) {
	pjsua_acc_config *acfg = &cfg->acc_cfg[i];

	if (acfg->cred_info[acfg->cred_count].username.slen)
	{
	    acfg->cred_count++;
	}

	/* When IMS mode is enabled for the account, verify that settings
	 * are okay.
	 */
	/* For now we check if IMS mode is activated by looking if
	 * initial_auth is set.
	 */
	if (acfg->auth_pref.initial_auth && acfg->cred_count) {
	    /* Realm must point to the real domain */
	    if (*acfg->cred_info[0].realm.ptr=='*') {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: cannot use '*' as realm with IMS"));
		return PJ_EINVAL;
	    }

	    /* Username for authentication must be in a@b format */
	    if (strchr(acfg->cred_info[0].username.ptr, '@')==0) {
		PJ_LOG(1,(THIS_FILE, 
			  "Error: Username for authentication must "
			  "be in user@domain format with IMS"));
		return PJ_EINVAL;
	    }
	}

	/*ycw-pjsip*/
	acfg->reg_timeout = cfg->cfg.reg_timeout;
	acfg->reg_retry_interval = cfg->cfg.reg_retry_interval;
    }


    return PJ_SUCCESS;
}



/*
 * Print log of call states. Since call states may be too long for logger,
 * printing it is a bit tricky, it should be printed part by part as long 
 * as the logger can accept.
 */
static void log_call_dump(int call_id) 
{
    unsigned call_dump_len;
    unsigned part_len;
    unsigned part_idx;
    unsigned log_decor;

    pjsua_call_dump(call_id, PJ_TRUE, some_buf, 
		    sizeof(some_buf), "  ");
    call_dump_len = strlen(some_buf);

    log_decor = pj_log_get_decor();
    pj_log_set_decor(log_decor & ~(PJ_LOG_HAS_NEWLINE | PJ_LOG_HAS_CR));
    PJ_LOG(3,(THIS_FILE, "\n"));
    pj_log_set_decor(0);

    part_idx = 0;
    part_len = PJ_LOG_MAX_SIZE-80;
    while (part_idx < call_dump_len) {
	char p_orig, *p;

	p = &some_buf[part_idx];
	if (part_idx + part_len > call_dump_len)
	    part_len = call_dump_len - part_idx;
	p_orig = p[part_len];
	p[part_len] = '\0';
	PJ_LOG(3,(THIS_FILE, "%s", p));
	p[part_len] = p_orig;
	part_idx += part_len;
    }
    pj_log_set_decor(log_decor);
}

/*****************************************************************************
 * Console application
 */

#ifdef HAVE_MULTIPART_TEST
  /*
   * Enable multipart in msg_data and add a dummy body into the
   * multipart bodies.
   */
  static void add_multipart(pjsua_msg_data *msg_data)
  {
      static pjsip_multipart_part *alt_part;

      if (!alt_part) {
	  pj_str_t type, subtype, content;

	  alt_part = pjsip_multipart_create_part(app_config.pool);

	  type = pj_str("text");
	  subtype = pj_str("plain");
	  content = pj_str("Sample text body of a multipart bodies");
	  alt_part->body = pjsip_msg_body_create(app_config.pool, &type,
						 &subtype, &content);
      }

      msg_data->multipart_ctype.type = pj_str("multipart");
      msg_data->multipart_ctype.subtype = pj_str("mixed");
      pj_list_push_back(&msg_data->multipart_parts, alt_part);
  }
#  define TEST_MULTIPART(msg_data)	add_multipart(msg_data)
#else
#  define TEST_MULTIPART(msg_data)
#endif

/*
 * Find next call when current call is disconnected or when user
 * press ']'
 */
static pj_bool_t find_next_call(void)
{
    int i, max;

    max = pjsua_call_get_max_count();
    for (i=current_call+1; i<max; ++i) {
	if (pjsua_call_is_active(i)) {
	    current_call = i;
	    return PJ_TRUE;
	}
    }

    for (i=0; i<current_call; ++i) {
	if (pjsua_call_is_active(i)) {
	    current_call = i;
	    return PJ_TRUE;
	}
    }

    current_call = PJSUA_INVALID_ID;
    return PJ_FALSE;
}

#	if 0
/*
 * Find previous call when user press '['
 */
static pj_bool_t find_prev_call(void)
{
    int i, max;

    max = pjsua_call_get_max_count();
    for (i=current_call-1; i>=0; --i) {
	if (pjsua_call_is_active(i)) {
	    current_call = i;
	    return PJ_TRUE;
	}
    }

    for (i=max-1; i>current_call; --i) {
	if (pjsua_call_is_active(i)) {
	    current_call = i;
	    return PJ_TRUE;
	}
    }

    current_call = PJSUA_INVALID_ID;
    return PJ_FALSE;
}
#	endif

/* Callback from timer when the maximum call duration has been
 * exceeded.
 */
static void call_timeout_callback(pj_timer_heap_t *timer_heap,
				  struct pj_timer_entry *entry)
{
    pjsua_call_id call_id = entry->id;
    pjsua_msg_data msg_data;
    pjsip_generic_string_hdr warn;
    pj_str_t hname = pj_str("Warning");
    pj_str_t hvalue = pj_str("399 pjsua \"Call duration exceeded\"");

    PJ_UNUSED_ARG(timer_heap);

    if (call_id == PJSUA_INVALID_ID) {
	PJ_LOG(1,(THIS_FILE, "Invalid call ID in timer callback"));
	return;
    }
    
    /* Add warning header */
    pjsua_msg_data_init(&msg_data);
    pjsip_generic_string_hdr_init2(&warn, &hname, &hvalue);
    pj_list_push_back(&msg_data.hdr_list, &warn);

    /* Call duration has been exceeded; disconnect the call */
    PJ_LOG(3,(THIS_FILE, "Duration (%d seconds) has been exceeded "
			 "for call %d, disconnecting the call",
			 app_config.duration, call_id));
    entry->id = PJSUA_INVALID_ID;
    pjsua_call_hangup(call_id, 200, NULL, &msg_data);
}


/*
 * Handler when invite state has changed.
 */
static void on_call_state(pjsua_call_id call_id, pjsip_event *e)
{
	pjsua_call_info call_info;

	/*ycw-pjsip*/
#	if 0
		PJ_UNUSED_ARG(e);
#	else
		#	if 0
		pjsip_transaction* tsx = e->body.tsx_state.tsx;
		#	endif
#	endif

    pjsua_call_get_info(call_id, &call_info);

    if (call_info.state == PJSIP_INV_STATE_DISCONNECTED)
	 {

		/* Stop all ringback for this call */
		/*ycw-pjsip--delete conference*/
		/*stop ring*/
		#if 0
		ring_stop(call_id);
		#endif

		/* Cancel duration timer, if any */
		if (app_config.call_data[call_id].timer.id != PJSUA_INVALID_ID)
		{
	   	struct call_data *cd = &app_config.call_data[call_id];
	   	pjsip_endpoint *endpt = pjsua_get_pjsip_endpt();

	   	cd->timer.id = PJSUA_INVALID_ID;
	   	pjsip_endpt_cancel_timer(endpt, &cd->timer);
		}

		/* Rewind play file when hangup automatically, 
		 * since file is not looped
		 */
		 /*ycw-pjsip--delete wave file*/
		#if 0
		if (app_config.auto_play_hangup)
		    pjsua_player_set_pos(app_config.wav_id, 0);
		#endif



		PJ_LOG(3,(THIS_FILE, "Call %d is DISCONNECTED [reason=%d (%s)]", 
		  call_id,
		  call_info.last_status,
		  call_info.last_status_text.ptr));

		if (call_id == current_call)
		{
	   	find_next_call();
		}

		/* Dump media state upon disconnected */
		if (1)
		{
		    PJ_LOG(5,(THIS_FILE, 
			      "Call %d disconnected, dumping media stats..", 
			      call_id));
		    log_call_dump(call_id);
		}

    }
	 else
	 {
		if (app_config.duration!=NO_LIMIT && 
		    call_info.state == PJSIP_INV_STATE_CONFIRMED) 
		{
		    /* Schedule timer to hangup call after the specified duration */
		    struct call_data *cd = &app_config.call_data[call_id];
		    pjsip_endpoint *endpt = pjsua_get_pjsip_endpt();
		    pj_time_val delay;

		    cd->timer.id = call_id;
		    delay.sec = app_config.duration;
		    delay.msec = 0;
		    pjsip_endpt_schedule_timer(endpt, &cd->timer, &delay);
		}

		if (call_info.state == PJSIP_INV_STATE_EARLY)
		{
	    int code;
	    pj_str_t reason;
	    pjsip_msg *msg;

	    /* This can only occur because of TX or RX message */
	    pj_assert(e->type == PJSIP_EVENT_TSX_STATE);

	    if (e->body.tsx_state.type == PJSIP_EVENT_RX_MSG)
		 {
			msg = e->body.tsx_state.src.rdata->msg_info.msg;
	    }
		 else
		 {
			msg = e->body.tsx_state.src.tdata->msg;
	    }

	    code = msg->line.status.code;
	    reason = msg->line.status.reason;

	    /* Start ringback for 180 for UAC unless there's SDP in 180 */
	    if (call_info.role==PJSIP_ROLE_UAC && code==180 && 
		msg->body == NULL && 
		call_info.media_status==PJSUA_CALL_MEDIA_NONE) 
	    {
		    	/*ycw-pjsip--delete conference bridge*/
			/*begin to ring back*/
			#if 0
			ringback_start(call_id);
			#endif
	    }

	    PJ_LOG(3,(THIS_FILE, "Call %d state changed to %s (%d %.*s)", 
		      call_id, call_info.state_text.ptr,
		      code, (int)reason.slen, reason.ptr));
	} else {
	    PJ_LOG(3,(THIS_FILE, "Call %d state changed to %s", 
		      call_id,
		      call_info.state_text.ptr));
	}

	if (current_call==PJSUA_INVALID_ID)
	    current_call = call_id;

    }
}


/**
 * Handler when there is incoming call.
 */
static void on_incoming_call(pjsua_acc_id acc_id, pjsua_call_id call_id,
			     pjsip_rx_data *rdata)
{

    pjsua_call_info call_info;

    PJ_UNUSED_ARG(acc_id);
    PJ_UNUSED_ARG(rdata);

    pjsua_call_get_info(call_id, &call_info);

    if (current_call==PJSUA_INVALID_ID)
    {
		current_call = call_id;
    }

#ifdef USE_GUI
    if (!showNotification(call_id))
	return;
#endif

#if 0
    if (app_config.auto_answer > 0)
	 {	 	
		pjsua_call_answer(call_id, -1, 0, app_config.auto_answer, NULL, NULL);
    }

    if (app_config.auto_answer < 200)
	 {
		PJ_LOG(3,(THIS_FILE,
			  "Incoming call for account %d!\n"
			  "From: %s\n"
			  "To: %s\n"
			  "Press a to answer or h to reject call",
			  acc_id,
			  call_info.remote_info.ptr,
			  call_info.local_info.ptr));
    }
#endif

}


/*
 * Handler when a transaction within a call has changed state.
 */
static void on_call_tsx_state(pjsua_call_id call_id,
			      pjsip_transaction *tsx,
			      pjsip_event *e)
{
    const pjsip_method info_method = 
    {
	PJSIP_OTHER_METHOD,
	{ "INFO", 4 }
    };
	unsigned short dtmfNum = 0;

    if (pjsip_method_cmp(&tsx->method, &info_method)==0) {
	/*
	 * Handle INFO method.
	 */
	if (tsx->role == PJSIP_ROLE_UAC && 
	    (tsx->state == PJSIP_TSX_STATE_COMPLETED ||
	       (tsx->state == PJSIP_TSX_STATE_TERMINATED &&
	        e->body.tsx_state.prev_state != PJSIP_TSX_STATE_COMPLETED))) 
	{
	    /* Status of outgoing INFO request */
	    if (tsx->status_code >= 200 && tsx->status_code < 300) {
		PJ_LOG(4,(THIS_FILE, 
			  "Call %d: DTMF sent successfully with INFO",
			  call_id));
	    } else if (tsx->status_code >= 300) {
		PJ_LOG(4,(THIS_FILE, 
			  "Call %d: Failed to send DTMF with INFO: %d/%.*s",
			  call_id,
		          tsx->status_code,
			  (int)tsx->status_text.slen,
			  tsx->status_text.ptr));
	    }
	} else if (tsx->role == PJSIP_ROLE_UAS &&
		   tsx->state == PJSIP_TSX_STATE_TRYING)
	{
	    /* Answer incoming INFO with 200/OK */
	    pjsip_rx_data *rdata;
	    pjsip_tx_data *tdata;
	    pj_status_t status;

	    rdata = e->body.tsx_state.src.rdata;

	    if (rdata->msg_info.msg->body) {
		status = pjsip_endpt_create_response(tsx->endpt, rdata,
						     200, NULL, &tdata);
		if (status == PJ_SUCCESS)
		    status = pjsip_tsx_send_msg(tsx, tdata);


/*Edited by huanglei, 2011/10/30*/
		DR_parseDTMFSipInfo(call_id, (char *)rdata->msg_info.msg->body->data, &dtmfNum);
/*end huanglei*/
		PJ_LOG(3,(THIS_FILE, "Call %d: incoming INFO:\n%.*s", 
			  call_id,
			  (int)rdata->msg_info.msg->body->len,
			  rdata->msg_info.msg->body->data));
	    } else {
		status = pjsip_endpt_create_response(tsx->endpt, rdata,
						     400, NULL, &tdata);
		if (status == PJ_SUCCESS)
		    status = pjsip_tsx_send_msg(tsx, tdata);
	    }
	}
    }
}

#if 0
/*
 * Callback on media state changed event.
 * The action may connect the call to sound device, to file, or
 * to loop the call.
 */
static void on_call_media_state(pjsua_call_id call_id)
{
    pjsua_call_info call_info;

    pjsua_call_get_info(call_id, &call_info);

    /* Connect ports appropriately when media status is ACTIVE or REMOTE HOLD,
     * otherwise we should NOT connect the ports.
     */
    if (call_info.media_status == PJSUA_CALL_MEDIA_ACTIVE ||
	call_info.media_status == PJSUA_CALL_MEDIA_REMOTE_HOLD)
    {
    #if 0
	pj_bool_t connect_sound = PJ_TRUE;

	/* Loopback sound, if desired */
		if (app_config.auto_loop)
		{
	    connect_sound = PJ_FALSE;
	}

	/* Automatically record conversation, if desired */
		if (app_config.auto_rec && app_config.rec_port != PJSUA_INVALID_ID)
		{
	}

	/* Stream a file, if desired */
	if ((app_config.auto_play || app_config.auto_play_hangup) && 
	    app_config.wav_port != PJSUA_INVALID_ID)
	{
	    connect_sound = PJ_FALSE;
	}
	#endif

    }

    /* Handle media status */
    switch (call_info.media_status) {
    case PJSUA_CALL_MEDIA_ACTIVE:
	PJ_LOG(3,(THIS_FILE, "Media for call %d is active", call_id));
	break;

    case PJSUA_CALL_MEDIA_LOCAL_HOLD:
	PJ_LOG(3,(THIS_FILE, "Media for call %d is suspended (hold) by local",
		  call_id));
	break;

    case PJSUA_CALL_MEDIA_REMOTE_HOLD:
	PJ_LOG(3,(THIS_FILE, 
		  "Media for call %d is suspended (hold) by remote",
		  call_id));
	break;

    case PJSUA_CALL_MEDIA_ERROR:
	PJ_LOG(3,(THIS_FILE,
		  "Media has reported error, disconnecting call"));
	{
	    pj_str_t reason = pj_str("ICE negotiation failed");
	    pjsua_call_hangup(call_id, 500, &reason, NULL);
	}
	break;

    case PJSUA_CALL_MEDIA_NONE:
	PJ_LOG(3,(THIS_FILE, 
		  "Media for call %d is inactive",
		  call_id));
	break;

    default:
	pj_assert(!"Unhandled media status");
	break;
    }
}
#endif

/*
 * DTMF callback.
 */
static void call_on_dtmf_callback(pjsua_call_id call_id, int dtmf)
{
    PJ_LOG(3,(THIS_FILE, "Incoming DTMF on call %d: %c", call_id, dtmf));
}

/*
 * Redirection handler.
 */
static pjsip_redirect_op call_on_redirected(pjsua_call_id call_id, 
					    const pjsip_uri *target,
					    const pjsip_event *e)
{

    PJ_UNUSED_ARG(e);

    if (app_config.redir_op == PJSIP_REDIRECT_PENDING)/*default:PJSIP_REDIRECT_ACCEPT*/
	 {
		char uristr[PJSIP_MAX_URL_SIZE];
		int len;

		len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR, target, uristr, sizeof(uristr));
		if (len < 1)
		{
	   	pj_ansi_strcpy(uristr, "--URI too long--");
		}

		PJ_LOG(4, (THIS_FILE, "Call %d is being redirected to %.*s. "
		  "Press 'Ra' to accept, 'Rr' to reject, or 'Rd' to "
		  "disconnect.",
		  call_id, len, uristr));

		
    }

    return app_config.redir_op;
}

/*
 * Handler registration status has changed.
 */
static void on_reg_state(pjsua_acc_id acc_id)
{
    PJ_UNUSED_ARG(acc_id);

    // Log already written.
}

#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0

/*
 * Handler for incoming presence subscription request
 */
static void on_incoming_subscribe(pjsua_acc_id acc_id,
				  pjsua_srv_pres *srv_pres,
				  pjsua_buddy_id buddy_id,
				  const pj_str_t *from,
				  pjsip_rx_data *rdata,
				  pjsip_status_code *code,
				  pj_str_t *reason,
				  pjsua_msg_data *msg_data)
{
    /* Just accept the request (the default behavior) */
    PJ_UNUSED_ARG(acc_id);
    PJ_UNUSED_ARG(srv_pres);
    PJ_UNUSED_ARG(buddy_id);
    PJ_UNUSED_ARG(from);
    PJ_UNUSED_ARG(rdata);
    PJ_UNUSED_ARG(code);
    PJ_UNUSED_ARG(reason);
    PJ_UNUSED_ARG(msg_data);
}

/*
 * Handler on buddy state changed.
 */
static void on_buddy_state(pjsua_buddy_id buddy_id)
{
    pjsua_buddy_info info;
    pjsua_buddy_get_info(buddy_id, &info);

    PJ_LOG(3,(THIS_FILE, "%.*s status is %.*s, subscription state is %s "
			 "(last termination reason code=%d %.*s)",
	      (int)info.uri.slen,
	      info.uri.ptr,
	      (int)info.status_text.slen,
	      info.status_text.ptr,
	      info.sub_state_name,
	      info.sub_term_code,
	      (int)info.sub_term_reason.slen,
	      info.sub_term_reason.ptr));
}


/*
 * Subscription state has changed.
 */
static void on_buddy_evsub_state(pjsua_buddy_id buddy_id,
				 pjsip_evsub *sub,
				 pjsip_event *event)
{
    char event_info[80];

    PJ_UNUSED_ARG(sub);

    event_info[0] = '\0';

    if (event->type == PJSIP_EVENT_TSX_STATE &&
	    event->body.tsx_state.type == PJSIP_EVENT_RX_MSG)
    {
	pjsip_rx_data *rdata = event->body.tsx_state.src.rdata;
	snprintf(event_info, sizeof(event_info),
		 " (RX %s)",
		 pjsip_rx_data_get_info(rdata));
    }

    PJ_LOG(4,(THIS_FILE,
	      "Buddy %d: subscription state: %s (event: %s%s)",
	      buddy_id, pjsip_evsub_get_state_name(sub),
	      pjsip_event_str(event->type),
	      event_info));

}
#	endif

#	if defined(SUPPORT_IM) && SUPPORT_IM!=0
/**
 * Incoming IM message (i.e. MESSAGE request)!
 */
static void on_pager(pjsua_call_id call_id, const pj_str_t *from, 
		     const pj_str_t *to, const pj_str_t *contact,
		     const pj_str_t *mime_type, const pj_str_t *text)
{
    /* Note: call index may be -1 */
    PJ_UNUSED_ARG(call_id);
    PJ_UNUSED_ARG(to);
    PJ_UNUSED_ARG(contact);
    PJ_UNUSED_ARG(mime_type);

    PJ_LOG(3,(THIS_FILE,"MESSAGE from %.*s: %.*s (%.*s)",
	      (int)from->slen, from->ptr,
	      (int)text->slen, text->ptr,
	      (int)mime_type->slen, mime_type->ptr));
}


/**
 * Received typing indication
 */
static void on_typing(pjsua_call_id call_id, const pj_str_t *from,
		      const pj_str_t *to, const pj_str_t *contact,
		      pj_bool_t is_typing)
{
    PJ_UNUSED_ARG(call_id);
    PJ_UNUSED_ARG(to);
    PJ_UNUSED_ARG(contact);

    PJ_LOG(3,(THIS_FILE, "IM indication: %.*s %s",
	      (int)from->slen, from->ptr,
	      (is_typing?"is typing..":"has stopped typing")));
}
#	endif

/**
 * Call transfer request status.
 */ 
static void on_call_transfer_status(pjsua_call_id call_id,
				    int status_code,
				    const pj_str_t *status_text,
				    pj_bool_t final,
				    pj_bool_t *p_cont)
{
	 pjsua_call* call = &pjsua_var.calls[call_id];

    PJ_LOG(3,(THIS_FILE, "Call %d: transfer status=%d (%.*s) %s",
	      call_id, status_code,
	      (int)status_text->slen, status_text->ptr,
	      (final ? "[final]" : "")));
	 if (status_code == 100)
	 {
	 	/*ycw-pjsip: CMSIP_REQUEST_SIP_TRANSFERNOTIFY*/
	 	cmsip_send_transfernotify(call_id, CMSIP_TRANSFERED_CALL_TRYING, status_code);
	 }
	 else if (status_code/10 == 18 || status_code/100 == 2 /*ycw-pjsip*/)
	 {
		PJ_LOG(3,(THIS_FILE, "Call %d: call transfered successfully, disconnecting call", call_id));
		/*ycw-pjsip: CMSIP_REQUEST_SIP_TRANSFERNOTIFY*/
		if (pjsua_call_is_active(call_id) && PJ_FALSE == call->finish_progressing)
		{
			cmsip_send_transfernotify(call_id, CMSIP_TRANSFERED_CALL_SUCCESS, status_code);
			pjsua_call_hangup(call_id, PJSIP_SC_GONE, NULL, NULL);
			*p_cont = PJ_FALSE;			
			call->finish_progressing = PJ_TRUE;
		}
    }
	 else if(status_code >= 300)
	 {	 
		/*ycw-pjsip: CMSIP_REQUEST_SIP_TRANSFERNOTIFY*/
	 	cmsip_send_transfernotify(call_id, CMSIP_TRANSFERED_CALL_FAIL, status_code);
	 }
	 	
}


/*
 * Notification that call is being replaced.
 */
static void on_call_replaced(pjsua_call_id old_call_id,
			     pjsua_call_id new_call_id)
{
    pjsua_call_info old_ci, new_ci;

    pjsua_call_get_info(old_call_id, &old_ci);
    pjsua_call_get_info(new_call_id, &new_ci);

    PJ_LOG(3,(THIS_FILE, "Call %d with %.*s is being replaced by "
			 "call %d with %.*s",
			 old_call_id, 
			 (int)old_ci.remote_info.slen, old_ci.remote_info.ptr,
			 new_call_id,
			 (int)new_ci.remote_info.slen, new_ci.remote_info.ptr));
}


/*
 * NAT type detection callback.
 */
static void on_nat_detect(const pj_stun_nat_detect_result *res)
{
    if (res->status != PJ_SUCCESS) {
	pjsua_perror(THIS_FILE, "NAT detection failed", res->status);
    } else {
	PJ_LOG(3, (THIS_FILE, "NAT detected as %s", res->nat_type_name));
    }
}


/*
 * MWI indication
 */
static void on_mwi_info(pjsua_acc_id acc_id, pjsua_mwi_info *mwi_info)
{
    pj_str_t body;
    
    PJ_LOG(3,(THIS_FILE, "Received MWI for acc %d:", acc_id));

    if (mwi_info->rdata->msg_info.ctype)
	 {
#if 3 <= PJ_LOG_MAX_LEVEL
		const pjsip_ctype_hdr *ctype = mwi_info->rdata->msg_info.ctype;
#endif

		PJ_LOG(3,(THIS_FILE, " Content-Type: %.*s/%.*s",
	          (int)ctype->media.type.slen,
		  ctype->media.type.ptr,
		  (int)ctype->media.subtype.slen,
		  ctype->media.subtype.ptr));
    }

    if (!mwi_info->rdata->msg_info.msg->body)
	 {
		PJ_LOG(3,(THIS_FILE, "  no message body"));
		return;
    }

    body.ptr = mwi_info->rdata->msg_info.msg->body->data;
    body.slen = mwi_info->rdata->msg_info.msg->body->len;

    PJ_LOG(3,(THIS_FILE, " Body:\n%.*s", (int)body.slen, body.ptr));
	 
	 /*ycw-pjsip:CMSIP_REQUEST_SIP_MWINOTIFY*/
	 cmsip_send_mwinotify(pjsua_var.acc[acc_id].cmAcctIndex, body.ptr, body.slen);
}


/*
 * Transport status notification
 */
static void on_transport_state(pjsip_transport *tp, 
			       pjsip_transport_state state,
			       const pjsip_transport_state_info *info)
{
    char host_port[128];

    pj_ansi_snprintf(host_port, sizeof(host_port), "[%.*s:%d]",
		     (int)tp->remote_name.host.slen,
		     pj_strnull(tp->remote_name.host.ptr),
		     tp->remote_name.port);

    switch (state) {
    case PJSIP_TP_STATE_CONNECTED:
	{
	    PJ_LOG(3,(THIS_FILE, "SIP %s transport is connected to %s",
		     tp->type_name, host_port));
	}
	break;

    case PJSIP_TP_STATE_DISCONNECTED:
	{
	    char buf[100];

	    snprintf(buf, sizeof(buf), "SIP %s transport is disconnected from %s",
		     tp->type_name, host_port);
	    pjsua_perror(THIS_FILE, buf, info->status);
	}
	break;

    default:
	break;
    }

#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0

    if (!pj_ansi_stricmp(tp->type_name, "tls") && info->ext_info &&
	(state == PJSIP_TP_STATE_CONNECTED || 
	 ((pjsip_tls_state_info*)info->ext_info)->
			         ssl_sock_info->verify_status != PJ_SUCCESS))
    {
	pjsip_tls_state_info *tls_info = (pjsip_tls_state_info*)info->ext_info;
	pj_ssl_sock_info *ssl_sock_info = tls_info->ssl_sock_info;
	char buf[2048];
	const char *verif_msgs[32];
	unsigned verif_msg_cnt;

	/* Dump server TLS certificate */
	pj_ssl_cert_info_dump(ssl_sock_info->remote_cert_info, "  ",
			      buf, sizeof(buf));
	PJ_LOG(4,(THIS_FILE, "TLS cert info of %s:\n%s", host_port, buf));

	/* Dump server TLS certificate verification result */
	verif_msg_cnt = PJ_ARRAY_SIZE(verif_msgs);
	pj_ssl_cert_get_verify_status_strings(ssl_sock_info->verify_status,
					      verif_msgs, &verif_msg_cnt);
	PJ_LOG(3,(THIS_FILE, "TLS cert verification result of %s : %s",
			     host_port,
			     (verif_msg_cnt == 1? verif_msgs[0]:"")));
	if (verif_msg_cnt > 1) {
	    unsigned i;
	    for (i = 0; i < verif_msg_cnt; ++i)
		PJ_LOG(3,(THIS_FILE, "- %s", verif_msgs[i]));
	}

	if (ssl_sock_info->verify_status &&
	    !app_config.udp_cfg.tls_setting.verify_server) 
	{
	    PJ_LOG(3,(THIS_FILE, "PJSUA is configured to ignore TLS cert "
				 "verification errors"));
	}
    }

#endif

}

/*
 * Notification on ICE error.
 */
static void on_ice_transport_error(int index, pj_ice_strans_op op,
				   pj_status_t status, void *param)
{
    PJ_UNUSED_ARG(op);
    PJ_UNUSED_ARG(param);
    PJ_PERROR(1,(THIS_FILE, status,
	         "ICE keep alive failure for transport %d", index));
}

/*
*	ycw-pjsip. Process REFER request.
*/
static void on_call_transfer_request(const pj_pool_t* pool, pjsua_call_id call_id,
				     const pjsip_uri *dst,
				     pjsip_status_code *code,
				     pj_bool_t* transferToSelf,
				     pjsua_acc_id* dstAcctId)
{
	char boundIpBuf[CMSIP_STR_64];/*sip:xxx.xxx.xxx.xxx or sips:xxx.xxx.xxx.xxx*/
	pjsip_status_code resCode = PJSIP_SC_ACCEPTED;
	pjsip_uri* ipUri = NULL;
	pjsip_uri* idUri = NULL;
	pjsip_sip_uri* ipSipUri = NULL;
	pjsip_sip_uri* idSipUri = NULL;
	pjsip_sip_uri* dstSipUri = NULL;
	pjsip_sip_uri* dummyUri = NULL;
	int size;
	int i;
	pj_status_t status;
	pjsua_acc* acc = NULL;
	char ip[MAX_URI_LEN];
	char* schemes[] = {"sip:", "sips:"}; /*we don't support other sip scheme now*/
	enum SIP_URI_TYPE
	{
		SIPURI_TYPE_SIP,
		SIPURI_TYPE_SIPS
	} sipUriType;
	
	
	PJ_UNUSED_ARG(call_id);

	if (PJSIP_URI_SCHEME_IS_SIP(dst))
	{
		sipUriType = SIPURI_TYPE_SIP;
	}
	else if (PJSIP_URI_SCHEME_IS_SIPS(dst))
	{
		sipUriType = SIPURI_TYPE_SIPS;
	}
	else
	{
		goto ON_ERROR;
	}

	size = sprintf(boundIpBuf, "%s%.*s", schemes[sipUriType], (int)pjsua_var.BoundIp.slen, 
							pj_strnull(pjsua_var.BoundIp.ptr));
	if (size >= sizeof(boundIpBuf))
	{
		PJ_LOG(1, (THIS_FILE, "Bound IP error!"));
		goto ON_ERROR;
	}
	ipUri = pjsip_parse_uri(pool, boundIpBuf, strlen(boundIpBuf), 0);
	if (NULL == ipUri)
	{
		PJ_LOG(1,(THIS_FILE, "parse Uri(%s) error!", boundIpBuf));
		goto ON_ERROR;
	}
	ipSipUri = (pjsip_sip_uri*)pjsip_uri_get_uri(ipUri);

	dstSipUri = (pjsip_sip_uri*)pjsip_uri_get_uri(dst);
	dummyUri = (pjsip_sip_uri*)pjsip_uri_clone(pool, dstSipUri);
	dummyUri->ttl_param = -1;
	pj_bzero(&dummyUri->user_param, sizeof(dummyUri->user_param));
	pj_bzero(&dummyUri->method_param, sizeof(dummyUri->method_param));
	pj_bzero(&dummyUri->transport_param, sizeof(dummyUri->transport_param));
	dummyUri->lr_param = 0;
	pj_bzero(&dummyUri->maddr_param, sizeof(dummyUri->maddr_param));
	pj_list_init(&dummyUri->header_param);
	pj_list_init(&dummyUri->other_param);

	status = pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI, dummyUri, ipSipUri);
	CMSIP_PRINT("user(%.*s,%.*s) passwd(%.*s, %.*s) host(%.*s,%.*s) port(%d,%d)",
		dummyUri->user.slen, dummyUri->user.ptr, ipSipUri->user.slen, ipSipUri->user.ptr,
		dummyUri->passwd.slen, dummyUri->passwd.ptr, ipSipUri->passwd.slen, ipSipUri->passwd.ptr,
		dummyUri->host.slen, dummyUri->host.ptr, ipSipUri->host.slen, ipSipUri->host.ptr,
		dummyUri->port, ipSipUri->port
	);
	if (PJ_SUCCESS==status)
	{
		*transferToSelf = PJ_TRUE;
		*dstAcctId = CMSIP_UNKNOWN;
		goto ON_RETURN;
	}
	else if (PJSIP_ECMPPORT == status)
	{
		if ((SIPURI_TYPE_SIP==sipUriType && 5060==dummyUri->port) 
			|| (SIPURI_TYPE_SIPS==sipUriType && 5061==dummyUri->port))
		{
			*transferToSelf = PJ_TRUE;
			*dstAcctId = CMSIP_UNKNOWN;
			goto ON_RETURN;
		}
		else
			{
			*transferToSelf = PJ_FALSE;
			*dstAcctId = CMSIP_UNKNOWN;
			resCode = PJSIP_SC_DECLINE;
				goto ON_RETURN;
			}
		}
	else if (0==dummyUri->user.slen)
	{
		/*TO DO:*/
		*transferToSelf =  PJ_FALSE;
		*dstAcctId = CMSIP_UNKNOWN;
		goto ON_RETURN;
	}


			for (i = 0; i < pjsua_var.acc_cnt; ++i)
			{
				acc = &pjsua_var.acc[i];
				if (!acc->valid
#	if defined(SUPPORT_ACCOUNT_RTT) && SUPPORT_ACCOUNT_RTT!=0
					|| acc->regDuration<=0
#	else
					|| !acc->regOK
#	endif
					)
				{
					continue;
				}

		idUri = pjsip_parse_uri(pool, acc->cfg.id.ptr, acc->cfg.id.slen, 0);
		if (NULL == idUri)
				{
			PJ_LOG(1,(THIS_FILE, "parse account id error!!!"));
			goto ON_ERROR;
		}
		idSipUri = (pjsip_sip_uri*)pjsip_uri_get_uri(idUri);
			CMSIP_PRINT("user(%.*s,%.*s) passwd(%.*s, %.*s) host(%.*s,%.*s) port(%d,%d)",
		dummyUri->user.slen, dummyUri->user.ptr, idSipUri->user.slen, idSipUri->user.ptr,
		dummyUri->passwd.slen, dummyUri->passwd.ptr, idSipUri->passwd.slen, idSipUri->passwd.ptr,
		dummyUri->host.slen, dummyUri->host.ptr, idSipUri->host.slen, idSipUri->host.ptr,
		dummyUri->port, idSipUri->port);


		status = pjsip_uri_cmp(PJSIP_URI_IN_REQ_URI, dummyUri, idSipUri);
		if (PJ_SUCCESS==status)
		{
			*transferToSelf = PJ_TRUE;
			*dstAcctId = i;
					goto ON_RETURN;
				}
		else if (PJSIP_ECMPHOST==status)
		{
			CMSIP_PRINT("compare  host error!!!");
			/*dummy uri's host may be a number and dot ip, but the account uri's host is a domain name*/
			size = snprintf(ip, sizeof(ip), "%.*s", (int)dummyUri->host.slen, pj_strnull(dummyUri->host.ptr));
			if (size >= sizeof(ip))
			{
				PJ_LOG(1, (THIS_FILE, "Refer-to host too long!!!"));
				goto ON_ERROR;
			}

			if( pjsua_matchInAccHostIpList(i, ip) || 0==pj_strcmp(&dummyUri->host, &pjsua_var.BoundIp))
				{
				if ((0==idSipUri->port 
						&& (0==dummyUri->port ||(SIPURI_TYPE_SIP==sipUriType && 5060==dummyUri->port)
								|| (SIPURI_TYPE_SIPS==sipUriType && 5061==dummyUri->port)))
					||(idSipUri->port == dummyUri->port))
				{
					*transferToSelf = PJ_TRUE;
					*dstAcctId = i;
					goto ON_RETURN;
				}
				else
				{
					*transferToSelf = PJ_FALSE;
					*dstAcctId = CMSIP_UNKNOWN;
					resCode = PJSIP_SC_DECLINE;
					goto ON_RETURN;
				}
			}
		}
		else if (PJSIP_ECMPPORT==status)
		{
			CMSIP_PRINT("compare port error!!!");
			if ((0==idSipUri->port 
						&& (0==dummyUri->port ||(SIPURI_TYPE_SIP==sipUriType && 5060==dummyUri->port)
								|| (SIPURI_TYPE_SIPS==sipUriType && 5061==dummyUri->port)))
				||(idSipUri->port == dummyUri->port))
			{
				*transferToSelf = PJ_TRUE;
				*dstAcctId = i;
				goto ON_RETURN;
			}
			else
			{
				*transferToSelf = PJ_FALSE;
				*dstAcctId = CMSIP_UNKNOWN;
				resCode = PJSIP_SC_DECLINE;
					goto ON_RETURN;
				}
			}
		}

	if (i >= pjsua_var.acc_cnt)
	{
		*transferToSelf = PJ_FALSE;
		*dstAcctId = CMSIP_UNKNOWN;
		goto ON_RETURN;
	}

ON_ERROR:
		*transferToSelf = PJ_FALSE;
		*dstAcctId = CMSIP_UNKNOWN;
		resCode = PJSIP_SC_INTERNAL_SERVER_ERROR;
	ON_RETURN:
		*code = resCode;
		return;

}


/*
 * Send arbitrary request to remote host
 */
static void send_request(pjsua_acc_id accId, char *cstr_method, const pj_str_t *dst_uri)
{
    pj_str_t str_method;
    pjsip_method method;
    pjsip_tx_data *tdata;
    pjsip_endpoint *endpt;
    pj_status_t status;
	/*By yuchuwei, For Telefonica. But it can be used in all the OPTIONS request*/
	const pjsip_hdr *cap_hdr = NULL;
	const pj_str_t STR_ACCEPT = {"Accept", 6};

    endpt = pjsua_get_pjsip_endpt();

    str_method = pj_str(cstr_method);
    pjsip_method_init_np(&method, &str_method);

    status = pjsua_acc_create_request(accId, &method, dst_uri, &tdata);
	if (status != PJ_SUCCESS)
	{
		pjsua_perror(THIS_FILE, "Unable to create request", status);
		return;
	}

	/*By yuchuwei, For Telefonica. But it can be used in all the OPTIONS request*/
	/* Only want to handle OPTIONS requests */
	if (pjsip_method_cmp(&tdata->msg->line.req.method, 
				pjsip_get_options_method()) == 0)
	{
		cap_hdr = (pjsip_hdr*)pjsip_msg_find_hdr_by_name(tdata->msg, &STR_ACCEPT, NULL);
		if (NULL == cap_hdr)
		{
	   		/* Add Accept header */
    		cap_hdr = pjsip_endpt_get_capability(pjsua_var.endpt, PJSIP_H_ACCEPT, NULL);
	    	if (cap_hdr)
			{
				pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*) pjsip_hdr_clone(tdata->pool, cap_hdr));
	    	}
		}
	
		CMSIP_PRINT("process outgoing OPTIONS request successfully");
	}
	/*End Telefonica*/


    status = pjsip_endpt_send_request(endpt, tdata, -1, NULL, NULL, accId);
    if (status != PJ_SUCCESS)
	 {
		pjsua_perror(THIS_FILE, "Unable to send request", status);
		return;
    }
}


/*
 * Change extended online status.
 */
 # if 0
static void change_online_status(void)
{
    char menuin[32];
    pj_bool_t online_status;
    pjrpid_element elem;
    int i, choice;

    enum {
	AVAILABLE, BUSY, OTP, IDLE, AWAY, BRB, OFFLINE, OPT_MAX
    };

    struct opt {
	int id;
	char *name;
    } opts[] = {
	{ AVAILABLE, "Available" },
	{ BUSY, "Busy"},
	{ OTP, "On the phone"},
	{ IDLE, "Idle"},
	{ AWAY, "Away"},
	{ BRB, "Be right back"},
	{ OFFLINE, "Offline"}
    };

    printf("\n"
	   "Choices:\n");
    for (i=0; i<PJ_ARRAY_SIZE(opts); ++i) {
	printf("  %d  %s\n", opts[i].id+1, opts[i].name);
    }

    if (!simple_input("Select status", menuin, sizeof(menuin)))
	return;

    choice = atoi(menuin) - 1;
    if (choice < 0 || choice >= OPT_MAX) {
	puts("Invalid selection");
	return;
    }

    pj_bzero(&elem, sizeof(elem));
    elem.type = PJRPID_ELEMENT_TYPE_PERSON;

    online_status = PJ_TRUE;

    switch (choice) {
    case AVAILABLE:
	break;
    case BUSY:
	elem.activity = PJRPID_ACTIVITY_BUSY;
	elem.note = pj_str("Busy");
	break;
    case OTP:
	elem.activity = PJRPID_ACTIVITY_BUSY;
	elem.note = pj_str("On the phone");
	break;
    case IDLE:
	elem.activity = PJRPID_ACTIVITY_UNKNOWN;
	elem.note = pj_str("Idle");
	break;
    case AWAY:
	elem.activity = PJRPID_ACTIVITY_AWAY;
	elem.note = pj_str("Away");
	break;
    case BRB:
	elem.activity = PJRPID_ACTIVITY_UNKNOWN;
	elem.note = pj_str("Be right back");
	break;
    case OFFLINE:
	online_status = PJ_FALSE;
	break;
    }

    pjsua_acc_set_online_status2(current_acc, online_status, &elem);
}
#	endif

#	if 0
/*
 * Change codec priorities.
 */
static void manage_codec_prio(void)
{
    pjsua_codec_info c[32];
    unsigned i, count = PJ_ARRAY_SIZE(c);
    char input[32];
    char *codec, *prio;
    pj_str_t id;
    int new_prio;
    pj_status_t status;

    printf("List of codecs:\n");

    pjsua_enum_codecs(c, &count);
    for (i=0; i<count; ++i)
	 {
		printf("  %d\t%.*s\n", c[i].priority, (int)c[i].codec_id.slen,
			       c[i].codec_id.ptr);
    }

    puts("");
    puts("Enter codec id and its new priority "
	 "(e.g. \"speex/16000 200\"), empty to cancel:");

    printf("Codec name (\"*\" for all) and priority: ");
    if (fgets(input, sizeof(input), stdin) == NULL)
	return;
    if (input[0]=='\r' || input[0]=='\n') {
	puts("Done");
	return;
    }

    codec = strtok(input, " \t\r\n");
    prio = strtok(NULL, " \r\n");

    if (!codec || !prio) {
	puts("Invalid input");
	return;
    }

    new_prio = atoi(prio);
    if (new_prio < 0) 
	new_prio = 0;
    else if (new_prio > PJMEDIA_CODEC_PRIO_HIGHEST) 
	new_prio = PJMEDIA_CODEC_PRIO_HIGHEST;

    status = pjsua_codec_set_priority(pj_cstr(&id, codec), 
				      (pj_uint8_t)new_prio);
    if (status != PJ_SUCCESS)
	pjsua_perror(THIS_FILE, "Error setting codec priority", status);
}
#	endif

/*
 * Main "user interface" loop.
 */
#if 0
void console_app_main(const pj_str_t *uri_to_call)
{
    char menuin[32];
    char buf[128];
    char text[128];
    int i, count;
    char *uri;
    pj_str_t tmp;
    struct input_result result;
    pjsua_msg_data msg_data;
    pjsua_call_info call_info;
    pjsua_acc_info acc_info;


    /* If user specifies URI to call, then call the URI */
    if (uri_to_call->slen) {
	pjsua_call_make_call( current_acc, uri_to_call, -1, 0, NULL, NULL, NULL);
    }

    keystroke_help();

    for (;;) {

	printf(">>> ");
	fflush(stdout);

	if (fgets(menuin, sizeof(menuin), stdin) == NULL) {
	    /* 
	     * Be friendly to users who redirect commands into
	     * program, when file ends, resume with kbd.
	     * If exit is desired end script with q for quit
	     */
 	    /* Reopen stdin/stdout/stderr to /dev/console */
#if defined(PJ_WIN32) && PJ_WIN32!=0
	    if (freopen ("CONIN$", "r", stdin) == NULL) {
#else
	    if (1) {
#endif
		puts("Cannot switch back to console from file redirection");
		menuin[0] = 'q';
		menuin[1] = '\0';
	    } else {
		puts("Switched back to console from file redirection");
		continue;
	    }
	}

	if (cmd_echo) {
	    printf("%s", menuin);
	}

	switch (menuin[0]) {

	case 'm':
	    /* Make call! : */
	    printf("(You currently have %d calls)\n", 
		     pjsua_call_get_count());
	    
	    uri = NULL;
	    ui_input_url("Make call", buf, sizeof(buf), &result);
	    if (result.nb_result != NO_NB)
		 {

			if (result.nb_result == -1 || result.nb_result == 0)
			{
		   	puts("You can't do that with make call!");
		   	continue;
			}
			else
			{
		   	pjsua_buddy_info binfo;
		   	pjsua_buddy_get_info(result.nb_result-1, &binfo);
		   	tmp.ptr = buf;
		   	pj_strncpy(&tmp, &binfo.uri, sizeof(buf));
			}

	    }
		 else if (result.uri_result)
		 {
			tmp = pj_str(result.uri_result);
	    }
		 else
		 {
			tmp.slen = 0;
	    }
	    
	    pjsua_msg_data_init(&msg_data);
	    TEST_MULTIPART(&msg_data);
	    pjsua_call_make_call( current_acc, &tmp, -1, 0, NULL, &msg_data, NULL);
	    break;

	case 'M':
	    /* Make multiple calls! : */
	    printf("(You currently have %d calls)\n", 
		   pjsua_call_get_count());
	    
	    if (!simple_input("Number of calls", menuin, sizeof(menuin)))
		continue;

	    count = my_atoi(menuin);
	    if (count < 1)
		continue;

	    ui_input_url("Make call", buf, sizeof(buf), &result);
	    if (result.nb_result != NO_NB) {
		pjsua_buddy_info binfo;
		if (result.nb_result == -1 || result.nb_result == 0) {
		    puts("You can't do that with make call!");
		    continue;
		}
		pjsua_buddy_get_info(result.nb_result-1, &binfo);
		tmp.ptr = buf;
		pj_strncpy(&tmp, &binfo.uri, sizeof(buf));
	    } else {
		tmp = pj_str(result.uri_result);
	    }

	    for (i=0; i<my_atoi(menuin); ++i) {
		pj_status_t status;
	    
		status = pjsua_call_make_call(current_acc, &tmp, -1, 0, NULL,
					      NULL, NULL);
		if (status != PJ_SUCCESS)
		    break;
	    }
	    break;

	case 'n':
	    i = pjsua_detect_nat_type();
	    if (i != PJ_SUCCESS)
		pjsua_perror(THIS_FILE, "Error", i);
	    break;

	case 'i':
	    /* Send instant messaeg */

	    /* i is for call index to send message, if any */
	    i = -1;
    
	    /* Make compiler happy. */
	    uri = NULL;

	    /* Input destination. */
	    ui_input_url("Send IM to", buf, sizeof(buf), &result);
	    if (result.nb_result != NO_NB) {

		if (result.nb_result == -1) {
		    puts("You can't send broadcast IM like that!");
		    continue;

		} else if (result.nb_result == 0) {
    
		    i = current_call;

		} else {
		    pjsua_buddy_info binfo;
		    pjsua_buddy_get_info(result.nb_result-1, &binfo);
		    tmp.ptr = buf;
		    pj_strncpy_with_null(&tmp, &binfo.uri, sizeof(buf));
		    uri = buf;
		}

	    } else if (result.uri_result) {
		uri = result.uri_result;
	    }
	    

	    /* Send typing indication. */
	    if (i != -1)
		pjsua_call_send_typing_ind(i, PJ_TRUE, NULL);
	    else {
		pj_str_t tmp_uri = pj_str(uri);
		pjsua_im_typing(current_acc, &tmp_uri, PJ_TRUE, NULL);
	    }

	    /* Input the IM . */
	    if (!simple_input("Message", text, sizeof(text))) {
		/*
		 * Cancelled.
		 * Send typing notification too, saying we're not typing.
		 */
		if (i != -1)
		    pjsua_call_send_typing_ind(i, PJ_FALSE, NULL);
		else {
		    pj_str_t tmp_uri = pj_str(uri);
		    pjsua_im_typing(current_acc, &tmp_uri, PJ_FALSE, NULL);
		}
		continue;
	    }

	    tmp = pj_str(text);

	    /* Send the IM */
	    if (i != -1)
		pjsua_call_send_im(i, NULL, &tmp, NULL, NULL);
	    else {
		pj_str_t tmp_uri = pj_str(uri);
		pjsua_im_send(current_acc, &tmp_uri, NULL, &tmp, NULL, NULL);
	    }

	    break;

	case 'a':

	    if (current_call != -1)
		 {
			pjsua_call_get_info(current_call, &call_info);
	    }
		 else
		 {
			/* Make compiler happy */
			call_info.role = PJSIP_ROLE_UAC;
			call_info.state = PJSIP_INV_STATE_DISCONNECTED;
	    }

	    if (current_call == -1 || 
		call_info.role != PJSIP_ROLE_UAS ||
		call_info.state >= PJSIP_INV_STATE_CONNECTING)
	    {
			puts("No pending incoming call");
			fflush(stdout);
			continue;

	    }
		 else
		 {
			int st_code;
			char contact[120];
			pj_str_t hname = { "Contact", 7 };
			pj_str_t hvalue;
			pjsip_generic_string_hdr hcontact;

			if (!simple_input("Answer with code (100-699)", buf, sizeof(buf)))
			    continue;
			
			st_code = my_atoi(buf);
			if (st_code < 100)
			    continue;

			pjsua_msg_data_init(&msg_data);

			if (st_code/100 == 3)
			{
			    if (!simple_input("Enter URL to be put in Contact", 
					      contact, sizeof(contact)))
				continue;
			    hvalue = pj_str(contact);
			    pjsip_generic_string_hdr_init2(&hcontact, &hname, &hvalue);

			    pj_list_push_back(&msg_data.hdr_list, &hcontact);
			}

			/*
			 * Must check again!
			 * Call may have been disconnected while we're waiting for 
			 * keyboard input.
			 */
			if (current_call == -1) {
			    puts("Call has been disconnected");
			    fflush(stdout);
			    continue;
			}

			pjsua_call_answer(current_call, -1, 0, st_code, NULL, &msg_data);
	    }

	    break;


	case 'h':

	    if (current_call == -1) {
		puts("No current call");
		fflush(stdout);
		continue;

	    } else if (menuin[1] == 'a') {
		
		/* Hangup all calls */
		pjsua_call_hangup_all();

	    } else {

		/* Hangup current calls */
		pjsua_call_hangup(current_call, 0, NULL, NULL);
	    }
	    break;

	case ']':
	case '[':
	    /*
	     * Cycle next/prev dialog.
	     */
	    if (menuin[0] == ']') {
		find_next_call();

	    } else {
		find_prev_call();
	    }

	    if (current_call != -1) {
		
		pjsua_call_get_info(current_call, &call_info);
		PJ_LOG(3,(THIS_FILE,"Current dialog: %.*s", 
			  (int)call_info.remote_info.slen, 
			  call_info.remote_info.ptr));

	    } else {
		PJ_LOG(3,(THIS_FILE,"No current dialog"));
	    }
	    break;


	case '>':
	case '<':
	    if (!simple_input("Enter account ID to select", buf, sizeof(buf)))
		break;

	    i = my_atoi(buf);
	    if (pjsua_acc_is_valid(i)) {
		pjsua_acc_set_default(i);
		PJ_LOG(3,(THIS_FILE, "Current account changed to %d", i));
	    } else {
		PJ_LOG(3,(THIS_FILE, "Invalid account id %d", i));
	    }
	    break;


	case '+':
	    if (menuin[1] == 'b') {
	    
		pjsua_buddy_config buddy_cfg;
		pjsua_buddy_id buddy_id;
		pj_status_t status;

		if (!simple_input("Enter buddy's URI:", buf, sizeof(buf)))
		    break;

		if (pjsua_verify_url(buf) != PJ_SUCCESS) {
		    printf("Invalid URI '%s'\n", buf);
		    break;
		}

		pj_bzero(&buddy_cfg, sizeof(pjsua_buddy_config));

		buddy_cfg.uri = pj_str(buf);
		buddy_cfg.subscribe = PJ_TRUE;

		status = pjsua_buddy_add(&buddy_cfg, &buddy_id);
		if (status == PJ_SUCCESS) {
		    printf("New buddy '%s' added at index %d\n",
			   buf, buddy_id+1);
		}

	    } else if (menuin[1] == 'a') {

		char id[80], registrar[80], realm[80], uname[80], passwd[30];
		pjsua_acc_config acc_cfg;
		pj_status_t status;

		if (!simple_input("Your SIP URL:", id, sizeof(id)))
		    break;
		if (!simple_input("URL of the registrar:", registrar, sizeof(registrar)))
		    break;
		if (!simple_input("Auth Realm:", realm, sizeof(realm)))
		    break;
		if (!simple_input("Auth Username:", uname, sizeof(uname)))
		    break;
		if (!simple_input("Auth Password:", passwd, sizeof(passwd)))
		    break;

		pjsua_acc_config_default(&acc_cfg);
		acc_cfg.id = pj_str(id);
		acc_cfg.reg_uri = pj_str(registrar);
		acc_cfg.cred_count = 1;
		acc_cfg.cred_info[0].scheme = pj_str("Digest");
		acc_cfg.cred_info[0].realm = pj_str(realm);
		acc_cfg.cred_info[0].username = pj_str(uname);
		acc_cfg.cred_info[0].data_type = 0;
		acc_cfg.cred_info[0].data = pj_str(passwd);

		status = pjsua_acc_add(&acc_cfg, PJ_TRUE, NULL);
		if (status != PJ_SUCCESS) {
		    pjsua_perror(THIS_FILE, "Error adding new account", status);
		}

	    } else {
		printf("Invalid input %s\n", menuin);
	    }
	    break;

	case '-':
	    if (menuin[1] == 'b') {
		if (!simple_input("Enter buddy ID to delete",buf,sizeof(buf)))
		    break;

		i = my_atoi(buf) - 1;

		if (!pjsua_buddy_is_valid(i)) {
		    printf("Invalid buddy id %d\n", i);
		} else {
		    pjsua_buddy_del(i);
		    printf("Buddy %d deleted\n", i);
		}

	    } else if (menuin[1] == 'a') {

		if (!simple_input("Enter account ID to delete",buf,sizeof(buf)))
		    break;

		i = my_atoi(buf);

		if (!pjsua_acc_is_valid(i)) {
		    printf("Invalid account id %d\n", i);
		} else {
		    pjsua_acc_del(i);
		    printf("Account %d deleted\n", i);
		}

	    } else {
		printf("Invalid input %s\n", menuin);
	    }
	    break;

	case 'H':
	    /*
	     * Hold call.
	     */
	    if (current_call != -1)
		 {		
			pjsua_call_set_hold(current_call, NULL);
	    }
		 else
		 {
			PJ_LOG(3,(THIS_FILE, "No current call"));
	    }
	    break;

	case 'v':
	    /*
	     * Send re-INVITE (to release hold, etc).
	     */
	    if (current_call != -1) {
		
		pjsua_call_reinvite(current_call, PJ_TRUE, NULL);

	    } else {
		PJ_LOG(3,(THIS_FILE, "No current call"));
	    }
	    break;

	case 'U':
	    /*
	     * Send UPDATE
	     */
	    if (current_call != -1) {
		
		pjsua_call_update(current_call, 0, NULL);

	    } else {
		PJ_LOG(3,(THIS_FILE, "No current call"));
	    }
	    break;

	case 'C':
	    if (menuin[1] == 'p') {
		manage_codec_prio();
	    }
	    break;

	case 'x':
	    /*
	     * Transfer call.
	     */
	    if (current_call == -1)
		 {		
			PJ_LOG(3,(THIS_FILE, "No current call"));
	    }
		 else
		 {
			int call = current_call;
			pjsip_generic_string_hdr refer_sub;
			pj_str_t STR_REFER_SUB = { "Refer-Sub", 9 };
			pj_str_t STR_FALSE = { "false", 5 };
			pjsua_call_info ci;

			pjsua_call_get_info(current_call, &ci);
			printf("Transfering current call [%d] %.*s\n",
		       current_call,
		       (int)ci.remote_info.slen, ci.remote_info.ptr);

			ui_input_url("Transfer to URL", buf, sizeof(buf), &result);

			/* Check if call is still there. */

			if (call != current_call)
			{
		   	puts("Call has been disconnected");
		   	continue;
			}

			pjsua_msg_data_init(&msg_data);
			if (app_config.no_refersub)
			{
		   	/* Add Refer-Sub: false in outgoing REFER request */
		   	pjsip_generic_string_hdr_init2(&refer_sub, &STR_REFER_SUB,
						   &STR_FALSE);
		   	pj_list_push_back(&msg_data.hdr_list, &refer_sub);
			}
			
			if (result.nb_result != NO_NB)
			{
		   	if (result.nb_result == -1 || result.nb_result == 0)
		   	{
					puts("You can't do that with transfer call!");
		   	}
		    	else
				{
					pjsua_buddy_info binfo;
					pjsua_buddy_get_info(result.nb_result-1, &binfo);
					pjsua_call_xfer( current_call, &binfo.uri, &msg_data);
		    	}

			}
			else if (result.uri_result)
			{
		   	pj_str_t tmp;
		   	tmp = pj_str(result.uri_result);
		   	pjsua_call_xfer( current_call, &tmp, &msg_data);
			}
	    }
	    break;

	case 'X':
	    /*
	     * Transfer call with replaces.
	     */
	    if (current_call == -1)
		 {		
			PJ_LOG(3,(THIS_FILE, "No current call"));
	    }
		 else
		 {
			int call = current_call;
			int dst_call;
			pjsip_generic_string_hdr refer_sub;
			pj_str_t STR_REFER_SUB = { "Refer-Sub", 9 };
			pj_str_t STR_FALSE = { "false", 5 };
			pjsua_call_id ids[PJSUA_MAX_CALLS];
			pjsua_call_info ci;
			unsigned i, count;

			count = PJ_ARRAY_SIZE(ids);
			pjsua_enum_calls(ids, &count);

			if (count <= 1)
			{
		   	puts("There are no other calls");
		   	continue;
			}

			pjsua_call_get_info(current_call, &ci);
			printf("Transfer call [%d] %.*s to one of the following:\n",
		       current_call,
		       (int)ci.remote_info.slen, ci.remote_info.ptr);

			for (i=0; i<count; ++i)
			{
		   	pjsua_call_info call_info;

		   	if (ids[i] == call)
				{
					continue;
		   	}

		    	pjsua_call_get_info(ids[i], &call_info);
		    	printf("%d  %.*s [%.*s]\n",
			   ids[i],
			   (int)call_info.remote_info.slen,
			   call_info.remote_info.ptr,
			   (int)call_info.state_text.slen,
			   call_info.state_text.ptr);
			}

			if (!simple_input("Enter call number to be replaced", 
			          buf, sizeof(buf)))
		   	continue;

			dst_call = my_atoi(buf);

			/* Check if call is still there. */

			if (call != current_call)
			{
		   	puts("Call has been disconnected");
		   	continue;
			}

			/* Check that destination call is valid. */
			if (dst_call == call)
			{
		   	puts("Destination call number must not be the same "
				"as the call being transfered");
		   	continue;
			}
			
			if (dst_call >= PJSUA_MAX_CALLS)
			{
		   	puts("Invalid destination call number");
		   	continue;
			}
			
			if (!pjsua_call_is_active(dst_call))
			{
		   	puts("Invalid destination call number");
		   	continue;
			}

			pjsua_msg_data_init(&msg_data);
			if (app_config.no_refersub)
			{
		   	/* Add Refer-Sub: false in outgoing REFER request */
		   	pjsip_generic_string_hdr_init2(&refer_sub, &STR_REFER_SUB,
						   &STR_FALSE);
		   	pj_list_push_back(&msg_data.hdr_list, &refer_sub);
			}

			pjsua_call_xfer_replaces(call, dst_call, 
					 PJSUA_XFER_NO_REQUIRE_REPLACES, 
					 &msg_data);
	    }
	    break;

	case '#':
		#if 0
	    /*
	     * Send DTMF strings.
	     */
	    if (current_call == -1)
		 {		
			PJ_LOG(3,(THIS_FILE, "No current call"));
	    } else if (!pjsua_call_has_media(current_call))
	    {
			PJ_LOG(3,(THIS_FILE, "Media is not established yet!"));
	    }
		 else
		 {
			pj_str_t digits;
			int call = current_call;
			pj_status_t status;

			if (!simple_input("DTMF strings to send (0-9*#A-B)", buf, 
				  sizeof(buf)))
			{
				break;
			}

			if (call != current_call)
			{
		   	puts("Call has been disconnected");
		   	continue;
			}

			digits = pj_str(buf);
			status = pjsua_call_dial_dtmf(current_call, &digits);
			if (status != PJ_SUCCESS)
			{
		   	pjsua_perror(THIS_FILE, "Unable to send DTMF", status);
			}
			else
			{
		   	puts("DTMF digits enqueued for transmission");
			}
	    }
		 #endif
	    break;

	case '*':
	    /* Send DTMF with INFO */
	    if (current_call == -1) {
		
		PJ_LOG(3,(THIS_FILE, "No current call"));

	    } else {
		const pj_str_t SIP_INFO = pj_str("INFO");
		pj_str_t digits;
		int call = current_call;
		int i;
		pj_status_t status;

		if (!simple_input("DTMF strings to send (0-9*#A-B)", buf, 
				  sizeof(buf)))
		{
			break;
		}

		if (call != current_call) {
		    puts("Call has been disconnected");
		    continue;
		}

		digits = pj_str(buf);
		for (i=0; i<digits.slen; ++i) {
		    char body[80];

		    pjsua_msg_data_init(&msg_data);
		    msg_data.content_type = pj_str("application/dtmf-relay");
		    
		    pj_ansi_snprintf(body, sizeof(body),
				     "Signal=%c\r\n"
				     "Duration=160",
				     buf[i]);
		    msg_data.msg_body = pj_str(body);

		    status = pjsua_call_send_request(current_call, &SIP_INFO, 
						     &msg_data);
		    if (status != PJ_SUCCESS) {
			break;
		    }
		}
	    }
	    break;

	case 'S':
	    /*
	     * Send arbitrary request
	     */
	    if (pjsua_acc_get_count() == 0) {
		puts("Sorry, need at least one account configured");
		break;
	    }

	    puts("Send arbitrary request to remote host");

	    /* Input METHOD */
	    if (!simple_input("Request method:",text,sizeof(text)))
		break;

	    /* Input destination URI */
	    uri = NULL;
	    ui_input_url("Destination URI", buf, sizeof(buf), &result);
	    if (result.nb_result != NO_NB) {

		if (result.nb_result == -1) {
		    puts("Sorry you can't do that!");
		    continue;
		} else if (result.nb_result == 0) {
		    uri = NULL;
		    if (current_call == PJSUA_INVALID_ID) {
			puts("No current call");
			continue;
		    }
		} else {
		    pjsua_buddy_info binfo;
		    pjsua_buddy_get_info(result.nb_result-1, &binfo);
		    tmp.ptr = buf;
		    pj_strncpy_with_null(&tmp, &binfo.uri, sizeof(buf));
		    uri = buf;
		}

	    } else if (result.uri_result) {
		uri = result.uri_result;
	    } else {
		continue;
	    }
	    
	    if (uri) {
		tmp = pj_str(uri);
		#if 0
		send_request(text, &tmp);
		#else
		send_request(current_acc, text, &tmp);
		#endif
	    } else {
		/* If you send call control request using this method
		 * (such requests includes BYE, CANCEL, etc.), it will
		 * not go well with the call state, so don't do it
		 * unless it's for testing.
		 */
		pj_str_t method = pj_str(text);
		pjsua_call_send_request(current_call, &method, NULL);
	    }
	    break;

	case 'e':
	    if (pj_ansi_strnicmp(menuin, "echo", 4)==0) {
		pj_str_t tmp;

		tmp.ptr = menuin+5;
		tmp.slen = pj_ansi_strlen(menuin)-6;

		if (tmp.slen < 1) {
		    puts("Usage: echo [0|1]");
		    break;
		}

		cmd_echo = *tmp.ptr != '0' || tmp.slen!=1;
	    }
	    break;

	case 's':
	    if (pj_ansi_strnicmp(menuin, "sleep", 5)==0) {
		pj_str_t tmp;
		int delay;

		tmp.ptr = menuin+6;
		tmp.slen = pj_ansi_strlen(menuin)-7;

		if (tmp.slen < 1) {
		    puts("Usage: sleep MSEC");
		    break;
		}

		delay = pj_strtoul(&tmp);
		if (delay < 0) delay = 0;
		pj_thread_sleep(delay);
		break;
	    }
	    /* Continue below */

	case 'u':
	    /*
	     * Subscribe/unsubscribe presence.
	     */
	    ui_input_url("(un)Subscribe presence of", buf, sizeof(buf), &result);
	    if (result.nb_result != NO_NB) {
		if (result.nb_result == -1) {
		    int i, count;
		    count = pjsua_get_buddy_count();
		    for (i=0; i<count; ++i)
			pjsua_buddy_subscribe_pres(i, menuin[0]=='s');
		} else if (result.nb_result == 0) {
		    puts("Sorry, can only subscribe to buddy's presence, "
			 "not from existing call");
		} else {
		    pjsua_buddy_subscribe_pres(result.nb_result-1, (menuin[0]=='s'));
		}

	    } else if (result.uri_result) {
		puts("Sorry, can only subscribe to buddy's presence, "
		     "not arbitrary URL (for now)");
	    }

	    break;

	case 'r':
	    switch (menuin[1]) {
	    case 'r':
		/*
		 * Re-Register.
		 */
		pjsua_acc_set_registration(current_acc, PJ_TRUE);
		break;
	    case 'u':
		/*
		 * Unregister
		 */
		pjsua_acc_set_registration(current_acc, PJ_FALSE);
		break;
	    }
	    break;
	    
	case 't':
	    pjsua_acc_get_info(current_acc, &acc_info);
	    acc_info.online_status = !acc_info.online_status;
	    pjsua_acc_set_online_status(current_acc, acc_info.online_status);
	    printf("Setting %s online status to %s\n",
		   acc_info.acc_uri.ptr,
		   (acc_info.online_status?"online":"offline"));
	    break;

	case 'T':
	    change_online_status();
	    break;

	case 'c':
	    switch (menuin[1]) {
	    case 'l':
		/*ycw-pjsip--delete conference bridge*/
		#if 0
		conf_list();
		#endif
		break;
	    case 'c':
	    case 'd':
		{
		    char tmp[10], src_port[10], dst_port[10];
			 /*ycw-pjsip--*/
			 #if 0
			 pj_status_t status;
			 #endif
		    int cnt;
		    const char *src_title, *dst_title;

		    cnt = sscanf(menuin, "%s %s %s", tmp, src_port, dst_port);

		    if (cnt != 3) {
			/*ycw-pjsip--delete conference bridge*/
			#if 0
			conf_list();
			#endif

			src_title = (menuin[1]=='c'?
				     "Connect src port #":
				     "Disconnect src port #");
			dst_title = (menuin[1]=='c'?
				     "To dst port #":
				     "From dst port #");

			if (!simple_input(src_title, src_port, sizeof(src_port)))
			    break;

			if (!simple_input(dst_title, dst_port, sizeof(dst_port)))
			    break;
		    }

		    if (menuin[1]=='c') {
			/*ycw-pjsip--delete conference bridge*/
			#if 0
			status = pjsua_conf_connect(my_atoi(src_port), 
						    my_atoi(dst_port));
			#endif
		    } else {
			/*ycw-pjsip--delete conference bridge*/
			#if 0
			status = pjsua_conf_disconnect(my_atoi(src_port), 
						       my_atoi(dst_port));
			#endif
		    }
			/*ycw-pjsip--delete conference bridge*/
			#if 0

		    if (status == PJ_SUCCESS) {
			puts("Success");
		    } else {
			puts("ERROR!!");
		    }
			#endif
		}
		break;
	    }
	    break;

	case 'V':
	    /* Adjust audio volume */
		/*ycw-pjsip-delete sound device*/
		#if 0
	    sprintf(buf, "Adjust mic level: [%4.1fx] ", app_config.mic_level);
	    if (simple_input(buf,text,sizeof(text))) {
		char *err;
		app_config.mic_level = (float)strtod(text, &err);
		pjsua_conf_adjust_rx_level(0, app_config.mic_level);
	    }
	    sprintf(buf, "Adjust speaker level: [%4.1fx] ", 
		    app_config.speaker_level);
	    if (simple_input(buf,text,sizeof(text))) {
		char *err;
		app_config.speaker_level = (float)strtod(text, &err);
		pjsua_conf_adjust_tx_level(0, app_config.speaker_level);
	    }
	#endif
	    break;

	case 'd':
	    if (menuin[1] == 'c') {
		char settings[2000];
		int len;

		len = write_settings(&app_config, settings, sizeof(settings));
		if (len < 1)
		    PJ_LOG(1,(THIS_FILE, "Error: not enough buffer"));
		else
		    PJ_LOG(3,(THIS_FILE, 
			      "Dumping configuration (%d bytes):\n%s\n",
			      len, settings));

	    } else if (menuin[1] == 'q') {

		if (current_call != PJSUA_INVALID_ID) {
		    log_call_dump(current_call);
		} else {
		    PJ_LOG(3,(THIS_FILE, "No current call"));
		}

	    } else {
		app_dump(menuin[1]=='d');
	    }
	    break;


	case 'f':
	    if (simple_input("Enter output filename", buf, sizeof(buf))) {
		char settings[2000];
		int len;

		len = write_settings(&app_config, settings, sizeof(settings));
		if (len < 1)
		    PJ_LOG(1,(THIS_FILE, "Error: not enough buffer"));
		else {
		    pj_oshandle_t fd;
		    pj_status_t status;

		    status = pj_file_open(app_config.pool, buf, 
					  PJ_O_WRONLY, &fd);
		    if (status != PJ_SUCCESS) {
			pjsua_perror(THIS_FILE, "Unable to open file", status);
		    } else {
			pj_ssize_t size = len;
			pj_file_write(fd, settings, &size);
			pj_file_close(fd);

			printf("Settings successfully written to '%s'\n", buf);
		    }
		}
		
	    }
	    break;


	case 'L':   /* Restart */
	    app_restart = PJ_TRUE;
	    /* Continues below */

	case 'q':
	    goto on_exit;

	case 'R':
	    if (!pjsua_call_is_active(current_call))
		 {
			PJ_LOG(1,(THIS_FILE, "Call %d has gone", current_call));
	    }
		 else if (menuin[1] == 'a')
		 {
			pjsua_call_process_redirect(current_call, 
					    PJSIP_REDIRECT_ACCEPT);
	    }
		 else if (menuin[1] == 'r')
		 {
			pjsua_call_process_redirect(current_call,
					    PJSIP_REDIRECT_REJECT);
	    }
		 else
		 {
			pjsua_call_process_redirect(current_call,
					    PJSIP_REDIRECT_STOP);
	    }
	    break;

	default:
	    if (menuin[0] != '\n' && menuin[0] != '\r') {
		printf("Invalid input %s", menuin);
	    }
	    keystroke_help();
	    break;
	}
    }

on_exit:
    ;
}
}
#	endif

/* 
 * fn		void cmsip_msg_process(const pj_str_t *uri_to_call)
 * brief	Receive the Messages from CM and process
 * details	
 *
 * param[in]	uri_to_call
 * param[out]	
 *
 * return	0--ok
 * retval	-1--fail
 			PJ_EEXITNOUNREG--exit without unregister
 *
 * history: add return value PJ_EEXITNOUNREG, to indicate that cm asks pjsip to exit 
 *			without unregister
 * note	ycw-pjsip	
 */
int  cmsip_msg_process(const pj_str_t *uri_to_call)
{

#if 0
	char menuin[32];
	char buf[128];
	char text[128];
	int i, count;
	char *uri;
	pj_str_t tmp;
	struct input_result result;
	pjsua_call_info call_info;
	pjsua_acc_info acc_info;
#endif

	pjsua_msg_data msg_data;	

	int ret = 0;
	char msgBuf[MAX_MSG_LEN];
	CMSIP_MSG *pPacket = NULL;

#	if 0
	/* If user specifies URI to call, then call the URI */
	if (uri_to_call->slen)
	{
		/*current_acc?uri_to_call
		*/
		pjsua_call_make_call( current_acc, uri_to_call, -1, 0, NULL, NULL, NULL);
	}
#	endif

   for (;;)
	{
		ret = cmsip_sockRecv(g_cmsip_cliSockfd, msgBuf, MAX_MSG_LEN);
		if (ret < 0)
		{
			PJ_LOG(4, (THIS_FILE, "pjsip receives cm message error!"));
			cmsip_send_systemlog(CMSIP_SYSTEMLOG_INFO, "error(%d) when recv msg from cm", ret);
			break;
		}
		
		pPacket = (CMSIP_MSG*)msgBuf;
		if (pPacket->type & CMSIP_MESSAGE_COMPLETION)
		{
			/**/
			PJ_TODO(PROCESS_UNCOMPLETE_PACKET);
		}
		else
		{
			if (pPacket->type & CMSIP_MESSAGE_REQUEST)
			{
				/*Request*/
				switch (pPacket->type & CMSIP_MSGTYPE_MASK)
				{
				/*SIP operations*/
				case CMSIP_REQUEST_SIP_REG:
				{
					CMSIP_SIP_REG* pReg = (CMSIP_SIP_REG*)pPacket->body;
					pjsua_acc_id accId = pjsua_acctIndexMap_cmToSip(pReg->accId);
					pjsua_acc_registration_manual(accId, PJ_TRUE);
				}
				break;
				case CMSIP_REQUEST_SIP_UNREG:
				{
					CMSIP_SIP_REG* pReg = (CMSIP_SIP_REG*)pPacket->body;
					pjsua_acc_id accId = pjsua_acctIndexMap_cmToSip(pReg->accId);
					pjsua_acc_registration_manual(accId, PJ_FALSE);
				}
				break;
				case	CMSIP_REQUEST_SIP_CALL:
				{
					pjsua_call_id call_id;
					pjsua_acc_id	accId = -1;
					char contactArray[1][MAX_URI_LEN] = {{0}};
					pj_status_t status = PJ_SUCCESS;

					CMSIP_SIP_CALL* pCall = (CMSIP_SIP_CALL*)pPacket->body;

					CMSIP_PRINT("================SIP CALL================================");
					CMSIP_PRINT("type[%d] acc[%d],seq[%d],dst[%s]",pCall->type, pCall->accId, pCall->seq, pCall->destUri);
					CMSIP_PRINT("========================================================");
#	if defined(SUPPORT_IPCALL_NO_ACCOUNT) && SUPPORT_IPCALL_NO_ACCOUNT==0
					CMSIP_ASSERT(pCall->accId >= 0);				
#	endif

#	if defined(SUPPORT_IPCALL_NO_ACCOUNT) && SUPPORT_IPCALL_NO_ACCOUNT!=0
					if (pCall->accId >= 0)
#	endif
						accId = pjsua_acctIndexMap_cmToSip(pCall->accId);
					
					pjsua_msg_data_init(&msg_data);
					pj_str_t tmp;
					tmp = pj_str(pCall->destUri);
					if (CMSIP_CALL_GENERIC == pCall->type)
					{						
						status = pjsua_call_make_call(accId, &tmp, pCall->seq, 0, NULL, &msg_data, &call_id);
					}
					else if (CMSIP_CALL_ANONYMOUS == pCall->type)
					{
						status = pjsua_call_make_call(accId, &tmp, pCall->seq, pj_call_anonymous, NULL, &msg_data, &call_id);
					}
					else if (CMSIP_CALL_PSTN == pCall->type)
					{
						status = pjsua_call_make_call(accId, &tmp,  pCall->seq, pj_call_pstn, NULL, &msg_data, &call_id);
					}
					else if (CMSIP_CALL_T38 == pCall->type)
					{
						status = pjsua_call_make_call(accId, &tmp, pCall->seq, pj_call_t38, NULL, &msg_data, &call_id);
					}
					else if (CMSIP_CALL_VOICEAPP == pCall->type)
					{
						status = pjsua_call_make_call(accId, &tmp, pCall->seq, pj_call_voiceapp, NULL, &msg_data, &call_id);
					}
					else if (CMSIP_CALL_VOICEAPP_ANONYMOUS == pCall->type)
					{
						status = pjsua_call_make_call(accId, &tmp, pCall->seq, pj_call_voiceapp_anonymous, NULL, &msg_data, &call_id);
					}

					if (PJ_SUCCESS == status)
					{
	 					cmsip_send_callStatus(CMSIP_CALL_GENERIC, call_id, pCall->seq, 100, contactArray, 1);	 
					}

				}
				break;
				case CMSIP_REQUEST_SIP_REINVITE:
				{
					CMSIP_SIP_REINVITE* pInv = (CMSIP_SIP_REINVITE*)pPacket->body;
					int callIndex = pInv->callIndex;
					int type = pInv->type;

					switch (type)
					{
					case CMSIP_CALL_T38:
						pjsua_call_change_mode(callIndex, pj_channel_t38, NULL);
						break;
					case CMSIP_CALL_PSTN: /*re-invite and pstn type only for fax passthrough. ycw*/
						pjsua_call_set_passthrough_codec(callIndex);
						break;
					case CMSIP_CALL_GENERIC:
						pjsua_call_reinvite(callIndex, 0, NULL);
						break;
					default:
						printf("--%s,%d:wrong call type!\n", __FUNCTION__, __LINE__);
						break;
					}
				}				
				break;
				case	CMSIP_REQUEST_SIP_TRANSFER_UNATTENDED:
				{
					pjsip_generic_string_hdr refer_sub;
					pj_str_t STR_REFER_SUB = { "Refer-Sub", 9 };
					pj_str_t STR_FALSE = { "false", 5 };
					pjsua_call_info ci;
					CMSIP_SIP_TRANSFER* pXfer = (CMSIP_SIP_TRANSFER*)pPacket->body;
					int call = pXfer->callIndex;
			
					pjsua_call_get_info(call, &ci);
					CMSIP_PRINT("***%s,%d******Transfering current call [%d] %.*s\n",
							__FUNCTION__, __LINE__,
		       			call,
		       			(int)ci.remote_info.slen, ci.remote_info.ptr);	

					pjsua_msg_data_init(&msg_data);
					if (app_config.no_refersub)
					{
		   			/* Add Refer-Sub: false in outgoing REFER request */
		   			pjsip_generic_string_hdr_init2(&refer_sub, &STR_REFER_SUB,
						   &STR_FALSE);
		   			pj_list_push_back(&msg_data.hdr_list, &refer_sub);
					}
			
					pj_str_t tmp;
		   		tmp = pj_str(pXfer->dstUri);
		   		pjsua_call_xfer( call, &tmp, &msg_data);	    
				}
				break;
				case CMSIP_REQUEST_SIP_TRANSFER_ATTENDED:
				{
					int call;
					int dst_call;
					pjsip_generic_string_hdr refer_sub;
					pj_str_t STR_REFER_SUB = { "Refer-Sub", 9 };
					pj_str_t STR_FALSE = { "false", 5 };
					pjsua_call_info ci;

					CMSIP_SIP_TRANSFER* pXfer = (CMSIP_SIP_TRANSFER*)pPacket->body;
					call = pXfer->callIndex;
					dst_call = pXfer->dstCallIndex;
					
					pjsua_call_get_info(call, &ci);
					CMSIP_PRINT("Transfer call [%d] %.*s :\n",
		       			call,
		       			(int)ci.remote_info.slen, ci.remote_info.ptr);
					CMSIP_PRINT("to:\n");
					pjsua_call_get_info(dst_call, &ci);
		    		CMSIP_PRINT("%d  %.*s [%.*s]\n",
			   			dst_call,
			   			(int)ci.remote_info.slen,
			   			ci.remote_info.ptr,
			   			(int)ci.state_text.slen,
			   			ci.state_text.ptr);
						
			
					/* Check that destination call is valid. */
					if (dst_call == call)
					{
		   			puts("Destination call number must not be the same "
							"as the call being transfered");
		   			continue;
					}
			
					if (dst_call >= PJSUA_MAX_CALLS)
					{
		   			puts("Invalid destination call number");
		   			continue;
					}
			
					if (!pjsua_call_is_active(dst_call))
					{
				   	puts("Invalid destination call number");
				   	continue;
					}

					pjsua_msg_data_init(&msg_data);
					if (app_config.no_refersub)
					{
				   	/* Add Refer-Sub: false in outgoing REFER request */
				   	pjsip_generic_string_hdr_init2(&refer_sub, &STR_REFER_SUB,
								   &STR_FALSE);
				   	pj_list_push_back(&msg_data.hdr_list, &refer_sub);
					}

					pjsua_call_xfer_replaces(call, dst_call, 
													 PJSUA_XFER_NO_REQUIRE_REPLACES, 
					 								&msg_data);
				}
				break;
				case	CMSIP_REQUEST_SIP_HOLD:
				{
					CMSIP_SIP_HOLD* pHold = (CMSIP_SIP_HOLD*)pPacket->body;
					int callId = pHold->callIndex;
					pjsua_call_set_hold(callId, NULL);
				}
				break;
				case	CMSIP_REQUEST_SIP_UNHOLD:
				{
					CMSIP_SIP_HOLD* pHold = (CMSIP_SIP_HOLD*)pPacket->body;
					int callId = pHold->callIndex;
					pjsua_call_reinvite(callId, PJ_TRUE, NULL);
				}
				break;
				case	CMSIP_REQUEST_SIP_OUTDTMF:
				{
					CMSIP_SIP_DTMF* pDtmf = (CMSIP_SIP_DTMF*)pPacket->body;
					int call = pDtmf->callIndex;
					CMSIP_DTMF_SEND_TYPE sendType = pDtmf->type;
					char digit = pDtmf->digit;
					char buf[8]={0};
					sprintf(buf, "%c", digit);

					switch (sendType)
					{
					case CMSIP_DTMF_RFC2833:
					#if 0
					{
						/*Send DTMF strings.*/
						if (!pjsua_call_has_media(call))
		    			{
							PJ_LOG(3,(THIS_FILE, "Media is not established yet!"));
		    			}
			 			else
			 			{
							pj_str_t digits;							
							pj_status_t status;

							digits = pj_str(buf);
							status = pjsua_call_dial_dtmf(call, &digits);
							if (status != PJ_SUCCESS)
							{
			   				pjsua_perror(THIS_FILE, "Unable to send DTMF", status);
							}
							else
							{
			   				puts("DTMF digits enqueued for transmission");
							}
		    			}
					}
					#endif
					break;
					case CMSIP_DTMF_SIPINFO:
					{
						
				   	 /* Send DTMF with INFO */
						const pj_str_t SIP_INFO = pj_str("INFO");
						pj_str_t digits;		
						int i;
						pj_status_t status;

						digits = pj_str(buf);
						for (i=0; i<digits.slen; ++i)
						{
		    				char body[80];

		    				pjsua_msg_data_init(&msg_data);
		    				msg_data.content_type = pj_str("application/dtmf-relay");		    
		    				pj_ansi_snprintf(body, sizeof(body), "Signal=%c\r\n"
											     "Duration=160", buf[i]);	
							
		    				msg_data.msg_body = pj_str(body);

		    				status = pjsua_call_send_request(call, &SIP_INFO, &msg_data);
		    				if (status != PJ_SUCCESS)
							{
								break;
		    				}
						}
					}
					break;
					case CMSIP_DTMF_INBAND:
						/*INBAND*/
					break;
					default:
						printf("----%s,%d--wrong packet,can not match a type!\n", __FUNCTION__, __LINE__);
					break;
					}
				}
				break;
				case	CMSIP_REQUEST_SIP_CALLRELEASE:
				{
					CMSIP_PRINT("=======recv Call Release request=================");
					CMSIP_SIP_CALLRELEASE* pCall = (CMSIP_SIP_CALLRELEASE*)pPacket->body;

					/* Hangup current calls */
					/*CM always give the initialize channelId.*/
					pjsua_call_release(pCall->callIndex);
				}
				break;
				case CMSIP_REQUEST_SIP_MWISUB:
				{
					/*we need not this request, so, do nothing here!*/
				}
				break;
				case CMSIP_REQUEST_SIP_MWIUNSUB:
				{
					/*we need not this request, so, do nothing here!*/
				}
				break;
				case CMSIP_REQUEST_SIP_GENREQ:
				{
					/*Send arbitrary request*/
					CMSIP_SIP_GENREQ* pReq = (CMSIP_SIP_GENREQ*)pPacket->body;
					pjsua_acc_id accId = pjsua_acctIndexMap_cmToSip(pReq->accId);
					pj_str_t tmp = pj_str(pReq->destUri);
					if (tmp.slen > 0)
					{
						send_request(accId, pReq->method, &tmp);
					}
				}
				break;

				/*Stack operation*/	
				case CMSIP_REQUEST_STACK_RESTART:
				{
					CMSIP_PRINT("===Restart pjSIP Stack=================================");
					app_restart = PJ_TRUE;
				}
				/*fall through*/
				case CMSIP_REQUEST_STACK_DISABLE:
				{
					int ip;
					CMSIP_PRINT("===receive a stack disable request====,exit..........\n");
					CMSIP_STACK_DISABLESTACK* pRequest = (CMSIP_STACK_DISABLESTACK*)(pPacket->body);
					ip = *((int*)pRequest->data);
					if (0 == ip)
					{
						return PJ_EEXITNOUNREG;
					}
					goto on_exit;
				}
				break; /*only keep the switch-case-break formation*/
				
				/* Usb Voice Mail */
				/* Added by sirrain zhang */
#ifdef INCLUDE_USB_VOICEMAIL
/*ycw-usbvm @ 2012-04-04: Usbvm should be started after the ACK for the INVITE.*/
				case CMSIP_REQUEST_USBVM_START:
				{
					CMSIP_PRINT("=================usbvm===============sip received msg:CMSIP_REQUEST_USBVM_START\n\n\n");
					CMSIP_USBVM_CONNECTION *pUsbVmCon = (CMSIP_USBVM_CONNECTION *)(pPacket->body);
					g_usbvm_recordHandle[pUsbVmCon->recordId].bNoAnswer = TRUE;
					g_usbvm_recordHandle[pUsbVmCon->recordId].endpt = pUsbVmCon->endpt;
					g_usbvm_recordHandle[pUsbVmCon->recordId].cnxId = pUsbVmCon->callIndex;
					g_usbvm_recordHandle[pUsbVmCon->recordId].remoteStatus = REMOTE_IDLE;
					g_usbvm_recordHandle[pUsbVmCon->recordId].ssrc = pUsbVmCon->ssrc;
#	if defined(PJ_MEDIA_TRANSIT_BY_PJSIP) && PJ_MEDIA_TRANSIT_BY_PJSIP==0
					CMSIP_USBVM_ENTER UsbVmEnter;
					UsbVmEnter.callIndex = pUsbVmCon->callIndex;
					UsbVmEnter.endpt = pUsbVmCon->endpt;
					UsbVmEnter.recordId = pUsbVmCon->recordId;
					UsbVmEnter.duration = pUsbVmCon->duration;
					UsbVmEnter.globalWav = pUsbVmCon->globalWav;
					usbvm_enterRemoteUSBvoiceMail(&UsbVmEnter);
#	endif
				}
				break;
			/* CMSIP_REQUEST_USBVM_EXIT*/
			/*  */
				case CMSIP_REQUEST_USBVM_OFFHOOK_INRECORD:
				{
					pj_status_t status;
					CMSIP_PRINT("HL_DBG:CMSIP_REQUEST_USBVM_OFFHOOK_INRECORD received! %s:%d\n",__FUNCTION__,__LINE__);	
					CMSIP_USBVM_EXIT *pUsbVmExit = (CMSIP_USBVM_EXIT *)(pPacket->body);
					if((g_usbvm_started[pUsbVmExit->callIndex]==TRUE) && (pUsbVmExit->recordId != -1))
					{
						usbvm_exitRemoteUSBvoiceMail(pUsbVmExit->recordId);
					}
#	if defined(PJ_MEDIA_TRANSIT_BY_PJSIP) && 0==PJ_MEDIA_TRANSIT_BY_PJSIP
#	if defined(INCLUDE_USB_VOICEMAIL)
					status = pjsua_call_usbvm_offhook_inRecord(pUsbVmExit->callIndex);
					if (status != PJ_SUCCESS)
					{
						pjsua_call_release(pUsbVmExit->callIndex);
					}
#	endif
#	endif
				}
				break;

#	if defined(PJ_MEDIA_TRANSIT_BY_PJSIP) && PJ_MEDIA_TRANSIT_BY_PJSIP!=0
					
				case CMSIP_REQUEST_USBVM_ENTER:
				{					
					CMSIP_PRINT("=================usbvm===============sip received msg:CMSIP_REQUEST_USBVM_ENTER\n\n\n");
					CMSIP_USBVM_ENTER *pUsbVmEnter = (CMSIP_USBVM_ENTER*)(pPacket->body);
					usbvm_enterRemoteUSBvoiceMail(pUsbVmEnter);
				}
				break;
#	endif
				case CMSIP_REQUEST_USBVM_EXIT:
				{				
					CMSIP_PRINT("=================usbvm===============sip received msg:CMSIP_REQUEST_USBVM_EXIT\n\n\n");
					CMSIP_USBVM_EXIT *pUsbVmExit = (CMSIP_USBVM_EXIT *)(pPacket->body);
					usbvm_exitRemoteUSBvoiceMail(pUsbVmExit->recordId);
				}
				break;
					
#if 0/* removed, useless now */
				
				case CMSIP_REQUEST_USBVM_GET_REMOTE_STATE:
				{
					CMSIP_PRINT("=================usbvm===============sip received msg:CMSIP_REQUEST_USBVM_GET_REMOTE_STATE\n\n\n");

					int remoteStat;
					CMSIP_MSG cmSipMsg;
					CMSIP_USBVM_SET_REMOTE_STAT *pSetRemoteStat = NULL;
					remoteStat = usbvm_checkRemoteRecPlayIsIDLE();
					/* Response remote status to cm module */
					cmSipMsg.type = CMSIP_RESPONSE_USBVM_SET_REMOTE_STATE;
					pSetRemoteStat = (CMSIP_USBVM_SET_REMOTE_STAT*)cmSipMsg.body;
					if (remoteStat == 0)
					{
						pSetRemoteStat->state = CMSIP_USBVM_REMOTE_STATE_IDLE;
					}
					else
					{
						pSetRemoteStat->state = CMSIP_USBVM_REMOTE_STATE_BUSY;
					}
					cmsip_sockSend(g_cmsip_cliSockfd, (char *)&cmSipMsg, sizeof(cmSipMsg));
				}
				break;
#endif
				
#if 0			/* removed 2012/05/22, no need now*/
				case CMSIP_REQUEST_USBVM_GET_REMOTE_FILE_STATUS:
				{
					CMSIP_PRINT("=================usbvm===============sip received msg:CMSIP_REQUEST_USBVM_GET_REMOTE_FILE_STATUS\n\n\n");

					int fileStatus=0;
					CMSIP_MSG cmSipMsg;
					CMSIP_SEND_REMOTE_FILE_STATUS *pSendRemoteFileStatus = NULL;
					cmSipMsg.type = CMSIP_RESPONSE_USBVM_SEND_REMOTE_FILE_STATUS;
					pSendRemoteFileStatus = (CMSIP_SEND_REMOTE_FILE_STATUS*)cmSipMsg.body;
					fileStatus = usbvm_checkRemoteRecFileIsIdle();
					if (fileStatus == 0)
					{
						pSendRemoteFileStatus->status = CMSIP_USBVM_REMOTE_FILE_STATUS_IDLE;
					}
					else
					{
						pSendRemoteFileStatus->status = CMSIP_USBVM_REMOTE_FILE_STATUS_BUSY;
					}
					cmsip_sockSend(g_cmsip_cliSockfd, (char *)&cmSipMsg, sizeof(cmSipMsg));
				}
					break;
				#endif
#endif /* INCLUDE_USB_VOICEMAIL */	

				/* DTMF reciever */
				case CMSIP_REQUEST_SIP_DTMF_RECEIVER_SWITCH:
				{
					CMSIP_DTMF_RECEIVER_SWITCH *pDtmfSwitch=(CMSIP_DTMF_RECEIVER_SWITCH*)(pPacket->body);				
					int cid=pDtmfSwitch->callId;
					if(cid != -1)
					{
/* Edited by huanglei, 2012/02/15 */
						/* Reset, no matter the switch is on or off.If the switch is always on, 
						we'll never recieve a OFF msg, so we reset all global variables before using them.*/
							g_dtmf_receiver_switch[cid] = pDtmfSwitch->cmd;
						CMSIP_PRINT("HL_DBG:dtmf switch[cid(%d)] change to %d\n",cid,g_dtmf_receiver_switch[cid]);
						DR_DetectInit();
							if(g_dtmf_receiver_switch[cid]==DTMF_RECEIVER_OFF)
							{DR_resetVar(cid);}
/* end huanglei */
					}
				}
					break;
				default:
				break;
				}
			}
			else
			{
				/*Response*/
				switch (pPacket->type & CMSIP_MSGTYPE_MASK)
				{
				/*SIP operation*/
				case CMSIP_RESPONSE_SIP_CALLSTATUS:
				{
					CMSIP_SIP_CALLSTATUS* pcallStat = (CMSIP_SIP_CALLSTATUS*)pPacket->body;
					int callIdx = pcallStat->callIndex;
					int st_code = pcallStat->statusCode;
					char contact[MAX_URI_LEN];
					pj_str_t hname = { "Contact", 7 };
					pj_str_t hvalue;
					pjsip_contact_hdr* hcontact = NULL;
					pj_pool_t* tmpPool = NULL;
# if defined(INCLUDE_PSTN_GATEWAY)
					pj_bool_t isPstn = PJ_FALSE;
#	endif
#if (defined (NUM_VOICEAPP_CHANNELS) && 0!=NUM_VOICEAPP_CHANNELS)
					pj_bool_t isVoiceapp = PJ_FALSE;
#endif
					CMSIP_ASSERT(callIdx >= 0);
	

					#ifdef CMSIP_DEBUG
					CMSIP_PRINT("----------------recv callstatus\n");
					CMSIP_PRINT("type[%s] callIndex[%d], status code[%d], contact[%s]\n",
								(pcallStat->type==CMSIP_CALL_PSTN)?"pstn":
									(
#ifdef  INCLUDE_USB_VOICEMAIL
										(pcallStat->type==CMSIP_CALL_USBVM)?"usbvm":
#endif
										"voip"),
								pcallStat->callIndex, pcallStat->statusCode,
								pcallStat->contact[0]);
					#endif

					if (st_code < 100)
					{
						PJ_LOG(4, (THIS_FILE, "error:status code is smaller than 100. break"));
						break;
					}

					pjsua_msg_data_init(&msg_data);
					if (PJSIP_IS_STATUS_IN_CLASS(st_code, 300))
					{
						strcpy(contact, pcallStat->contact[0]);
						hvalue = pj_str(contact);

						tmpPool = pjsua_pool_create("tmp", MAX_URI_LEN, MAX_URI_LEN);
						if (NULL == tmpPool)
						{
							break;
						}

						hcontact = (pjsip_contact_hdr*)
							pjsip_parse_hdr(tmpPool, &hname, hvalue.ptr, 
								hvalue.slen, NULL);
						
						pj_list_push_back(&msg_data.hdr_list, hcontact);
					}

					if (
#	if defined(INCLUDE_PSTN_GATEWAY)
					CMSIP_CALL_PSTN == pcallStat->type
#	else
					0
#	endif
					)
					{
#	if defined(INCLUDE_PSTN_GATEWAY)
						isPstn = PJ_TRUE;
#	endif
					}
#if (defined (NUM_VOICEAPP_CHANNELS) && 0!=NUM_VOICEAPP_CHANNELS)
					if(CMSIP_CALL_VOICEAPP == pcallStat->type)
					{
						isVoiceapp = PJ_TRUE;
					}
#endif
					pjsua_call_answer(callIdx, 
#	if defined(INCLUDE_PSTN_GATEWAY)
											isPstn,
#	endif
#if (defined (NUM_VOICEAPP_CHANNELS) && 0!=NUM_VOICEAPP_CHANNELS)
											isVoiceapp,
#endif
#	if defined(PJ_MEDIA_TRANSIT_BY_PJSIP) && PJ_MEDIA_TRANSIT_BY_PJSIP==0
#	if defined(INCLUDE_USB_VOICEMAIL)
											(CMSIP_CALL_USBVM == pcallStat->type),
#	endif
#	endif
											st_code, NULL, &msg_data
											);
					if (tmpPool != NULL)
					{
						pj_pool_release(tmpPool);
					}

				}
				break;
				case CMSIP_RESPONSE_SIP_GENRES:
				break;
				case CMSIP_RESPONSE_SIP_CALLRELEASE_ACK:
				{
					CMSIP_PRINT("----recv callRelease Ack-----------------------------");
					CMSIP_SIP_CALLRELEASE* pCallRelease = (CMSIP_SIP_CALLRELEASE*)pPacket->body;
					pjsua_call_process_callReleaseAck(pCallRelease->callIndex);
				}
				break;
				default:
				break;
				}
			}
		}	

    }

on_exit:
    PJ_TODO(NOTHING);

return ret;
}



/*****************************************************************************
 * A simple module to handle otherwise unhandled request. We will register
 * this with the lowest priority.
 */

/* Notification on incoming request */
static pj_bool_t default_mod_on_rx_request(pjsip_rx_data *rdata)
{
    pjsip_tx_data *tdata;
    pjsip_status_code status_code;
    pj_status_t status;

    /* Don't respond to ACK! */
    if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, 
			 &pjsip_ack_method) == 0)
	return PJ_TRUE;

    /* Create basic response. */
    if (pjsip_method_cmp(&rdata->msg_info.msg->line.req.method, 
			 &pjsip_notify_method) == 0)
    {
	/* Unsolicited NOTIFY's, send with Bad Request */
	status_code = PJSIP_SC_BAD_REQUEST;
    } else {
	/* Probably unknown method */
	status_code = PJSIP_SC_METHOD_NOT_ALLOWED;
    }
    status = pjsip_endpt_create_response(pjsua_get_pjsip_endpt(), 
					 rdata, status_code, 
					 NULL, &tdata);
    if (status != PJ_SUCCESS) {
	pjsua_perror(THIS_FILE, "Unable to create response", status);
	return PJ_TRUE;
    }

    /* Add Allow if we're responding with 405 */
    if (status_code == PJSIP_SC_METHOD_NOT_ALLOWED) {
	const pjsip_hdr *cap_hdr;
	cap_hdr = pjsip_endpt_get_capability(pjsua_get_pjsip_endpt(), 
					     PJSIP_H_ALLOW, NULL);
	if (cap_hdr) {
	    pjsip_msg_add_hdr(tdata->msg, pjsip_hdr_clone(tdata->pool, 
							   cap_hdr));
	}
    }

    /* Add User-Agent header */
    {
	pj_str_t user_agent;
	char tmp[80];
	const pj_str_t USER_AGENT = { "User-Agent", 10};
	pjsip_hdr *h;

#	if 0
	pj_ansi_snprintf(tmp, sizeof(tmp), "PJSUA v%s/%s", 
			 pj_get_version(), PJ_OS_NAME);
#	else
	pj_ansi_snprintf(tmp, sizeof(tmp), "TP-Link SIP Stack V1.0.0");
#	endif
	pj_strdup2_with_null(tdata->pool, &user_agent, tmp);

	h = (pjsip_hdr*) pjsip_generic_string_hdr_create(tdata->pool,
							 &USER_AGENT,
							 &user_agent);
	pjsip_msg_add_hdr(tdata->msg, h);
    }

    pjsip_endpt_send_response2(pjsua_get_pjsip_endpt(), rdata, tdata, 
			       NULL, NULL);

    return PJ_TRUE;
}


/* The module instance. */
static pjsip_module mod_default_handler = 
{
    NULL, NULL,				/* prev, next.		*/
    { "mod-default-handler", 19 },	/* Name.		*/
    -1,					/* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION+99,	/* Priority	        */
    NULL,				/* load()		*/
    NULL,				/* start()		*/
    NULL,				/* stop()		*/
    NULL,				/* unload()		*/
    &default_mod_on_rx_request,		/* on_rx_request()	*/
    NULL,				/* on_rx_response()	*/
    NULL,				/* on_tx_request.	*/
    NULL,				/* on_tx_response()	*/
    NULL,				/* on_tsx_state()	*/

};




/*****************************************************************************
 * Public API
 */

pj_status_t app_init(int argc, char *argv[])
{
	pjsua_transport_id transport_id = -1;
	pjsua_transport_config tcp_cfg;
	unsigned i;
	pj_status_t status;

	app_restart = PJ_FALSE;

	/* Create pjsua */
	status = pjsua_create();
	if (status != PJ_SUCCESS)
		return status;

	/* Create pool for application */
	app_config.pool = pjsua_pool_create("pjsua-app", 1000, 1000);

	/* Initialize default config */
	default_config(&app_config);

	/* Parse the arguments */
	status = parse_args(argc, argv, &app_config, &uri_arg);
	if (status != PJ_SUCCESS)
		return status;

/*yuchuwei@2012-04-05*/
#	if 0
	 if (app_config.cfg.nameserver_count <= 0)
	 {
	 	char buf[40];
		pj_str_t defaultIp;
		defaultIp.ptr = buf;
		memcpy(defaultIp.ptr, pjsua_var.BoundIp.ptr, pjsua_var.BoundIp.slen);
		defaultIp.slen = pjsua_var.BoundIp.slen;
		defaultIp.ptr[defaultIp.slen] = 0;
	 	pjsua_init_random_seed(&defaultIp);
	 }
	 else
	 {
	 	pjsua_init_random_seed(NULL);
	 }
#	else
	{
		char buf[40];
		pj_str_t defaultIp;
		defaultIp.ptr = buf;
		memcpy(defaultIp.ptr, pjsua_var.BoundIp.ptr, pjsua_var.BoundIp.slen);
		defaultIp.slen = pjsua_var.BoundIp.slen;
		defaultIp.ptr[defaultIp.slen] = 0;
	 	pjsua_init_random_seed(&defaultIp);
	}
#	endif

#if INCLUDE_FWMARK
	pjsua_var.fwmark = app_config.fwmark;
	if (pjsua_var.fwmark != 0)
	{
		printf("now fwmark is enabled, value is %d\n", pjsua_var.fwmark);
		pj_setSockFwmark(pjsua_var.fwmark);
	}
#endif

	/*ycw-pjsip-enableT38*/
	pjsua_var.enableT38 = app_config.enableT38;

#	if defined(INCLUDE_USB_VOICEMAIL)
    /* wlm: for voice mail remote access */
	pjsua_var.enableVMRemoteAcc = app_config.enableVMRemoteAcc;
#   endif /* INCLUDE_USB_VOICEMAIL */

	pjsua_var.fwType = app_config.fwType;

	pjsua_var.bindDev.ptr = (char*)pj_pool_zalloc(pjsua_var.pool, 1+app_config.udp_cfg.bound_ifName.slen);
	if (NULL == pjsua_var.bindDev.ptr)
	{
		cmsip_send_systemlog(CMSIP_SYSTEMLOG_INFO, "can not alloc mem for ua var pool");
		return PJ_ENOMEM; /*will exit pjsua*/
	}
	memcpy(pjsua_var.bindDev.ptr, app_config.udp_cfg.bound_ifName.ptr, app_config.udp_cfg.bound_ifName.slen);
	pjsua_var.bindDev.ptr[app_config.udp_cfg.bound_ifName.slen] = 0;
	pjsua_var.bindDev.slen = app_config.udp_cfg.bound_ifName.slen;

	/* Initialize application callbacks */
	app_config.cfg.cb.on_call_state = &on_call_state;
#if 0
	app_config.cfg.cb.on_call_media_state = &on_call_media_state;
#endif
	app_config.cfg.cb.on_incoming_call = &on_incoming_call;
	app_config.cfg.cb.on_call_tsx_state = &on_call_tsx_state;
	app_config.cfg.cb.on_dtmf_digit = &call_on_dtmf_callback;
	app_config.cfg.cb.on_call_redirected = &call_on_redirected;
	app_config.cfg.cb.on_reg_state = &on_reg_state;
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	app_config.cfg.cb.on_incoming_subscribe = &on_incoming_subscribe;
	app_config.cfg.cb.on_buddy_state = &on_buddy_state;
	app_config.cfg.cb.on_buddy_evsub_state = &on_buddy_evsub_state;
#	endif

#	if defined(SUPPORT_IM) && SUPPORT_IM!=0
	app_config.cfg.cb.on_pager = &on_pager;
	app_config.cfg.cb.on_typing = &on_typing;
#	endif
	app_config.cfg.cb.on_call_transfer_status = &on_call_transfer_status;
	app_config.cfg.cb.on_call_replaced = &on_call_replaced;
	app_config.cfg.cb.on_nat_detect = &on_nat_detect;
	app_config.cfg.cb.on_mwi_info = &on_mwi_info;
	app_config.cfg.cb.on_transport_state = &on_transport_state;
	app_config.cfg.cb.on_ice_transport_error = &on_ice_transport_error;
	 /*ycw-pjsip*/
	app_config.cfg.cb.on_call_transfer_request = &on_call_transfer_request;
#if (1 <= PJ_LOG_MAX_LEVEL)
	app_config.log_cfg.cb = log_cb;
#endif /* (1 <= PJ_LOG_MAX_LEVEL) */

#if 0
	/* Set sound device latency */
	if (app_config.capture_lat > 0)
		app_config.media_cfg.snd_rec_latency = app_config.capture_lat;
	if (app_config.playback_lat)
		app_config.media_cfg.snd_play_latency = app_config.playback_lat;
#endif

	/* Initialize pjsua */
	status = pjsua_init(&app_config.cfg, 
#if (1 <= PJ_LOG_MAX_LEVEL)
			&app_config.log_cfg,
#endif /* (1 <= PJ_LOG_MAX_LEVEL) */
			&app_config.media_cfg);
	if (status != PJ_SUCCESS)
		return status;
	/*ycw-pjsip-usbvm*/
	for (i = 0; i < app_config.usbvmEndpt_cnt; ++i)
	{
		pjsua_init_usbvmConfig(&app_config.usbvmEndptConfig[i], i);
	}

	/* Initialize our module to handle otherwise unhandled request */
	status = pjsip_endpt_register_module(pjsua_get_pjsip_endpt(),
					 &mod_default_handler);
	if (status != PJ_SUCCESS)
		return status;

	/* Initialize calls data */
	for (i=0; i<PJ_ARRAY_SIZE(app_config.call_data); ++i)
	{
		app_config.call_data[i].timer.id = PJSUA_INVALID_ID;
		app_config.call_data[i].timer.cb = &call_timeout_callback;
	}

	pj_memcpy(&tcp_cfg, &app_config.udp_cfg, sizeof(tcp_cfg));


	/* Add UDP transport unless it's disabled. */
	if (!app_config.no_udp)
	{
		pjsip_transport_type_e type = PJSIP_TRANSPORT_UDP;

		status = pjsua_transport_create(type, &app_config.udp_cfg, &transport_id);
		if (status != PJ_SUCCESS)
			goto on_error;

		if (app_config.udp_cfg.port == 0)
		{
			pjsua_transport_info ti;
			pj_sockaddr_in *a;

			pjsua_transport_get_info(transport_id, &ti);
			a = (pj_sockaddr_in*)&ti.local_addr;

			tcp_cfg.port = pj_ntohs(a->sin_port);
		}

		/* Add UDP IPv6 transport unless it's disabled. */
		if (app_config.ipv6)
		{
			pjsip_transport_type_e type = PJSIP_TRANSPORT_UDP6;
			pjsua_transport_config udp_cfg;

			udp_cfg = app_config.udp_cfg;
			if (udp_cfg.port == 0)
			{
				udp_cfg.port = 5060;
			}
			else
			{
				udp_cfg.port += 10;
			}
			status = pjsua_transport_create(type, &udp_cfg, &transport_id);
			if (status != PJ_SUCCESS)
			{
				goto on_error;
			}

			if (app_config.udp_cfg.port == 0)
			{
				pjsua_transport_info ti;
				pj_sockaddr_in *a;

				pjsua_transport_get_info(transport_id, &ti);
				a = (pj_sockaddr_in*)&ti.local_addr;

				tcp_cfg.port = pj_ntohs(a->sin_port);
			}
		}
	}
	else if (!app_config.no_tcp)     /* Add TCP transport unless it's disabled */
	{
		status = pjsua_transport_create(PJSIP_TRANSPORT_TCP, &tcp_cfg,  &transport_id);
		if (status != PJ_SUCCESS)
		{
			goto on_error;
		}
	}
#if defined(PJSIP_HAS_TLS_TRANSPORT) && PJSIP_HAS_TLS_TRANSPORT!=0
	else if (app_config.use_tls) /* Add TLS transport when application wants one */
	{
		pjsua_acc_id acc_id;

		/* Copy the QoS settings */
		tcp_cfg.tls_setting.qos_type = tcp_cfg.qos_type;
		pj_memcpy(&tcp_cfg.tls_setting.qos_params, &tcp_cfg.qos_params, sizeof(tcp_cfg.qos_params));

		/* Set TLS port as TCP port+1 */
		tcp_cfg.port++;
		status = pjsua_transport_create(PJSIP_TRANSPORT_TLS, &tcp_cfg, &transport_id);
		tcp_cfg.port--;
		if (status != PJ_SUCCESS)
		{
			goto on_error;
		}
	
		/* Add local account */
		pjsua_acc_add_local(transport_id, PJ_FALSE, &acc_id);
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
		pjsua_acc_set_online_status(acc_id, PJ_TRUE);
#	endif
	}
#endif

	if (transport_id == -1)
	{
		PJ_LOG(1,(THIS_FILE, "Error: no transport is configured"));
		status = -1;
		goto on_error;
	}

	/* Add accounts */
	for (i=0; i<app_config.acc_cnt; ++i)
	{
		/*ycw-20120611*/
		/*Because we have only one transport for sending SIP Signal, so I bind all accounts to 
		this transport.*/
		app_config.acc_cfg[i].transport_id = transport_id;
		
		status = pjsua_acc_add(&app_config.acc_cfg[i], PJ_TRUE, NULL);
#	if	0
		if (status != PJ_SUCCESS)
		{
			goto on_error;
		}
#	endif
#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
		/**:PRESENCE,pjsua_acc_add
		*REGISTER
		*
		*default_acc-1
		*current_acc-1ASSERT
		*PRESENCE,pjsua_acc_set_onlinestatus
		*pjsua_acc_add
		*
		*/
		PJ_TODO(PJSUA_SET_ACCOUNT_ONLINE);
		pjsua_acc_set_online_status(current_acc, PJ_TRUE);
#	endif
	}

#	if defined(SUPPORT_PRESENCE) && SUPPORT_PRESENCE!=0
	/* Add buddies */
	for (i=0; i<app_config.buddy_cnt; ++i)
	{
		status = pjsua_buddy_add(&app_config.buddy_cfg[i], NULL);
		if (status != PJ_SUCCESS)
		{
			goto on_error;
		}
	}
#	endif

	/* Optionally disable some codec */
	for (i=0; i<app_config.codec_dis_cnt; ++i)
	{
		pjsua_codec_set_priority(&app_config.codec_dis[i],PJMEDIA_CODEC_PRIO_DISABLED);
	}

	/* Optionally set codec orders */
	for (i=0; i<app_config.codec_cnt; ++i)
	{
		pjsua_codec_set_priority(&app_config.codec_arg[i],
				 (pj_uint8_t)(PJMEDIA_CODEC_PRIO_NORMAL+i+9));
	}

	/* Add RTP transports */
#ifdef TRANSPORT_ADAPTER_SAMPLE
	status = transport_adapter_sample();
#else
	if (app_config.ipv6)
		status = create_ipv6_media_transports();
	else
		status = pjsua_media_transports_create(&app_config.rtp_cfg);
#endif
	if (status != PJ_SUCCESS)
		goto on_error;

	/*ycw-pjsip. t38*/
	if (pjsua_var.enableT38)
	{
		pjsua_media_set_capability(pjsua_faxr_t38);
	}
	/* Initialize remote USB voicemail module */
	/* Added by sirrain zhang */
#ifdef INCLUDE_USB_VOICEMAIL
	usbvm_remoteRecPlayInit();
#endif /* INCLUDE_USB_VOICEMAIL */
	DR_receiverInit();

	return PJ_SUCCESS;

on_error:
	app_destroy();
	return status;
}

pj_status_t app_main(void)
{
    pj_status_t status = PJ_SUCCESS;

    /* Start pjsua */
    status = pjsua_start();
    if (status != PJ_SUCCESS)
	{
		#if 0
		app_destroy();
		#endif
		return status;
    }

	status = cmsip_msg_process(&uri_arg);

	
    return status;
}

pj_status_t app_destroy(void)
{
    pj_status_t status;	 

    if (app_config.pool)
	 {
		pj_pool_release(app_config.pool);
		app_config.pool = NULL;
    }

    status = pjsua_destroy();
    pj_bzero(&app_config, sizeof(app_config));

   return status;
}


#ifdef STEREO_DEMO
/*
 * In this stereo demo, we open the sound device in stereo mode and
 * arrange the attachment to the PJSUA-LIB conference bridge as such
 * so that channel0/left channel of the sound device corresponds to
 * slot 0 in the bridge, and channel1/right channel of the sound
 * device corresponds to slot 1 in the bridge. Then user can independently
 * feed different media to/from the speakers/microphones channels, by
 * connecting them to slot 0 or 1 respectively.
 *
 * Here's how the connection looks like:
 *
   +-----------+ stereo +-----------------+ 2x mono +-----------+
   | AUDIO DEV |<------>| SPLITCOMB   left|<------->|#0  BRIDGE |
   +-----------+        |            right|<------->|#1         |
                        +-----------------+         +-----------+
 */
static void stereo_demo()
{
    pjmedia_port *conf;
    pj_status_t status;

    /* Disable existing sound device */
    conf = pjsua_set_no_snd_dev();

    /* Create stereo-mono splitter/combiner */
    status = pjmedia_splitcomb_create(app_config.pool, 
				      conf->info.clock_rate /* clock rate */,
				      2	    /* stereo */,
				      2 * conf->info.samples_per_frame,
				      conf->info.bits_per_sample,
				      0	    /* options */,
				      &app_config.sc);
    pj_assert(status == PJ_SUCCESS);

    /* Connect channel0 (left channel?) to conference port slot0 */
    status = pjmedia_splitcomb_set_channel(app_config.sc, 0 /* ch0 */, 
					   0 /*options*/,
					   conf);
    pj_assert(status == PJ_SUCCESS);

    /* Create reverse channel for channel1 (right channel?)... */
    status = pjmedia_splitcomb_create_rev_channel(app_config.pool,
						  app_config.sc,
						  1  /* ch1 */,
						  0  /* options */,
						  &app_config.sc_ch1);
    pj_assert(status == PJ_SUCCESS);

    /* .. and register it to conference bridge (it would be slot1
     * if there's no other devices connected to the bridge)
     */
    status = pjsua_conf_add_port(app_config.pool, app_config.sc_ch1, 
				 &app_config.sc_ch1_slot);
    pj_assert(status == PJ_SUCCESS);
    
    /* Create sound device */
    status = pjmedia_snd_port_create(app_config.pool, -1, -1, 
				     conf->info.clock_rate,
				     2	    /* stereo */,
				     2 * conf->info.samples_per_frame,
				     conf->info.bits_per_sample,
				     0, &app_config.snd);
    pj_assert(status == PJ_SUCCESS);


    /* Connect the splitter to the sound device */
    status = pjmedia_snd_port_connect(app_config.snd, app_config.sc);
    pj_assert(status == PJ_SUCCESS);

}
#endif

#ifdef TRANSPORT_ADAPTER_SAMPLE
static pj_status_t create_transport_adapter(pjmedia_endpt *med_endpt, int port,
					    pjmedia_transport **p_tp)
{
    pjmedia_transport *udp;
    pj_status_t status;

    /* Create the UDP media transport */
    status = pjmedia_transport_udp_create(med_endpt, NULL, port, 0, &udp);
    if (status != PJ_SUCCESS)
	return status;

    /* Create the adapter */
    status = pjmedia_tp_adapter_create(med_endpt, NULL, udp, p_tp);
    if (status != PJ_SUCCESS) {
	pjmedia_transport_close(udp);
	return status;
    }

    return PJ_SUCCESS;
}

static pj_status_t transport_adapter_sample(void)
{
    pjsua_media_transport tp[PJSUA_MAX_CALLS];
    pj_status_t status;
    int port = 7000;
    unsigned i;

    for (i=0; i<app_config.cfg.max_calls; ++i) {
	status = create_transport_adapter(pjsua_get_pjmedia_endpt(), 
					  port + i*10,
					  &tp[i].transport);
	if (status != PJ_SUCCESS)
	    return status;
    }

    return pjsua_media_transports_attach(tp, i, PJ_TRUE);
}
#endif

static pj_status_t create_ipv6_media_transports(void)
{
    pjsua_media_transport tp[PJSUA_MAX_CALLS];
    pj_status_t status;
    int port = app_config.rtp_cfg.port;
    unsigned i;

    for (i=0; i<app_config.cfg.max_calls; ++i) {
	enum { MAX_RETRY = 10 };
	pj_sock_t sock[2];
	pjmedia_sock_info si;
	unsigned j;

	/* Get rid of uninitialized var compiler warning with MSVC */
	status = PJ_SUCCESS;

	for (j=0; j<MAX_RETRY; ++j) {
	    unsigned k;

	    for (k=0; k<2; ++k) {
		pj_sockaddr bound_addr;

		status = pj_sock_socket(pj_AF_INET6(), pj_SOCK_DGRAM(), 0, &sock[k]);
		if (status != PJ_SUCCESS)
		    break;

		status = pj_sockaddr_init(pj_AF_INET6(), &bound_addr,
					  &app_config.rtp_cfg.bound_addr, 
					  (unsigned short)(port+k));
		if (status != PJ_SUCCESS)
		    break;

		status = pj_sock_bind(sock[k], &bound_addr, 
				      pj_sockaddr_get_len(&bound_addr));
		if (status != PJ_SUCCESS)
		    break;
	    }
	    if (status != PJ_SUCCESS) {
		if (k==1)
		    pj_sock_close(sock[0]);

		if (port != 0)
		    port += 10;
		else
		    break;

		continue;
	    }

	    pj_bzero(&si, sizeof(si));
	    si.rtp_sock = sock[0];
	    si.rtcp_sock = sock[1];
	
	    pj_sockaddr_init(pj_AF_INET6(), &si.rtp_addr_name, 
			     &app_config.rtp_cfg.public_addr, 
			     (unsigned short)(port));
	    pj_sockaddr_init(pj_AF_INET6(), &si.rtcp_addr_name, 
			     &app_config.rtp_cfg.public_addr, 
			     (unsigned short)(port+1));

	    status = pjmedia_transport_udp_attach(pjsua_get_pjmedia_endpt(),
						  NULL,
						  &si,
						  0,
						  &tp[i].transport);
	    if (port != 0)
		port += 10;
	    else
		break;

	    if (status == PJ_SUCCESS)
		break;
	}

	if (status != PJ_SUCCESS) {
	    pjsua_perror(THIS_FILE, "Error creating IPv6 UDP media transport", 
			 status);
	    for (j=0; j<i; ++j) {
		pjmedia_transport_close(tp[j].transport);
	    }
	    return status;
	}
    }

    return pjsua_media_transports_attach(tp, i, PJ_TRUE);
}

